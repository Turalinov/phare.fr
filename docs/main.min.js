/**
 * Swiper 7.2.0
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2021 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: October 27, 2021
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Swiper = factory());
}(this, (function () { 'use strict';

    /**
     * SSR Window 4.0.1
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: October 27, 2021
     */

    /* eslint-disable no-param-reassign */
    function isObject$1(obj) {
      return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
    }

    function extend$1(target = {}, src = {}) {
      Object.keys(src).forEach(key => {
        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
          extend$1(target[key], src[key]);
        }
      });
    }

    const ssrDocument = {
      body: {},

      addEventListener() {},

      removeEventListener() {},

      activeElement: {
        blur() {},

        nodeName: ''
      },

      querySelector() {
        return null;
      },

      querySelectorAll() {
        return [];
      },

      getElementById() {
        return null;
      },

      createEvent() {
        return {
          initEvent() {}

        };
      },

      createElement() {
        return {
          children: [],
          childNodes: [],
          style: {},

          setAttribute() {},

          getElementsByTagName() {
            return [];
          }

        };
      },

      createElementNS() {
        return {};
      },

      importNode() {
        return null;
      },

      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      }
    };

    function getDocument() {
      const doc = typeof document !== 'undefined' ? document : {};
      extend$1(doc, ssrDocument);
      return doc;
    }

    const ssrWindow = {
      document: ssrDocument,
      navigator: {
        userAgent: ''
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      },
      history: {
        replaceState() {},

        pushState() {},

        go() {},

        back() {}

      },
      CustomEvent: function CustomEvent() {
        return this;
      },

      addEventListener() {},

      removeEventListener() {},

      getComputedStyle() {
        return {
          getPropertyValue() {
            return '';
          }

        };
      },

      Image() {},

      Date() {},

      screen: {},

      setTimeout() {},

      clearTimeout() {},

      matchMedia() {
        return {};
      },

      requestAnimationFrame(callback) {
        if (typeof setTimeout === 'undefined') {
          callback();
          return null;
        }

        return setTimeout(callback, 0);
      },

      cancelAnimationFrame(id) {
        if (typeof setTimeout === 'undefined') {
          return;
        }

        clearTimeout(id);
      }

    };

    function getWindow() {
      const win = typeof window !== 'undefined' ? window : {};
      extend$1(win, ssrWindow);
      return win;
    }

    /**
     * Dom7 4.0.1
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: October 27, 2021
     */
    /* eslint-disable no-proto */

    function makeReactive(obj) {
      const proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get() {
          return proto;
        },

        set(value) {
          proto.__proto__ = value;
        }

      });
    }

    class Dom7 extends Array {
      constructor(items) {
        super(...(items || []));
        makeReactive(this);
      }

    }

    function arrayFlat(arr = []) {
      const res = [];
      arr.forEach(el => {
        if (Array.isArray(el)) {
          res.push(...arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }

    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }

    function arrayUnique(arr) {
      const uniqueArray = [];

      for (let i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }

      return uniqueArray;
    }


    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }

      const a = [];
      const res = context.querySelectorAll(selector);

      for (let i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }

      return a;
    }

    function $(selector, context) {
      const window = getWindow();
      const document = getDocument();
      let arr = [];

      if (!context && selector instanceof Dom7) {
        return selector;
      }

      if (!selector) {
        return new Dom7(arr);
      }

      if (typeof selector === 'string') {
        const html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          let toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          const tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (let i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);

      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }

      return new Dom7(arrayUnique(arr));
    }

    $.fn = Dom7.prototype; // eslint-disable-next-line

    function addClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.add(...classNames);
      });
      return this;
    }

    function removeClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.remove(...classNames);
      });
      return this;
    }

    function toggleClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        classNames.forEach(className => {
          el.classList.toggle(className);
        });
      });
    }

    function hasClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      return arrayFilter(this, el => {
        return classNames.filter(className => el.classList.contains(className)).length > 0;
      }).length > 0;
    }

    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs


      for (let i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (const attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      return this;
    }

    function removeAttr(attr) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }

      return this;
    }

    function transform(transform) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }

      return this;
    }

    function transition$1(duration) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
      }

      return this;
    }

    function on(...args) {
      let [eventType, targetSelector, listener, capture] = args;

      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }

      if (!capture) capture = false;

      function handleLiveEvent(e) {
        const target = e.target;
        if (!target) return;
        const eventData = e.target.dom7EventData || [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
          const parents = $(target).parents(); // eslint-disable-line

          for (let k = 0; k < parents.length; k += 1) {
            if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
          }
        }
      }

      function handleEvent(e) {
        const eventData = e && e.target ? e.target.dom7EventData || [] : [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        listener.apply(this, eventData);
      }

      const events = eventType.split(' ');
      let j;

      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];

        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
            el.dom7LiveListeners[event].push({
              listener,
              proxyListener: handleLiveEvent
            });
            el.addEventListener(event, handleLiveEvent, capture);
          }
        }
      }

      return this;
    }

    function off(...args) {
      let [eventType, targetSelector, listener, capture] = args;

      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }

      if (!capture) capture = false;
      const events = eventType.split(' ');

      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];

        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
          let handlers;

          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }

          if (handlers && handlers.length) {
            for (let k = handlers.length - 1; k >= 0; k -= 1) {
              const handler = handlers[k];

              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }

      return this;
    }

    function trigger(...args) {
      const window = getWindow();
      const events = args[0].split(' ');
      const eventData = args[1];

      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];

        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];

          if (window.CustomEvent) {
            const evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }

      return this;
    }

    function transitionEnd$1(callback) {
      const dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }

      if (callback) {
        dom.on('transitionend', fireCallBack);
      }

      return this;
    }

    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
        }

        return this[0].offsetWidth;
      }

      return null;
    }

    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
        }

        return this[0].offsetHeight;
      }

      return null;
    }

    function offset() {
      if (this.length > 0) {
        const window = getWindow();
        const document = getDocument();
        const el = this[0];
        const box = el.getBoundingClientRect();
        const body = document.body;
        const clientTop = el.clientTop || body.clientTop || 0;
        const clientLeft = el.clientLeft || body.clientLeft || 0;
        const scrollTop = el === window ? window.scrollY : el.scrollTop;
        const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }

      return null;
    }

    function styles() {
      const window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }

    function css(props, value) {
      const window = getWindow();
      let i;

      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (const prop in props) {
              this[i].style[prop] = props[prop];
            }
          }

          return this;
        }
      }

      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }

        return this;
      }

      return this;
    }

    function each(callback) {
      if (!callback) return this;
      this.forEach((el, index) => {
        callback.apply(el, [el, index]);
      });
      return this;
    }

    function filter(callback) {
      const result = arrayFilter(this, callback);
      return $(result);
    }

    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }

      return this;
    }

    function text(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }

      return this;
    }

    function is(selector) {
      const window = getWindow();
      const document = getDocument();
      const el = this[0];
      let compareWith;
      let i;
      if (!el || typeof selector === 'undefined') return false;

      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      if (selector === document) {
        return el === document;
      }

      if (selector === window) {
        return el === window;
      }

      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      return false;
    }

    function index() {
      let child = this[0];
      let i;

      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }

        return i;
      }

      return undefined;
    }

    function eq(index) {
      if (typeof index === 'undefined') return this;
      const length = this.length;

      if (index > length - 1) {
        return $([]);
      }

      if (index < 0) {
        const returnIndex = length + index;
        if (returnIndex < 0) return $([]);
        return $([this[returnIndex]]);
      }

      return $([this[index]]);
    }

    function append(...els) {
      let newChild;
      const document = getDocument();

      for (let k = 0; k < els.length; k += 1) {
        newChild = els[k];

        for (let i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (let j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }

    function prepend(newChild) {
      const document = getDocument();
      let i;
      let j;

      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    }

    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return $([this[0].nextElementSibling]);
          }

          return $([]);
        }

        if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function nextAll(selector) {
      const nextEls = [];
      let el = this[0];
      if (!el) return $([]);

      while (el.nextElementSibling) {
        const next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($(next).is(selector)) nextEls.push(next);
        } else nextEls.push(next);

        el = next;
      }

      return $(nextEls);
    }

    function prev(selector) {
      if (this.length > 0) {
        const el = this[0];

        if (selector) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
            return $([el.previousElementSibling]);
          }

          return $([]);
        }

        if (el.previousElementSibling) return $([el.previousElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function prevAll(selector) {
      const prevEls = [];
      let el = this[0];
      if (!el) return $([]);

      while (el.previousElementSibling) {
        const prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($(prev).is(selector)) prevEls.push(prev);
        } else prevEls.push(prev);

        el = prev;
      }

      return $(prevEls);
    }

    function parent(selector) {
      const parents = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $(parents);
    }

    function parents(selector) {
      const parents = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        let parent = this[i].parentNode; // eslint-disable-line

        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) parents.push(parent);
          } else {
            parents.push(parent);
          }

          parent = parent.parentNode;
        }
      }

      return $(parents);
    }

    function closest(selector) {
      let closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $([]);
      }

      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }

      return closest;
    }

    function find(selector) {
      const foundElements = [];

      for (let i = 0; i < this.length; i += 1) {
        const found = this[i].querySelectorAll(selector);

        for (let j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }

      return $(foundElements);
    }

    function children(selector) {
      const children = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        const childNodes = this[i].children;

        for (let j = 0; j < childNodes.length; j += 1) {
          if (!selector || $(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }

      return $(children);
    }

    function remove() {
      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }

      return this;
    }

    const Methods = {
      addClass,
      removeClass,
      hasClass,
      toggleClass,
      attr,
      removeAttr,
      transform,
      transition: transition$1,
      on,
      off,
      trigger,
      transitionEnd: transitionEnd$1,
      outerWidth,
      outerHeight,
      styles,
      offset,
      css,
      each,
      html,
      text,
      is,
      index,
      eq,
      append,
      prepend,
      next,
      nextAll,
      prev,
      prevAll,
      parent,
      parents,
      closest,
      find,
      children,
      filter,
      remove
    };
    Object.keys(Methods).forEach(methodName => {
      Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
      });
    });

    function deleteProps(obj) {
      const object = obj;
      Object.keys(object).forEach(key => {
        try {
          object[key] = null;
        } catch (e) {// no getter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    }

    function nextTick(callback, delay = 0) {
      return setTimeout(callback, delay);
    }

    function now() {
      return Date.now();
    }

    function getComputedStyle$1(el) {
      const window = getWindow();
      let style;

      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }

      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }

      if (!style) {
        style = el.style;
      }

      return style;
    }

    function getTranslate(el, axis = 'x') {
      const window = getWindow();
      let matrix;
      let curTransform;
      let transformMatrix;
      const curStyle = getComputedStyle$1(el);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }

    function isObject(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }

      return node && (node.nodeType === 1 || node.nodeType === 11);
    }

    function extend(...args) {
      const to = Object(args[0]);
      const noExtend = ['__proto__', 'constructor', 'prototype'];

      for (let i = 1; i < args.length; i += 1) {
        const nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);

          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                to[nextKey] = {};

                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }

    function setCSSProperty(el, varName, varValue) {
      el.style.setProperty(varName, varValue);
    }

    function animateCSSModeScroll({
      swiper,
      targetPosition,
      side
    }) {
      const window = getWindow();
      const startPosition = -swiper.translate;
      let startTime = null;
      let time;
      const duration = swiper.params.speed;
      swiper.wrapperEl.style.scrollSnapType = 'none';
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      const dir = targetPosition > startPosition ? 'next' : 'prev';

      const isOutOfBound = (current, target) => {
        return dir === 'next' && current >= target || dir === 'prev' && current <= target;
      };

      const animate = () => {
        time = new Date().getTime();

        if (startTime === null) {
          startTime = time;
        }

        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);

        if (isOutOfBound(currentPosition, targetPosition)) {
          currentPosition = targetPosition;
        }

        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });

        if (isOutOfBound(currentPosition, targetPosition)) {
          swiper.wrapperEl.style.overflow = 'hidden';
          swiper.wrapperEl.style.scrollSnapType = '';
          setTimeout(() => {
            swiper.wrapperEl.style.overflow = '';
            swiper.wrapperEl.scrollTo({
              [side]: currentPosition
            });
          });
          window.cancelAnimationFrame(swiper.cssModeFrameID);
          return;
        }

        swiper.cssModeFrameID = window.requestAnimationFrame(animate);
      };

      animate();
    }

    let support;

    function calcSupport() {
      const window = getWindow();
      const document = getDocument();
      return {
        smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        passiveListener: function checkPassiveListener() {
          let supportsPassive = false;

          try {
            const opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get() {
                supportsPassive = true;
              }

            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {// No support
          }

          return supportsPassive;
        }(),
        gestures: function checkGestures() {
          return 'ongesturestart' in window;
        }()
      };
    }

    function getSupport() {
      if (!support) {
        support = calcSupport();
      }

      return support;
    }

    let deviceCached;

    function calcDevice({
      userAgent
    } = {}) {
      const support = getSupport();
      const window = getWindow();
      const platform = window.navigator.platform;
      const ua = userAgent || window.navigator.userAgent;
      const device = {
        ios: false,
        android: false
      };
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      const windows = platform === 'Win32';
      let macos = platform === 'MacIntel'; // iPadOs 13 fix

      const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      } // Android


      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // Export object


      return device;
    }

    function getDevice(overrides = {}) {
      if (!deviceCached) {
        deviceCached = calcDevice(overrides);
      }

      return deviceCached;
    }

    let browser;

    function calcBrowser() {
      const window = getWindow();

      function isSafari() {
        const ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }

      return {
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
      };
    }

    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }

      return browser;
    }

    function Resize({
      swiper,
      on,
      emit
    }) {
      const window = getWindow();
      let observer = null;

      const resizeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('beforeResize');
        emit('resize');
      };

      const createObserver = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        observer = new ResizeObserver(entries => {
          const {
            width,
            height
          } = swiper;
          let newWidth = width;
          let newHeight = height;
          entries.forEach(({
            contentBoxSize,
            contentRect,
            target
          }) => {
            if (target && target !== swiper.el) return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });

          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
        observer.observe(swiper.el);
      };

      const removeObserver = () => {
        if (observer && observer.unobserve && swiper.el) {
          observer.unobserve(swiper.el);
          observer = null;
        }
      };

      const orientationChangeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('orientationchange');
      };

      on('init', () => {
        if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
          createObserver();
          return;
        }

        window.addEventListener('resize', resizeHandler);
        window.addEventListener('orientationchange', orientationChangeHandler);
      });
      on('destroy', () => {
        removeObserver();
        window.removeEventListener('resize', resizeHandler);
        window.removeEventListener('orientationchange', orientationChangeHandler);
      });
    }

    function Observer({
      swiper,
      extendParams,
      on,
      emit
    }) {
      const observers = [];
      const window = getWindow();

      const attach = (target, options = {}) => {
        const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        const observer = new ObserverFunc(mutations => {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            emit('observerUpdate', mutations[0]);
            return;
          }

          const observerUpdate = function observerUpdate() {
            emit('observerUpdate', mutations[0]);
          };

          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData
        });
        observers.push(observer);
      };

      const init = () => {
        if (!swiper.params.observer) return;

        if (swiper.params.observeParents) {
          const containerParents = swiper.$el.parents();

          for (let i = 0; i < containerParents.length; i += 1) {
            attach(containerParents[i]);
          }
        } // Observe container


        attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren
        }); // Observe wrapper

        attach(swiper.$wrapperEl[0], {
          attributes: false
        });
      };

      const destroy = () => {
        observers.forEach(observer => {
          observer.disconnect();
        });
        observers.splice(0, observers.length);
      };

      extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      });
      on('init', init);
      on('destroy', destroy);
    }

    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
      on(events, handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(event => {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },

      once(events, handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;

        function onceHandler(...args) {
          self.off(events, onceHandler);

          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }

          handler.apply(self, args);
        }

        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },

      onAny(handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';

        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }

        return self;
      },

      offAny(handler) {
        const self = this;
        if (!self.eventsAnyListeners) return self;
        const index = self.eventsAnyListeners.indexOf(handler);

        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }

        return self;
      },

      off(events, handler) {
        const self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(event => {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach((eventHandler, index) => {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },

      emit(...args) {
        const self = this;
        if (!self.eventsListeners) return self;
        let events;
        let data;
        let context;

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }

        data.unshift(context);
        const eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(event => {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach(eventHandler => {
              eventHandler.apply(context, [event, ...data]);
            });
          }

          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(eventHandler => {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      }

    };

    function updateSize() {
      const swiper = this;
      let width;
      let height;
      const $el = swiper.$el;

      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }

      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }

      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
      } // Subtract paddings


      width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
      height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      Object.assign(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height
      });
    }

    function updateSlides() {
      const swiper = this;

      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        } // prettier-ignore


        return {
          'width': 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          'marginRight': 'marginBottom'
        }[property];
      }

      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }

      const params = swiper.params;
      const {
        $wrapperEl,
        size: swiperSize,
        rtlTranslate: rtl,
        wrongRTL
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      let snapGrid = [];
      const slidesGrid = [];
      const slidesSizesGrid = [];
      let offsetBefore = params.slidesOffsetBefore;

      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }

      let offsetAfter = params.slidesOffsetAfter;

      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }

      const previousSnapGridLength = swiper.snapGrid.length;
      const previousSlidesGridLength = swiper.slidesGrid.length;
      let spaceBetween = params.spaceBetween;
      let slidePosition = -offsetBefore;
      let prevSlideSize = 0;
      let index = 0;

      if (typeof swiperSize === 'undefined') {
        return;
      }

      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
      }

      swiper.virtualSize = -spaceBetween; // reset margins

      if (rtl) slides.css({
        marginLeft: '',
        marginBottom: '',
        marginTop: ''
      });else slides.css({
        marginRight: '',
        marginBottom: '',
        marginTop: ''
      }); // reset cssMode offsets

      if (params.centeredSlides && params.cssMode) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
      }

      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;

      if (gridEnabled) {
        swiper.grid.initSlides(slidesLength);
      } // Calc slides


      let slideSize;
      const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
        return typeof params.breakpoints[key].slidesPerView !== 'undefined';
      }).length > 0;

      for (let i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        const slide = slides.eq(i);

        if (gridEnabled) {
          swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
        }

        if (slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          if (shouldResetSlideSize) {
            slides[i].style[getDirectionLabel('width')] = ``;
          }

          const slideStyles = getComputedStyle(slide[0]);
          const currentTransform = slide[0].style.transform;
          const currentWebKitTransform = slide[0].style.webkitTransform;

          if (currentTransform) {
            slide[0].style.transform = 'none';
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }

          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            const width = getDirectionPropertyValue(slideStyles, 'width');
            const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            const boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              const {
                clientWidth,
                offsetWidth
              } = slide[0];
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }

          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }

          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);

          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
          }
        }

        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }

        slidesSizesGrid.push(slideSize);

        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }

        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }

      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;

      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({
          width: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }

      if (params.setWrapperSize) {
        $wrapperEl.css({
          [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }

      if (gridEnabled) {
        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
      } // Remove last grid elements depending on width


      if (!params.centeredSlides) {
        const newSlidesGrid = [];

        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);

          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;

        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }

      if (snapGrid.length === 0) snapGrid = [0];

      if (params.spaceBetween !== 0) {
        const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides.filter((_, slideIndex) => {
          if (!params.cssMode) return true;

          if (slideIndex === slides.length - 1) {
            return false;
          }

          return true;
        }).css({
          [key]: `${spaceBetween}px`
        });
      }

      if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        const maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(snap => {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }

      if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;

        if (allSlidesSize < swiperSize) {
          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
          snapGrid.forEach((snap, snapIndex) => {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach((snap, snapIndex) => {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }

      Object.assign(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
      });

      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
        const addToSnapGrid = -swiper.snapGrid[0];
        const addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
        swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
      }

      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }

      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }

      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }

      if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
      }
    }

    function updateAutoHeight(speed) {
      const swiper = this;
      const activeSlides = [];
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let newHeight = 0;
      let i;

      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }

      const getSlideByIndex = index => {
        if (isVirtual) {
          return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
        }

        return swiper.slides.eq(index)[0];
      }; // Find slides currently in view


      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each(slide => {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            const index = swiper.activeIndex + i;
            if (index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      } // Find new height from highest slide in view


      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          const height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      } // Update Height


      if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }

    function updateSlidesOffset() {
      const swiper = this;
      const slides = swiper.slides;

      for (let i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }

    function updateSlidesProgress(translate = this && this.translate || 0) {
      const swiper = this;
      const params = swiper.params;
      const {
        slides,
        rtlTranslate: rtl,
        snapGrid
      } = swiper;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
      let offsetCenter = -translate;
      if (rtl) offsetCenter = translate; // Visible Slides

      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];

      for (let i = 0; i < slides.length; i += 1) {
        const slide = slides[i];
        let slideOffset = slide.swiperSlideOffset;

        if (params.cssMode && params.centeredSlides) {
          slideOffset -= slides[0].swiperSlideOffset;
        }

        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }

        slide.progress = rtl ? -slideProgress : slideProgress;
        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
      }

      swiper.visibleSlides = $(swiper.visibleSlides);
    }

    function updateProgress(translate) {
      const swiper = this;

      if (typeof translate === 'undefined') {
        const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
      }

      const params = swiper.params;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      let {
        progress,
        isBeginning,
        isEnd
      } = swiper;
      const wasBeginning = isBeginning;
      const wasEnd = isEnd;

      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }

      Object.assign(swiper, {
        progress,
        isBeginning,
        isEnd
      });
      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }

      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }

      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit('fromEdge');
      }

      swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
      const swiper = this;
      const {
        slides,
        params,
        $wrapperEl,
        activeIndex,
        realIndex
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
      let activeSlide;

      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
      } else {
        activeSlide = slides.eq(activeIndex);
      } // Active classes


      activeSlide.addClass(params.slideActiveClass);

      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        }
      } // Next Slide


      let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);

      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      } // Prev Slide


      let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);

      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }

      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
        }

        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
        }
      }

      swiper.emitSlidesClasses();
    }

    function updateActiveIndex(newActiveIndex) {
      const swiper = this;
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      const {
        slidesGrid,
        snapGrid,
        params,
        activeIndex: previousIndex,
        realIndex: previousRealIndex,
        snapIndex: previousSnapIndex
      } = swiper;
      let activeIndex = newActiveIndex;
      let snapIndex;

      if (typeof activeIndex === 'undefined') {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        } // Normalize slideIndex


        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }

      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }

      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }

        return;
      } // Get real index


      const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
      Object.assign(swiper, {
        snapIndex,
        realIndex,
        previousIndex,
        activeIndex
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');

      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }

      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }

    function updateClickedSlide(e) {
      const swiper = this;
      const params = swiper.params;
      const slide = $(e.target).closest(`.${params.slideClass}`)[0];
      let slideFound = false;
      let slideIndex;

      if (slide) {
        for (let i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }

      if (slide && slideFound) {
        swiper.clickedSlide = slide;

        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }

      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }

    var update = {
      updateSize,
      updateSlides,
      updateAutoHeight,
      updateSlidesOffset,
      updateSlidesProgress,
      updateProgress,
      updateSlidesClasses,
      updateActiveIndex,
      updateClickedSlide
    };

    function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
      const swiper = this;
      const {
        params,
        rtlTranslate: rtl,
        translate,
        $wrapperEl
      } = swiper;

      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }

      if (params.cssMode) {
        return translate;
      }

      let currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
      const swiper = this;
      const {
        rtlTranslate: rtl,
        params,
        $wrapperEl,
        wrapperEl,
        progress
      } = swiper;
      let x = 0;
      let y = 0;
      const z = 0;

      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }

      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }

      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
      }

      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }

      swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
      return -this.snapGrid[0];
    }

    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }

    function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
      const swiper = this;
      const {
        params,
        wrapperEl
      } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      const minTranslate = swiper.minTranslate();
      const maxTranslate = swiper.maxTranslate();
      let newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

      swiper.updateProgress(newTranslate);

      if (params.cssMode) {
        const isH = swiper.isHorizontal();

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: -newTranslate,
              side: isH ? 'left' : 'top'
            });
            return true;
          }

          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: -newTranslate,
            behavior: 'smooth'
          });
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;

              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }

      return true;
    }

    var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate,
      minTranslate,
      maxTranslate,
      translateTo
    };

    function setTransition(duration, byController) {
      const swiper = this;

      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }

      swiper.emit('setTransition', duration, byController);
    }

    function transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step
    }) {
      const {
        activeIndex,
        previousIndex
      } = swiper;
      let dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit(`transition${step}`);

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit(`slideResetTransition${step}`);
          return;
        }

        swiper.emit(`slideChangeTransition${step}`);

        if (dir === 'next') {
          swiper.emit(`slideNextTransition${step}`);
        } else {
          swiper.emit(`slidePrevTransition${step}`);
        }
      }
    }

    function transitionStart(runCallbacks = true, direction) {
      const swiper = this;
      const {
        params
      } = swiper;
      if (params.cssMode) return;

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'Start'
      });
    }

    function transitionEnd(runCallbacks = true, direction) {
      const swiper = this;
      const {
        params
      } = swiper;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'End'
      });
    }

    var transition = {
      setTransition,
      transitionStart,
      transitionEnd
    };

    function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        const indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        const isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.


        index = indexAsNumber;
      }

      const swiper = this;
      let slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      const {
        params,
        snapGrid,
        slidesGrid,
        previousIndex,
        activeIndex,
        rtlTranslate: rtl,
        wrapperEl,
        enabled
      } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }

      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }

      const translate = -snapGrid[snapIndex]; // Update progress

      swiper.updateProgress(translate); // Normalize slideIndex

      if (params.normalizeSlideIndex) {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          const normalizedTranslate = -Math.floor(translate * 100);
          const normalizedGrid = Math.floor(slidesGrid[i] * 100);
          const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
              slideIndex = i;
            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGrid) {
            slideIndex = i;
          }
        }
      } // Directions locks


      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }

        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }

      let direction;
      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
        swiper.updateActiveIndex(slideIndex); // Update Height

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        swiper.updateSlidesClasses();

        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }

        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }

        return false;
      }

      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        const t = rtl ? translate : -translate;

        if (speed === 0) {
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

          if (isVirtual) {
            swiper.wrapperEl.style.scrollSnapType = 'none';
            swiper._immediateVirtual = true;
          }

          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;

          if (isVirtual) {
            requestAnimationFrame(() => {
              swiper.wrapperEl.style.scrollSnapType = '';
              swiper._swiperImmediateVirtual = false;
            });
          }
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: t,
              side: isH ? 'left' : 'top'
            });
            return true;
          }

          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: t,
            behavior: 'smooth'
          });
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onSlideToWrapperTransitionEnd) {
            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
              swiper.onSlideToWrapperTransitionEnd = null;
              delete swiper.onSlideToWrapperTransitionEnd;
              swiper.transitionEnd(runCallbacks, direction);
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
      }

      return true;
    }

    function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      let newIndex = index;

      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }

      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      const {
        animating,
        enabled,
        params
      } = swiper;
      if (!enabled) return swiper;
      let perGroup = params.slidesPerGroup;

      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
      }

      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      const {
        params,
        animating,
        snapGrid,
        slidesGrid,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled) return swiper;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      const translate = rtlTranslate ? swiper.translate : -swiper.translate;

      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }

      const normalizedTranslate = normalize(translate);
      const normalizedSnapGrid = snapGrid.map(val => normalize(val));
      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

      if (typeof prevSnap === 'undefined' && params.cssMode) {
        let prevSnapIndex;
        snapGrid.forEach((snap, snapIndex) => {
          if (normalizedTranslate >= snap) {
            // prevSnap = snap;
            prevSnapIndex = snapIndex;
          }
        });

        if (typeof prevSnapIndex !== 'undefined') {
          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
      }

      let prevIndex = 0;

      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;

        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
          prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
          prevIndex = Math.max(prevIndex, 0);
        }
      }

      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
      const swiper = this;
      let index = swiper.activeIndex;
      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];

        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];

        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }

      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
      const swiper = this;
      const {
        params,
        $wrapperEl
      } = swiper;
      const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      let slideToIndex = swiper.clickedIndex;
      let realIndex;

      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
            nextTick(() => {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }

    var slide = {
      slideTo,
      slideToLoop,
      slideNext,
      slidePrev,
      slideReset,
      slideToClosest,
      slideToClickedSlide
    };

    function loopCreate() {
      const swiper = this;
      const document = getDocument();
      const {
        params,
        $wrapperEl
      } = swiper; // Remove duplicated slides

      const $selector = $($wrapperEl.children()[0].parentNode);
      $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
      let slides = $selector.children(`.${params.slideClass}`);

      if (params.loopFillGroupWithBlank) {
        const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

        if (blankSlidesNum !== params.slidesPerGroup) {
          for (let i = 0; i < blankSlidesNum; i += 1) {
            const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
            $selector.append(blankNode);
          }

          slides = $selector.children(`.${params.slideClass}`);
        }
      }

      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;

      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }

      const prependSlides = [];
      const appendSlides = [];
      slides.each((el, index) => {
        const slide = $(el);

        if (index < swiper.loopedSlides) {
          appendSlides.push(el);
        }

        if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
          prependSlides.push(el);
        }

        slide.attr('data-swiper-slide-index', index);
      });

      for (let i = 0; i < appendSlides.length; i += 1) {
        $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }

      for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
        $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }

    function loopFix() {
      const swiper = this;
      swiper.emit('beforeLoopFix');
      const {
        activeIndex,
        slides,
        loopedSlides,
        allowSlidePrev,
        allowSlideNext,
        snapGrid,
        rtlTranslate: rtl
      } = swiper;
      let newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      const snapTranslate = -snapGrid[activeIndex];
      const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
    }

    function loopDestroy() {
      const swiper = this;
      const {
        $wrapperEl,
        params,
        slides
      } = swiper;
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
      slides.removeAttr('data-swiper-slide-index');
    }

    var loop = {
      loopCreate,
      loopFix,
      loopDestroy
    };

    function setGrabCursor(moving) {
      const swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
      const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
      el.style.cursor = 'move';
      el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
      el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
      const swiper = this;

      if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
      }

      swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    }

    var grabCursor = {
      setGrabCursor,
      unsetGrabCursor
    };

    function closestElement(selector, base = this) {
      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        const found = el.closest(selector);
        return found || __closestFrom(el.getRootNode().host);
      }

      return __closestFrom(base);
    }

    function onTouchStart(event) {
      const swiper = this;
      const document = getDocument();
      const window = getWindow();
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        enabled
      } = swiper;
      if (!enabled) return;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }

      if (!swiper.animating && params.cssMode && params.loop) {
        swiper.loopFix();
      }

      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      let $targetEl = $(e.target);

      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }

      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return; // change target el for shadow root component

      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $(event.path[0]);
      }

      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
      const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }

      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }

      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      const startX = touches.currentX;
      const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }

      Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;

      if (e.type !== 'touchstart') {
        let preventDefault = true;
        if ($targetEl.is(data.focusableElements)) preventDefault = false;

        if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
          document.activeElement.blur();
        }

        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }

      swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
      const document = getDocument();
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        enabled
      } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }

        return;
      }

      if (data.isTouchEvent && e.type !== 'touchmove') return;
      const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }

      if (!swiper.allowTouchMove) {
        // isMoved = true;
        swiper.allowClick = false;

        if (data.isTouched) {
          Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now();
        }

        return;
      }

      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
          return;
        }
      }

      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }

      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }

      if (e.targetTouches && e.targetTouches.length > 1) return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      const diffX = touches.currentX - touches.startX;
      const diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

      if (typeof data.isScrolling === 'undefined') {
        let touchAngle;

        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }

      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }

      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }

      if (!data.startMoving) {
        return;
      }

      swiper.allowClick = false;

      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }

      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }

      if (!data.isMoved) {
        if (params.loop && !params.cssMode) {
          swiper.loopFix();
        }

        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);

        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }

        data.allowMomentumBounce = false; // Grab Cursor

        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }

        swiper.emit('sliderFirstMove', e);
      }

      swiper.emit('sliderMove', e);
      data.isMoved = true;
      let diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
      let disableParentSwiper = true;
      let resistanceRatio = params.resistanceRatio;

      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }

      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }

      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      } // Directions locks


      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      } // Threshold


      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }

      if (!params.followFinger || params.cssMode) return; // Update active index in free mode

      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
        swiper.freeMode.onTouchMove();
      } // Update progress


      swiper.updateProgress(data.currentTranslate); // Update translate

      swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd(event) {
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        slidesGrid,
        enabled
      } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }

      data.allowTouchCallbacks = false;

      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }

        data.isMoved = false;
        data.startMoving = false;
        return;
      } // Return Grab Cursor


      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      } // Time diff


      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

      if (swiper.allowClick) {
        swiper.updateClickedSlide(e);
        swiper.emit('tap click', e);

        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }

      data.lastClickTime = now();
      nextTick(() => {
        if (!swiper.destroyed) swiper.allowClick = true;
      });

      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }

      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      let currentPos;

      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }

      if (params.cssMode) {
        return;
      }

      if (swiper.params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({
          currentPos
        });
        return;
      } // Find current slide


      let stopIndex = 0;
      let groupSize = swiper.slidesSizesGrid[0];

      for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

        if (typeof slidesGrid[i + increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      } // Find current slide size


      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }

        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(stopIndex + increment);
          }

          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }

    function onResize() {
      const swiper = this;
      const {
        params,
        el
      } = swiper;
      if (el && el.offsetWidth === 0) return; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      } // Save locks


      const {
        allowSlideNext,
        allowSlidePrev,
        snapGrid
      } = swiper; // Disable locks on resize

      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();

      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      } // Return locks after resize


      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }

    function onClick(e) {
      const swiper = this;
      if (!swiper.enabled) return;

      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();

        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }

    function onScroll() {
      const swiper = this;
      const {
        wrapperEl,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;

      if (swiper.isHorizontal()) {
        swiper.translate = -wrapperEl.scrollLeft;
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      } // eslint-disable-next-line


      if (swiper.translate === -0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }

      swiper.emit('setTranslate', swiper.translate, false);
    }

    let dummyEventAttached = false;

    function dummyEventListener() {}

    const events = (swiper, method) => {
      const document = getDocument();
      const {
        params,
        touchEvents,
        el,
        wrapperEl,
        device,
        support
      } = swiper;
      const capture = !!params.nested;
      const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
      const swiperMethod = method; // Touch Events

      if (!support.touch) {
        el[domMethod](touchEvents.start, swiper.onTouchStart, false);
        document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
        document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
      } else {
        const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
        el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
          passive: false,
          capture
        } : capture);
        el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);

        if (touchEvents.cancel) {
          el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el[domMethod]('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl[domMethod]('scroll', swiper.onScroll);
      } // Resize handler


      if (params.updateOnWindowResize) {
        swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      } else {
        swiper[swiperMethod]('observerUpdate', onResize, true);
      }
    };

    function attachEvents() {
      const swiper = this;
      const document = getDocument();
      const {
        params,
        support
      } = swiper;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);

      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }

      swiper.onClick = onClick.bind(swiper);

      if (support.touch && !dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }

      events(swiper, 'on');
    }

    function detachEvents() {
      const swiper = this;
      events(swiper, 'off');
    }

    var events$1 = {
      attachEvents,
      detachEvents
    };

    const isGridEnabled = (swiper, params) => {
      return swiper.grid && params.grid && params.grid.rows > 1;
    };

    function setBreakpoint() {
      const swiper = this;
      const {
        activeIndex,
        initialized,
        loopedSlides = 0,
        params,
        $el
      } = swiper;
      const breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

      const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
      const breakpointParams = breakpointOnlyParams || swiper.originalParams;
      const wasMultiRow = isGridEnabled(swiper, params);
      const isMultiRow = isGridEnabled(swiper, breakpointParams);
      const wasEnabled = params.enabled;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(`${params.containerModifierClass}grid`);

        if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
          $el.addClass(`${params.containerModifierClass}grid-column`);
        }

        swiper.emitContainerClasses();
      }

      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      extend(swiper.params, breakpointParams);
      const isEnabled = swiper.params.enabled;
      Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });

      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }

      swiper.currentBreakpoint = breakpoint;
      swiper.emit('_beforeBreakpoint', breakpointParams);

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }

    function getBreakpoint(breakpoints, base = 'window', containerEl) {
      if (!breakpoints || base === 'container' && !containerEl) return undefined;
      let breakpoint = false;
      const window = getWindow();
      const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
      const points = Object.keys(breakpoints).map(point => {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          const minRatio = parseFloat(point.substr(1));
          const value = currentHeight * minRatio;
          return {
            value,
            point
          };
        }

        return {
          value: point,
          point
        };
      });
      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));

      for (let i = 0; i < points.length; i += 1) {
        const {
          point,
          value
        } = points[i];

        if (base === 'window') {
          if (window.matchMedia(`(min-width: ${value}px)`).matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }

      return breakpoint || 'max';
    }

    var breakpoints = {
      setBreakpoint,
      getBreakpoint
    };

    function prepareClasses(entries, prefix) {
      const resultClasses = [];
      entries.forEach(item => {
        if (typeof item === 'object') {
          Object.keys(item).forEach(classNames => {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }

    function addClasses() {
      const swiper = this;
      const {
        classNames,
        params,
        rtl,
        $el,
        device,
        support
      } = swiper; // prettier-ignore

      const suffixes = prepareClasses(['initialized', params.direction, {
        'pointer-events': !support.touch
      }, {
        'free-mode': swiper.params.freeMode && params.freeMode.enabled
      }, {
        'autoheight': params.autoHeight
      }, {
        'rtl': rtl
      }, {
        'grid': params.grid && params.grid.rows > 1
      }, {
        'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
      }, {
        'android': device.android
      }, {
        'ios': device.ios
      }, {
        'css-mode': params.cssMode
      }, {
        'centered': params.cssMode && params.centeredSlides
      }], params.containerModifierClass);
      classNames.push(...suffixes);
      $el.addClass([...classNames].join(' '));
      swiper.emitContainerClasses();
    }

    function removeClasses() {
      const swiper = this;
      const {
        $el,
        classNames
      } = swiper;
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }

    var classes = {
      addClasses,
      removeClasses
    };

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      const window = getWindow();
      let image;

      function onReady() {
        if (callback) callback();
      }

      const isPicture = $(imageEl).parent('picture')[0];

      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;

          if (sizes) {
            image.sizes = sizes;
          }

          if (srcset) {
            image.srcset = srcset;
          }

          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }

    function preloadImages() {
      const swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');

      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }

      for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
        const imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
      }
    }

    var images = {
      loadImage,
      preloadImages
    };

    function checkOverflow() {
      const swiper = this;
      const {
        isLocked: wasLocked,
        params
      } = swiper;
      const {
        slidesOffsetBefore
      } = params;

      if (slidesOffsetBefore) {
        const lastSlideIndex = swiper.slides.length - 1;
        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }

      if (params.allowSlideNext === true) {
        swiper.allowSlideNext = !swiper.isLocked;
      }

      if (params.allowSlidePrev === true) {
        swiper.allowSlidePrev = !swiper.isLocked;
      }

      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
      }

      if (wasLocked !== swiper.isLocked) {
        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
      }
    }

    var checkOverflow$1 = {
      checkOverflow
    };

    var defaults = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'wrapper',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: true,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: 'slide',
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: false,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: true,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      // NS
      containerModifierClass: 'swiper-',
      // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false
    };

    function moduleExtendParams(params, allModulesParams) {
      return function extendParams(obj = {}) {
        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];

        if (typeof moduleParams !== 'object' || moduleParams === null) {
          extend(allModulesParams, obj);
          return;
        }

        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
          params[moduleParamName] = {
            auto: true
          };
        }

        if (!(moduleParamName in params && 'enabled' in moduleParams)) {
          extend(allModulesParams, obj);
          return;
        }

        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }

        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }

        if (!params[moduleParamName]) params[moduleParamName] = {
          enabled: false
        };
        extend(allModulesParams, obj);
      };
    }

    /* eslint no-param-reassign: "off" */
    const prototypes = {
      eventsEmitter,
      update,
      translate,
      transition,
      slide,
      loop,
      grabCursor,
      events: events$1,
      breakpoints,
      checkOverflow: checkOverflow$1,
      classes,
      images
    };
    const extendedDefaults = {};

    class Swiper {
      constructor(...args) {
        let el;
        let params;

        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
          params = args[0];
        } else {
          [el, params] = args;
        }

        if (!params) params = {};
        params = extend({}, params);
        if (el && !params.el) params.el = el;

        if (params.el && $(params.el).length > 1) {
          const swipers = [];
          $(params.el).each(containerEl => {
            const newParams = extend({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        } // Swiper Instance


        const swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = [...swiper.__modules__];

        if (params.modules && Array.isArray(params.modules)) {
          swiper.modules.push(...params.modules);
        }

        const allModulesParams = {};
        swiper.modules.forEach(mod => {
          mod({
            swiper,
            extendParams: moduleExtendParams(params, allModulesParams),
            on: swiper.on.bind(swiper),
            once: swiper.once.bind(swiper),
            off: swiper.off.bind(swiper),
            emit: swiper.emit.bind(swiper)
          });
        }); // Extend defaults with modules params

        const swiperParams = extend({}, defaults, allModulesParams); // Extend defaults with passed params

        swiper.params = extend({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend({}, swiper.params);
        swiper.passedParams = extend({}, params); // add event listeners

        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach(eventName => {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }

        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        } // Save Dom lib


        swiper.$ = $; // Extend Swiper

        Object.assign(swiper, {
          enabled: swiper.params.enabled,
          el,
          // Classes
          classNames: [],
          // Slides
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],

          // isDirection
          isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },

          isVertical() {
            return swiper.params.direction === 'vertical';
          },

          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          // Touch Events
          touchEvents: function touchEvents() {
            const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            const desktop = ['pointerdown', 'pointermove', 'pointerup'];
            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3]
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2]
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          }(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0
        });
        swiper.emit('_swiper'); // Init

        if (swiper.params.init) {
          swiper.init();
        } // Return app instance


        return swiper;
      }

      enable() {
        const swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;

        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }

        swiper.emit('enable');
      }

      disable() {
        const swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;

        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }

        swiper.emit('disable');
      }

      setProgress(progress, speed) {
        const swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper.minTranslate();
        const max = swiper.maxTranslate();
        const current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      emitContainerClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const cls = swiper.el.className.split(' ').filter(className => {
          return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit('_containerClasses', cls.join(' '));
      }

      getSlideClasses(slideEl) {
        const swiper = this;
        return slideEl.className.split(' ').filter(className => {
          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(' ');
      }

      emitSlidesClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const updates = [];
        swiper.slides.each(slideEl => {
          const classNames = swiper.getSlideClasses(slideEl);
          updates.push({
            slideEl,
            classNames
          });
          swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
      }

      slidesPerViewDynamic(view = 'current', exact = false) {
        const swiper = this;
        const {
          params,
          slides,
          slidesGrid,
          slidesSizesGrid,
          size: swiperSize,
          activeIndex
        } = swiper;
        let spv = 1;

        if (params.centeredSlides) {
          let slideSize = slides[activeIndex].swiperSlideSize;
          let breakLoop;

          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }

          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          // eslint-disable-next-line
          if (view === 'current') {
            for (let i = activeIndex + 1; i < slides.length; i += 1) {
              const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;

              if (slideInView) {
                spv += 1;
              }
            }
          } else {
            // previous
            for (let i = activeIndex - 1; i >= 0; i -= 1) {
              const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;

              if (slideInView) {
                spv += 1;
              }
            }
          }
        }

        return spv;
      }

      update() {
        const swiper = this;
        if (!swiper || swiper.destroyed) return;
        const {
          snapGrid,
          params
        } = swiper; // Breakpoints

        if (params.breakpoints) {
          swiper.setBreakpoint();
        }

        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        function setTranslate() {
          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        let translated;

        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
          setTranslate();

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }

          if (!translated) {
            setTranslate();
          }
        }

        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }

        swiper.emit('update');
      }

      changeDirection(newDirection, needUpdate = true) {
        const swiper = this;
        const currentDirection = swiper.params.direction;

        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }

        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
          return swiper;
        }

        swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(slideEl => {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
        return swiper;
      }

      mount(el) {
        const swiper = this;
        if (swiper.mounted) return true; // Find el

        const $el = $(el || swiper.params.el);
        el = $el[0];

        if (!el) {
          return false;
        }

        el.swiper = swiper;

        const getWrapperSelector = () => {
          return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
        };

        const getWrapper = () => {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            const res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

            res.children = options => $el.children(options);

            return res;
          }

          return $el.children(getWrapperSelector());
        }; // Find Wrapper


        let $wrapperEl = getWrapper();

        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          const document = getDocument();
          const wrapper = document.createElement('div');
          $wrapperEl = $(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
            $wrapperEl.append(slideEl);
          });
        }

        Object.assign(swiper, {
          $el,
          el,
          $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box'
        });
        return true;
      }

      init(el) {
        const swiper = this;
        if (swiper.initialized) return swiper;
        const mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit('beforeInit'); // Set breakpoint

        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        } // Add Classes


        swiper.addClasses(); // Create loop

        if (swiper.params.loop) {
          swiper.loopCreate();
        } // Update size


        swiper.updateSize(); // Update slides

        swiper.updateSlides();

        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        } // Set Grab Cursor


        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }

        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        } // Slide To Initial Slide


        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        } // Attach events


        swiper.attachEvents(); // Init Flag

        swiper.initialized = true; // Emit

        swiper.emit('init');
        swiper.emit('afterInit');
        return swiper;
      }

      destroy(deleteInstance = true, cleanStyles = true) {
        const swiper = this;
        const {
          params,
          $el,
          $wrapperEl,
          slides
        } = swiper;

        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }

        swiper.emit('beforeDestroy'); // Init Flag

        swiper.initialized = false; // Detach events

        swiper.detachEvents(); // Destroy loop

        if (params.loop) {
          swiper.loopDestroy();
        } // Cleanup styles


        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');

          if (slides && slides.length) {
            slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
          }
        }

        swiper.emit('destroy'); // Detach emitter events

        Object.keys(swiper.eventsListeners).forEach(eventName => {
          swiper.off(eventName);
        });

        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }

        swiper.destroyed = true;
        return null;
      }

      static extendDefaults(newDefaults) {
        extend(extendedDefaults, newDefaults);
      }

      static get extendedDefaults() {
        return extendedDefaults;
      }

      static get defaults() {
        return defaults;
      }

      static installModule(mod) {
        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
        const modules = Swiper.prototype.__modules__;

        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
          modules.push(mod);
        }
      }

      static use(module) {
        if (Array.isArray(module)) {
          module.forEach(m => Swiper.installModule(m));
          return Swiper;
        }

        Swiper.installModule(module);
        return Swiper;
      }

    }

    Object.keys(prototypes).forEach(prototypeGroup => {
      Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper.use([Resize, Observer]);

    function Virtual({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        virtual: {
          enabled: false,
          slides: [],
          cache: true,
          renderSlide: null,
          renderExternal: null,
          renderExternalUpdate: true,
          addSlidesBefore: 0,
          addSlidesAfter: 0
        }
      });
      let cssModeTimeout;
      swiper.virtual = {
        cache: {},
        from: undefined,
        to: undefined,
        slides: [],
        offset: 0,
        slidesGrid: []
      };

      function renderSlide(slide, index) {
        const params = swiper.params.virtual;

        if (params.cache && swiper.virtual.cache[index]) {
          return swiper.virtual.cache[index];
        }

        const $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
        if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
        if (params.cache) swiper.virtual.cache[index] = $slideEl;
        return $slideEl;
      }

      function update(force) {
        const {
          slidesPerView,
          slidesPerGroup,
          centeredSlides
        } = swiper.params;
        const {
          addSlidesBefore,
          addSlidesAfter
        } = swiper.params.virtual;
        const {
          from: previousFrom,
          to: previousTo,
          slides,
          slidesGrid: previousSlidesGrid,
          offset: previousOffset
        } = swiper.virtual;

        if (!swiper.params.cssMode) {
          swiper.updateActiveIndex();
        }

        const activeIndex = swiper.activeIndex || 0;
        let offsetProp;
        if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
        let slidesAfter;
        let slidesBefore;

        if (centeredSlides) {
          slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
          slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
        } else {
          slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
          slidesBefore = slidesPerGroup + addSlidesBefore;
        }

        const from = Math.max((activeIndex || 0) - slidesBefore, 0);
        const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
        const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
        Object.assign(swiper.virtual, {
          from,
          to,
          offset,
          slidesGrid: swiper.slidesGrid
        });

        function onRendered() {
          swiper.updateSlides();
          swiper.updateProgress();
          swiper.updateSlidesClasses();

          if (swiper.lazy && swiper.params.lazy.enabled) {
            swiper.lazy.load();
          }
        }

        if (previousFrom === from && previousTo === to && !force) {
          if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
            swiper.slides.css(offsetProp, `${offset}px`);
          }

          swiper.updateProgress();
          return;
        }

        if (swiper.params.virtual.renderExternal) {
          swiper.params.virtual.renderExternal.call(swiper, {
            offset,
            from,
            to,
            slides: function getSlides() {
              const slidesToRender = [];

              for (let i = from; i <= to; i += 1) {
                slidesToRender.push(slides[i]);
              }

              return slidesToRender;
            }()
          });

          if (swiper.params.virtual.renderExternalUpdate) {
            onRendered();
          }

          return;
        }

        const prependIndexes = [];
        const appendIndexes = [];

        if (force) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
        } else {
          for (let i = previousFrom; i <= previousTo; i += 1) {
            if (i < from || i > to) {
              swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
            }
          }
        }

        for (let i = 0; i < slides.length; i += 1) {
          if (i >= from && i <= to) {
            if (typeof previousTo === 'undefined' || force) {
              appendIndexes.push(i);
            } else {
              if (i > previousTo) appendIndexes.push(i);
              if (i < previousFrom) prependIndexes.push(i);
            }
          }
        }

        appendIndexes.forEach(index => {
          swiper.$wrapperEl.append(renderSlide(slides[index], index));
        });
        prependIndexes.sort((a, b) => b - a).forEach(index => {
          swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
        });
        swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
        onRendered();
      }

      function appendSlide(slides) {
        if (typeof slides === 'object' && 'length' in slides) {
          for (let i = 0; i < slides.length; i += 1) {
            if (slides[i]) swiper.virtual.slides.push(slides[i]);
          }
        } else {
          swiper.virtual.slides.push(slides);
        }

        update(true);
      }

      function prependSlide(slides) {
        const activeIndex = swiper.activeIndex;
        let newActiveIndex = activeIndex + 1;
        let numberOfNewSlides = 1;

        if (Array.isArray(slides)) {
          for (let i = 0; i < slides.length; i += 1) {
            if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
          }

          newActiveIndex = activeIndex + slides.length;
          numberOfNewSlides = slides.length;
        } else {
          swiper.virtual.slides.unshift(slides);
        }

        if (swiper.params.virtual.cache) {
          const cache = swiper.virtual.cache;
          const newCache = {};
          Object.keys(cache).forEach(cachedIndex => {
            const $cachedEl = cache[cachedIndex];
            const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');

            if (cachedElIndex) {
              $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
            }

            newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
          });
          swiper.virtual.cache = newCache;
        }

        update(true);
        swiper.slideTo(newActiveIndex, 0);
      }

      function removeSlide(slidesIndexes) {
        if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
        let activeIndex = swiper.activeIndex;

        if (Array.isArray(slidesIndexes)) {
          for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
            swiper.virtual.slides.splice(slidesIndexes[i], 1);

            if (swiper.params.virtual.cache) {
              delete swiper.virtual.cache[slidesIndexes[i]];
            }

            if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
            activeIndex = Math.max(activeIndex, 0);
          }
        } else {
          swiper.virtual.slides.splice(slidesIndexes, 1);

          if (swiper.params.virtual.cache) {
            delete swiper.virtual.cache[slidesIndexes];
          }

          if (slidesIndexes < activeIndex) activeIndex -= 1;
          activeIndex = Math.max(activeIndex, 0);
        }

        update(true);
        swiper.slideTo(activeIndex, 0);
      }

      function removeAllSlides() {
        swiper.virtual.slides = [];

        if (swiper.params.virtual.cache) {
          swiper.virtual.cache = {};
        }

        update(true);
        swiper.slideTo(0, 0);
      }

      on('beforeInit', () => {
        if (!swiper.params.virtual.enabled) return;
        swiper.virtual.slides = swiper.params.virtual.slides;
        swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;

        if (!swiper.params.initialSlide) {
          update();
        }
      });
      on('setTranslate', () => {
        if (!swiper.params.virtual.enabled) return;

        if (swiper.params.cssMode && !swiper._immediateVirtual) {
          clearTimeout(cssModeTimeout);
          cssModeTimeout = setTimeout(() => {
            update();
          }, 100);
        } else {
          update();
        }
      });
      on('init update resize', () => {
        if (!swiper.params.virtual.enabled) return;

        if (swiper.params.cssMode) {
          setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
        }
      });
      Object.assign(swiper.virtual, {
        appendSlide,
        prependSlide,
        removeSlide,
        removeAllSlides,
        update
      });
    }

    /* eslint-disable consistent-return */
    function Keyboard({
      swiper,
      extendParams,
      on,
      emit
    }) {
      const document = getDocument();
      const window = getWindow();
      swiper.keyboard = {
        enabled: false
      };
      extendParams({
        keyboard: {
          enabled: false,
          onlyInViewport: true,
          pageUpDown: true
        }
      });

      function handle(event) {
        if (!swiper.enabled) return;
        const {
          rtlTranslate: rtl
        } = swiper;
        let e = event;
        if (e.originalEvent) e = e.originalEvent; // jquery fix

        const kc = e.keyCode || e.charCode;
        const pageUpDown = swiper.params.keyboard.pageUpDown;
        const isPageUp = pageUpDown && kc === 33;
        const isPageDown = pageUpDown && kc === 34;
        const isArrowLeft = kc === 37;
        const isArrowRight = kc === 39;
        const isArrowUp = kc === 38;
        const isArrowDown = kc === 40; // Directions locks

        if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
          return false;
        }

        if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
          return false;
        }

        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
          return undefined;
        }

        if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
          return undefined;
        }

        if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
          let inView = false; // Check that swiper should be inside of visible area of window

          if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
            return undefined;
          }

          const $el = swiper.$el;
          const swiperWidth = $el[0].clientWidth;
          const swiperHeight = $el[0].clientHeight;
          const windowWidth = window.innerWidth;
          const windowHeight = window.innerHeight;
          const swiperOffset = swiper.$el.offset();
          if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
          const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];

          for (let i = 0; i < swiperCoord.length; i += 1) {
            const point = swiperCoord[i];

            if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
              if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

              inView = true;
            }
          }

          if (!inView) return undefined;
        }

        if (swiper.isHorizontal()) {
          if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
            if (e.preventDefault) e.preventDefault();else e.returnValue = false;
          }

          if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
          if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
        } else {
          if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
            if (e.preventDefault) e.preventDefault();else e.returnValue = false;
          }

          if (isPageDown || isArrowDown) swiper.slideNext();
          if (isPageUp || isArrowUp) swiper.slidePrev();
        }

        emit('keyPress', kc);
        return undefined;
      }

      function enable() {
        if (swiper.keyboard.enabled) return;
        $(document).on('keydown', handle);
        swiper.keyboard.enabled = true;
      }

      function disable() {
        if (!swiper.keyboard.enabled) return;
        $(document).off('keydown', handle);
        swiper.keyboard.enabled = false;
      }

      on('init', () => {
        if (swiper.params.keyboard.enabled) {
          enable();
        }
      });
      on('destroy', () => {
        if (swiper.keyboard.enabled) {
          disable();
        }
      });
      Object.assign(swiper.keyboard, {
        enable,
        disable
      });
    }

    /* eslint-disable consistent-return */
    function Mousewheel({
      swiper,
      extendParams,
      on,
      emit
    }) {
      const window = getWindow();
      extendParams({
        mousewheel: {
          enabled: false,
          releaseOnEdges: false,
          invert: false,
          forceToAxis: false,
          sensitivity: 1,
          eventsTarget: 'container',
          thresholdDelta: null,
          thresholdTime: null
        }
      });
      swiper.mousewheel = {
        enabled: false
      };
      let timeout;
      let lastScrollTime = now();
      let lastEventBeforeSnap;
      const recentWheelEvents = [];

      function normalize(e) {
        // Reasonable defaults
        const PIXEL_STEP = 10;
        const LINE_HEIGHT = 40;
        const PAGE_HEIGHT = 800;
        let sX = 0;
        let sY = 0; // spinX, spinY

        let pX = 0;
        let pY = 0; // pixelX, pixelY
        // Legacy

        if ('detail' in e) {
          sY = e.detail;
        }

        if ('wheelDelta' in e) {
          sY = -e.wheelDelta / 120;
        }

        if ('wheelDeltaY' in e) {
          sY = -e.wheelDeltaY / 120;
        }

        if ('wheelDeltaX' in e) {
          sX = -e.wheelDeltaX / 120;
        } // side scrolling on FF with DOMMouseScroll


        if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
          sX = sY;
          sY = 0;
        }

        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;

        if ('deltaY' in e) {
          pY = e.deltaY;
        }

        if ('deltaX' in e) {
          pX = e.deltaX;
        }

        if (e.shiftKey && !pX) {
          // if user scrolls with shift he wants horizontal scroll
          pX = pY;
          pY = 0;
        }

        if ((pX || pY) && e.deltaMode) {
          if (e.deltaMode === 1) {
            // delta in LINE units
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
          } else {
            // delta in PAGE units
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
          }
        } // Fall-back if spin cannot be determined


        if (pX && !sX) {
          sX = pX < 1 ? -1 : 1;
        }

        if (pY && !sY) {
          sY = pY < 1 ? -1 : 1;
        }

        return {
          spinX: sX,
          spinY: sY,
          pixelX: pX,
          pixelY: pY
        };
      }

      function handleMouseEnter() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = true;
      }

      function handleMouseLeave() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = false;
      }

      function animateSlider(newEvent) {
        if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
          // Prevent if delta of wheel scroll delta is below configured threshold
          return false;
        }

        if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
          // Prevent if time between scrolls is below configured threshold
          return false;
        } // If the movement is NOT big enough and
        // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
        //   Don't go any further (avoid insignificant scroll movement).


        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
          // Return false as a default
          return true;
        } // If user is scrolling towards the end:
        //   If the slider hasn't hit the latest slide or
        //   if the slider is a loop and
        //   if the slider isn't moving right now:
        //     Go to next slide and
        //     emit a scroll event.
        // Else (the user is scrolling towards the beginning) and
        // if the slider hasn't hit the first slide or
        // if the slider is a loop and
        // if the slider isn't moving right now:
        //   Go to prev slide and
        //   emit a scroll event.


        if (newEvent.direction < 0) {
          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
            swiper.slideNext();
            emit('scroll', newEvent.raw);
          }
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
          swiper.slidePrev();
          emit('scroll', newEvent.raw);
        } // If you got here is because an animation has been triggered so store the current time


        lastScrollTime = new window.Date().getTime(); // Return false as a default

        return false;
      }

      function releaseScroll(newEvent) {
        const params = swiper.params.mousewheel;

        if (newEvent.direction < 0) {
          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
            // Return true to animate scroll on edges
            return true;
          }
        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }

        return false;
      }

      function handle(event) {
        let e = event;
        let disableParentSwiper = true;
        if (!swiper.enabled) return;
        const params = swiper.params.mousewheel;

        if (swiper.params.cssMode) {
          e.preventDefault();
        }

        let target = swiper.$el;

        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }

        if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
        if (e.originalEvent) e = e.originalEvent; // jquery fix

        let delta = 0;
        const rtlFactor = swiper.rtlTranslate ? -1 : 1;
        const data = normalize(e);

        if (params.forceToAxis) {
          if (swiper.isHorizontal()) {
            if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
        } else {
          delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
        }

        if (delta === 0) return true;
        if (params.invert) delta = -delta; // Get the scroll positions

        let positions = swiper.getTranslate() + delta * params.sensitivity;
        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
        //     the disableParentSwiper will be true.
        // When loop is false:
        //     if the scroll positions is not on edge,
        //     then the disableParentSwiper will be true.
        //     if the scroll on edge positions,
        //     then the disableParentSwiper will be false.

        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();

        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
          // Register the new event in a variable which stores the relevant data
          const newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta),
            raw: event
          }; // Keep the most recent events

          if (recentWheelEvents.length >= 2) {
            recentWheelEvents.shift(); // only store the last N events
          }

          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
          //   If direction has changed or
          //   if the scroll is quicker than the previous one:
          //     Animate the slider.
          // Else (this is the first time the wheel is moved):
          //     Animate the slider.

          if (prevEvent) {
            if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
              animateSlider(newEvent);
            }
          } else {
            animateSlider(newEvent);
          } // If it's time to release the scroll:
          //   Return now so you don't hit the preventDefault.


          if (releaseScroll(newEvent)) {
            return true;
          }
        } else {
          // Freemode or scrollContainer:
          // If we recently snapped after a momentum scroll, then ignore wheel events
          // to give time for the deceleration to finish. Stop ignoring after 500 msecs
          // or if it's a new scroll (larger delta or inverse sign as last event before
          // an end-of-momentum snap).
          const newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta)
          };
          const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;

          if (!ignoreWheelEvents) {
            lastEventBeforeSnap = undefined;

            if (swiper.params.loop) {
              swiper.loopFix();
            }

            let position = swiper.getTranslate() + delta * params.sensitivity;
            const wasBeginning = swiper.isBeginning;
            const wasEnd = swiper.isEnd;
            if (position >= swiper.minTranslate()) position = swiper.minTranslate();
            if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
            swiper.setTransition(0);
            swiper.setTranslate(position);
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();

            if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
              swiper.updateSlidesClasses();
            }

            if (swiper.params.freeMode.sticky) {
              // When wheel scrolling starts with sticky (aka snap) enabled, then detect
              // the end of a momentum scroll by storing recent (N=15?) wheel events.
              // 1. do all N events have decreasing or same (absolute value) delta?
              // 2. did all N events arrive in the last M (M=500?) msecs?
              // 3. does the earliest event have an (absolute value) delta that's
              //    at least P (P=1?) larger than the most recent event's delta?
              // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
              // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
              // Snap immediately and ignore remaining wheel events in this scroll.
              // See comment above for "remaining wheel events in this scroll" determination.
              // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
              clearTimeout(timeout);
              timeout = undefined;

              if (recentWheelEvents.length >= 15) {
                recentWheelEvents.shift(); // only store the last N events
              }

              const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
              const firstEvent = recentWheelEvents[0];
              recentWheelEvents.push(newEvent);

              if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                recentWheelEvents.splice(0);
              } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                // We're at the end of the deceleration of a momentum scroll, so there's no need
                // to wait for more events. Snap ASAP on the next tick.
                // Also, because there's some remaining momentum we'll bias the snap in the
                // direction of the ongoing scroll because it's better UX for the scroll to snap
                // in the same direction as the scroll instead of reversing to snap.  Therefore,
                // if it's already scrolled more than 20% in the current direction, keep going.
                const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                timeout = nextTick(() => {
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 0); // no delay; move on next tick
              }

              if (!timeout) {
                // if we get here, then we haven't detected the end of a momentum scroll, so
                // we'll consider a scroll "complete" when there haven't been any wheel events
                // for 500ms.
                timeout = nextTick(() => {
                  const snapToThreshold = 0.5;
                  lastEventBeforeSnap = newEvent;
                  recentWheelEvents.splice(0);
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 500);
              }
            } // Emit event


            if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay

            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

            if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
          }
        }

        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        return false;
      }

      function events(method) {
        let target = swiper.$el;

        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }

        target[method]('mouseenter', handleMouseEnter);
        target[method]('mouseleave', handleMouseLeave);
        target[method]('wheel', handle);
      }

      function enable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.removeEventListener('wheel', handle);
          return true;
        }

        if (swiper.mousewheel.enabled) return false;
        events('on');
        swiper.mousewheel.enabled = true;
        return true;
      }

      function disable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.addEventListener(event, handle);
          return true;
        }

        if (!swiper.mousewheel.enabled) return false;
        events('off');
        swiper.mousewheel.enabled = false;
        return true;
      }

      on('init', () => {
        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
          disable();
        }

        if (swiper.params.mousewheel.enabled) enable();
      });
      on('destroy', () => {
        if (swiper.params.cssMode) {
          enable();
        }

        if (swiper.mousewheel.enabled) disable();
      });
      Object.assign(swiper.mousewheel, {
        enable,
        disable
      });
    }

    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
      const document = getDocument();

      if (swiper.params.createElements) {
        Object.keys(checkProps).forEach(key => {
          if (!params[key] && params.auto === true) {
            let element = swiper.$el.children(`.${checkProps[key]}`)[0];

            if (!element) {
              element = document.createElement('div');
              element.className = checkProps[key];
              swiper.$el.append(element);
            }

            params[key] = element;
            originalParams[key] = element;
          }
        });
      }

      return params;
    }

    function Navigation({
      swiper,
      extendParams,
      on,
      emit
    }) {
      extendParams({
        navigation: {
          nextEl: null,
          prevEl: null,
          hideOnClick: false,
          disabledClass: 'swiper-button-disabled',
          hiddenClass: 'swiper-button-hidden',
          lockClass: 'swiper-button-lock'
        }
      });
      swiper.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null
      };

      function getEl(el) {
        let $el;

        if (el) {
          $el = $(el);

          if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
            $el = swiper.$el.find(el);
          }
        }

        return $el;
      }

      function toggleEl($el, disabled) {
        const params = swiper.params.navigation;

        if ($el && $el.length > 0) {
          $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
          if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;

          if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }
        }
      }

      function update() {
        // Update Navigation Buttons
        if (swiper.params.loop) return;
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        toggleEl($prevEl, swiper.isBeginning);
        toggleEl($nextEl, swiper.isEnd);
      }

      function onPrevClick(e) {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop) return;
        swiper.slidePrev();
      }

      function onNextClick(e) {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop) return;
        swiper.slideNext();
      }

      function init() {
        const params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
          nextEl: 'swiper-button-next',
          prevEl: 'swiper-button-prev'
        });
        if (!(params.nextEl || params.prevEl)) return;
        const $nextEl = getEl(params.nextEl);
        const $prevEl = getEl(params.prevEl);

        if ($nextEl && $nextEl.length > 0) {
          $nextEl.on('click', onNextClick);
        }

        if ($prevEl && $prevEl.length > 0) {
          $prevEl.on('click', onPrevClick);
        }

        Object.assign(swiper.navigation, {
          $nextEl,
          nextEl: $nextEl && $nextEl[0],
          $prevEl,
          prevEl: $prevEl && $prevEl[0]
        });

        if (!swiper.enabled) {
          if ($nextEl) $nextEl.addClass(params.lockClass);
          if ($prevEl) $prevEl.addClass(params.lockClass);
        }
      }

      function destroy() {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;

        if ($nextEl && $nextEl.length) {
          $nextEl.off('click', onNextClick);
          $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }

        if ($prevEl && $prevEl.length) {
          $prevEl.off('click', onPrevClick);
          $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
      }

      on('init', () => {
        init();
        update();
      });
      on('toEdge fromEdge lock unlock', () => {
        update();
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;

        if ($nextEl) {
          $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }

        if ($prevEl) {
          $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }
      });
      on('click', (_s, e) => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        const targetEl = e.target;

        if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
          if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
          let isHidden;

          if ($nextEl) {
            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }

          if (isHidden === true) {
            emit('navigationShow');
          } else {
            emit('navigationHide');
          }

          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }

          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      });
      Object.assign(swiper.navigation, {
        update,
        init,
        destroy
      });
    }

    function classesToSelector(classes = '') {
      return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
    }

    function Pagination({
      swiper,
      extendParams,
      on,
      emit
    }) {
      const pfx = 'swiper-pagination';
      extendParams({
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets',
          // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: number => number,
          formatFractionTotal: number => number,
          bulletClass: `${pfx}-bullet`,
          bulletActiveClass: `${pfx}-bullet-active`,
          modifierClass: `${pfx}-`,
          currentClass: `${pfx}-current`,
          totalClass: `${pfx}-total`,
          hiddenClass: `${pfx}-hidden`,
          progressbarFillClass: `${pfx}-progressbar-fill`,
          progressbarOppositeClass: `${pfx}-progressbar-opposite`,
          clickableClass: `${pfx}-clickable`,
          lockClass: `${pfx}-lock`,
          horizontalClass: `${pfx}-horizontal`,
          verticalClass: `${pfx}-vertical`
        }
      });
      swiper.pagination = {
        el: null,
        $el: null,
        bullets: []
      };
      let bulletSize;
      let dynamicBulletIndex = 0;

      function isPaginationDisabled() {
        return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
      }

      function setSideBullets($bulletEl, position) {
        const {
          bulletActiveClass
        } = swiper.params.pagination;
        $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
      }

      function update() {
        // Render || Update Pagination bullets/items
        const rtl = swiper.rtl;
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const $el = swiper.pagination.$el; // Current/Total

        let current;
        const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        if (swiper.params.loop) {
          current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }

          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        } // Types


        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
          const bullets = swiper.pagination.bullets;
          let firstIndex;
          let lastIndex;
          let midIndex;

          if (params.dynamicBullets) {
            bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);

            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              dynamicBulletIndex += current - swiper.previousIndex;

              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (dynamicBulletIndex < 0) {
                dynamicBulletIndex = 0;
              }
            }

            firstIndex = current - dynamicBulletIndex;
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }

          bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));

          if ($el.length > 1) {
            bullets.each(bullet => {
              const $bullet = $(bullet);
              const bulletIndex = $bullet.index();

              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }

              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass(`${params.bulletActiveClass}-main`);
                }

                if (bulletIndex === firstIndex) {
                  setSideBullets($bullet, 'prev');
                }

                if (bulletIndex === lastIndex) {
                  setSideBullets($bullet, 'next');
                }
              }
            });
          } else {
            const $bullet = bullets.eq(current);
            const bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);

            if (params.dynamicBullets) {
              const $firstDisplayedBullet = bullets.eq(firstIndex);
              const $lastDisplayedBullet = bullets.eq(lastIndex);

              for (let i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
              }

              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                  for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                    bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                  }

                  bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                } else {
                  setSideBullets($firstDisplayedBullet, 'prev');
                  setSideBullets($lastDisplayedBullet, 'next');
                }
              } else {
                setSideBullets($firstDisplayedBullet, 'prev');
                setSideBullets($lastDisplayedBullet, 'next');
              }
            }
          }

          if (params.dynamicBullets) {
            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
            const offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
          }
        }

        if (params.type === 'fraction') {
          $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
          $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }

        if (params.type === 'progressbar') {
          let progressbarDirection;

          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }

          const scale = (current + 1) / total;
          let scaleX = 1;
          let scaleY = 1;

          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }

          $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
        }

        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          emit('paginationRender', $el[0]);
        } else {
          emit('paginationUpdate', $el[0]);
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      }

      function render() {
        // Render Container
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const $el = swiper.pagination.$el;
        let paginationHTML = '';

        if (params.type === 'bullets') {
          let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

          if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
            numberOfBullets = slidesLength;
          }

          for (let i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
            }
          }

          $el.html(paginationHTML);
          swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }

        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
          }

          $el.html(paginationHTML);
        }

        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
          }

          $el.html(paginationHTML);
        }

        if (params.type !== 'custom') {
          emit('paginationRender', swiper.pagination.$el[0]);
        }
      }

      function init() {
        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
          el: 'swiper-pagination'
        });
        const params = swiper.params.pagination;
        if (!params.el) return;
        let $el = $(params.el);
        if ($el.length === 0) return;

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
          $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

          if ($el.length > 1) {
            $el = $el.filter(el => {
              if ($(el).parents('.swiper')[0] !== swiper.el) return false;
              return true;
            });
          }
        }

        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }

        $el.addClass(params.modifierClass + params.type);
        $el.addClass(params.modifierClass + swiper.params.direction);

        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
          dynamicBulletIndex = 0;

          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }

        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }

        if (params.clickable) {
          $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
            e.preventDefault();
            let index = $(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }

        Object.assign(swiper.pagination, {
          $el,
          el: $el[0]
        });

        if (!swiper.enabled) {
          $el.addClass(params.lockClass);
        }
      }

      function destroy() {
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        $el.removeClass(params.modifierClass + swiper.params.direction);
        if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

        if (params.clickable) {
          $el.off('click', classesToSelector(params.bulletClass));
        }
      }

      on('init', () => {
        init();
        render();
        update();
      });
      on('activeIndexChange', () => {
        if (swiper.params.loop) {
          update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          update();
        }
      });
      on('snapIndexChange', () => {
        if (!swiper.params.loop) {
          update();
        }
      });
      on('slidesLengthChange', () => {
        if (swiper.params.loop) {
          render();
          update();
        }
      });
      on('snapGridLengthChange', () => {
        if (!swiper.params.loop) {
          render();
          update();
        }
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const {
          $el
        } = swiper.pagination;

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
        }
      });
      on('lock unlock', () => {
        update();
      });
      on('click', (_s, e) => {
        const targetEl = e.target;
        const {
          $el
        } = swiper.pagination;

        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
          if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
          const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);

          if (isHidden === true) {
            emit('paginationShow');
          } else {
            emit('paginationHide');
          }

          $el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      });
      Object.assign(swiper.pagination, {
        render,
        update,
        init,
        destroy
      });
    }

    function Scrollbar({
      swiper,
      extendParams,
      on,
      emit
    }) {
      const document = getDocument();
      let isTouched = false;
      let timeout = null;
      let dragTimeout = null;
      let dragStartPos;
      let dragSize;
      let trackSize;
      let divider;
      extendParams({
        scrollbar: {
          el: null,
          dragSize: 'auto',
          hide: false,
          draggable: false,
          snapOnRelease: true,
          lockClass: 'swiper-scrollbar-lock',
          dragClass: 'swiper-scrollbar-drag'
        }
      });
      swiper.scrollbar = {
        el: null,
        dragEl: null,
        $el: null,
        $dragEl: null
      };

      function setTranslate() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {
          scrollbar,
          rtlTranslate: rtl,
          progress
        } = swiper;
        const {
          $dragEl,
          $el
        } = scrollbar;
        const params = swiper.params.scrollbar;
        let newSize = dragSize;
        let newPos = (trackSize - dragSize) * progress;

        if (rtl) {
          newPos = -newPos;

          if (newPos > 0) {
            newSize = dragSize - newPos;
            newPos = 0;
          } else if (-newPos + dragSize > trackSize) {
            newSize = trackSize + newPos;
          }
        } else if (newPos < 0) {
          newSize = dragSize + newPos;
          newPos = 0;
        } else if (newPos + dragSize > trackSize) {
          newSize = trackSize - newPos;
        }

        if (swiper.isHorizontal()) {
          $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
          $dragEl[0].style.width = `${newSize}px`;
        } else {
          $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
          $dragEl[0].style.height = `${newSize}px`;
        }

        if (params.hide) {
          clearTimeout(timeout);
          $el[0].style.opacity = 1;
          timeout = setTimeout(() => {
            $el[0].style.opacity = 0;
            $el.transition(400);
          }, 1000);
        }
      }

      function setTransition(duration) {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.$dragEl.transition(duration);
      }

      function updateSize() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {
          scrollbar
        } = swiper;
        const {
          $dragEl,
          $el
        } = scrollbar;
        $dragEl[0].style.width = '';
        $dragEl[0].style.height = '';
        trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));

        if (swiper.params.scrollbar.dragSize === 'auto') {
          dragSize = trackSize * divider;
        } else {
          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }

        if (swiper.isHorizontal()) {
          $dragEl[0].style.width = `${dragSize}px`;
        } else {
          $dragEl[0].style.height = `${dragSize}px`;
        }

        if (divider >= 1) {
          $el[0].style.display = 'none';
        } else {
          $el[0].style.display = '';
        }

        if (swiper.params.scrollbar.hide) {
          $el[0].style.opacity = 0;
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
        }
      }

      function getPointerPosition(e) {
        if (swiper.isHorizontal()) {
          return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
        }

        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
      }

      function setDragPosition(e) {
        const {
          scrollbar,
          rtlTranslate: rtl
        } = swiper;
        const {
          $el
        } = scrollbar;
        let positionRatio;
        positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);

        if (rtl) {
          positionRatio = 1 - positionRatio;
        }

        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      function onDragStart(e) {
        const params = swiper.params.scrollbar;
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el,
          $dragEl
        } = scrollbar;
        isTouched = true;
        dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
        e.preventDefault();
        e.stopPropagation();
        $wrapperEl.transition(100);
        $dragEl.transition(100);
        setDragPosition(e);
        clearTimeout(dragTimeout);
        $el.transition(0);

        if (params.hide) {
          $el.css('opacity', 1);
        }

        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', 'none');
        }

        emit('scrollbarDragStart', e);
      }

      function onDragMove(e) {
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el,
          $dragEl
        } = scrollbar;
        if (!isTouched) return;
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        setDragPosition(e);
        $wrapperEl.transition(0);
        $el.transition(0);
        $dragEl.transition(0);
        emit('scrollbarDragMove', e);
      }

      function onDragEnd(e) {
        const params = swiper.params.scrollbar;
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el
        } = scrollbar;
        if (!isTouched) return;
        isTouched = false;

        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', '');
          $wrapperEl.transition('');
        }

        if (params.hide) {
          clearTimeout(dragTimeout);
          dragTimeout = nextTick(() => {
            $el.css('opacity', 0);
            $el.transition(400);
          }, 1000);
        }

        emit('scrollbarDragEnd', e);

        if (params.snapOnRelease) {
          swiper.slideToClosest();
        }
      }

      function events(method) {
        const {
          scrollbar,
          touchEventsTouch,
          touchEventsDesktop,
          params,
          support
        } = swiper;
        const $el = scrollbar.$el;
        const target = $el[0];
        const activeListener = support.passiveListener && params.passiveListeners ? {
          passive: false,
          capture: false
        } : false;
        const passiveListener = support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        if (!target) return;
        const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';

        if (!support.touch) {
          target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
          document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
          document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
        } else {
          target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
          target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
          target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
        }
      }

      function enableDraggable() {
        if (!swiper.params.scrollbar.el) return;
        events('on');
      }

      function disableDraggable() {
        if (!swiper.params.scrollbar.el) return;
        events('off');
      }

      function init() {
        const {
          scrollbar,
          $el: $swiperEl
        } = swiper;
        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
          el: 'swiper-scrollbar'
        });
        const params = swiper.params.scrollbar;
        if (!params.el) return;
        let $el = $(params.el);

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
          $el = $swiperEl.find(params.el);
        }

        let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);

        if ($dragEl.length === 0) {
          $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
          $el.append($dragEl);
        }

        Object.assign(scrollbar, {
          $el,
          el: $el[0],
          $dragEl,
          dragEl: $dragEl[0]
        });

        if (params.draggable) {
          enableDraggable();
        }

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      }

      function destroy() {
        disableDraggable();
      }

      on('init', () => {
        init();
        updateSize();
        setTranslate();
      });
      on('update resize observerUpdate lock unlock', () => {
        updateSize();
      });
      on('setTranslate', () => {
        setTranslate();
      });
      on('setTransition', (_s, duration) => {
        setTransition(duration);
      });
      on('enable disable', () => {
        const {
          $el
        } = swiper.scrollbar;

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      });
      on('destroy', () => {
        destroy();
      });
      Object.assign(swiper.scrollbar, {
        updateSize,
        setTranslate,
        init,
        destroy
      });
    }

    function Parallax({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        parallax: {
          enabled: false
        }
      });

      const setTransform = (el, progress) => {
        const {
          rtl
        } = swiper;
        const $el = $(el);
        const rtlFactor = rtl ? -1 : 1;
        const p = $el.attr('data-swiper-parallax') || '0';
        let x = $el.attr('data-swiper-parallax-x');
        let y = $el.attr('data-swiper-parallax-y');
        const scale = $el.attr('data-swiper-parallax-scale');
        const opacity = $el.attr('data-swiper-parallax-opacity');

        if (x || y) {
          x = x || '0';
          y = y || '0';
        } else if (swiper.isHorizontal()) {
          x = p;
          y = '0';
        } else {
          y = p;
          x = '0';
        }

        if (x.indexOf('%') >= 0) {
          x = `${parseInt(x, 10) * progress * rtlFactor}%`;
        } else {
          x = `${x * progress * rtlFactor}px`;
        }

        if (y.indexOf('%') >= 0) {
          y = `${parseInt(y, 10) * progress}%`;
        } else {
          y = `${y * progress}px`;
        }

        if (typeof opacity !== 'undefined' && opacity !== null) {
          const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
          $el[0].style.opacity = currentOpacity;
        }

        if (typeof scale === 'undefined' || scale === null) {
          $el.transform(`translate3d(${x}, ${y}, 0px)`);
        } else {
          const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
          $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
        }
      };

      const setTranslate = () => {
        const {
          $el,
          slides,
          progress,
          snapGrid
        } = swiper;
        $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
          setTransform(el, progress);
        });
        slides.each((slideEl, slideIndex) => {
          let slideProgress = slideEl.progress;

          if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
            slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
          }

          slideProgress = Math.min(Math.max(slideProgress, -1), 1);
          $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
            setTransform(el, slideProgress);
          });
        });
      };

      const setTransition = (duration = swiper.params.speed) => {
        const {
          $el
        } = swiper;
        $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
          const $parallaxEl = $(parallaxEl);
          let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
          if (duration === 0) parallaxDuration = 0;
          $parallaxEl.transition(parallaxDuration);
        });
      };

      on('beforeInit', () => {
        if (!swiper.params.parallax.enabled) return;
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      });
      on('init', () => {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTranslate', () => {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTransition', (_swiper, duration) => {
        if (!swiper.params.parallax.enabled) return;
        setTransition(duration);
      });
    }

    function Zoom({
      swiper,
      extendParams,
      on,
      emit
    }) {
      const window = getWindow();
      extendParams({
        zoom: {
          enabled: false,
          maxRatio: 3,
          minRatio: 1,
          toggle: true,
          containerClass: 'swiper-zoom-container',
          zoomedSlideClass: 'swiper-slide-zoomed'
        }
      });
      swiper.zoom = {
        enabled: false
      };
      let currentScale = 1;
      let isScaling = false;
      let gesturesEnabled;
      let fakeGestureTouched;
      let fakeGestureMoved;
      const gesture = {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3
      };
      const image = {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {}
      };
      const velocity = {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined
      };
      let scale = 1;
      Object.defineProperty(swiper.zoom, 'scale', {
        get() {
          return scale;
        },

        set(value) {
          if (scale !== value) {
            const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
            const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
            emit('zoomChange', value, imageEl, slideEl);
          }

          scale = value;
        }

      });

      function getDistanceBetweenTouches(e) {
        if (e.targetTouches.length < 2) return 1;
        const x1 = e.targetTouches[0].pageX;
        const y1 = e.targetTouches[0].pageY;
        const x2 = e.targetTouches[1].pageX;
        const y2 = e.targetTouches[1].pageY;
        const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        return distance;
      } // Events


      function onGestureStart(e) {
        const support = swiper.support;
        const params = swiper.params.zoom;
        fakeGestureTouched = false;
        fakeGestureMoved = false;

        if (!support.gestures) {
          if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
            return;
          }

          fakeGestureTouched = true;
          gesture.scaleStart = getDistanceBetweenTouches(e);
        }

        if (!gesture.$slideEl || !gesture.$slideEl.length) {
          gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
          if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('img, svg, canvas, picture, .swiper-zoom-target');
          gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
          gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

          if (gesture.$imageWrapEl.length === 0) {
            gesture.$imageEl = undefined;
            return;
          }
        }

        if (gesture.$imageEl) {
          gesture.$imageEl.transition(0);
        }

        isScaling = true;
      }

      function onGestureChange(e) {
        const support = swiper.support;
        const params = swiper.params.zoom;
        const zoom = swiper.zoom;

        if (!support.gestures) {
          if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
            return;
          }

          fakeGestureMoved = true;
          gesture.scaleMove = getDistanceBetweenTouches(e);
        }

        if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
          if (e.type === 'gesturechange') onGestureStart(e);
          return;
        }

        if (support.gestures) {
          zoom.scale = e.scale * currentScale;
        } else {
          zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
        }

        if (zoom.scale > gesture.maxRatio) {
          zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
        }

        if (zoom.scale < params.minRatio) {
          zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
        }

        gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
      }

      function onGestureEnd(e) {
        const device = swiper.device;
        const support = swiper.support;
        const params = swiper.params.zoom;
        const zoom = swiper.zoom;

        if (!support.gestures) {
          if (!fakeGestureTouched || !fakeGestureMoved) {
            return;
          }

          if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
            return;
          }

          fakeGestureTouched = false;
          fakeGestureMoved = false;
        }

        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
        gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        currentScale = zoom.scale;
        isScaling = false;
        if (zoom.scale === 1) gesture.$slideEl = undefined;
      }

      function onTouchStart(e) {
        const device = swiper.device;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (image.isTouched) return;
        if (device.android && e.cancelable) e.preventDefault();
        image.isTouched = true;
        image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      }

      function onTouchMove(e) {
        const zoom = swiper.zoom;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        swiper.allowClick = false;
        if (!image.isTouched || !gesture.$slideEl) return;

        if (!image.isMoved) {
          image.width = gesture.$imageEl[0].offsetWidth;
          image.height = gesture.$imageEl[0].offsetHeight;
          image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
          image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
          gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
          gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
          gesture.$imageWrapEl.transition(0);
        } // Define if we need image drag


        const scaledWidth = image.width * zoom.scale;
        const scaledHeight = image.height * zoom.scale;
        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

        if (!image.isMoved && !isScaling) {
          if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
            image.isTouched = false;
            return;
          }

          if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
            image.isTouched = false;
            return;
          }
        }

        if (e.cancelable) {
          e.preventDefault();
        }

        e.stopPropagation();
        image.isMoved = true;
        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

        if (image.currentX < image.minX) {
          image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
        }

        if (image.currentX > image.maxX) {
          image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
        }

        if (image.currentY < image.minY) {
          image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
        }

        if (image.currentY > image.maxY) {
          image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
        } // Velocity


        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
        if (!velocity.prevTime) velocity.prevTime = Date.now();
        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
        velocity.prevPositionX = image.touchesCurrent.x;
        velocity.prevPositionY = image.touchesCurrent.y;
        velocity.prevTime = Date.now();
        gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
      }

      function onTouchEnd() {
        const zoom = swiper.zoom;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

        if (!image.isTouched || !image.isMoved) {
          image.isTouched = false;
          image.isMoved = false;
          return;
        }

        image.isTouched = false;
        image.isMoved = false;
        let momentumDurationX = 300;
        let momentumDurationY = 300;
        const momentumDistanceX = velocity.x * momentumDurationX;
        const newPositionX = image.currentX + momentumDistanceX;
        const momentumDistanceY = velocity.y * momentumDurationY;
        const newPositionY = image.currentY + momentumDistanceY; // Fix duration

        if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
        if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
        const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
        image.currentX = newPositionX;
        image.currentY = newPositionY; // Define if we need image drag

        const scaledWidth = image.width * zoom.scale;
        const scaledHeight = image.height * zoom.scale;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
        gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
      }

      function onTransitionEnd() {
        const zoom = swiper.zoom;

        if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
          if (gesture.$imageEl) {
            gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
          }

          if (gesture.$imageWrapEl) {
            gesture.$imageWrapEl.transform('translate3d(0,0,0)');
          }

          zoom.scale = 1;
          currentScale = 1;
          gesture.$slideEl = undefined;
          gesture.$imageEl = undefined;
          gesture.$imageWrapEl = undefined;
        }
      }

      function zoomIn(e) {
        const zoom = swiper.zoom;
        const params = swiper.params.zoom;

        if (!gesture.$slideEl) {
          if (e && e.target) {
            gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
          }

          if (!gesture.$slideEl) {
            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
              gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
            } else {
              gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            }
          }

          gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('img, svg, canvas, picture, .swiper-zoom-target');
          gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
        }

        if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;

        if (swiper.params.cssMode) {
          swiper.wrapperEl.style.overflow = 'hidden';
          swiper.wrapperEl.style.touchAction = 'none';
        }

        gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
        let touchX;
        let touchY;
        let offsetX;
        let offsetY;
        let diffX;
        let diffY;
        let translateX;
        let translateY;
        let imageWidth;
        let imageHeight;
        let scaledWidth;
        let scaledHeight;
        let translateMinX;
        let translateMinY;
        let translateMaxX;
        let translateMaxY;
        let slideWidth;
        let slideHeight;

        if (typeof image.touchesStart.x === 'undefined' && e) {
          touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
          touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
        } else {
          touchX = image.touchesStart.x;
          touchY = image.touchesStart.y;
        }

        zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
        currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

        if (e) {
          slideWidth = gesture.$slideEl[0].offsetWidth;
          slideHeight = gesture.$slideEl[0].offsetHeight;
          offsetX = gesture.$slideEl.offset().left + window.scrollX;
          offsetY = gesture.$slideEl.offset().top + window.scrollY;
          diffX = offsetX + slideWidth / 2 - touchX;
          diffY = offsetY + slideHeight / 2 - touchY;
          imageWidth = gesture.$imageEl[0].offsetWidth;
          imageHeight = gesture.$imageEl[0].offsetHeight;
          scaledWidth = imageWidth * zoom.scale;
          scaledHeight = imageHeight * zoom.scale;
          translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
          translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
          translateMaxX = -translateMinX;
          translateMaxY = -translateMinY;
          translateX = diffX * zoom.scale;
          translateY = diffY * zoom.scale;

          if (translateX < translateMinX) {
            translateX = translateMinX;
          }

          if (translateX > translateMaxX) {
            translateX = translateMaxX;
          }

          if (translateY < translateMinY) {
            translateY = translateMinY;
          }

          if (translateY > translateMaxY) {
            translateY = translateMaxY;
          }
        } else {
          translateX = 0;
          translateY = 0;
        }

        gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
        gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
      }

      function zoomOut() {
        const zoom = swiper.zoom;
        const params = swiper.params.zoom;

        if (!gesture.$slideEl) {
          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
            gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
          } else {
            gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          }

          gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('img, svg, canvas, picture, .swiper-zoom-target');
          gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
        }

        if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;

        if (swiper.params.cssMode) {
          swiper.wrapperEl.style.overflow = '';
          swiper.wrapperEl.style.touchAction = '';
        }

        zoom.scale = 1;
        currentScale = 1;
        gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
        gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
        gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
        gesture.$slideEl = undefined;
      } // Toggle Zoom


      function zoomToggle(e) {
        const zoom = swiper.zoom;

        if (zoom.scale && zoom.scale !== 1) {
          // Zoom Out
          zoomOut();
        } else {
          // Zoom In
          zoomIn(e);
        }
      }

      function getListeners() {
        const support = swiper.support;
        const passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        const activeListenerWithCapture = support.passiveListener ? {
          passive: false,
          capture: true
        } : true;
        return {
          passiveListener,
          activeListenerWithCapture
        };
      }

      function getSlideSelector() {
        return `.${swiper.params.slideClass}`;
      }

      function toggleGestures(method) {
        const {
          passiveListener
        } = getListeners();
        const slideSelector = getSlideSelector();
        swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
        swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
        swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
      }

      function enableGestures() {
        if (gesturesEnabled) return;
        gesturesEnabled = true;
        toggleGestures('on');
      }

      function disableGestures() {
        if (!gesturesEnabled) return;
        gesturesEnabled = false;
        toggleGestures('off');
      } // Attach/Detach Events


      function enable() {
        const zoom = swiper.zoom;
        if (zoom.enabled) return;
        zoom.enabled = true;
        const support = swiper.support;
        const {
          passiveListener,
          activeListenerWithCapture
        } = getListeners();
        const slideSelector = getSlideSelector(); // Scale image

        if (support.gestures) {
          swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
          swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === 'touchstart') {
          swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
          swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
          swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);

          if (swiper.touchEvents.cancel) {
            swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
          }
        } // Move image


        swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
      }

      function disable() {
        const zoom = swiper.zoom;
        if (!zoom.enabled) return;
        const support = swiper.support;
        zoom.enabled = false;
        const {
          passiveListener,
          activeListenerWithCapture
        } = getListeners();
        const slideSelector = getSlideSelector(); // Scale image

        if (support.gestures) {
          swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
          swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === 'touchstart') {
          swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
          swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
          swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);

          if (swiper.touchEvents.cancel) {
            swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
          }
        } // Move image


        swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
      }

      on('init', () => {
        if (swiper.params.zoom.enabled) {
          enable();
        }
      });
      on('destroy', () => {
        disable();
      });
      on('touchStart', (_s, e) => {
        if (!swiper.zoom.enabled) return;
        onTouchStart(e);
      });
      on('touchEnd', (_s, e) => {
        if (!swiper.zoom.enabled) return;
        onTouchEnd();
      });
      on('doubleTap', (_s, e) => {
        if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
          zoomToggle(e);
        }
      });
      on('transitionEnd', () => {
        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
          onTransitionEnd();
        }
      });
      on('slideChange', () => {
        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
          onTransitionEnd();
        }
      });
      Object.assign(swiper.zoom, {
        enable,
        disable,
        in: zoomIn,
        out: zoomOut,
        toggle: zoomToggle
      });
    }

    function Lazy({
      swiper,
      extendParams,
      on,
      emit
    }) {
      extendParams({
        lazy: {
          checkInView: false,
          enabled: false,
          loadPrevNext: false,
          loadPrevNextAmount: 1,
          loadOnTransitionStart: false,
          scrollingElement: '',
          elementClass: 'swiper-lazy',
          loadingClass: 'swiper-lazy-loading',
          loadedClass: 'swiper-lazy-loaded',
          preloaderClass: 'swiper-lazy-preloader'
        }
      });
      swiper.lazy = {};
      let scrollHandlerAttached = false;
      let initialImageLoaded = false;

      function loadInSlide(index, loadInDuplicate = true) {
        const params = swiper.params.lazy;
        if (typeof index === 'undefined') return;
        if (swiper.slides.length === 0) return;
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`) : swiper.slides.eq(index);
        const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);

        if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
          $images.push($slideEl[0]);
        }

        if ($images.length === 0) return;
        $images.each(imageEl => {
          const $imageEl = $(imageEl);
          $imageEl.addClass(params.loadingClass);
          const background = $imageEl.attr('data-background');
          const src = $imageEl.attr('data-src');
          const srcset = $imageEl.attr('data-srcset');
          const sizes = $imageEl.attr('data-sizes');
          const $pictureEl = $imageEl.parent('picture');
          swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
            if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;

            if (background) {
              $imageEl.css('background-image', `url("${background}")`);
              $imageEl.removeAttr('data-background');
            } else {
              if (srcset) {
                $imageEl.attr('srcset', srcset);
                $imageEl.removeAttr('data-srcset');
              }

              if (sizes) {
                $imageEl.attr('sizes', sizes);
                $imageEl.removeAttr('data-sizes');
              }

              if ($pictureEl.length) {
                $pictureEl.children('source').each(sourceEl => {
                  const $source = $(sourceEl);

                  if ($source.attr('data-srcset')) {
                    $source.attr('srcset', $source.attr('data-srcset'));
                    $source.removeAttr('data-srcset');
                  }
                });
              }

              if (src) {
                $imageEl.attr('src', src);
                $imageEl.removeAttr('data-src');
              }
            }

            $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
            $slideEl.find(`.${params.preloaderClass}`).remove();

            if (swiper.params.loop && loadInDuplicate) {
              const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

              if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
                loadInSlide(originalSlide.index(), false);
              } else {
                const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
                loadInSlide(duplicatedSlide.index(), false);
              }
            }

            emit('lazyImageReady', $slideEl[0], $imageEl[0]);

            if (swiper.params.autoHeight) {
              swiper.updateAutoHeight();
            }
          });
          emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
        });
      }

      function load() {
        const {
          $wrapperEl,
          params: swiperParams,
          slides,
          activeIndex
        } = swiper;
        const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
        const params = swiperParams.lazy;
        let slidesPerView = swiperParams.slidesPerView;

        if (slidesPerView === 'auto') {
          slidesPerView = 0;
        }

        function slideExist(index) {
          if (isVirtual) {
            if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
              return true;
            }
          } else if (slides[index]) return true;

          return false;
        }

        function slideIndex(slideEl) {
          if (isVirtual) {
            return $(slideEl).attr('data-swiper-slide-index');
          }

          return $(slideEl).index();
        }

        if (!initialImageLoaded) initialImageLoaded = true;

        if (swiper.params.watchSlidesProgress) {
          $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each(slideEl => {
            const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
            loadInSlide(index);
          });
        } else if (slidesPerView > 1) {
          for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
            if (slideExist(i)) loadInSlide(i);
          }
        } else {
          loadInSlide(activeIndex);
        }

        if (params.loadPrevNext) {
          if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
            const amount = params.loadPrevNextAmount;
            const spv = slidesPerView;
            const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
            const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

            for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
              if (slideExist(i)) loadInSlide(i);
            } // Prev Slides


            for (let i = minIndex; i < activeIndex; i += 1) {
              if (slideExist(i)) loadInSlide(i);
            }
          } else {
            const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
            if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
            const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
            if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
          }
        }
      }

      function checkInViewOnLoad() {
        const window = getWindow();
        if (!swiper || swiper.destroyed) return;
        const $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);
        const isWindow = $scrollElement[0] === window;
        const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
        const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
        const swiperOffset = swiper.$el.offset();
        const {
          rtlTranslate: rtl
        } = swiper;
        let inView = false;
        if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
        const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

        for (let i = 0; i < swiperCoord.length; i += 1) {
          const point = swiperCoord[i];

          if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
            if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

            inView = true;
          }
        }

        const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;

        if (inView) {
          load();
          $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
        } else if (!scrollHandlerAttached) {
          scrollHandlerAttached = true;
          $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
        }
      }

      on('beforeInit', () => {
        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
          swiper.params.preloadImages = false;
        }
      });
      on('init', () => {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on('scroll', () => {
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
          load();
        }
      });
      on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on('transitionStart', () => {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
            if (swiper.params.lazy.checkInView) {
              checkInViewOnLoad();
            } else {
              load();
            }
          }
        }
      });
      on('transitionEnd', () => {
        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on('slideChange', () => {
        const {
          lazy,
          cssMode,
          watchSlidesProgress,
          touchReleaseOnEdges,
          resistanceRatio
        } = swiper.params;

        if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
          load();
        }
      });
      Object.assign(swiper.lazy, {
        load,
        loadInSlide
      });
    }

    /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
    function Controller({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        controller: {
          control: undefined,
          inverse: false,
          by: 'slide' // or 'container'

        }
      });
      swiper.controller = {
        control: undefined
      };

      function LinearSpline(x, y) {
        const binarySearch = function search() {
          let maxIndex;
          let minIndex;
          let guess;
          return (array, val) => {
            minIndex = -1;
            maxIndex = array.length;

            while (maxIndex - minIndex > 1) {
              guess = maxIndex + minIndex >> 1;

              if (array[guess] <= val) {
                minIndex = guess;
              } else {
                maxIndex = guess;
              }
            }

            return maxIndex;
          };
        }();

        this.x = x;
        this.y = y;
        this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
        // (x1,y1) is the known point before given value,
        // (x3,y3) is the known point after given value.

        let i1;
        let i3;

        this.interpolate = function interpolate(x2) {
          if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

          i3 = binarySearch(this.x, x2);
          i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
          // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

          return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
        };

        return this;
      } // xxx: for now i will just save one spline function to to


      function getInterpolateFunction(c) {
        if (!swiper.controller.spline) {
          swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
        }
      }

      function setTranslate(_t, byController) {
        const controlled = swiper.controller.control;
        let multiplier;
        let controlledTranslate;
        const Swiper = swiper.constructor;

        function setControlledTranslate(c) {
          // this will create an Interpolate function based on the snapGrids
          // x is the Grid of the scrolled scroller and y will be the controlled scroller
          // it makes sense to create this only once and recall it for the interpolation
          // the function does a lot of value caching for performance
          const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

          if (swiper.params.controller.by === 'slide') {
            getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
            // but it did not work out

            controlledTranslate = -swiper.controller.spline.interpolate(-translate);
          }

          if (!controlledTranslate || swiper.params.controller.by === 'container') {
            multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
            controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
          }

          if (swiper.params.controller.inverse) {
            controlledTranslate = c.maxTranslate() - controlledTranslate;
          }

          c.updateProgress(controlledTranslate);
          c.setTranslate(controlledTranslate, swiper);
          c.updateActiveIndex();
          c.updateSlidesClasses();
        }

        if (Array.isArray(controlled)) {
          for (let i = 0; i < controlled.length; i += 1) {
            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
              setControlledTranslate(controlled[i]);
            }
          }
        } else if (controlled instanceof Swiper && byController !== controlled) {
          setControlledTranslate(controlled);
        }
      }

      function setTransition(duration, byController) {
        const Swiper = swiper.constructor;
        const controlled = swiper.controller.control;
        let i;

        function setControlledTransition(c) {
          c.setTransition(duration, swiper);

          if (duration !== 0) {
            c.transitionStart();

            if (c.params.autoHeight) {
              nextTick(() => {
                c.updateAutoHeight();
              });
            }

            c.$wrapperEl.transitionEnd(() => {
              if (!controlled) return;

              if (c.params.loop && swiper.params.controller.by === 'slide') {
                c.loopFix();
              }

              c.transitionEnd();
            });
          }
        }

        if (Array.isArray(controlled)) {
          for (i = 0; i < controlled.length; i += 1) {
            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
              setControlledTransition(controlled[i]);
            }
          }
        } else if (controlled instanceof Swiper && byController !== controlled) {
          setControlledTransition(controlled);
        }
      }

      function removeSpline() {
        if (!swiper.controller.control) return;

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      }

      on('beforeInit', () => {
        swiper.controller.control = swiper.params.controller.control;
      });
      on('update', () => {
        removeSpline();
      });
      on('resize', () => {
        removeSpline();
      });
      on('observerUpdate', () => {
        removeSpline();
      });
      on('setTranslate', (_s, translate, byController) => {
        if (!swiper.controller.control) return;
        swiper.controller.setTranslate(translate, byController);
      });
      on('setTransition', (_s, duration, byController) => {
        if (!swiper.controller.control) return;
        swiper.controller.setTransition(duration, byController);
      });
      Object.assign(swiper.controller, {
        setTranslate,
        setTransition
      });
    }

    function A11y({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        a11y: {
          enabled: true,
          notificationClass: 'swiper-notification',
          prevSlideMessage: 'Previous slide',
          nextSlideMessage: 'Next slide',
          firstSlideMessage: 'This is the first slide',
          lastSlideMessage: 'This is the last slide',
          paginationBulletMessage: 'Go to slide {{index}}',
          slideLabelMessage: '{{index}} / {{slidesLength}}',
          containerMessage: null,
          containerRoleDescriptionMessage: null,
          itemRoleDescriptionMessage: null,
          slideRole: 'group'
        }
      });
      let liveRegion = null;

      function notify(message) {
        const notification = liveRegion;
        if (notification.length === 0) return;
        notification.html('');
        notification.html(message);
      }

      function getRandomNumber(size = 16) {
        const randomChar = () => Math.round(16 * Math.random()).toString(16);

        return 'x'.repeat(size).replace(/x/g, randomChar);
      }

      function makeElFocusable($el) {
        $el.attr('tabIndex', '0');
      }

      function makeElNotFocusable($el) {
        $el.attr('tabIndex', '-1');
      }

      function addElRole($el, role) {
        $el.attr('role', role);
      }

      function addElRoleDescription($el, description) {
        $el.attr('aria-roledescription', description);
      }

      function addElControls($el, controls) {
        $el.attr('aria-controls', controls);
      }

      function addElLabel($el, label) {
        $el.attr('aria-label', label);
      }

      function addElId($el, id) {
        $el.attr('id', id);
      }

      function addElLive($el, live) {
        $el.attr('aria-live', live);
      }

      function disableEl($el) {
        $el.attr('aria-disabled', true);
      }

      function enableEl($el) {
        $el.attr('aria-disabled', false);
      }

      function onEnterOrSpaceKey(e) {
        if (e.keyCode !== 13 && e.keyCode !== 32) return;
        const params = swiper.params.a11y;
        const $targetEl = $(e.target);

        if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
          if (!(swiper.isEnd && !swiper.params.loop)) {
            swiper.slideNext();
          }

          if (swiper.isEnd) {
            notify(params.lastSlideMessage);
          } else {
            notify(params.nextSlideMessage);
          }
        }

        if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
          if (!(swiper.isBeginning && !swiper.params.loop)) {
            swiper.slidePrev();
          }

          if (swiper.isBeginning) {
            notify(params.firstSlideMessage);
          } else {
            notify(params.prevSlideMessage);
          }
        }

        if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
          $targetEl[0].click();
        }
      }

      function updateNavigation() {
        if (swiper.params.loop || !swiper.navigation) return;
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;

        if ($prevEl && $prevEl.length > 0) {
          if (swiper.isBeginning) {
            disableEl($prevEl);
            makeElNotFocusable($prevEl);
          } else {
            enableEl($prevEl);
            makeElFocusable($prevEl);
          }
        }

        if ($nextEl && $nextEl.length > 0) {
          if (swiper.isEnd) {
            disableEl($nextEl);
            makeElNotFocusable($nextEl);
          } else {
            enableEl($nextEl);
            makeElFocusable($nextEl);
          }
        }
      }

      function hasPagination() {
        return swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length;
      }

      function updatePagination() {
        const params = swiper.params.a11y;

        if (hasPagination()) {
          swiper.pagination.bullets.each(bulletEl => {
            const $bulletEl = $(bulletEl);
            makeElFocusable($bulletEl);

            if (!swiper.params.pagination.renderBullet) {
              addElRole($bulletEl, 'button');
              addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
            }
          });
        }
      }

      const initNavEl = ($el, wrapperId, message) => {
        makeElFocusable($el);

        if ($el[0].tagName !== 'BUTTON') {
          addElRole($el, 'button');
          $el.on('keydown', onEnterOrSpaceKey);
        }

        addElLabel($el, message);
        addElControls($el, wrapperId);
      };

      function init() {
        const params = swiper.params.a11y;
        swiper.$el.append(liveRegion); // Container

        const $containerEl = swiper.$el;

        if (params.containerRoleDescriptionMessage) {
          addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
        }

        if (params.containerMessage) {
          addElLabel($containerEl, params.containerMessage);
        } // Wrapper


        const $wrapperEl = swiper.$wrapperEl;
        const wrapperId = $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;
        const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
        addElId($wrapperEl, wrapperId);
        addElLive($wrapperEl, live); // Slide

        if (params.itemRoleDescriptionMessage) {
          addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
        }

        addElRole($(swiper.slides), params.slideRole);
        const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
        swiper.slides.each((slideEl, index) => {
          const $slideEl = $(slideEl);
          const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
          const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
          addElLabel($slideEl, ariaLabelMessage);
        }); // Navigation

        let $nextEl;
        let $prevEl;

        if (swiper.navigation && swiper.navigation.$nextEl) {
          $nextEl = swiper.navigation.$nextEl;
        }

        if (swiper.navigation && swiper.navigation.$prevEl) {
          $prevEl = swiper.navigation.$prevEl;
        }

        if ($nextEl && $nextEl.length) {
          initNavEl($nextEl, wrapperId, params.nextSlideMessage);
        }

        if ($prevEl && $prevEl.length) {
          initNavEl($prevEl, wrapperId, params.prevSlideMessage);
        } // Pagination


        if (hasPagination()) {
          swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
        }
      }

      function destroy() {
        if (liveRegion && liveRegion.length > 0) liveRegion.remove();
        let $nextEl;
        let $prevEl;

        if (swiper.navigation && swiper.navigation.$nextEl) {
          $nextEl = swiper.navigation.$nextEl;
        }

        if (swiper.navigation && swiper.navigation.$prevEl) {
          $prevEl = swiper.navigation.$prevEl;
        }

        if ($nextEl) {
          $nextEl.off('keydown', onEnterOrSpaceKey);
        }

        if ($prevEl) {
          $prevEl.off('keydown', onEnterOrSpaceKey);
        } // Pagination


        if (hasPagination()) {
          swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
        }
      }

      on('beforeInit', () => {
        liveRegion = $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
      });
      on('afterInit', () => {
        if (!swiper.params.a11y.enabled) return;
        init();
        updateNavigation();
      });
      on('toEdge', () => {
        if (!swiper.params.a11y.enabled) return;
        updateNavigation();
      });
      on('fromEdge', () => {
        if (!swiper.params.a11y.enabled) return;
        updateNavigation();
      });
      on('paginationUpdate', () => {
        if (!swiper.params.a11y.enabled) return;
        updatePagination();
      });
      on('destroy', () => {
        if (!swiper.params.a11y.enabled) return;
        destroy();
      });
    }

    function History({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        history: {
          enabled: false,
          root: '',
          replaceState: false,
          key: 'slides'
        }
      });
      let initialized = false;
      let paths = {};

      const slugify = text => {
        return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
      };

      const getPathValues = urlOverride => {
        const window = getWindow();
        let location;

        if (urlOverride) {
          location = new URL(urlOverride);
        } else {
          location = window.location;
        }

        const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
        const total = pathArray.length;
        const key = pathArray[total - 2];
        const value = pathArray[total - 1];
        return {
          key,
          value
        };
      };

      const setHistory = (key, index) => {
        const window = getWindow();
        if (!initialized || !swiper.params.history.enabled) return;
        let location;

        if (swiper.params.url) {
          location = new URL(swiper.params.url);
        } else {
          location = window.location;
        }

        const slide = swiper.slides.eq(index);
        let value = slugify(slide.attr('data-history'));

        if (swiper.params.history.root.length > 0) {
          let root = swiper.params.history.root;
          if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
          value = `${root}/${key}/${value}`;
        } else if (!location.pathname.includes(key)) {
          value = `${key}/${value}`;
        }

        const currentState = window.history.state;

        if (currentState && currentState.value === value) {
          return;
        }

        if (swiper.params.history.replaceState) {
          window.history.replaceState({
            value
          }, null, value);
        } else {
          window.history.pushState({
            value
          }, null, value);
        }
      };

      const scrollToSlide = (speed, value, runCallbacks) => {
        if (value) {
          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
            const slide = swiper.slides.eq(i);
            const slideHistory = slugify(slide.attr('data-history'));

            if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
              const index = slide.index();
              swiper.slideTo(index, speed, runCallbacks);
            }
          }
        } else {
          swiper.slideTo(0, speed, runCallbacks);
        }
      };

      const setHistoryPopState = () => {
        paths = getPathValues(swiper.params.url);
        scrollToSlide(swiper.params.speed, swiper.paths.value, false);
      };

      const init = () => {
        const window = getWindow();
        if (!swiper.params.history) return;

        if (!window.history || !window.history.pushState) {
          swiper.params.history.enabled = false;
          swiper.params.hashNavigation.enabled = true;
          return;
        }

        initialized = true;
        paths = getPathValues(swiper.params.url);
        if (!paths.key && !paths.value) return;
        scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);

        if (!swiper.params.history.replaceState) {
          window.addEventListener('popstate', setHistoryPopState);
        }
      };

      const destroy = () => {
        const window = getWindow();

        if (!swiper.params.history.replaceState) {
          window.removeEventListener('popstate', setHistoryPopState);
        }
      };

      on('init', () => {
        if (swiper.params.history.enabled) {
          init();
        }
      });
      on('destroy', () => {
        if (swiper.params.history.enabled) {
          destroy();
        }
      });
      on('transitionEnd _freeModeNoMomentumRelease', () => {
        if (initialized) {
          setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      });
      on('slideChange', () => {
        if (initialized && swiper.params.cssMode) {
          setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      });
    }

    function HashNavigation({
      swiper,
      extendParams,
      emit,
      on
    }) {
      let initialized = false;
      const document = getDocument();
      const window = getWindow();
      extendParams({
        hashNavigation: {
          enabled: false,
          replaceState: false,
          watchState: false
        }
      });

      const onHashChange = () => {
        emit('hashChange');
        const newHash = document.location.hash.replace('#', '');
        const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

        if (newHash !== activeSlideHash) {
          const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
          if (typeof newIndex === 'undefined') return;
          swiper.slideTo(newIndex);
        }
      };

      const setHash = () => {
        if (!initialized || !swiper.params.hashNavigation.enabled) return;

        if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
          window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');
          emit('hashSet');
        } else {
          const slide = swiper.slides.eq(swiper.activeIndex);
          const hash = slide.attr('data-hash') || slide.attr('data-history');
          document.location.hash = hash || '';
          emit('hashSet');
        }
      };

      const init = () => {
        if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
        initialized = true;
        const hash = document.location.hash.replace('#', '');

        if (hash) {
          const speed = 0;

          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
            const slide = swiper.slides.eq(i);
            const slideHash = slide.attr('data-hash') || slide.attr('data-history');

            if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
              const index = slide.index();
              swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
            }
          }
        }

        if (swiper.params.hashNavigation.watchState) {
          $(window).on('hashchange', onHashChange);
        }
      };

      const destroy = () => {
        if (swiper.params.hashNavigation.watchState) {
          $(window).off('hashchange', onHashChange);
        }
      };

      on('init', () => {
        if (swiper.params.hashNavigation.enabled) {
          init();
        }
      });
      on('destroy', () => {
        if (swiper.params.hashNavigation.enabled) {
          destroy();
        }
      });
      on('transitionEnd _freeModeNoMomentumRelease', () => {
        if (initialized) {
          setHash();
        }
      });
      on('slideChange', () => {
        if (initialized && swiper.params.cssMode) {
          setHash();
        }
      });
    }

    /* eslint no-underscore-dangle: "off" */
    function Autoplay({
      swiper,
      extendParams,
      on,
      emit
    }) {
      let timeout;
      swiper.autoplay = {
        running: false,
        paused: false
      };
      extendParams({
        autoplay: {
          enabled: false,
          delay: 3000,
          waitForTransition: true,
          disableOnInteraction: true,
          stopOnLastSlide: false,
          reverseDirection: false,
          pauseOnMouseEnter: false
        }
      });

      function run() {
        const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
        let delay = swiper.params.autoplay.delay;

        if ($activeSlideEl.attr('data-swiper-autoplay')) {
          delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
        }

        clearTimeout(timeout);
        timeout = nextTick(() => {
          let autoplayResult;

          if (swiper.params.autoplay.reverseDirection) {
            if (swiper.params.loop) {
              swiper.loopFix();
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.isBeginning) {
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
              autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
              emit('autoplay');
            } else {
              stop();
            }
          } else if (swiper.params.loop) {
            swiper.loopFix();
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.isEnd) {
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
            emit('autoplay');
          } else {
            stop();
          }

          if (swiper.params.cssMode && swiper.autoplay.running) run();else if (autoplayResult === false) {
            run();
          }
        }, delay);
      }

      function start() {
        if (typeof timeout !== 'undefined') return false;
        if (swiper.autoplay.running) return false;
        swiper.autoplay.running = true;
        emit('autoplayStart');
        run();
        return true;
      }

      function stop() {
        if (!swiper.autoplay.running) return false;
        if (typeof timeout === 'undefined') return false;

        if (timeout) {
          clearTimeout(timeout);
          timeout = undefined;
        }

        swiper.autoplay.running = false;
        emit('autoplayStop');
        return true;
      }

      function pause(speed) {
        if (!swiper.autoplay.running) return;
        if (swiper.autoplay.paused) return;
        if (timeout) clearTimeout(timeout);
        swiper.autoplay.paused = true;

        if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
          swiper.autoplay.paused = false;
          run();
        } else {
          ['transitionend', 'webkitTransitionEnd'].forEach(event => {
            swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
          });
        }
      }

      function onVisibilityChange() {
        const document = getDocument();

        if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
          pause();
        }

        if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
          run();
          swiper.autoplay.paused = false;
        }
      }

      function onTransitionEnd(e) {
        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
        if (e.target !== swiper.$wrapperEl[0]) return;
        ['transitionend', 'webkitTransitionEnd'].forEach(event => {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
        swiper.autoplay.paused = false;

        if (!swiper.autoplay.running) {
          stop();
        } else {
          run();
        }
      }

      function onMouseEnter() {
        if (swiper.params.autoplay.disableOnInteraction) {
          stop();
        } else {
          pause();
        }

        ['transitionend', 'webkitTransitionEnd'].forEach(event => {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
      }

      function onMouseLeave() {
        if (swiper.params.autoplay.disableOnInteraction) {
          return;
        }

        swiper.autoplay.paused = false;
        run();
      }

      function attachMouseEvents() {
        if (swiper.params.autoplay.pauseOnMouseEnter) {
          swiper.$el.on('mouseenter', onMouseEnter);
          swiper.$el.on('mouseleave', onMouseLeave);
        }
      }

      function detachMouseEvents() {
        swiper.$el.off('mouseenter', onMouseEnter);
        swiper.$el.off('mouseleave', onMouseLeave);
      }

      on('init', () => {
        if (swiper.params.autoplay.enabled) {
          start();
          const document = getDocument();
          document.addEventListener('visibilitychange', onVisibilityChange);
          attachMouseEvents();
        }
      });
      on('beforeTransitionStart', (_s, speed, internal) => {
        if (swiper.autoplay.running) {
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.pause(speed);
          } else {
            stop();
          }
        }
      });
      on('sliderFirstMove', () => {
        if (swiper.autoplay.running) {
          if (swiper.params.autoplay.disableOnInteraction) {
            stop();
          } else {
            pause();
          }
        }
      });
      on('touchEnd', () => {
        if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
          run();
        }
      });
      on('destroy', () => {
        detachMouseEvents();

        if (swiper.autoplay.running) {
          stop();
        }

        const document = getDocument();
        document.removeEventListener('visibilitychange', onVisibilityChange);
      });
      Object.assign(swiper.autoplay, {
        pause,
        run,
        start,
        stop
      });
    }

    function Thumb({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        thumbs: {
          swiper: null,
          multipleActiveThumbs: true,
          autoScrollOffset: 0,
          slideThumbActiveClass: 'swiper-slide-thumb-active',
          thumbsContainerClass: 'swiper-thumbs'
        }
      });
      let initialized = false;
      let swiperCreated = false;
      swiper.thumbs = {
        swiper: null
      };

      function onThumbClick() {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        const clickedIndex = thumbsSwiper.clickedIndex;
        const clickedSlide = thumbsSwiper.clickedSlide;
        if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
        if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
        let slideToIndex;

        if (thumbsSwiper.params.loop) {
          slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
        } else {
          slideToIndex = clickedIndex;
        }

        if (swiper.params.loop) {
          let currentIndex = swiper.activeIndex;

          if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
            swiper.loopFix(); // eslint-disable-next-line

            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            currentIndex = swiper.activeIndex;
          }

          const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
          const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
          if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
        }

        swiper.slideTo(slideToIndex);
      }

      function init() {
        const {
          thumbs: thumbsParams
        } = swiper.params;
        if (initialized) return false;
        initialized = true;
        const SwiperClass = swiper.constructor;

        if (thumbsParams.swiper instanceof SwiperClass) {
          swiper.thumbs.swiper = thumbsParams.swiper;
          Object.assign(swiper.thumbs.swiper.originalParams, {
            watchSlidesProgress: true,
            slideToClickedSlide: false
          });
          Object.assign(swiper.thumbs.swiper.params, {
            watchSlidesProgress: true,
            slideToClickedSlide: false
          });
        } else if (isObject(thumbsParams.swiper)) {
          const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
          Object.assign(thumbsSwiperParams, {
            watchSlidesProgress: true,
            slideToClickedSlide: false
          });
          swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
          swiperCreated = true;
        }

        swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
        swiper.thumbs.swiper.on('tap', onThumbClick);
        return true;
      }

      function update(initial) {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
        const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
        const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;

        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
          let currentThumbsIndex = thumbsSwiper.activeIndex;
          let newThumbsIndex;
          let direction;

          if (thumbsSwiper.params.loop) {
            if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
              thumbsSwiper.loopFix(); // eslint-disable-next-line

              thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
              currentThumbsIndex = thumbsSwiper.activeIndex;
            } // Find actual thumbs index to slide to


            const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
            const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();

            if (typeof prevThumbsIndex === 'undefined') {
              newThumbsIndex = nextThumbsIndex;
            } else if (typeof nextThumbsIndex === 'undefined') {
              newThumbsIndex = prevThumbsIndex;
            } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
              newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
            } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
              newThumbsIndex = nextThumbsIndex;
            } else {
              newThumbsIndex = prevThumbsIndex;
            }

            direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
          } else {
            newThumbsIndex = swiper.realIndex;
            direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
          }

          if (useOffset) {
            newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
          }

          if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
            if (thumbsSwiper.params.centeredSlides) {
              if (newThumbsIndex > currentThumbsIndex) {
                newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
              } else {
                newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
              }
            } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;

            thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
          }
        } // Activate thumbs


        let thumbsToActivate = 1;
        const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
          thumbsToActivate = swiper.params.slidesPerView;
        }

        if (!swiper.params.thumbs.multipleActiveThumbs) {
          thumbsToActivate = 1;
        }

        thumbsToActivate = Math.floor(thumbsToActivate);
        thumbsSwiper.slides.removeClass(thumbActiveClass);

        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
          for (let i = 0; i < thumbsToActivate; i += 1) {
            thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
          }
        } else {
          for (let i = 0; i < thumbsToActivate; i += 1) {
            thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
          }
        }
      }

      on('beforeInit', () => {
        const {
          thumbs
        } = swiper.params;
        if (!thumbs || !thumbs.swiper) return;
        init();
        update(true);
      });
      on('slideChange update resize observerUpdate', () => {
        if (!swiper.thumbs.swiper) return;
        update();
      });
      on('setTransition', (_s, duration) => {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        thumbsSwiper.setTransition(duration);
      });
      on('beforeDestroy', () => {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;

        if (swiperCreated && thumbsSwiper) {
          thumbsSwiper.destroy();
        }
      });
      Object.assign(swiper.thumbs, {
        init,
        update
      });
    }

    function freeMode({
      swiper,
      extendParams,
      emit,
      once
    }) {
      extendParams({
        freeMode: {
          enabled: false,
          momentum: true,
          momentumRatio: 1,
          momentumBounce: true,
          momentumBounceRatio: 1,
          momentumVelocityRatio: 1,
          sticky: false,
          minimumVelocity: 0.02
        }
      });

      function onTouchMove() {
        const {
          touchEventsData: data,
          touches
        } = swiper; // Velocity

        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime
          });
        }

        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: now()
        });
      }

      function onTouchEnd({
        currentPos
      }) {
        const {
          params,
          $wrapperEl,
          rtlTranslate: rtl,
          snapGrid,
          touchEventsData: data
        } = swiper; // Time diff

        const touchEndTime = now();
        const timeDiff = touchEndTime - data.touchStartTime;

        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }

          return;
        }

        if (params.freeMode.momentum) {
          if (data.velocities.length > 1) {
            const lastMoveEvent = data.velocities.pop();
            const velocityEvent = data.velocities.pop();
            const distance = lastMoveEvent.position - velocityEvent.position;
            const time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;

            if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
              swiper.velocity = 0;
            } // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.


            if (time > 150 || now() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }

          swiper.velocity *= params.freeMode.momentumVelocityRatio;
          data.velocities.length = 0;
          let momentumDuration = 1000 * params.freeMode.momentumRatio;
          const momentumDistance = swiper.velocity * momentumDuration;
          let newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;
          let doBounce = false;
          let afterBouncePosition;
          const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
          let needsLoopFix;

          if (newPosition < swiper.maxTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }

              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }

              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeMode.sticky) {
            let nextSlide;

            for (let j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }

            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }

            newPosition = -newPosition;
          }

          if (needsLoopFix) {
            once('transitionEnd', () => {
              swiper.loopFix();
            });
          } // Fix duration


          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }

            if (params.freeMode.sticky) {
              // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeMode.sticky) {
            swiper.slideToClosest();
            return;
          }

          if (params.freeMode.momentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(() => {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(() => {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            emit('_freeModeNoMomentumRelease');
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);

            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(() => {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.updateProgress(newPosition);
          }

          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeMode.sticky) {
          swiper.slideToClosest();
          return;
        } else if (params.freeMode) {
          emit('_freeModeNoMomentumRelease');
        }

        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
      }

      Object.assign(swiper, {
        freeMode: {
          onTouchMove,
          onTouchEnd
        }
      });
    }

    function Grid({
      swiper,
      extendParams
    }) {
      extendParams({
        grid: {
          rows: 1,
          fill: 'column'
        }
      });
      let slidesNumberEvenToRows;
      let slidesPerRow;
      let numFullColumns;

      const initSlides = slidesLength => {
        const {
          slidesPerView
        } = swiper.params;
        const {
          rows,
          fill
        } = swiper.params.grid;
        slidesPerRow = slidesNumberEvenToRows / rows;
        numFullColumns = Math.floor(slidesLength / rows);

        if (Math.floor(slidesLength / rows) === slidesLength / rows) {
          slidesNumberEvenToRows = slidesLength;
        } else {
          slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
        }

        if (slidesPerView !== 'auto' && fill === 'row') {
          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
        }
      };

      const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
        const {
          slidesPerGroup,
          spaceBetween
        } = swiper.params;
        const {
          rows,
          fill
        } = swiper.params.grid; // Set slides order

        let newSlideOrderIndex;
        let column;
        let row;

        if (fill === 'row' && slidesPerGroup > 1) {
          const groupIndex = Math.floor(i / (slidesPerGroup * rows));
          const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
          const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
          row = Math.floor(slideIndexInGroup / columnsInGroup);
          column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
          newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
          slide.css({
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex
          });
        } else if (fill === 'column') {
          column = Math.floor(i / rows);
          row = i - column * rows;

          if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
            row += 1;

            if (row >= rows) {
              row = 0;
              column += 1;
            }
          }
        } else {
          row = Math.floor(i / slidesPerRow);
          column = i - row * slidesPerRow;
        }

        slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');
      };

      const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
        const {
          spaceBetween,
          centeredSlides,
          roundLengths
        } = swiper.params;
        const {
          rows
        } = swiper.params.grid;
        swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
        swiper.$wrapperEl.css({
          [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`
        });

        if (centeredSlides) {
          snapGrid.splice(0, snapGrid.length);
          const newSlidesGrid = [];

          for (let i = 0; i < snapGrid.length; i += 1) {
            let slidesGridItem = snapGrid[i];
            if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
          }

          snapGrid.push(...newSlidesGrid);
        }
      };

      swiper.grid = {
        initSlides,
        updateSlide,
        updateWrapperSize
      };
    }

    function appendSlide(slides) {
      const swiper = this;
      const {
        $wrapperEl,
        params
      } = swiper;

      if (params.loop) {
        swiper.loopDestroy();
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
      } else {
        $wrapperEl.append(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!params.observer) {
        swiper.update();
      }
    }

    function prependSlide(slides) {
      const swiper = this;
      const {
        params,
        $wrapperEl,
        activeIndex
      } = swiper;

      if (params.loop) {
        swiper.loopDestroy();
      }

      let newActiveIndex = activeIndex + 1;

      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.prepend(slides[i]);
        }

        newActiveIndex = activeIndex + slides.length;
      } else {
        $wrapperEl.prepend(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!params.observer) {
        swiper.update();
      }

      swiper.slideTo(newActiveIndex, 0, false);
    }

    function addSlide(index, slides) {
      const swiper = this;
      const {
        $wrapperEl,
        params,
        activeIndex
      } = swiper;
      let activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
      }

      const baseLength = swiper.slides.length;

      if (index <= 0) {
        swiper.prependSlide(slides);
        return;
      }

      if (index >= baseLength) {
        swiper.appendSlide(slides);
        return;
      }

      let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
      const slidesBuffer = [];

      for (let i = baseLength - 1; i >= index; i -= 1) {
        const currentSlide = swiper.slides.eq(i);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }

        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
      } else {
        $wrapperEl.append(slides);
      }

      for (let i = 0; i < slidesBuffer.length; i += 1) {
        $wrapperEl.append(slidesBuffer[i]);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!params.observer) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeSlide(slidesIndexes) {
      const swiper = this;
      const {
        params,
        $wrapperEl,
        activeIndex
      } = swiper;
      let activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
      }

      let newActiveIndex = activeIndexBuffer;
      let indexToRemove;

      if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
        for (let i = 0; i < slidesIndexes.length; i += 1) {
          indexToRemove = slidesIndexes[i];
          if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }

        newActiveIndex = Math.max(newActiveIndex, 0);
      } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!params.observer) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeAllSlides() {
      const swiper = this;
      const slidesIndexes = [];

      for (let i = 0; i < swiper.slides.length; i += 1) {
        slidesIndexes.push(i);
      }

      swiper.removeSlide(slidesIndexes);
    }

    function Manipulation({
      swiper
    }) {
      Object.assign(swiper, {
        appendSlide: appendSlide.bind(swiper),
        prependSlide: prependSlide.bind(swiper),
        addSlide: addSlide.bind(swiper),
        removeSlide: removeSlide.bind(swiper),
        removeAllSlides: removeAllSlides.bind(swiper)
      });
    }

    function effectInit(params) {
      const {
        effect,
        swiper,
        on,
        setTranslate,
        setTransition,
        overwriteParams,
        perspective
      } = params;
      on('beforeInit', () => {
        if (swiper.params.effect !== effect) return;
        swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);

        if (perspective && perspective()) {
          swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
        }

        const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
        Object.assign(swiper.params, overwriteParamsResult);
        Object.assign(swiper.originalParams, overwriteParamsResult);
      });
      on('setTranslate', () => {
        if (swiper.params.effect !== effect) return;
        setTranslate();
      });
      on('setTransition', (_s, duration) => {
        if (swiper.params.effect !== effect) return;
        setTransition(duration);
      });
    }

    function effectTarget(effectParams, $slideEl) {
      if (effectParams.transformEl) {
        return $slideEl.find(effectParams.transformEl).css({
          'backface-visibility': 'hidden',
          '-webkit-backface-visibility': 'hidden'
        });
      }

      return $slideEl;
    }

    function effectVirtualTransitionEnd({
      swiper,
      duration,
      transformEl,
      allSlides
    }) {
      const {
        slides,
        activeIndex,
        $wrapperEl
      } = swiper;

      if (swiper.params.virtualTranslate && duration !== 0) {
        let eventTriggered = false;
        let $transitionEndTarget;

        if (allSlides) {
          $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
        } else {
          $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
        }

        $transitionEndTarget.transitionEnd(() => {
          if (eventTriggered) return;
          if (!swiper || swiper.destroyed) return;
          eventTriggered = true;
          swiper.animating = false;
          const triggerEvents = ['webkitTransitionEnd', 'transitionend'];

          for (let i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    }

    function EffectFade({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        fadeEffect: {
          crossFade: false,
          transformEl: null
        }
      });

      const setTranslate = () => {
        const {
          slides
        } = swiper;
        const params = swiper.params.fadeEffect;

        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = swiper.slides.eq(i);
          const offset = $slideEl[0].swiperSlideOffset;
          let tx = -offset;
          if (!swiper.params.virtualTranslate) tx -= swiper.translate;
          let ty = 0;

          if (!swiper.isHorizontal()) {
            ty = tx;
            tx = 0;
          }

          const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
          const $targetEl = effectTarget(params, $slideEl);
          $targetEl.css({
            opacity: slideOpacity
          }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
        }
      };

      const setTransition = duration => {
        const {
          transformEl
        } = swiper.params.fadeEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration);
        effectVirtualTransitionEnd({
          swiper,
          duration,
          transformEl,
          allSlides: true
        });
      };

      effectInit({
        effect: 'fade',
        swiper,
        on,
        setTranslate,
        setTransition,
        overwriteParams: () => ({
          slidesPerView: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: !swiper.params.cssMode
        })
      });
    }

    function EffectCube({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        cubeEffect: {
          slideShadows: true,
          shadow: true,
          shadowOffset: 20,
          shadowScale: 0.94
        }
      });

      const setTranslate = () => {
        const {
          $el,
          $wrapperEl,
          slides,
          width: swiperWidth,
          height: swiperHeight,
          rtlTranslate: rtl,
          size: swiperSize,
          browser
        } = swiper;
        const params = swiper.params.cubeEffect;
        const isHorizontal = swiper.isHorizontal();
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        let wrapperRotate = 0;
        let $cubeShadowEl;

        if (params.shadow) {
          if (isHorizontal) {
            $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

            if ($cubeShadowEl.length === 0) {
              $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
              $wrapperEl.append($cubeShadowEl);
            }

            $cubeShadowEl.css({
              height: `${swiperWidth}px`
            });
          } else {
            $cubeShadowEl = $el.find('.swiper-cube-shadow');

            if ($cubeShadowEl.length === 0) {
              $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
              $el.append($cubeShadowEl);
            }
          }
        }

        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = slides.eq(i);
          let slideIndex = i;

          if (isVirtual) {
            slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
          }

          let slideAngle = slideIndex * 90;
          let round = Math.floor(slideAngle / 360);

          if (rtl) {
            slideAngle = -slideAngle;
            round = Math.floor(-slideAngle / 360);
          }

          const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
          let tx = 0;
          let ty = 0;
          let tz = 0;

          if (slideIndex % 4 === 0) {
            tx = -round * 4 * swiperSize;
            tz = 0;
          } else if ((slideIndex - 1) % 4 === 0) {
            tx = 0;
            tz = -round * 4 * swiperSize;
          } else if ((slideIndex - 2) % 4 === 0) {
            tx = swiperSize + round * 4 * swiperSize;
            tz = swiperSize;
          } else if ((slideIndex - 3) % 4 === 0) {
            tx = -swiperSize;
            tz = 3 * swiperSize + swiperSize * 4 * round;
          }

          if (rtl) {
            tx = -tx;
          }

          if (!isHorizontal) {
            ty = tx;
            tx = 0;
          }

          const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;

          if (progress <= 1 && progress > -1) {
            wrapperRotate = slideIndex * 90 + progress * 90;
            if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
          }

          $slideEl.transform(transform);

          if (params.slideShadows) {
            // Set shadows
            let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

            if (shadowBefore.length === 0) {
              shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
              $slideEl.append(shadowBefore);
            }

            if (shadowAfter.length === 0) {
              shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
              $slideEl.append(shadowAfter);
            }

            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
          }
        }

        $wrapperEl.css({
          '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
          'transform-origin': `50% 50% -${swiperSize / 2}px`
        });

        if (params.shadow) {
          if (isHorizontal) {
            $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
          } else {
            const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
            const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
            const scale1 = params.shadowScale;
            const scale2 = params.shadowScale / multiplier;
            const offset = params.shadowOffset;
            $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
          }
        }

        const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
        $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
      };

      const setTransition = duration => {
        const {
          $el,
          slides
        } = swiper;
        slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
          $el.find('.swiper-cube-shadow').transition(duration);
        }
      };

      effectInit({
        effect: 'cube',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => true,
        overwriteParams: () => ({
          slidesPerView: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          resistanceRatio: 0,
          spaceBetween: 0,
          centeredSlides: false,
          virtualTranslate: true
        })
      });
    }

    function createShadow(params, $slideEl, side) {
      const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
      const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
      let $shadowEl = $shadowContainer.children(`.${shadowClass}`);

      if (!$shadowEl.length) {
        $shadowEl = $(`<div class="swiper-slide-shadow${side ? `-${side}` : ''}"></div>`);
        $shadowContainer.append($shadowEl);
      }

      return $shadowEl;
    }

    function EffectFlip({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        flipEffect: {
          slideShadows: true,
          limitRotation: true,
          transformEl: null
        }
      });

      const setTranslate = () => {
        const {
          slides,
          rtlTranslate: rtl
        } = swiper;
        const params = swiper.params.flipEffect;

        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = slides.eq(i);
          let progress = $slideEl[0].progress;

          if (swiper.params.flipEffect.limitRotation) {
            progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
          }

          const offset = $slideEl[0].swiperSlideOffset;
          const rotate = -180 * progress;
          let rotateY = rotate;
          let rotateX = 0;
          let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
          let ty = 0;

          if (!swiper.isHorizontal()) {
            ty = tx;
            tx = 0;
            rotateX = -rotateY;
            rotateY = 0;
          } else if (rtl) {
            rotateY = -rotateY;
          }

          $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

          if (params.slideShadows) {
            // Set shadows
            let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

            if (shadowBefore.length === 0) {
              shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
            }

            if (shadowAfter.length === 0) {
              shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
            }

            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
          }

          const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
          const $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(transform);
        }
      };

      const setTransition = duration => {
        const {
          transformEl
        } = swiper.params.flipEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
        effectVirtualTransitionEnd({
          swiper,
          duration,
          transformEl
        });
      };

      effectInit({
        effect: 'flip',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => true,
        overwriteParams: () => ({
          slidesPerView: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: !swiper.params.cssMode
        })
      });
    }

    function EffectCoverflow({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        coverflowEffect: {
          rotate: 50,
          stretch: 0,
          depth: 100,
          scale: 1,
          modifier: 1,
          slideShadows: true,
          transformEl: null
        }
      });

      const setTranslate = () => {
        const {
          width: swiperWidth,
          height: swiperHeight,
          slides,
          slidesSizesGrid
        } = swiper;
        const params = swiper.params.coverflowEffect;
        const isHorizontal = swiper.isHorizontal();
        const transform = swiper.translate;
        const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
        const rotate = isHorizontal ? params.rotate : -params.rotate;
        const translate = params.depth; // Each slide offset from center

        for (let i = 0, length = slides.length; i < length; i += 1) {
          const $slideEl = slides.eq(i);
          const slideSize = slidesSizesGrid[i];
          const slideOffset = $slideEl[0].swiperSlideOffset;
          const offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
          let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
          let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

          let translateZ = -translate * Math.abs(offsetMultiplier);
          let stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

          if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
            stretch = parseFloat(params.stretch) / 100 * slideSize;
          }

          let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
          let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
          let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values

          if (Math.abs(translateX) < 0.001) translateX = 0;
          if (Math.abs(translateY) < 0.001) translateY = 0;
          if (Math.abs(translateZ) < 0.001) translateZ = 0;
          if (Math.abs(rotateY) < 0.001) rotateY = 0;
          if (Math.abs(rotateX) < 0.001) rotateX = 0;
          if (Math.abs(scale) < 0.001) scale = 0;
          const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
          const $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(slideTransform);
          $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

          if (params.slideShadows) {
            // Set shadows
            let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

            if ($shadowBeforeEl.length === 0) {
              $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');
            }

            if ($shadowAfterEl.length === 0) {
              $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');
            }

            if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
            if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
          }
        }
      };

      const setTransition = duration => {
        const {
          transformEl
        } = swiper.params.coverflowEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
      };

      effectInit({
        effect: 'coverflow',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => true,
        overwriteParams: () => ({
          watchSlidesProgress: true
        })
      });
    }

    function EffectCreative({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        creativeEffect: {
          transformEl: null,
          limitProgress: 1,
          shadowPerProgress: false,
          progressMultiplier: 1,
          perspective: true,
          prev: {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            opacity: 1,
            scale: 1
          },
          next: {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            opacity: 1,
            scale: 1
          }
        }
      });

      const getTranslateValue = value => {
        if (typeof value === 'string') return value;
        return `${value}px`;
      };

      const setTranslate = () => {
        const {
          slides,
          $wrapperEl,
          slidesSizesGrid
        } = swiper;
        const params = swiper.params.creativeEffect;
        const {
          progressMultiplier: multiplier
        } = params;
        const isCenteredSlides = swiper.params.centeredSlides;

        if (isCenteredSlides) {
          const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
          $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
        }

        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = slides.eq(i);
          const slideProgress = $slideEl[0].progress;
          const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
          let originalProgress = progress;

          if (!isCenteredSlides) {
            originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
          }

          const offset = $slideEl[0].swiperSlideOffset;
          const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
          const r = [0, 0, 0];
          let custom = false;

          if (!swiper.isHorizontal()) {
            t[1] = t[0];
            t[0] = 0;
          }

          let data = {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            scale: 1,
            opacity: 1
          };

          if (progress < 0) {
            data = params.next;
            custom = true;
          } else if (progress > 0) {
            data = params.prev;
            custom = true;
          } // set translate


          t.forEach((value, index) => {
            t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
          }); // set rotates

          r.forEach((value, index) => {
            r[index] = data.rotate[index] * Math.abs(progress * multiplier);
          });
          $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
          const translateString = t.join(', ');
          const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
          const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
          const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
          const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; // Set shadows

          if (custom && data.shadow || !custom) {
            let $shadowEl = $slideEl.children('.swiper-slide-shadow');

            if ($shadowEl.length === 0 && data.shadow) {
              $shadowEl = createShadow(params, $slideEl);
            }

            if ($shadowEl.length) {
              const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
              $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
            }
          }

          const $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(transform).css({
            opacity: opacityString
          });

          if (data.origin) {
            $targetEl.css('transform-origin', data.origin);
          }
        }
      };

      const setTransition = duration => {
        const {
          transformEl
        } = swiper.params.creativeEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
        effectVirtualTransitionEnd({
          swiper,
          duration,
          transformEl,
          allSlides: true
        });
      };

      effectInit({
        effect: 'creative',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => swiper.params.creativeEffect.perspective,
        overwriteParams: () => ({
          watchSlidesProgress: true,
          virtualTranslate: !swiper.params.cssMode
        })
      });
    }

    function EffectCards({
      swiper,
      extendParams,
      on
    }) {
      extendParams({
        cardsEffect: {
          slideShadows: true,
          transformEl: null
        }
      });

      const setTranslate = () => {
        const {
          slides,
          activeIndex
        } = swiper;
        const params = swiper.params.cardsEffect;
        const {
          startTranslate,
          isTouched
        } = swiper.touchEventsData;
        const currentTranslate = swiper.translate;

        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = slides.eq(i);
          const slideProgress = $slideEl[0].progress;
          const progress = Math.min(Math.max(slideProgress, -4), 4);
          let offset = $slideEl[0].swiperSlideOffset;

          if (swiper.params.centeredSlides && !swiper.params.cssMode) {
            swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
          }

          if (swiper.params.centeredSlides && swiper.params.cssMode) {
            offset -= slides[0].swiperSlideOffset;
          }

          let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
          let tY = 0;
          const tZ = -100 * Math.abs(progress);
          let scale = 1;
          let rotate = -2 * progress;
          let tXAdd = 8 - Math.abs(progress) * 0.75;
          const isSwipeToNext = (i === activeIndex || i === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
          const isSwipeToPrev = (i === activeIndex || i === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;

          if (isSwipeToNext || isSwipeToPrev) {
            const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
            rotate += -28 * progress * subProgress;
            scale += -0.5 * subProgress;
            tXAdd += 96 * subProgress;
            tY = `${-25 * subProgress * Math.abs(progress)}%`;
          }

          if (progress < 0) {
            // next
            tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
          } else if (progress > 0) {
            // prev
            tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
          } else {
            tX = `${tX}px`;
          }

          if (!swiper.isHorizontal()) {
            const prevY = tY;
            tY = tX;
            tX = prevY;
          }

          const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
          const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${rotate}deg)
        scale(${scaleString})
      `;

          if (params.slideShadows) {
            // Set shadows
            let $shadowEl = $slideEl.find('.swiper-slide-shadow');

            if ($shadowEl.length === 0) {
              $shadowEl = createShadow(params, $slideEl);
            }

            if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
          }

          $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
          const $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(transform);
        }
      };

      const setTransition = duration => {
        const {
          transformEl
        } = swiper.params.cardsEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
        effectVirtualTransitionEnd({
          swiper,
          duration,
          transformEl
        });
      };

      effectInit({
        effect: 'cards',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => true,
        overwriteParams: () => ({
          watchSlidesProgress: true,
          virtualTranslate: !swiper.params.cssMode
        })
      });
    }

    // Swiper Class
    const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
    Swiper.use(modules);

    return Swiper;

})));
//# sourceMappingURL=swiper-bundle.js.map
;(typeof navigator !== "undefined") && (function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define(function() {
            return factory(root);
        });
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory(root);
    } else {
        root.lottie = factory(root);
        root.bodymovin = root.lottie;
    }
}((window || {}), function(window) {
	/* global locationHref:writable, animationManager, subframeEnabled:writable, defaultCurveSegments:writable, roundValues,
expressionsPlugin:writable, PropertyFactory, ShapePropertyFactory, Matrix, idPrefix:writable */
/* exported locationHref, subframeEnabled, expressionsPlugin, idPrefix */

'use strict';

/* exported svgNS, locationHref, initialDefaultFrame */

var svgNS = 'http://www.w3.org/2000/svg';

var locationHref = '';

var initialDefaultFrame = -999999;

/* global createSizedArray */
/* exported subframeEnabled, expressionsPlugin, isSafari, cachedColors, bmPow, bmSqrt, bmFloor, bmMax, bmMin, ProjectInterface,
defaultCurveSegments, degToRads, roundCorner, bmRnd, styleDiv, BMEnterFrameEvent, BMCompleteEvent, BMCompleteLoopEvent,
BMSegmentStartEvent, BMDestroyEvent, BMRenderFrameErrorEvent, BMConfigErrorEvent, BMAnimationConfigErrorEvent, createElementID,
addSaturationToRGB, addBrightnessToRGB, addHueToRGB, rgbToHex */

var subframeEnabled = true;
var idPrefix = '';
var expressionsPlugin;
var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var cachedColors = {};
var bmRnd;
var bmPow = Math.pow;
var bmSqrt = Math.sqrt;
var bmFloor = Math.floor;
var bmMax = Math.max;
var bmMin = Math.min;

var BMMath = {};
(function () {
  var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];
  var i;
  var len = propertyNames.length;
  for (i = 0; i < len; i += 1) {
    BMMath[propertyNames[i]] = Math[propertyNames[i]];
  }
}());

function ProjectInterface() { return {}; }

BMMath.random = Math.random;
BMMath.abs = function (val) {
  var tOfVal = typeof val;
  if (tOfVal === 'object' && val.length) {
    var absArr = createSizedArray(val.length);
    var i;
    var len = val.length;
    for (i = 0; i < len; i += 1) {
      absArr[i] = Math.abs(val[i]);
    }
    return absArr;
  }
  return Math.abs(val);
};
var defaultCurveSegments = 150;
var degToRads = Math.PI / 180;
var roundCorner = 0.5519;

function roundValues(flag) {
  if (flag) {
    bmRnd = Math.round;
  } else {
    bmRnd = function (val) {
      return val;
    };
  }
}
roundValues(false);

function styleDiv(element) {
  element.style.position = 'absolute';
  element.style.top = 0;
  element.style.left = 0;
  element.style.display = 'block';
  element.style.transformOrigin = '0 0';
  element.style.webkitTransformOrigin = '0 0';
  element.style.backfaceVisibility = 'visible';
  element.style.webkitBackfaceVisibility = 'visible';
  element.style.transformStyle = 'preserve-3d';
  element.style.webkitTransformStyle = 'preserve-3d';
  element.style.mozTransformStyle = 'preserve-3d';
}

function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
  this.type = type;
  this.currentTime = currentTime;
  this.totalTime = totalTime;
  this.direction = frameMultiplier < 0 ? -1 : 1;
}

function BMCompleteEvent(type, frameMultiplier) {
  this.type = type;
  this.direction = frameMultiplier < 0 ? -1 : 1;
}

function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
  this.type = type;
  this.currentLoop = currentLoop;
  this.totalLoops = totalLoops;
  this.direction = frameMultiplier < 0 ? -1 : 1;
}

function BMSegmentStartEvent(type, firstFrame, totalFrames) {
  this.type = type;
  this.firstFrame = firstFrame;
  this.totalFrames = totalFrames;
}

function BMDestroyEvent(type, target) {
  this.type = type;
  this.target = target;
}

function BMRenderFrameErrorEvent(nativeError, currentTime) {
  this.type = 'renderFrameError';
  this.nativeError = nativeError;
  this.currentTime = currentTime;
}

function BMConfigErrorEvent(nativeError) {
  this.type = 'configError';
  this.nativeError = nativeError;
}

function BMAnimationConfigErrorEvent(type, nativeError) {
  this.type = type;
  this.nativeError = nativeError;
}

var createElementID = (function () {
  var _count = 0;
  return function createID() {
    _count += 1;
    return idPrefix + '__lottie_element_' + _count;
  };
}());

function HSVtoRGB(h, s, v) {
  var r;
  var g;
  var b;
  var i;
  var f;
  var p;
  var q;
  var t;
  i = Math.floor(h * 6);
  f = h * 6 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
    default: break;
  }
  return [r,
    g,
    b];
}

function RGBtoHSV(r, g, b) {
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var d = max - min;
  var h;
  var s = (max === 0 ? 0 : d / max);
  var v = max / 255;

  switch (max) {
    case min: h = 0; break;
    case r: h = (g - b) + d * (g < b ? 6 : 0); h /= 6 * d; break;
    case g: h = (b - r) + d * 2; h /= 6 * d; break;
    case b: h = (r - g) + d * 4; h /= 6 * d; break;
    default: break;
  }

  return [
    h,
    s,
    v,
  ];
}

function addSaturationToRGB(color, offset) {
  var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
  hsv[1] += offset;
  if (hsv[1] > 1) {
    hsv[1] = 1;
  } else if (hsv[1] <= 0) {
    hsv[1] = 0;
  }
  return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
}

function addBrightnessToRGB(color, offset) {
  var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
  hsv[2] += offset;
  if (hsv[2] > 1) {
    hsv[2] = 1;
  } else if (hsv[2] < 0) {
    hsv[2] = 0;
  }
  return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
}

function addHueToRGB(color, offset) {
  var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
  hsv[0] += offset / 360;
  if (hsv[0] > 1) {
    hsv[0] -= 1;
  } else if (hsv[0] < 0) {
    hsv[0] += 1;
  }
  return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
}

var rgbToHex = (function () {
  var colorMap = [];
  var i;
  var hex;
  for (i = 0; i < 256; i += 1) {
    hex = i.toString(16);
    colorMap[i] = hex.length === 1 ? '0' + hex : hex;
  }

  return function (r, g, b) {
    if (r < 0) {
      r = 0;
    }
    if (g < 0) {
      g = 0;
    }
    if (b < 0) {
      b = 0;
    }
    return '#' + colorMap[r] + colorMap[g] + colorMap[b];
  };
}());

function BaseEvent() {}
BaseEvent.prototype = {
  triggerEvent: function (eventName, args) {
    if (this._cbs[eventName]) {
      var callbacks = this._cbs[eventName];
      for (var i = 0; i < callbacks.length; i += 1) {
        callbacks[i](args);
      }
    }
  },
  addEventListener: function (eventName, callback) {
    if (!this._cbs[eventName]) {
      this._cbs[eventName] = [];
    }
    this._cbs[eventName].push(callback);

    return function () {
      this.removeEventListener(eventName, callback);
    }.bind(this);
  },
  removeEventListener: function (eventName, callback) {
    if (!callback) {
      this._cbs[eventName] = null;
    } else if (this._cbs[eventName]) {
      var i = 0;
      var len = this._cbs[eventName].length;
      while (i < len) {
        if (this._cbs[eventName][i] === callback) {
          this._cbs[eventName].splice(i, 1);
          i -= 1;
          len -= 1;
        }
        i += 1;
      }
      if (!this._cbs[eventName].length) {
        this._cbs[eventName] = null;
      }
    }
  },
};

/* exported createTypedArray, createSizedArray */

var createTypedArray = (function () {
  function createRegularArray(type, len) {
    var i = 0;
    var arr = [];
    var value;
    switch (type) {
      case 'int16':
      case 'uint8c':
        value = 1;
        break;
      default:
        value = 1.1;
        break;
    }
    for (i = 0; i < len; i += 1) {
      arr.push(value);
    }
    return arr;
  }
  function createTypedArrayFactory(type, len) {
    if (type === 'float32') {
      return new Float32Array(len);
    } if (type === 'int16') {
      return new Int16Array(len);
    } if (type === 'uint8c') {
      return new Uint8ClampedArray(len);
    }
    return createRegularArray(type, len);
  }
  if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
    return createTypedArrayFactory;
  }
  return createRegularArray;
}());

function createSizedArray(len) {
  return Array.apply(null, { length: len });
}

/* global svgNS */
/* exported createNS */

function createNS(type) {
  // return {appendChild:function(){},setAttribute:function(){},style:{}}
  return document.createElementNS(svgNS, type);
}

/* exported createTag */

function createTag(type) {
  // return {appendChild:function(){},setAttribute:function(){},style:{}}
  return document.createElement(type);
}

function DynamicPropertyContainer() {}
DynamicPropertyContainer.prototype = {
  addDynamicProperty: function (prop) {
    if (this.dynamicProperties.indexOf(prop) === -1) {
      this.dynamicProperties.push(prop);
      this.container.addDynamicProperty(this);
      this._isAnimated = true;
    }
  },
  iterateDynamicProperties: function () {
    this._mdf = false;
    var i;
    var len = this.dynamicProperties.length;
    for (i = 0; i < len; i += 1) {
      this.dynamicProperties[i].getValue();
      if (this.dynamicProperties[i]._mdf) {
        this._mdf = true;
      }
    }
  },
  initDynamicPropertyContainer: function (container) {
    this.container = container;
    this.dynamicProperties = [];
    this._mdf = false;
    this._isAnimated = false;
  },
};

/* exported getBlendMode */

var getBlendMode = (function () {
  var blendModeEnums = {
    0: 'source-over',
    1: 'multiply',
    2: 'screen',
    3: 'overlay',
    4: 'darken',
    5: 'lighten',
    6: 'color-dodge',
    7: 'color-burn',
    8: 'hard-light',
    9: 'soft-light',
    10: 'difference',
    11: 'exclusion',
    12: 'hue',
    13: 'saturation',
    14: 'color',
    15: 'luminosity',
  };

  return function (mode) {
    return blendModeEnums[mode] || '';
  };
}());

/* exported lineCapEnum, lineJoinEnum */

var lineCapEnum = {
  1: 'butt',
  2: 'round',
  3: 'square',
};

var lineJoinEnum = {
  1: 'miter',
  2: 'round',
  3: 'bevel',
};

/* global createTypedArray */

/*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */

/**
 * 2D transformation matrix object initialized with identity matrix.
 *
 * The matrix can synchronize a canvas context by supplying the context
 * as an argument, or later apply current absolute transform to an
 * existing context.
 *
 * All values are handled as floating point values.
 *
 * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
 * @prop {number} a - scale x
 * @prop {number} b - shear y
 * @prop {number} c - shear x
 * @prop {number} d - scale y
 * @prop {number} e - translate x
 * @prop {number} f - translate y
 * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
 * @constructor
 */

var Matrix = (function () {
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _tan = Math.tan;
  var _rnd = Math.round;

  function reset() {
    this.props[0] = 1;
    this.props[1] = 0;
    this.props[2] = 0;
    this.props[3] = 0;
    this.props[4] = 0;
    this.props[5] = 1;
    this.props[6] = 0;
    this.props[7] = 0;
    this.props[8] = 0;
    this.props[9] = 0;
    this.props[10] = 1;
    this.props[11] = 0;
    this.props[12] = 0;
    this.props[13] = 0;
    this.props[14] = 0;
    this.props[15] = 1;
    return this;
  }

  function rotate(angle) {
    if (angle === 0) {
      return this;
    }
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  }

  function rotateX(angle) {
    if (angle === 0) {
      return this;
    }
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
  }

  function rotateY(angle) {
    if (angle === 0) {
      return this;
    }
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
  }

  function rotateZ(angle) {
    if (angle === 0) {
      return this;
    }
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  }

  function shear(sx, sy) {
    return this._t(1, sy, sx, 1, 0, 0);
  }

  function skew(ax, ay) {
    return this.shear(_tan(ax), _tan(ay));
  }

  function skewFromAxis(ax, angle) {
    var mCos = _cos(angle);
    var mSin = _sin(angle);
    return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
      ._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
      ._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
  }

  function scale(sx, sy, sz) {
    if (!sz && sz !== 0) {
      sz = 1;
    }
    if (sx === 1 && sy === 1 && sz === 1) {
      return this;
    }
    return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
  }

  function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
    this.props[0] = a;
    this.props[1] = b;
    this.props[2] = c;
    this.props[3] = d;
    this.props[4] = e;
    this.props[5] = f;
    this.props[6] = g;
    this.props[7] = h;
    this.props[8] = i;
    this.props[9] = j;
    this.props[10] = k;
    this.props[11] = l;
    this.props[12] = m;
    this.props[13] = n;
    this.props[14] = o;
    this.props[15] = p;
    return this;
  }

  function translate(tx, ty, tz) {
    tz = tz || 0;
    if (tx !== 0 || ty !== 0 || tz !== 0) {
      return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
    }
    return this;
  }

  function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
    var _p = this.props;

    if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
      // NOTE: commenting this condition because TurboFan deoptimizes code when present
      // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
      _p[12] = _p[12] * a2 + _p[15] * m2;
      _p[13] = _p[13] * f2 + _p[15] * n2;
      _p[14] = _p[14] * k2 + _p[15] * o2;
      _p[15] *= p2;
      // }
      this._identityCalculated = false;
      return this;
    }

    var a1 = _p[0];
    var b1 = _p[1];
    var c1 = _p[2];
    var d1 = _p[3];
    var e1 = _p[4];
    var f1 = _p[5];
    var g1 = _p[6];
    var h1 = _p[7];
    var i1 = _p[8];
    var j1 = _p[9];
    var k1 = _p[10];
    var l1 = _p[11];
    var m1 = _p[12];
    var n1 = _p[13];
    var o1 = _p[14];
    var p1 = _p[15];

    /* matrix order (canvas compatible):
         * ace
         * bdf
         * 001
         */
    _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
    _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
    _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
    _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;

    _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
    _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
    _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
    _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;

    _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
    _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
    _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
    _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;

    _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
    _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
    _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
    _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;

    this._identityCalculated = false;
    return this;
  }

  function isIdentity() {
    if (!this._identityCalculated) {
      this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
      this._identityCalculated = true;
    }
    return this._identity;
  }

  function equals(matr) {
    var i = 0;
    while (i < 16) {
      if (matr.props[i] !== this.props[i]) {
        return false;
      }
      i += 1;
    }
    return true;
  }

  function clone(matr) {
    var i;
    for (i = 0; i < 16; i += 1) {
      matr.props[i] = this.props[i];
    }
    return matr;
  }

  function cloneFromProps(props) {
    var i;
    for (i = 0; i < 16; i += 1) {
      this.props[i] = props[i];
    }
  }

  function applyToPoint(x, y, z) {
    return {
      x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
      y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
      z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],
    };
    /* return {
         x: x * me.a + y * me.c + me.e,
         y: x * me.b + y * me.d + me.f
         }; */
  }
  function applyToX(x, y, z) {
    return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
  }
  function applyToY(x, y, z) {
    return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
  }
  function applyToZ(x, y, z) {
    return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
  }

  function getInverseMatrix() {
    var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
    var a = this.props[5] / determinant;
    var b = -this.props[1] / determinant;
    var c = -this.props[4] / determinant;
    var d = this.props[0] / determinant;
    var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
    var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
    var inverseMatrix = new Matrix();
    inverseMatrix.props[0] = a;
    inverseMatrix.props[1] = b;
    inverseMatrix.props[4] = c;
    inverseMatrix.props[5] = d;
    inverseMatrix.props[12] = e;
    inverseMatrix.props[13] = f;
    return inverseMatrix;
  }

  function inversePoint(pt) {
    var inverseMatrix = this.getInverseMatrix();
    return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
  }

  function inversePoints(pts) {
    var i;
    var len = pts.length;
    var retPts = [];
    for (i = 0; i < len; i += 1) {
      retPts[i] = inversePoint(pts[i]);
    }
    return retPts;
  }

  function applyToTriplePoints(pt1, pt2, pt3) {
    var arr = createTypedArray('float32', 6);
    if (this.isIdentity()) {
      arr[0] = pt1[0];
      arr[1] = pt1[1];
      arr[2] = pt2[0];
      arr[3] = pt2[1];
      arr[4] = pt3[0];
      arr[5] = pt3[1];
    } else {
      var p0 = this.props[0];
      var p1 = this.props[1];
      var p4 = this.props[4];
      var p5 = this.props[5];
      var p12 = this.props[12];
      var p13 = this.props[13];
      arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
      arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
      arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
      arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
      arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
      arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
    }
    return arr;
  }

  function applyToPointArray(x, y, z) {
    var arr;
    if (this.isIdentity()) {
      arr = [x, y, z];
    } else {
      arr = [
        x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
        x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
        x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],
      ];
    }
    return arr;
  }

  function applyToPointStringified(x, y) {
    if (this.isIdentity()) {
      return x + ',' + y;
    }
    var _p = this.props;
    return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
  }

  function toCSS() {
    // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
    /* if(this.isIdentity()) {
            return '';
        } */
    var i = 0;
    var props = this.props;
    var cssValue = 'matrix3d(';
    var v = 10000;
    while (i < 16) {
      cssValue += _rnd(props[i] * v) / v;
      cssValue += i === 15 ? ')' : ',';
      i += 1;
    }
    return cssValue;
  }

  function roundMatrixProperty(val) {
    var v = 10000;
    if ((val < 0.000001 && val > 0) || (val > -0.000001 && val < 0)) {
      return _rnd(val * v) / v;
    }
    return val;
  }

  function to2dCSS() {
    // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
    /* if(this.isIdentity()) {
            return '';
        } */
    var props = this.props;
    var _a = roundMatrixProperty(props[0]);
    var _b = roundMatrixProperty(props[1]);
    var _c = roundMatrixProperty(props[4]);
    var _d = roundMatrixProperty(props[5]);
    var _e = roundMatrixProperty(props[12]);
    var _f = roundMatrixProperty(props[13]);
    return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';
  }

  return function () {
    this.reset = reset;
    this.rotate = rotate;
    this.rotateX = rotateX;
    this.rotateY = rotateY;
    this.rotateZ = rotateZ;
    this.skew = skew;
    this.skewFromAxis = skewFromAxis;
    this.shear = shear;
    this.scale = scale;
    this.setTransform = setTransform;
    this.translate = translate;
    this.transform = transform;
    this.applyToPoint = applyToPoint;
    this.applyToX = applyToX;
    this.applyToY = applyToY;
    this.applyToZ = applyToZ;
    this.applyToPointArray = applyToPointArray;
    this.applyToTriplePoints = applyToTriplePoints;
    this.applyToPointStringified = applyToPointStringified;
    this.toCSS = toCSS;
    this.to2dCSS = to2dCSS;
    this.clone = clone;
    this.cloneFromProps = cloneFromProps;
    this.equals = equals;
    this.inversePoints = inversePoints;
    this.inversePoint = inversePoint;
    this.getInverseMatrix = getInverseMatrix;
    this._t = this.transform;
    this.isIdentity = isIdentity;
    this._identity = true;
    this._identityCalculated = false;

    this.props = createTypedArray('float32', 16);
    this.reset();
  };
}());

/* eslint-disable */
/*
 Copyright 2014 David Bau.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
    var global = this,
        width = 256,        // each RC4 output is 0 <= x < 256
        chunks = 6,         // at least six RC4 outputs for each double
        digits = 52,        // there are 52 significant digits in a double
        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1,
        nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
    function seedrandom(seed, options, callback) {
        var key = [];
        options = (options === true) ? { entropy: true } : (options || {});

        // Flatten the seed string or build one from local entropy if needed.
        var shortseed = mixkey(flatten(
            options.entropy ? [seed, tostring(pool)] :
                (seed === null) ? autoseed() : seed, 3), key);

        // Use the seed to initialize an ARC4 generator.
        var arc4 = new ARC4(key);

        // This function returns a random double in [0, 1) that contains
        // randomness in every bit of the mantissa of the IEEE 754 value.
        var prng = function() {
            var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
                d = startdenom,                 //   and denominator d = 2 ^ 48.
                x = 0;                          //   and no 'extra last byte'.
            while (n < significance) {          // Fill up all significant digits by
                n = (n + x) * width;              //   shifting numerator and
                d *= width;                       //   denominator and generating a
                x = arc4.g(1);                    //   new least-significant-byte.
            }
            while (n >= overflow) {             // To avoid rounding up, before adding
                n /= 2;                           //   last byte, shift everything
                d /= 2;                           //   right using integer math until
                x >>>= 1;                         //   we have exactly the desired bits.
            }
            return (n + x) / d;                 // Form the number within [0, 1).
        };

        prng.int32 = function() { return arc4.g(4) | 0; };
        prng.quick = function() { return arc4.g(4) / 0x100000000; };
        prng.double = prng;

        // Mix the randomness into accumulated entropy.
        mixkey(tostring(arc4.S), pool);

        // Calling convention: what to return as a function of prng, seed, is_math.
        return (options.pass || callback ||
        function(prng, seed, is_math_call, state) {
            if (state) {
                // Load the arc4 state from the given state if it has an S array.
                if (state.S) { copy(state, arc4); }
                // Only provide the .state method if requested via options.state.
                prng.state = function() { return copy(arc4, {}); };
            }

            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) { math[rngname] = prng; return seed; }

            // Otherwise, it is a newer calling convention, so return the
            // prng directly.
            else return prng;
        })(
            prng,
            shortseed,
            'global' in options ? options.global : (this == math),
            options.state);
    }
    math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
    function ARC4(key) {
        var t, keylen = key.length,
            me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

        // The empty key [] is treated as [0].
        if (!keylen) { key = [keylen++]; }

        // Set up S using the standard key scheduling algorithm.
        while (i < width) {
            s[i] = i++;
        }
        for (i = 0; i < width; i++) {
            s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
            s[j] = t;
        }

        // The "g" method returns the next (count) outputs as one number.
        me.g = function(count) {
            // Using instance members instead of closure state nearly doubles speed.
            var t, r = 0,
                i = me.i, j = me.j, s = me.S;
            while (count--) {
                t = s[i = mask & (i + 1)];
                r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
            }
            me.i = i; me.j = j;
            return r;
            // For robust unpredictability, the function call below automatically
            // discards an initial batch of values.  This is called RC4-drop[256].
            // See http://google.com/search?q=rsa+fluhrer+response&btnI
        };
    }

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
    function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
    }

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
    function flatten(obj, depth) {
        var result = [], typ = (typeof obj), prop;
        if (depth && typ == 'object') {
            for (prop in obj) {
                try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
            }
        }
        return (result.length ? result : typ == 'string' ? obj : obj + '\0');
    }

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
    function mixkey(seed, key) {
        var stringseed = seed + '', smear, j = 0;
        while (j < stringseed.length) {
            key[mask & j] =
                mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
        }
        return tostring(key);
    }

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
    function autoseed() {
        try {
            if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
            var out = new Uint8Array(width);
            (global.crypto || global.msCrypto).getRandomValues(out);
            return tostring(out);
        } catch (e) {
            var browser = global.navigator,
                plugins = browser && browser.plugins;
            return [+new Date(), global, plugins, global.screen, tostring(pool)];
        }
    }

//
// tostring()
// Converts an array of charcodes to a string
//
    function tostring(a) {
        return String.fromCharCode.apply(0, a);
    }

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
    mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//

// End anonymous scope, and pass initial values.
})(
    [],     // pool: entropy pool starts empty
    BMMath    // math: package containing random, pow, and seedrandom
);
/* eslint-disable */
var BezierFactory = (function () {
  /**
     * BezierEasing - use bezier curve for transition easing function
     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
     *
     * Credits: is based on Firefox's nsSMILKeySpline.cpp
     * Usage:
     * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
     * spline.get(x) => returns the easing value | x must be in [0, 1] range
     *
     */

  var ob = {};
  ob.getBezierEasing = getBezierEasing;
  var beziers = {};

  function getBezierEasing(a, b, c, d, nm) {
    var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');
    if (beziers[str]) {
      return beziers[str];
    }
    var bezEasing = new BezierEasing([a, b, c, d]);
    beziers[str] = bezEasing;
    return bezEasing;
  }

  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  var float32ArraySupported = typeof Float32Array === 'function';

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
  function C(aA1) { return 3.0 * aA1; }

  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
      currentT,
      i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) return aGuessT;
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  /**
     * points is an array of [ mX1, mY1, mX2, mY2 ]
     */
  function BezierEasing(points) {
    this._p = points;
    this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    this._precomputed = false;

    this.get = this.get.bind(this);
  }

  BezierEasing.prototype = {

    get: function (x) {
      var mX1 = this._p[0],
        mY1 = this._p[1],
        mX2 = this._p[2],
        mY2 = this._p[3];
      if (!this._precomputed) this._precompute();
      if (mX1 === mY1 && mX2 === mY2) return x; // linear
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (x === 0) return 0;
      if (x === 1) return 1;
      return calcBezier(this._getTForX(x), mY1, mY2);
    },

    // Private part

    _precompute: function () {
      var mX1 = this._p[0],
        mY1 = this._p[1],
        mX2 = this._p[2],
        mY2 = this._p[3];
      this._precomputed = true;
      if (mX1 !== mY1 || mX2 !== mY2) { this._calcSampleValues(); }
    },

    _calcSampleValues: function () {
      var mX1 = this._p[0],
        mX2 = this._p[2];
      for (var i = 0; i < kSplineTableSize; ++i) {
        this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    },

    /**
         * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
         */
    _getTForX: function (aX) {
      var mX1 = this._p[0],
        mX2 = this._p[2],
        mSampleValues = this._mSampleValues;

      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }
      --currentSample;

      // Interpolate to provide an initial guess for t
      var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;

      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } if (initialSlope === 0.0) {
        return guessForT;
      }
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    },
  };

  return ob;
}());

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { // eslint-disable-line no-plusplus
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = setTimeout(function () {
        callback(currTime + timeToCall);
      },
      timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  }
}());

/* exported extendPrototype, getDescriptor, createProxyFunction */

function extendPrototype(sources, destination) {
  var i;
  var len = sources.length;
  var sourcePrototype;
  for (i = 0; i < len; i += 1) {
    sourcePrototype = sources[i].prototype;
    for (var attr in sourcePrototype) {
      if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
    }
  }
}

function getDescriptor(object, prop) {
  return Object.getOwnPropertyDescriptor(object, prop);
}

function createProxyFunction(prototype) {
  function ProxyFunction() {}
  ProxyFunction.prototype = prototype;
  return ProxyFunction;
}

/* global segmentsLengthPool, defaultCurveSegments, createSizedArray, bmPow, bmSqrt, bmFloor, createTypedArray, bezierLengthPool */
/* exported bez */

function bezFunction() {
  var math = Math;

  function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
    var det1 = (x1 * y2) + (y1 * x3) + (x2 * y3) - (x3 * y2) - (y3 * x1) - (x2 * y1);
    return det1 > -0.001 && det1 < 0.001;
  }

  function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
    if (z1 === 0 && z2 === 0 && z3 === 0) {
      return pointOnLine2D(x1, y1, x2, y2, x3, y3);
    }
    var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
    var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
    var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
    var diffDist;
    if (dist1 > dist2) {
      if (dist1 > dist3) {
        diffDist = dist1 - dist2 - dist3;
      } else {
        diffDist = dist3 - dist2 - dist1;
      }
    } else if (dist3 > dist2) {
      diffDist = dist3 - dist2 - dist1;
    } else {
      diffDist = dist2 - dist1 - dist3;
    }
    return diffDist > -0.0001 && diffDist < 0.0001;
  }

  var getBezierLength = (function () {
    return function (pt1, pt2, pt3, pt4) {
      var curveSegments = defaultCurveSegments;
      var k;
      var i;
      var len;
      var ptCoord;
      var perc;
      var addedLength = 0;
      var ptDistance;
      var point = [];
      var lastPoint = [];
      var lengthData = bezierLengthPool.newElement();
      len = pt3.length;
      for (k = 0; k < curveSegments; k += 1) {
        perc = k / (curveSegments - 1);
        ptDistance = 0;
        for (i = 0; i < len; i += 1) {
          ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
          point[i] = ptCoord;
          if (lastPoint[i] !== null) {
            ptDistance += bmPow(point[i] - lastPoint[i], 2);
          }
          lastPoint[i] = point[i];
        }
        if (ptDistance) {
          ptDistance = bmSqrt(ptDistance);
          addedLength += ptDistance;
        }
        lengthData.percents[k] = perc;
        lengthData.lengths[k] = addedLength;
      }
      lengthData.addedLength = addedLength;
      return lengthData;
    };
  }());

  function getSegmentsLength(shapeData) {
    var segmentsLength = segmentsLengthPool.newElement();
    var closed = shapeData.c;
    var pathV = shapeData.v;
    var pathO = shapeData.o;
    var pathI = shapeData.i;
    var i;
    var len = shapeData._length;
    var lengths = segmentsLength.lengths;
    var totalLength = 0;
    for (i = 0; i < len - 1; i += 1) {
      lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
      totalLength += lengths[i].addedLength;
    }
    if (closed && len) {
      lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
      totalLength += lengths[i].addedLength;
    }
    segmentsLength.totalLength = totalLength;
    return segmentsLength;
  }

  function BezierData(length) {
    this.segmentLength = 0;
    this.points = new Array(length);
  }

  function PointData(partial, point) {
    this.partialLength = partial;
    this.point = point;
  }

  var buildBezierData = (function () {
    var storedData = {};

    return function (pt1, pt2, pt3, pt4) {
      var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');
      if (!storedData[bezierName]) {
        var curveSegments = defaultCurveSegments;
        var k;
        var i;
        var len;
        var ptCoord;
        var perc;
        var addedLength = 0;
        var ptDistance;
        var point;
        var lastPoint = null;
        if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
          curveSegments = 2;
        }
        var bezierData = new BezierData(curveSegments);
        len = pt3.length;
        for (k = 0; k < curveSegments; k += 1) {
          point = createSizedArray(len);
          perc = k / (curveSegments - 1);
          ptDistance = 0;
          for (i = 0; i < len; i += 1) {
            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
            point[i] = ptCoord;
            if (lastPoint !== null) {
              ptDistance += bmPow(point[i] - lastPoint[i], 2);
            }
          }
          ptDistance = bmSqrt(ptDistance);
          addedLength += ptDistance;
          bezierData.points[k] = new PointData(ptDistance, point);
          lastPoint = point;
        }
        bezierData.segmentLength = addedLength;
        storedData[bezierName] = bezierData;
      }
      return storedData[bezierName];
    };
  }());

  function getDistancePerc(perc, bezierData) {
    var percents = bezierData.percents;
    var lengths = bezierData.lengths;
    var len = percents.length;
    var initPos = bmFloor((len - 1) * perc);
    var lengthPos = perc * bezierData.addedLength;
    var lPerc = 0;
    if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
      return percents[initPos];
    }
    var dir = lengths[initPos] > lengthPos ? -1 : 1;
    var flag = true;
    while (flag) {
      if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
        lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
        flag = false;
      } else {
        initPos += dir;
      }
      if (initPos < 0 || initPos >= len - 1) {
        // FIX for TypedArrays that don't store floating point values with enough accuracy
        if (initPos === len - 1) {
          return percents[initPos];
        }
        flag = false;
      }
    }
    return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
  }

  function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
    var t1 = getDistancePerc(percent, bezierData);
    var u1 = 1 - t1;
    var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
    var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
    return [ptX, ptY];
  }

  var bezierSegmentPoints = createTypedArray('float32', 8);

  function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
    if (startPerc < 0) {
      startPerc = 0;
    } else if (startPerc > 1) {
      startPerc = 1;
    }
    var t0 = getDistancePerc(startPerc, bezierData);
    endPerc = endPerc > 1 ? 1 : endPerc;
    var t1 = getDistancePerc(endPerc, bezierData);
    var i;
    var len = pt1.length;
    var u0 = 1 - t0;
    var u1 = 1 - t1;
    var u0u0u0 = u0 * u0 * u0;
    var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase
    var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase
    var t0t0t0 = t0 * t0 * t0;
    //
    var u0u0u1 = u0 * u0 * u1;
    var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase
    var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase
    var t0t0t1 = t0 * t0 * t1;
    //
    var u0u1u1 = u0 * u1 * u1;
    var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase
    var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase
    var t0t1t1 = t0 * t1 * t1;
    //
    var u1u1u1 = u1 * u1 * u1;
    var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase
    var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase
    var t1t1t1 = t1 * t1 * t1;
    for (i = 0; i < len; i += 1) {
      bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
      bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
      bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
      bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
    }

    return bezierSegmentPoints;
  }

  return {
    getSegmentsLength: getSegmentsLength,
    getNewSegment: getNewSegment,
    getPointInSegment: getPointInSegment,
    buildBezierData: buildBezierData,
    pointOnLine2D: pointOnLine2D,
    pointOnLine3D: pointOnLine3D,
  };
}

var bez = bezFunction();

/* exported dataManager */

function dataFunctionManager() {
  // var tCanvasHelper = createTag('canvas').getContext('2d');

  function completeLayers(layers, comps, fontManager) {
    var layerData;
    var i;
    var len = layers.length;
    var j;
    var jLen;
    var k;
    var kLen;
    for (i = 0; i < len; i += 1) {
      layerData = layers[i];
      if (('ks' in layerData) && !layerData.completed) {
        layerData.completed = true;
        if (layerData.tt) {
          layers[i - 1].td = layerData.tt;
        }
        if (layerData.hasMask) {
          var maskProps = layerData.masksProperties;
          jLen = maskProps.length;
          for (j = 0; j < jLen; j += 1) {
            if (maskProps[j].pt.k.i) {
              convertPathsToAbsoluteValues(maskProps[j].pt.k);
            } else {
              kLen = maskProps[j].pt.k.length;
              for (k = 0; k < kLen; k += 1) {
                if (maskProps[j].pt.k[k].s) {
                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                }
                if (maskProps[j].pt.k[k].e) {
                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                }
              }
            }
          }
        }
        if (layerData.ty === 0) {
          layerData.layers = findCompLayers(layerData.refId, comps);
          completeLayers(layerData.layers, comps, fontManager);
        } else if (layerData.ty === 4) {
          completeShapes(layerData.shapes);
        } else if (layerData.ty === 5) {
          completeText(layerData, fontManager);
        }
      }
    }
  }

  function findCompLayers(id, comps) {
    var i = 0;
    var len = comps.length;
    while (i < len) {
      if (comps[i].id === id) {
        if (!comps[i].layers.__used) {
          comps[i].layers.__used = true;
          return comps[i].layers;
        }
        return JSON.parse(JSON.stringify(comps[i].layers));
      }
      i += 1;
    }
    return null;
  }

  function completeShapes(arr) {
    var i;
    var len = arr.length;
    var j;
    var jLen;
    for (i = len - 1; i >= 0; i -= 1) {
      if (arr[i].ty === 'sh') {
        if (arr[i].ks.k.i) {
          convertPathsToAbsoluteValues(arr[i].ks.k);
        } else {
          jLen = arr[i].ks.k.length;
          for (j = 0; j < jLen; j += 1) {
            if (arr[i].ks.k[j].s) {
              convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
            }
            if (arr[i].ks.k[j].e) {
              convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
            }
          }
        }
      } else if (arr[i].ty === 'gr') {
        completeShapes(arr[i].it);
      }
    }
  }

  function convertPathsToAbsoluteValues(path) {
    var i;
    var len = path.i.length;
    for (i = 0; i < len; i += 1) {
      path.i[i][0] += path.v[i][0];
      path.i[i][1] += path.v[i][1];
      path.o[i][0] += path.v[i][0];
      path.o[i][1] += path.v[i][1];
    }
  }

  function checkVersion(minimum, animVersionString) {
    var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];
    if (minimum[0] > animVersion[0]) {
      return true;
    } if (animVersion[0] > minimum[0]) {
      return false;
    }
    if (minimum[1] > animVersion[1]) {
      return true;
    } if (animVersion[1] > minimum[1]) {
      return false;
    }
    if (minimum[2] > animVersion[2]) {
      return true;
    } if (animVersion[2] > minimum[2]) {
      return false;
    }
    return null;
  }

  var checkText = (function () {
    var minimumVersion = [4, 4, 14];

    function updateTextLayer(textLayer) {
      var documentData = textLayer.t.d;
      textLayer.t.d = {
        k: [
          {
            s: documentData,
            t: 0,
          },
        ],
      };
    }

    function iterateLayers(layers) {
      var i;
      var len = layers.length;
      for (i = 0; i < len; i += 1) {
        if (layers[i].ty === 5) {
          updateTextLayer(layers[i]);
        }
      }
    }

    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }());

  var checkChars = (function () {
    var minimumVersion = [4, 7, 99];
    return function (animationData) {
      if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
        var i;
        var len = animationData.chars.length;
        var j;
        var jLen;
        var pathData;
        var paths;
        for (i = 0; i < len; i += 1) {
          if (animationData.chars[i].data && animationData.chars[i].data.shapes) {
            paths = animationData.chars[i].data.shapes[0].it;
            jLen = paths.length;

            for (j = 0; j < jLen; j += 1) {
              pathData = paths[j].ks.k;
              if (!pathData.__converted) {
                convertPathsToAbsoluteValues(paths[j].ks.k);
                pathData.__converted = true;
              }
            }
          }
        }
      }
    };
  }());

  var checkPathProperties = (function () {
    var minimumVersion = [5, 7, 15];

    function updateTextLayer(textLayer) {
      var pathData = textLayer.t.p;
      if (typeof pathData.a === 'number') {
        pathData.a = {
          a: 0,
          k: pathData.a,
        };
      }
      if (typeof pathData.p === 'number') {
        pathData.p = {
          a: 0,
          k: pathData.p,
        };
      }
      if (typeof pathData.r === 'number') {
        pathData.r = {
          a: 0,
          k: pathData.r,
        };
      }
    }

    function iterateLayers(layers) {
      var i;
      var len = layers.length;
      for (i = 0; i < len; i += 1) {
        if (layers[i].ty === 5) {
          updateTextLayer(layers[i]);
        }
      }
    }

    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }());

  var checkColors = (function () {
    var minimumVersion = [4, 1, 9];

    function iterateShapes(shapes) {
      var i;
      var len = shapes.length;
      var j;
      var jLen;
      for (i = 0; i < len; i += 1) {
        if (shapes[i].ty === 'gr') {
          iterateShapes(shapes[i].it);
        } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
          if (shapes[i].c.k && shapes[i].c.k[0].i) {
            jLen = shapes[i].c.k.length;
            for (j = 0; j < jLen; j += 1) {
              if (shapes[i].c.k[j].s) {
                shapes[i].c.k[j].s[0] /= 255;
                shapes[i].c.k[j].s[1] /= 255;
                shapes[i].c.k[j].s[2] /= 255;
                shapes[i].c.k[j].s[3] /= 255;
              }
              if (shapes[i].c.k[j].e) {
                shapes[i].c.k[j].e[0] /= 255;
                shapes[i].c.k[j].e[1] /= 255;
                shapes[i].c.k[j].e[2] /= 255;
                shapes[i].c.k[j].e[3] /= 255;
              }
            }
          } else {
            shapes[i].c.k[0] /= 255;
            shapes[i].c.k[1] /= 255;
            shapes[i].c.k[2] /= 255;
            shapes[i].c.k[3] /= 255;
          }
        }
      }
    }

    function iterateLayers(layers) {
      var i;
      var len = layers.length;
      for (i = 0; i < len; i += 1) {
        if (layers[i].ty === 4) {
          iterateShapes(layers[i].shapes);
        }
      }
    }

    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }());

  var checkShapes = (function () {
    var minimumVersion = [4, 4, 18];

    function completeClosingShapes(arr) {
      var i;
      var len = arr.length;
      var j;
      var jLen;
      for (i = len - 1; i >= 0; i -= 1) {
        if (arr[i].ty === 'sh') {
          if (arr[i].ks.k.i) {
            arr[i].ks.k.c = arr[i].closed;
          } else {
            jLen = arr[i].ks.k.length;
            for (j = 0; j < jLen; j += 1) {
              if (arr[i].ks.k[j].s) {
                arr[i].ks.k[j].s[0].c = arr[i].closed;
              }
              if (arr[i].ks.k[j].e) {
                arr[i].ks.k[j].e[0].c = arr[i].closed;
              }
            }
          }
        } else if (arr[i].ty === 'gr') {
          completeClosingShapes(arr[i].it);
        }
      }
    }

    function iterateLayers(layers) {
      var layerData;
      var i;
      var len = layers.length;
      var j;
      var jLen;
      var k;
      var kLen;
      for (i = 0; i < len; i += 1) {
        layerData = layers[i];
        if (layerData.hasMask) {
          var maskProps = layerData.masksProperties;
          jLen = maskProps.length;
          for (j = 0; j < jLen; j += 1) {
            if (maskProps[j].pt.k.i) {
              maskProps[j].pt.k.c = maskProps[j].cl;
            } else {
              kLen = maskProps[j].pt.k.length;
              for (k = 0; k < kLen; k += 1) {
                if (maskProps[j].pt.k[k].s) {
                  maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                }
                if (maskProps[j].pt.k[k].e) {
                  maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                }
              }
            }
          }
        }
        if (layerData.ty === 4) {
          completeClosingShapes(layerData.shapes);
        }
      }
    }

    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }());

  function completeData(animationData, fontManager) {
    if (animationData.__complete) {
      return;
    }
    checkColors(animationData);
    checkText(animationData);
    checkChars(animationData);
    checkPathProperties(animationData);
    checkShapes(animationData);
    completeLayers(animationData.layers, animationData.assets, fontManager);
    animationData.__complete = true;
  }

  function completeText(data) {
    if (data.t.a.length === 0 && !('m' in data.t.p)) {
      data.singleShape = true;
    }
  }

  var moduleOb = {};
  moduleOb.completeData = completeData;
  moduleOb.checkColors = checkColors;
  moduleOb.checkChars = checkChars;
  moduleOb.checkPathProperties = checkPathProperties;
  moduleOb.checkShapes = checkShapes;
  moduleOb.completeLayers = completeLayers;

  return moduleOb;
}

var dataManager = dataFunctionManager();

/* exported getFontProperties */

function getFontProperties(fontData) {
  var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];

  var fWeight = 'normal'; var
    fStyle = 'normal';
  var len = styles.length;
  var styleName;
  for (var i = 0; i < len; i += 1) {
    styleName = styles[i].toLowerCase();
    switch (styleName) {
      case 'italic':
        fStyle = 'italic';
        break;
      case 'bold':
        fWeight = '700';
        break;
      case 'black':
        fWeight = '900';
        break;
      case 'medium':
        fWeight = '500';
        break;
      case 'regular':
      case 'normal':
        fWeight = '400';
        break;
      case 'light':
      case 'thin':
        fWeight = '200';
        break;
      default:
        break;
    }
  }

  return {
    style: fStyle,
    weight: fontData.fWeight || fWeight,
  };
}

/* global createNS, createTag, getFontProperties */
/* exported FontManager */

var FontManager = (function () {
  var maxWaitingTime = 5000;
  var emptyChar = {
    w: 0,
    size: 0,
    shapes: [],
  };
  var combinedCharacters = [];
  // Hindi characters
  combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366,
    2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379,
    2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);

  var surrogateModifiers = [
    'd83cdffb',
    'd83cdffc',
    'd83cdffd',
    'd83cdffe',
    'd83cdfff',
  ];

  var zeroWidthJoiner = [65039, 8205];

  function trimFontOptions(font) {
    var familyArray = font.split(',');
    var i;
    var len = familyArray.length;
    var enabledFamilies = [];
    for (i = 0; i < len; i += 1) {
      if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
        enabledFamilies.push(familyArray[i]);
      }
    }
    return enabledFamilies.join(',');
  }

  function setUpNode(font, family) {
    var parentNode = createTag('span');
    // Node is invisible to screen readers.
    parentNode.setAttribute('aria-hidden', true);
    parentNode.style.fontFamily = family;
    var node = createTag('span');
    // Characters that vary significantly among different fonts
    node.innerText = 'giItT1WQy@!-/#';
    // Visible - so we can measure it - but not on the screen
    parentNode.style.position = 'absolute';
    parentNode.style.left = '-10000px';
    parentNode.style.top = '-10000px';
    // Large font size makes even subtle changes obvious
    parentNode.style.fontSize = '300px';
    // Reset any font properties
    parentNode.style.fontVariant = 'normal';
    parentNode.style.fontStyle = 'normal';
    parentNode.style.fontWeight = 'normal';
    parentNode.style.letterSpacing = '0';
    parentNode.appendChild(node);
    document.body.appendChild(parentNode);

    // Remember width with no applied web font
    var width = node.offsetWidth;
    node.style.fontFamily = trimFontOptions(font) + ', ' + family;
    return { node: node, w: width, parent: parentNode };
  }

  function checkLoadedFonts() {
    var i;
    var len = this.fonts.length;
    var node;
    var w;
    var loadedCount = len;
    for (i = 0; i < len; i += 1) {
      if (this.fonts[i].loaded) {
        loadedCount -= 1;
      } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
        this.fonts[i].loaded = true;
      } else {
        node = this.fonts[i].monoCase.node;
        w = this.fonts[i].monoCase.w;
        if (node.offsetWidth !== w) {
          loadedCount -= 1;
          this.fonts[i].loaded = true;
        } else {
          node = this.fonts[i].sansCase.node;
          w = this.fonts[i].sansCase.w;
          if (node.offsetWidth !== w) {
            loadedCount -= 1;
            this.fonts[i].loaded = true;
          }
        }
        if (this.fonts[i].loaded) {
          this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
          this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
        }
      }
    }

    if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
      setTimeout(this.checkLoadedFontsBinded, 20);
    } else {
      setTimeout(this.setIsLoadedBinded, 10);
    }
  }

  function createHelper(def, fontData) {
    var tHelper = createNS('text');
    tHelper.style.fontSize = '100px';
    // tHelper.style.fontFamily = fontData.fFamily;

    var fontProps = getFontProperties(fontData);
    tHelper.setAttribute('font-family', fontData.fFamily);
    tHelper.setAttribute('font-style', fontProps.style);
    tHelper.setAttribute('font-weight', fontProps.weight);
    tHelper.textContent = '1';
    if (fontData.fClass) {
      tHelper.style.fontFamily = 'inherit';
      tHelper.setAttribute('class', fontData.fClass);
    } else {
      tHelper.style.fontFamily = fontData.fFamily;
    }
    def.appendChild(tHelper);
    var tCanvasHelper = createTag('canvas').getContext('2d');
    tCanvasHelper.font = fontData.fWeight + ' ' + fontData.fStyle + ' 100px ' + fontData.fFamily;
    // tCanvasHelper.font = ' 100px '+ fontData.fFamily;
    return tHelper;
  }

  function addFonts(fontData, defs) {
    if (!fontData) {
      this.isLoaded = true;
      return;
    }
    if (this.chars) {
      this.isLoaded = true;
      this.fonts = fontData.list;
      return;
    }

    var fontArr = fontData.list;
    var i;
    var len = fontArr.length;
    var _pendingFonts = len;
    for (i = 0; i < len; i += 1) {
      var shouldLoadFont = true;
      var loadedSelector;
      var j;
      fontArr[i].loaded = false;
      fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
      fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');
      if (!fontArr[i].fPath) {
        fontArr[i].loaded = true;
        _pendingFonts -= 1;
      } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
        loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');

        if (loadedSelector.length > 0) {
          shouldLoadFont = false;
        }

        if (shouldLoadFont) {
          var s = createTag('style');
          s.setAttribute('f-forigin', fontArr[i].fOrigin);
          s.setAttribute('f-origin', fontArr[i].origin);
          s.setAttribute('f-family', fontArr[i].fFamily);
          s.type = 'text/css';
          s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
          defs.appendChild(s);
        }
      } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
        loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');

        for (j = 0; j < loadedSelector.length; j += 1) {
          if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
            // Font is already loaded
            shouldLoadFont = false;
          }
        }

        if (shouldLoadFont) {
          var l = createTag('link');
          l.setAttribute('f-forigin', fontArr[i].fOrigin);
          l.setAttribute('f-origin', fontArr[i].origin);
          l.type = 'text/css';
          l.rel = 'stylesheet';
          l.href = fontArr[i].fPath;
          document.body.appendChild(l);
        }
      } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
        loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');

        for (j = 0; j < loadedSelector.length; j += 1) {
          if (fontArr[i].fPath === loadedSelector[j].src) {
            // Font is already loaded
            shouldLoadFont = false;
          }
        }

        if (shouldLoadFont) {
          var sc = createTag('link');
          sc.setAttribute('f-forigin', fontArr[i].fOrigin);
          sc.setAttribute('f-origin', fontArr[i].origin);
          sc.setAttribute('rel', 'stylesheet');
          sc.setAttribute('href', fontArr[i].fPath);
          defs.appendChild(sc);
        }
      }
      fontArr[i].helper = createHelper(defs, fontArr[i]);
      fontArr[i].cache = {};
      this.fonts.push(fontArr[i]);
    }
    if (_pendingFonts === 0) {
      this.isLoaded = true;
    } else {
      // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
      // Adding this timeout seems to fix it
      setTimeout(this.checkLoadedFonts.bind(this), 100);
    }
  }

  function addChars(chars) {
    if (!chars) {
      return;
    }
    if (!this.chars) {
      this.chars = [];
    }
    var i;
    var len = chars.length;
    var j;
    var jLen = this.chars.length;
    var found;
    for (i = 0; i < len; i += 1) {
      j = 0;
      found = false;
      while (j < jLen) {
        if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
          found = true;
        }
        j += 1;
      }
      if (!found) {
        this.chars.push(chars[i]);
        jLen += 1;
      }
    }
  }

  function getCharData(char, style, font) {
    var i = 0;
    var len = this.chars.length;
    while (i < len) {
      if (this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font) {
        return this.chars[i];
      }
      i += 1;
    }
    if (((typeof char === 'string' && char.charCodeAt(0) !== 13) || !char)
            && console
            && console.warn // eslint-disable-line no-console
            && !this._warned
    ) {
      this._warned = true;
      console.warn('Missing character from exported characters list: ', char, style, font); // eslint-disable-line no-console
    }
    return emptyChar;
  }

  function measureText(char, fontName, size) {
    var fontData = this.getFontByName(fontName);
    var index = char.charCodeAt(0);
    if (!fontData.cache[index + 1]) {
      var tHelper = fontData.helper;
      // Canvas version
      // fontData.cache[index] = tHelper.measureText(char).width / 100;
      // SVG version
      // console.log(tHelper.getBBox().width)
      if (char === ' ') {
        tHelper.textContent = '|' + char + '|';
        var doubleSize = tHelper.getComputedTextLength();
        tHelper.textContent = '||';
        var singleSize = tHelper.getComputedTextLength();
        fontData.cache[index + 1] = (doubleSize - singleSize) / 100;
      } else {
        tHelper.textContent = char;
        fontData.cache[index + 1] = (tHelper.getComputedTextLength()) / 100;
      }
    }
    return fontData.cache[index + 1] * size;
  }

  function getFontByName(name) {
    var i = 0;
    var len = this.fonts.length;
    while (i < len) {
      if (this.fonts[i].fName === name) {
        return this.fonts[i];
      }
      i += 1;
    }
    return this.fonts[0];
  }

  function isModifier(firstCharCode, secondCharCode) {
    var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
    return surrogateModifiers.indexOf(sum) !== -1;
  }

  function isZeroWidthJoiner(firstCharCode, secondCharCode) {
    if (!secondCharCode) {
      return firstCharCode === zeroWidthJoiner[1];
    }
    return firstCharCode === zeroWidthJoiner[0] && secondCharCode === zeroWidthJoiner[1];
  }

  function isCombinedCharacter(char) {
    return combinedCharacters.indexOf(char) !== -1;
  }

  function setIsLoaded() {
    this.isLoaded = true;
  }

  var Font = function () {
    this.fonts = [];
    this.chars = null;
    this.typekitLoaded = 0;
    this.isLoaded = false;
    this._warned = false;
    this.initTime = Date.now();
    this.setIsLoadedBinded = this.setIsLoaded.bind(this);
    this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
  };
  Font.isModifier = isModifier;
  Font.isZeroWidthJoiner = isZeroWidthJoiner;
  Font.isCombinedCharacter = isCombinedCharacter;

  var fontPrototype = {
    addChars: addChars,
    addFonts: addFonts,
    getCharData: getCharData,
    getFontByName: getFontByName,
    measureText: measureText,
    checkLoadedFonts: checkLoadedFonts,
    setIsLoaded: setIsLoaded,
  };

  Font.prototype = fontPrototype;

  return Font;
}());

/* global initialDefaultFrame, BezierFactory, degToRads, bez, createTypedArray */
/* exported PropertyFactory */

var PropertyFactory = (function () {
  var initFrame = initialDefaultFrame;
  var mathAbs = Math.abs;

  function interpolateValue(frameNum, caching) {
    var offsetTime = this.offsetTime;
    var newValue;
    if (this.propType === 'multidimensional') {
      newValue = createTypedArray('float32', this.pv.length);
    }
    var iterationIndex = caching.lastIndex;
    var i = iterationIndex;
    var len = this.keyframes.length - 1;
    var flag = true;
    var keyData;
    var nextKeyData;

    while (flag) {
      keyData = this.keyframes[i];
      nextKeyData = this.keyframes[i + 1];
      if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
        if (keyData.h) {
          keyData = nextKeyData;
        }
        iterationIndex = 0;
        break;
      }
      if ((nextKeyData.t - offsetTime) > frameNum) {
        iterationIndex = i;
        break;
      }
      if (i < len - 1) {
        i += 1;
      } else {
        iterationIndex = 0;
        flag = false;
      }
    }

    var k;
    var kLen;
    var perc;
    var jLen;
    var j;
    var fnc;
    var nextKeyTime = nextKeyData.t - offsetTime;
    var keyTime = keyData.t - offsetTime;
    var endValue;
    if (keyData.to) {
      if (!keyData.bezierData) {
        keyData.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
      }
      var bezierData = keyData.bezierData;
      if (frameNum >= nextKeyTime || frameNum < keyTime) {
        var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
        kLen = bezierData.points[ind].point.length;
        for (k = 0; k < kLen; k += 1) {
          newValue[k] = bezierData.points[ind].point[k];
        }
        // caching._lastKeyframeIndex = -1;
      } else {
        if (keyData.__fnct) {
          fnc = keyData.__fnct;
        } else {
          fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
          keyData.__fnct = fnc;
        }
        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
        var distanceInLine = bezierData.segmentLength * perc;

        var segmentPerc;
        var addedLength = (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastAddedLength : 0;
        j = (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastPoint : 0;
        flag = true;
        jLen = bezierData.points.length;
        while (flag) {
          addedLength += bezierData.points[j].partialLength;
          if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
            kLen = bezierData.points[j].point.length;
            for (k = 0; k < kLen; k += 1) {
              newValue[k] = bezierData.points[j].point[k];
            }
            break;
          } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
            segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
            kLen = bezierData.points[j].point.length;
            for (k = 0; k < kLen; k += 1) {
              newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
            }
            break;
          }
          if (j < jLen - 1) {
            j += 1;
          } else {
            flag = false;
          }
        }
        caching._lastPoint = j;
        caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
        caching._lastKeyframeIndex = i;
      }
    } else {
      var outX;
      var outY;
      var inX;
      var inY;
      var keyValue;
      len = keyData.s.length;
      endValue = nextKeyData.s || keyData.e;
      if (this.sh && keyData.h !== 1) {
        if (frameNum >= nextKeyTime) {
          newValue[0] = endValue[0];
          newValue[1] = endValue[1];
          newValue[2] = endValue[2];
        } else if (frameNum <= keyTime) {
          newValue[0] = keyData.s[0];
          newValue[1] = keyData.s[1];
          newValue[2] = keyData.s[2];
        } else {
          var quatStart = createQuaternion(keyData.s);
          var quatEnd = createQuaternion(endValue);
          var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
          quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
        }
      } else {
        for (i = 0; i < len; i += 1) {
          if (keyData.h !== 1) {
            if (frameNum >= nextKeyTime) {
              perc = 1;
            } else if (frameNum < keyTime) {
              perc = 0;
            } else {
              if (keyData.o.x.constructor === Array) {
                if (!keyData.__fnct) {
                  keyData.__fnct = [];
                }
                if (!keyData.__fnct[i]) {
                  outX = (typeof keyData.o.x[i] === 'undefined') ? keyData.o.x[0] : keyData.o.x[i];
                  outY = (typeof keyData.o.y[i] === 'undefined') ? keyData.o.y[0] : keyData.o.y[i];
                  inX = (typeof keyData.i.x[i] === 'undefined') ? keyData.i.x[0] : keyData.i.x[i];
                  inY = (typeof keyData.i.y[i] === 'undefined') ? keyData.i.y[0] : keyData.i.y[i];
                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                  keyData.__fnct[i] = fnc;
                } else {
                  fnc = keyData.__fnct[i];
                }
              } else if (!keyData.__fnct) {
                outX = keyData.o.x;
                outY = keyData.o.y;
                inX = keyData.i.x;
                inY = keyData.i.y;
                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                keyData.__fnct = fnc;
              } else {
                fnc = keyData.__fnct;
              }
              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
            }
          }

          endValue = nextKeyData.s || keyData.e;
          keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;

          if (this.propType === 'multidimensional') {
            newValue[i] = keyValue;
          } else {
            newValue = keyValue;
          }
        }
      }
    }
    caching.lastIndex = iterationIndex;
    return newValue;
  }

  // based on @Toji's https://github.com/toji/gl-matrix/
  function slerp(a, b, t) {
    var out = [];
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    var bx = b[0];
    var by = b[1];
    var bz = b[2];
    var bw = b[3];

    var omega;
    var cosom;
    var sinom;
    var scale0;
    var scale1;

    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if ((1.0 - cosom) > 0.000001) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1.0 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;

    return out;
  }

  function quaternionToEuler(out, quat) {
    var qx = quat[0];
    var qy = quat[1];
    var qz = quat[2];
    var qw = quat[3];
    var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
    var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
    var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
    out[0] = heading / degToRads;
    out[1] = attitude / degToRads;
    out[2] = bank / degToRads;
  }

  function createQuaternion(values) {
    var heading = values[0] * degToRads;
    var attitude = values[1] * degToRads;
    var bank = values[2] * degToRads;
    var c1 = Math.cos(heading / 2);
    var c2 = Math.cos(attitude / 2);
    var c3 = Math.cos(bank / 2);
    var s1 = Math.sin(heading / 2);
    var s2 = Math.sin(attitude / 2);
    var s3 = Math.sin(bank / 2);
    var w = c1 * c2 * c3 - s1 * s2 * s3;
    var x = s1 * s2 * c3 + c1 * c2 * s3;
    var y = s1 * c2 * c3 + c1 * s2 * s3;
    var z = c1 * s2 * c3 - s1 * c2 * s3;

    return [x, y, z, w];
  }

  function getValueAtCurrentTime() {
    var frameNum = this.comp.renderedFrame - this.offsetTime;
    var initTime = this.keyframes[0].t - this.offsetTime;
    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
    if (!(frameNum === this._caching.lastFrame || (this._caching.lastFrame !== initFrame && ((this._caching.lastFrame >= endTime && frameNum >= endTime) || (this._caching.lastFrame < initTime && frameNum < initTime))))) {
      if (this._caching.lastFrame >= frameNum) {
        this._caching._lastKeyframeIndex = -1;
        this._caching.lastIndex = 0;
      }

      var renderResult = this.interpolateValue(frameNum, this._caching);
      this.pv = renderResult;
    }
    this._caching.lastFrame = frameNum;
    return this.pv;
  }

  function setVValue(val) {
    var multipliedValue;
    if (this.propType === 'unidimensional') {
      multipliedValue = val * this.mult;
      if (mathAbs(this.v - multipliedValue) > 0.00001) {
        this.v = multipliedValue;
        this._mdf = true;
      }
    } else {
      var i = 0;
      var len = this.v.length;
      while (i < len) {
        multipliedValue = val[i] * this.mult;
        if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
          this.v[i] = multipliedValue;
          this._mdf = true;
        }
        i += 1;
      }
    }
  }

  function processEffectsSequence() {
    if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
      return;
    }
    if (this.lock) {
      this.setVValue(this.pv);
      return;
    }
    this.lock = true;
    this._mdf = this._isFirstFrame;
    var i;
    var len = this.effectsSequence.length;
    var finalValue = this.kf ? this.pv : this.data.k;
    for (i = 0; i < len; i += 1) {
      finalValue = this.effectsSequence[i](finalValue);
    }
    this.setVValue(finalValue);
    this._isFirstFrame = false;
    this.lock = false;
    this.frameId = this.elem.globalData.frameId;
  }

  function addEffect(effectFunction) {
    this.effectsSequence.push(effectFunction);
    this.container.addDynamicProperty(this);
  }

  function ValueProperty(elem, data, mult, container) {
    this.propType = 'unidimensional';
    this.mult = mult || 1;
    this.data = data;
    this.v = mult ? data.k * mult : data.k;
    this.pv = data.k;
    this._mdf = false;
    this.elem = elem;
    this.container = container;
    this.comp = elem.comp;
    this.k = false;
    this.kf = false;
    this.vel = 0;
    this.effectsSequence = [];
    this._isFirstFrame = true;
    this.getValue = processEffectsSequence;
    this.setVValue = setVValue;
    this.addEffect = addEffect;
  }

  function MultiDimensionalProperty(elem, data, mult, container) {
    this.propType = 'multidimensional';
    this.mult = mult || 1;
    this.data = data;
    this._mdf = false;
    this.elem = elem;
    this.container = container;
    this.comp = elem.comp;
    this.k = false;
    this.kf = false;
    this.frameId = -1;
    var i;
    var len = data.k.length;
    this.v = createTypedArray('float32', len);
    this.pv = createTypedArray('float32', len);
    this.vel = createTypedArray('float32', len);
    for (i = 0; i < len; i += 1) {
      this.v[i] = data.k[i] * this.mult;
      this.pv[i] = data.k[i];
    }
    this._isFirstFrame = true;
    this.effectsSequence = [];
    this.getValue = processEffectsSequence;
    this.setVValue = setVValue;
    this.addEffect = addEffect;
  }

  function KeyframedValueProperty(elem, data, mult, container) {
    this.propType = 'unidimensional';
    this.keyframes = data.k;
    this.offsetTime = elem.data.st;
    this.frameId = -1;
    this._caching = {
      lastFrame: initFrame, lastIndex: 0, value: 0, _lastKeyframeIndex: -1,
    };
    this.k = true;
    this.kf = true;
    this.data = data;
    this.mult = mult || 1;
    this.elem = elem;
    this.container = container;
    this.comp = elem.comp;
    this.v = initFrame;
    this.pv = initFrame;
    this._isFirstFrame = true;
    this.getValue = processEffectsSequence;
    this.setVValue = setVValue;
    this.interpolateValue = interpolateValue;
    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
    this.addEffect = addEffect;
  }

  function KeyframedMultidimensionalProperty(elem, data, mult, container) {
    this.propType = 'multidimensional';
    var i;
    var len = data.k.length;
    var s;
    var e;
    var to;
    var ti;
    for (i = 0; i < len - 1; i += 1) {
      if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
        s = data.k[i].s;
        e = data.k[i + 1].s;
        to = data.k[i].to;
        ti = data.k[i].ti;
        if ((s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1])) || (s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2]))) {
          data.k[i].to = null;
          data.k[i].ti = null;
        }
        if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
          if (s.length === 2 || (s[2] === e[2] && to[2] === 0 && ti[2] === 0)) {
            data.k[i].to = null;
            data.k[i].ti = null;
          }
        }
      }
    }
    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
    this.data = data;
    this.keyframes = data.k;
    this.offsetTime = elem.data.st;
    this.k = true;
    this.kf = true;
    this._isFirstFrame = true;
    this.mult = mult || 1;
    this.elem = elem;
    this.container = container;
    this.comp = elem.comp;
    this.getValue = processEffectsSequence;
    this.setVValue = setVValue;
    this.interpolateValue = interpolateValue;
    this.frameId = -1;
    var arrLen = data.k[0].s.length;
    this.v = createTypedArray('float32', arrLen);
    this.pv = createTypedArray('float32', arrLen);
    for (i = 0; i < arrLen; i += 1) {
      this.v[i] = initFrame;
      this.pv[i] = initFrame;
    }
    this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray('float32', arrLen) };
    this.addEffect = addEffect;
  }

  function getProp(elem, data, type, mult, container) {
    var p;
    if (!data.k.length) {
      p = new ValueProperty(elem, data, mult, container);
    } else if (typeof (data.k[0]) === 'number') {
      p = new MultiDimensionalProperty(elem, data, mult, container);
    } else {
      switch (type) {
        case 0:
          p = new KeyframedValueProperty(elem, data, mult, container);
          break;
        case 1:
          p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
          break;
        default:
          break;
      }
    }
    if (p.effectsSequence.length) {
      container.addDynamicProperty(p);
    }
    return p;
  }

  var ob = {
    getProp: getProp,
  };
  return ob;
}());

/* global Matrix, degToRads, PropertyFactory, extendPrototype, DynamicPropertyContainer */
/* exported TransformPropertyFactory */

var TransformPropertyFactory = (function () {
  var defaultVector = [0, 0];

  function applyToMatrix(mat) {
    var _mdf = this._mdf;
    this.iterateDynamicProperties();
    this._mdf = this._mdf || _mdf;
    if (this.a) {
      mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
    }
    if (this.s) {
      mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
    }
    if (this.sk) {
      mat.skewFromAxis(-this.sk.v, this.sa.v);
    }
    if (this.r) {
      mat.rotate(-this.r.v);
    } else {
      mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
        .rotateY(this.or.v[1])
        .rotateX(this.or.v[0]);
    }
    if (this.data.p.s) {
      if (this.data.p.z) {
        mat.translate(this.px.v, this.py.v, -this.pz.v);
      } else {
        mat.translate(this.px.v, this.py.v, 0);
      }
    } else {
      mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
    }
  }
  function processKeys(forceRender) {
    if (this.elem.globalData.frameId === this.frameId) {
      return;
    }
    if (this._isDirty) {
      this.precalculateMatrix();
      this._isDirty = false;
    }

    this.iterateDynamicProperties();

    if (this._mdf || forceRender) {
      var frameRate;
      this.v.cloneFromProps(this.pre.props);
      if (this.appliedTransformations < 1) {
        this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
      }
      if (this.appliedTransformations < 2) {
        this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
      }
      if (this.sk && this.appliedTransformations < 3) {
        this.v.skewFromAxis(-this.sk.v, this.sa.v);
      }
      if (this.r && this.appliedTransformations < 4) {
        this.v.rotate(-this.r.v);
      } else if (!this.r && this.appliedTransformations < 4) {
        this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
          .rotateY(this.or.v[1])
          .rotateX(this.or.v[0]);
      }
      if (this.autoOriented) {
        var v1;
        var v2;
        frameRate = this.elem.globalData.frameRate;
        if (this.p && this.p.keyframes && this.p.getValueAtTime) {
          if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
            v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
            v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
          } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
            v1 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t / frameRate), 0);
            v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
          } else {
            v1 = this.p.pv;
            v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
          }
        } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
          v1 = [];
          v2 = [];
          var px = this.px;
          var py = this.py;
          if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
            v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
            v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
            v2[0] = px.getValueAtTime((px.keyframes[0].t) / frameRate, 0);
            v2[1] = py.getValueAtTime((py.keyframes[0].t) / frameRate, 0);
          } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
            v1[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t / frameRate), 0);
            v1[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t / frameRate), 0);
            v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
            v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
          } else {
            v1 = [px.pv, py.pv];
            v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
            v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
          }
        } else {
          v2 = defaultVector;
          v1 = v2;
        }
        this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
      }
      if (this.data.p && this.data.p.s) {
        if (this.data.p.z) {
          this.v.translate(this.px.v, this.py.v, -this.pz.v);
        } else {
          this.v.translate(this.px.v, this.py.v, 0);
        }
      } else {
        this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
      }
    }
    this.frameId = this.elem.globalData.frameId;
  }

  function precalculateMatrix() {
    if (!this.a.k) {
      this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
      this.appliedTransformations = 1;
    } else {
      return;
    }
    if (!this.s.effectsSequence.length) {
      this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
      this.appliedTransformations = 2;
    } else {
      return;
    }
    if (this.sk) {
      if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
        this.pre.skewFromAxis(-this.sk.v, this.sa.v);
        this.appliedTransformations = 3;
      } else {
        return;
      }
    }
    if (this.r) {
      if (!this.r.effectsSequence.length) {
        this.pre.rotate(-this.r.v);
        this.appliedTransformations = 4;
      }
    } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
      this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
        .rotateY(this.or.v[1])
        .rotateX(this.or.v[0]);
      this.appliedTransformations = 4;
    }
  }

  function autoOrient() {
    //
    // var prevP = this.getValueAtTime();
  }

  function addDynamicProperty(prop) {
    this._addDynamicProperty(prop);
    this.elem.addDynamicProperty(prop);
    this._isDirty = true;
  }

  function TransformProperty(elem, data, container) {
    this.elem = elem;
    this.frameId = -1;
    this.propType = 'transform';
    this.data = data;
    this.v = new Matrix();
    // Precalculated matrix with non animated properties
    this.pre = new Matrix();
    this.appliedTransformations = 0;
    this.initDynamicPropertyContainer(container || elem);
    if (data.p && data.p.s) {
      this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
      this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
      if (data.p.z) {
        this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
      }
    } else {
      this.p = PropertyFactory.getProp(elem, data.p || { k: [0, 0, 0] }, 1, 0, this);
    }
    if (data.rx) {
      this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
      this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
      this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
      if (data.or.k[0].ti) {
        var i;
        var len = data.or.k.length;
        for (i = 0; i < len; i += 1) {
          data.or.k[i].to = null;
          data.or.k[i].ti = null;
        }
      }
      this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
      // sh Indicates it needs to be capped between -180 and 180
      this.or.sh = true;
    } else {
      this.r = PropertyFactory.getProp(elem, data.r || { k: 0 }, 0, degToRads, this);
    }
    if (data.sk) {
      this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
      this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
    }
    this.a = PropertyFactory.getProp(elem, data.a || { k: [0, 0, 0] }, 1, 0, this);
    this.s = PropertyFactory.getProp(elem, data.s || { k: [100, 100, 100] }, 1, 0.01, this);
    // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
    if (data.o) {
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
    } else {
      this.o = { _mdf: false, v: 1 };
    }
    this._isDirty = true;
    if (!this.dynamicProperties.length) {
      this.getValue(true);
    }
  }

  TransformProperty.prototype = {
    applyToMatrix: applyToMatrix,
    getValue: processKeys,
    precalculateMatrix: precalculateMatrix,
    autoOrient: autoOrient,
  };

  extendPrototype([DynamicPropertyContainer], TransformProperty);
  TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
  TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;

  function getTransformProperty(elem, data, container) {
    return new TransformProperty(elem, data, container);
  }

  return {
    getTransformProperty: getTransformProperty,
  };
}());

/* global createSizedArray, createSizedArray, pointPool */

function ShapePath() {
  this.c = false;
  this._length = 0;
  this._maxLength = 8;
  this.v = createSizedArray(this._maxLength);
  this.o = createSizedArray(this._maxLength);
  this.i = createSizedArray(this._maxLength);
}

ShapePath.prototype.setPathData = function (closed, len) {
  this.c = closed;
  this.setLength(len);
  var i = 0;
  while (i < len) {
    this.v[i] = pointPool.newElement();
    this.o[i] = pointPool.newElement();
    this.i[i] = pointPool.newElement();
    i += 1;
  }
};

ShapePath.prototype.setLength = function (len) {
  while (this._maxLength < len) {
    this.doubleArrayLength();
  }
  this._length = len;
};

ShapePath.prototype.doubleArrayLength = function () {
  this.v = this.v.concat(createSizedArray(this._maxLength));
  this.i = this.i.concat(createSizedArray(this._maxLength));
  this.o = this.o.concat(createSizedArray(this._maxLength));
  this._maxLength *= 2;
};

ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
  var arr;
  this._length = Math.max(this._length, pos + 1);
  if (this._length >= this._maxLength) {
    this.doubleArrayLength();
  }
  switch (type) {
    case 'v':
      arr = this.v;
      break;
    case 'i':
      arr = this.i;
      break;
    case 'o':
      arr = this.o;
      break;
    default:
      arr = [];
      break;
  }
  if (!arr[pos] || (arr[pos] && !replace)) {
    arr[pos] = pointPool.newElement();
  }
  arr[pos][0] = x;
  arr[pos][1] = y;
};

ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
  this.setXYAt(vX, vY, 'v', pos, replace);
  this.setXYAt(oX, oY, 'o', pos, replace);
  this.setXYAt(iX, iY, 'i', pos, replace);
};

ShapePath.prototype.reverse = function () {
  var newPath = new ShapePath();
  newPath.setPathData(this.c, this._length);
  var vertices = this.v;
  var outPoints = this.o;
  var inPoints = this.i;
  var init = 0;
  if (this.c) {
    newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
    init = 1;
  }
  var cnt = this._length - 1;
  var len = this._length;

  var i;
  for (i = init; i < len; i += 1) {
    newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
    cnt -= 1;
  }
  return newPath;
};

/* global extendPrototype, roundCorner, BezierFactory, shapePool, degToRads,
  shapeCollectionPool, PropertyFactory, bmMin, DynamicPropertyContainer */
/* exported ShapePropertyFactory */

var ShapePropertyFactory = (function () {
  var initFrame = -999999;

  function interpolateShape(frameNum, previousValue, caching) {
    var iterationIndex = caching.lastIndex;
    var keyPropS;
    var keyPropE;
    var isHold;
    var j;
    var k;
    var jLen;
    var kLen;
    var perc;
    var vertexValue;
    var kf = this.keyframes;
    if (frameNum < kf[0].t - this.offsetTime) {
      keyPropS = kf[0].s[0];
      isHold = true;
      iterationIndex = 0;
    } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
      keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
      /* if(kf[kf.length - 1].s){
                keyPropS = kf[kf.length - 1].s[0];
            }else{
                keyPropS = kf[kf.length - 2].e[0];
            } */
      isHold = true;
    } else {
      var i = iterationIndex;
      var len = kf.length - 1;
      var flag = true;
      var keyData;
      var nextKeyData;
      while (flag) {
        keyData = kf[i];
        nextKeyData = kf[i + 1];
        if ((nextKeyData.t - this.offsetTime) > frameNum) {
          break;
        }
        if (i < len - 1) {
          i += 1;
        } else {
          flag = false;
        }
      }
      isHold = keyData.h === 1;
      iterationIndex = i;
      if (!isHold) {
        if (frameNum >= nextKeyData.t - this.offsetTime) {
          perc = 1;
        } else if (frameNum < keyData.t - this.offsetTime) {
          perc = 0;
        } else {
          var fnc;
          if (keyData.__fnct) {
            fnc = keyData.__fnct;
          } else {
            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
            keyData.__fnct = fnc;
          }
          perc = fnc((frameNum - (keyData.t - this.offsetTime)) / ((nextKeyData.t - this.offsetTime) - (keyData.t - this.offsetTime)));
        }
        keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
      }
      keyPropS = keyData.s[0];
    }
    jLen = previousValue._length;
    kLen = keyPropS.i[0].length;
    caching.lastIndex = iterationIndex;

    for (j = 0; j < jLen; j += 1) {
      for (k = 0; k < kLen; k += 1) {
        vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
        previousValue.i[j][k] = vertexValue;
        vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
        previousValue.o[j][k] = vertexValue;
        vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
        previousValue.v[j][k] = vertexValue;
      }
    }
  }

  function interpolateShapeCurrentTime() {
    var frameNum = this.comp.renderedFrame - this.offsetTime;
    var initTime = this.keyframes[0].t - this.offsetTime;
    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
    var lastFrame = this._caching.lastFrame;
    if (!(lastFrame !== initFrame && ((lastFrame < initTime && frameNum < initTime) || (lastFrame > endTime && frameNum > endTime)))) {
      /// /
      this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
      this.interpolateShape(frameNum, this.pv, this._caching);
      /// /
    }
    this._caching.lastFrame = frameNum;
    return this.pv;
  }

  function resetShape() {
    this.paths = this.localShapeCollection;
  }

  function shapesEqual(shape1, shape2) {
    if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
      return false;
    }
    var i;
    var len = shape1._length;
    for (i = 0; i < len; i += 1) {
      if (shape1.v[i][0] !== shape2.v[i][0]
            || shape1.v[i][1] !== shape2.v[i][1]
            || shape1.o[i][0] !== shape2.o[i][0]
            || shape1.o[i][1] !== shape2.o[i][1]
            || shape1.i[i][0] !== shape2.i[i][0]
            || shape1.i[i][1] !== shape2.i[i][1]) {
        return false;
      }
    }
    return true;
  }

  function setVValue(newPath) {
    if (!shapesEqual(this.v, newPath)) {
      this.v = shapePool.clone(newPath);
      this.localShapeCollection.releaseShapes();
      this.localShapeCollection.addShape(this.v);
      this._mdf = true;
      this.paths = this.localShapeCollection;
    }
  }

  function processEffectsSequence() {
    if (this.elem.globalData.frameId === this.frameId) {
      return;
    } if (!this.effectsSequence.length) {
      this._mdf = false;
      return;
    }
    if (this.lock) {
      this.setVValue(this.pv);
      return;
    }
    this.lock = true;
    this._mdf = false;
    var finalValue;
    if (this.kf) {
      finalValue = this.pv;
    } else if (this.data.ks) {
      finalValue = this.data.ks.k;
    } else {
      finalValue = this.data.pt.k;
    }
    var i;
    var len = this.effectsSequence.length;
    for (i = 0; i < len; i += 1) {
      finalValue = this.effectsSequence[i](finalValue);
    }
    this.setVValue(finalValue);
    this.lock = false;
    this.frameId = this.elem.globalData.frameId;
  }

  function ShapeProperty(elem, data, type) {
    this.propType = 'shape';
    this.comp = elem.comp;
    this.container = elem;
    this.elem = elem;
    this.data = data;
    this.k = false;
    this.kf = false;
    this._mdf = false;
    var pathData = type === 3 ? data.pt.k : data.ks.k;
    this.v = shapePool.clone(pathData);
    this.pv = shapePool.clone(this.v);
    this.localShapeCollection = shapeCollectionPool.newShapeCollection();
    this.paths = this.localShapeCollection;
    this.paths.addShape(this.v);
    this.reset = resetShape;
    this.effectsSequence = [];
  }

  function addEffect(effectFunction) {
    this.effectsSequence.push(effectFunction);
    this.container.addDynamicProperty(this);
  }

  ShapeProperty.prototype.interpolateShape = interpolateShape;
  ShapeProperty.prototype.getValue = processEffectsSequence;
  ShapeProperty.prototype.setVValue = setVValue;
  ShapeProperty.prototype.addEffect = addEffect;

  function KeyframedShapeProperty(elem, data, type) {
    this.propType = 'shape';
    this.comp = elem.comp;
    this.elem = elem;
    this.container = elem;
    this.offsetTime = elem.data.st;
    this.keyframes = type === 3 ? data.pt.k : data.ks.k;
    this.k = true;
    this.kf = true;
    var len = this.keyframes[0].s[0].i.length;
    this.v = shapePool.newElement();
    this.v.setPathData(this.keyframes[0].s[0].c, len);
    this.pv = shapePool.clone(this.v);
    this.localShapeCollection = shapeCollectionPool.newShapeCollection();
    this.paths = this.localShapeCollection;
    this.paths.addShape(this.v);
    this.lastFrame = initFrame;
    this.reset = resetShape;
    this._caching = { lastFrame: initFrame, lastIndex: 0 };
    this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
  }
  KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
  KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
  KeyframedShapeProperty.prototype.setVValue = setVValue;
  KeyframedShapeProperty.prototype.addEffect = addEffect;

  var EllShapeProperty = (function () {
    var cPoint = roundCorner;

    function EllShapePropertyFactory(elem, data) {
      /* this.v = {
                v: createSizedArray(4),
                i: createSizedArray(4),
                o: createSizedArray(4),
                c: true
            }; */
      this.v = shapePool.newElement();
      this.v.setPathData(true, 4);
      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
      this.paths = this.localShapeCollection;
      this.localShapeCollection.addShape(this.v);
      this.d = data.d;
      this.elem = elem;
      this.comp = elem.comp;
      this.frameId = -1;
      this.initDynamicPropertyContainer(elem);
      this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
      this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.k = false;
        this.convertEllToPath();
      }
    }

    EllShapePropertyFactory.prototype = {
      reset: resetShape,
      getValue: function () {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();

        if (this._mdf) {
          this.convertEllToPath();
        }
      },
      convertEllToPath: function () {
        var p0 = this.p.v[0];
        var p1 = this.p.v[1];
        var s0 = this.s.v[0] / 2;
        var s1 = this.s.v[1] / 2;
        var _cw = this.d !== 3;
        var _v = this.v;
        _v.v[0][0] = p0;
        _v.v[0][1] = p1 - s1;
        _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
        _v.v[1][1] = p1;
        _v.v[2][0] = p0;
        _v.v[2][1] = p1 + s1;
        _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
        _v.v[3][1] = p1;
        _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
        _v.i[0][1] = p1 - s1;
        _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
        _v.i[1][1] = p1 - s1 * cPoint;
        _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
        _v.i[2][1] = p1 + s1;
        _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
        _v.i[3][1] = p1 + s1 * cPoint;
        _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
        _v.o[0][1] = p1 - s1;
        _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
        _v.o[1][1] = p1 + s1 * cPoint;
        _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
        _v.o[2][1] = p1 + s1;
        _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
        _v.o[3][1] = p1 - s1 * cPoint;
      },
    };

    extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);

    return EllShapePropertyFactory;
  }());

  var StarShapeProperty = (function () {
    function StarShapePropertyFactory(elem, data) {
      this.v = shapePool.newElement();
      this.v.setPathData(true, 0);
      this.elem = elem;
      this.comp = elem.comp;
      this.data = data;
      this.frameId = -1;
      this.d = data.d;
      this.initDynamicPropertyContainer(elem);
      if (data.sy === 1) {
        this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
        this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
        this.convertToPath = this.convertStarToPath;
      } else {
        this.convertToPath = this.convertPolygonToPath;
      }
      this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
      this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
      this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
      this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
      this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
      this.localShapeCollection.addShape(this.v);
      this.paths = this.localShapeCollection;
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.k = false;
        this.convertToPath();
      }
    }

    StarShapePropertyFactory.prototype = {
      reset: resetShape,
      getValue: function () {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        if (this._mdf) {
          this.convertToPath();
        }
      },
      convertStarToPath: function () {
        var numPts = Math.floor(this.pt.v) * 2;
        var angle = (Math.PI * 2) / numPts;
        /* this.v.v.length = numPts;
                this.v.i.length = numPts;
                this.v.o.length = numPts; */
        var longFlag = true;
        var longRad = this.or.v;
        var shortRad = this.ir.v;
        var longRound = this.os.v;
        var shortRound = this.is.v;
        var longPerimSegment = (2 * Math.PI * longRad) / (numPts * 2);
        var shortPerimSegment = (2 * Math.PI * shortRad) / (numPts * 2);
        var i;
        var rad;
        var roundness;
        var perimSegment;
        var currentAng = -Math.PI / 2;
        currentAng += this.r.v;
        var dir = this.data.d === 3 ? -1 : 1;
        this.v._length = 0;
        for (i = 0; i < numPts; i += 1) {
          rad = longFlag ? longRad : shortRad;
          roundness = longFlag ? longRound : shortRound;
          perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
          var x = rad * Math.cos(currentAng);
          var y = rad * Math.sin(currentAng);
          var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
          var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
          x += +this.p.v[0];
          y += +this.p.v[1];
          this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);

          /* this.v.v[i] = [x,y];
                    this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
                    this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
                    this.v._length = numPts; */
          longFlag = !longFlag;
          currentAng += angle * dir;
        }
      },
      convertPolygonToPath: function () {
        var numPts = Math.floor(this.pt.v);
        var angle = (Math.PI * 2) / numPts;
        var rad = this.or.v;
        var roundness = this.os.v;
        var perimSegment = (2 * Math.PI * rad) / (numPts * 4);
        var i;
        var currentAng = -Math.PI * 0.5;
        var dir = this.data.d === 3 ? -1 : 1;
        currentAng += this.r.v;
        this.v._length = 0;
        for (i = 0; i < numPts; i += 1) {
          var x = rad * Math.cos(currentAng);
          var y = rad * Math.sin(currentAng);
          var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
          var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
          x += +this.p.v[0];
          y += +this.p.v[1];
          this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
          currentAng += angle * dir;
        }
        this.paths.length = 0;
        this.paths[0] = this.v;
      },

    };
    extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);

    return StarShapePropertyFactory;
  }());

  var RectShapeProperty = (function () {
    function RectShapePropertyFactory(elem, data) {
      this.v = shapePool.newElement();
      this.v.c = true;
      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
      this.localShapeCollection.addShape(this.v);
      this.paths = this.localShapeCollection;
      this.elem = elem;
      this.comp = elem.comp;
      this.frameId = -1;
      this.d = data.d;
      this.initDynamicPropertyContainer(elem);
      this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
      this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
      this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.k = false;
        this.convertRectToPath();
      }
    }

    RectShapePropertyFactory.prototype = {
      convertRectToPath: function () {
        var p0 = this.p.v[0];
        var p1 = this.p.v[1];
        var v0 = this.s.v[0] / 2;
        var v1 = this.s.v[1] / 2;
        var round = bmMin(v0, v1, this.r.v);
        var cPoint = round * (1 - roundCorner);
        this.v._length = 0;

        if (this.d === 2 || this.d === 1) {
          this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
          this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
          if (round !== 0) {
            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
          } else {
            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
          }
        } else {
          this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
          if (round !== 0) {
            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
          } else {
            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
            this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
          }
        }
      },
      getValue: function () {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        if (this._mdf) {
          this.convertRectToPath();
        }
      },
      reset: resetShape,
    };
    extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);

    return RectShapePropertyFactory;
  }());

  function getShapeProp(elem, data, type) {
    var prop;
    if (type === 3 || type === 4) {
      var dataProp = type === 3 ? data.pt : data.ks;
      var keys = dataProp.k;
      if (keys.length) {
        prop = new KeyframedShapeProperty(elem, data, type);
      } else {
        prop = new ShapeProperty(elem, data, type);
      }
    } else if (type === 5) {
      prop = new RectShapeProperty(elem, data);
    } else if (type === 6) {
      prop = new EllShapeProperty(elem, data);
    } else if (type === 7) {
      prop = new StarShapeProperty(elem, data);
    }
    if (prop.k) {
      elem.addDynamicProperty(prop);
    }
    return prop;
  }

  function getConstructorFunction() {
    return ShapeProperty;
  }

  function getKeyframedConstructorFunction() {
    return KeyframedShapeProperty;
  }

  var ob = {};
  ob.getShapeProp = getShapeProp;
  ob.getConstructorFunction = getConstructorFunction;
  ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
  return ob;
}());

/* global shapeCollectionPool, initialDefaultFrame, extendPrototype, DynamicPropertyContainer */
/* exported ShapeModifiers */

var ShapeModifiers = (function () {
  var ob = {};
  var modifiers = {};
  ob.registerModifier = registerModifier;
  ob.getModifier = getModifier;

  function registerModifier(nm, factory) {
    if (!modifiers[nm]) {
      modifiers[nm] = factory;
    }
  }

  function getModifier(nm, elem, data) {
    return new modifiers[nm](elem, data);
  }

  return ob;
}());

function ShapeModifier() {}
ShapeModifier.prototype.initModifierProperties = function () {};
ShapeModifier.prototype.addShapeToModifier = function () {};
ShapeModifier.prototype.addShape = function (data) {
  if (!this.closed) {
    // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
    data.sh.container.addDynamicProperty(data.sh);
    var shapeData = { shape: data.sh, data: data, localShapeCollection: shapeCollectionPool.newShapeCollection() };
    this.shapes.push(shapeData);
    this.addShapeToModifier(shapeData);
    if (this._isAnimated) {
      data.setAsAnimated();
    }
  }
};
ShapeModifier.prototype.init = function (elem, data) {
  this.shapes = [];
  this.elem = elem;
  this.initDynamicPropertyContainer(elem);
  this.initModifierProperties(elem, data);
  this.frameId = initialDefaultFrame;
  this.closed = false;
  this.k = false;
  if (this.dynamicProperties.length) {
    this.k = true;
  } else {
    this.getValue(true);
  }
};
ShapeModifier.prototype.processKeys = function () {
  if (this.elem.globalData.frameId === this.frameId) {
    return;
  }
  this.frameId = this.elem.globalData.frameId;
  this.iterateDynamicProperties();
};

extendPrototype([DynamicPropertyContainer], ShapeModifier);

/* global extendPrototype, ShapeModifier, PropertyFactory, segmentsLengthPool, bez, shapePool, ShapeModifiers */

function TrimModifier() {
}
extendPrototype([ShapeModifier], TrimModifier);
TrimModifier.prototype.initModifierProperties = function (elem, data) {
  this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
  this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
  this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
  this.sValue = 0;
  this.eValue = 0;
  this.getValue = this.processKeys;
  this.m = data.m;
  this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
};

TrimModifier.prototype.addShapeToModifier = function (shapeData) {
  shapeData.pathsData = [];
};

TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
  var segments = [];
  if (e <= 1) {
    segments.push({
      s: s,
      e: e,
    });
  } else if (s >= 1) {
    segments.push({
      s: s - 1,
      e: e - 1,
    });
  } else {
    segments.push({
      s: s,
      e: 1,
    });
    segments.push({
      s: 0,
      e: e - 1,
    });
  }
  var shapeSegments = [];
  var i;
  var len = segments.length;
  var segmentOb;
  for (i = 0; i < len; i += 1) {
    segmentOb = segments[i];
    if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
      var shapeS;
      var shapeE;
      if (segmentOb.s * totalModifierLength <= addedLength) {
        shapeS = 0;
      } else {
        shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
      }
      if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
        shapeE = 1;
      } else {
        shapeE = ((segmentOb.e * totalModifierLength - addedLength) / shapeLength);
      }
      shapeSegments.push([shapeS, shapeE]);
    }
  }
  if (!shapeSegments.length) {
    shapeSegments.push([0, 0]);
  }
  return shapeSegments;
};

TrimModifier.prototype.releasePathsData = function (pathsData) {
  var i;
  var len = pathsData.length;
  for (i = 0; i < len; i += 1) {
    segmentsLengthPool.release(pathsData[i]);
  }
  pathsData.length = 0;
  return pathsData;
};

TrimModifier.prototype.processShapes = function (_isFirstFrame) {
  var s;
  var e;
  if (this._mdf || _isFirstFrame) {
    var o = (this.o.v % 360) / 360;
    if (o < 0) {
      o += 1;
    }
    if (this.s.v > 1) {
      s = 1 + o;
    } else if (this.s.v < 0) {
      s = 0 + o;
    } else {
      s = this.s.v + o;
    }
    if (this.e.v > 1) {
      e = 1 + o;
    } else if (this.e.v < 0) {
      e = 0 + o;
    } else {
      e = this.e.v + o;
    }

    if (s > e) {
      var _s = s;
      s = e;
      e = _s;
    }
    s = Math.round(s * 10000) * 0.0001;
    e = Math.round(e * 10000) * 0.0001;
    this.sValue = s;
    this.eValue = e;
  } else {
    s = this.sValue;
    e = this.eValue;
  }
  var shapePaths;
  var i;
  var len = this.shapes.length;
  var j;
  var jLen;
  var pathsData;
  var pathData;
  var totalShapeLength;
  var totalModifierLength = 0;

  if (e === s) {
    for (i = 0; i < len; i += 1) {
      this.shapes[i].localShapeCollection.releaseShapes();
      this.shapes[i].shape._mdf = true;
      this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
      if (this._mdf) {
        this.shapes[i].pathsData.length = 0;
      }
    }
  } else if (!((e === 1 && s === 0) || (e === 0 && s === 1))) {
    var segments = [];
    var shapeData;
    var localShapeCollection;
    for (i = 0; i < len; i += 1) {
      shapeData = this.shapes[i];
      // if shape hasn't changed and trim properties haven't changed, cached previous path can be used
      if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
        shapeData.shape.paths = shapeData.localShapeCollection;
      } else {
        shapePaths = shapeData.shape.paths;
        jLen = shapePaths._length;
        totalShapeLength = 0;
        if (!shapeData.shape._mdf && shapeData.pathsData.length) {
          totalShapeLength = shapeData.totalShapeLength;
        } else {
          pathsData = this.releasePathsData(shapeData.pathsData);
          for (j = 0; j < jLen; j += 1) {
            pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
            pathsData.push(pathData);
            totalShapeLength += pathData.totalLength;
          }
          shapeData.totalShapeLength = totalShapeLength;
          shapeData.pathsData = pathsData;
        }

        totalModifierLength += totalShapeLength;
        shapeData.shape._mdf = true;
      }
    }
    var shapeS = s;
    var shapeE = e;
    var addedLength = 0;
    var edges;
    for (i = len - 1; i >= 0; i -= 1) {
      shapeData = this.shapes[i];
      if (shapeData.shape._mdf) {
        localShapeCollection = shapeData.localShapeCollection;
        localShapeCollection.releaseShapes();
        // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
        if (this.m === 2 && len > 1) {
          edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
          addedLength += shapeData.totalShapeLength;
        } else {
          edges = [[shapeS, shapeE]];
        }
        jLen = edges.length;
        for (j = 0; j < jLen; j += 1) {
          shapeS = edges[j][0];
          shapeE = edges[j][1];
          segments.length = 0;
          if (shapeE <= 1) {
            segments.push({
              s: shapeData.totalShapeLength * shapeS,
              e: shapeData.totalShapeLength * shapeE,
            });
          } else if (shapeS >= 1) {
            segments.push({
              s: shapeData.totalShapeLength * (shapeS - 1),
              e: shapeData.totalShapeLength * (shapeE - 1),
            });
          } else {
            segments.push({
              s: shapeData.totalShapeLength * shapeS,
              e: shapeData.totalShapeLength,
            });
            segments.push({
              s: 0,
              e: shapeData.totalShapeLength * (shapeE - 1),
            });
          }
          var newShapesData = this.addShapes(shapeData, segments[0]);
          if (segments[0].s !== segments[0].e) {
            if (segments.length > 1) {
              var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
              if (lastShapeInCollection.c) {
                var lastShape = newShapesData.pop();
                this.addPaths(newShapesData, localShapeCollection);
                newShapesData = this.addShapes(shapeData, segments[1], lastShape);
              } else {
                this.addPaths(newShapesData, localShapeCollection);
                newShapesData = this.addShapes(shapeData, segments[1]);
              }
            }
            this.addPaths(newShapesData, localShapeCollection);
          }
        }
        shapeData.shape.paths = localShapeCollection;
      }
    }
  } else if (this._mdf) {
    for (i = 0; i < len; i += 1) {
      // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
      // Don't remove this even if it's losing cached info.
      this.shapes[i].pathsData.length = 0;
      this.shapes[i].shape._mdf = true;
    }
  }
};

TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
  var i;
  var len = newPaths.length;
  for (i = 0; i < len; i += 1) {
    localShapeCollection.addShape(newPaths[i]);
  }
};

TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
  shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
  shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
  if (newShape) {
    shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
  }
  shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
};

TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
  shapePath.setXYAt(points[1], points[5], 'o', pos);
  shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
  if (newShape) {
    shapePath.setXYAt(points[0], points[4], 'v', pos);
  }
  shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
};

TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
  var pathsData = shapeData.pathsData;
  var shapePaths = shapeData.shape.paths.shapes;
  var i;
  var len = shapeData.shape.paths._length;
  var j;
  var jLen;
  var addedLength = 0;
  var currentLengthData;
  var segmentCount;
  var lengths;
  var segment;
  var shapes = [];
  var initPos;
  var newShape = true;
  if (!shapePath) {
    shapePath = shapePool.newElement();
    segmentCount = 0;
    initPos = 0;
  } else {
    segmentCount = shapePath._length;
    initPos = shapePath._length;
  }
  shapes.push(shapePath);
  for (i = 0; i < len; i += 1) {
    lengths = pathsData[i].lengths;
    shapePath.c = shapePaths[i].c;
    jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
    for (j = 1; j < jLen; j += 1) {
      currentLengthData = lengths[j - 1];
      if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
        addedLength += currentLengthData.addedLength;
        shapePath.c = false;
      } else if (addedLength > shapeSegment.e) {
        shapePath.c = false;
        break;
      } else {
        if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
          this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
          newShape = false;
        } else {
          segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
          this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
          // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
          newShape = false;
          shapePath.c = false;
        }
        addedLength += currentLengthData.addedLength;
        segmentCount += 1;
      }
    }
    if (shapePaths[i].c && lengths.length) {
      currentLengthData = lengths[j - 1];
      if (addedLength <= shapeSegment.e) {
        var segmentLength = lengths[j - 1].addedLength;
        if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
          this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
          newShape = false;
        } else {
          segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
          this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
          // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
          newShape = false;
          shapePath.c = false;
        }
      } else {
        shapePath.c = false;
      }
      addedLength += currentLengthData.addedLength;
      segmentCount += 1;
    }
    if (shapePath._length) {
      shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
      shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
    }
    if (addedLength > shapeSegment.e) {
      break;
    }
    if (i < len - 1) {
      shapePath = shapePool.newElement();
      newShape = true;
      shapes.push(shapePath);
      segmentCount = 0;
    }
  }
  return shapes;
};

ShapeModifiers.registerModifier('tm', TrimModifier);

/* global extendPrototype, ShapeModifier, PropertyFactory, shapePool, roundCorner, ShapeModifiers */

function RoundCornersModifier() {}
extendPrototype([ShapeModifier], RoundCornersModifier);
RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
  this.getValue = this.processKeys;
  this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
  this._isAnimated = !!this.rd.effectsSequence.length;
};

RoundCornersModifier.prototype.processPath = function (path, round) {
  var clonedPath = shapePool.newElement();
  clonedPath.c = path.c;
  var i;
  var len = path._length;
  var currentV;
  var currentI;
  var currentO;
  var closerV;
  var distance;
  var newPosPerc;
  var index = 0;
  var vX;
  var vY;
  var oX;
  var oY;
  var iX;
  var iY;
  for (i = 0; i < len; i += 1) {
    currentV = path.v[i];
    currentO = path.o[i];
    currentI = path.i[i];
    if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
      if ((i === 0 || i === len - 1) && !path.c) {
        clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
        /* clonedPath.v[index] = currentV;
                clonedPath.o[index] = currentO;
                clonedPath.i[index] = currentI; */
        index += 1;
      } else {
        if (i === 0) {
          closerV = path.v[len - 1];
        } else {
          closerV = path.v[i - 1];
        }
        distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
        newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
        iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
        vX = iX;
        iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
        vY = iY;
        oX = vX - (vX - currentV[0]) * roundCorner;
        oY = vY - (vY - currentV[1]) * roundCorner;
        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
        index += 1;

        if (i === len - 1) {
          closerV = path.v[0];
        } else {
          closerV = path.v[i + 1];
        }
        distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
        newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
        oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
        vX = oX;
        oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
        vY = oY;
        iX = vX - (vX - currentV[0]) * roundCorner;
        iY = vY - (vY - currentV[1]) * roundCorner;
        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
        index += 1;
      }
    } else {
      clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
      index += 1;
    }
  }
  return clonedPath;
};

RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
  var shapePaths;
  var i;
  var len = this.shapes.length;
  var j;
  var jLen;
  var rd = this.rd.v;

  if (rd !== 0) {
    var shapeData;
    var localShapeCollection;
    for (i = 0; i < len; i += 1) {
      shapeData = this.shapes[i];
      localShapeCollection = shapeData.localShapeCollection;
      if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
        localShapeCollection.releaseShapes();
        shapeData.shape._mdf = true;
        shapePaths = shapeData.shape.paths.shapes;
        jLen = shapeData.shape.paths._length;
        for (j = 0; j < jLen; j += 1) {
          localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
        }
      }
      shapeData.shape.paths = shapeData.localShapeCollection;
    }
  }
  if (!this.dynamicProperties.length) {
    this._mdf = false;
  }
};

ShapeModifiers.registerModifier('rd', RoundCornersModifier);

/* global extendPrototype, ShapeModifier, PropertyFactory, shapePool, ShapeModifiers */

function PuckerAndBloatModifier() {}
extendPrototype([ShapeModifier], PuckerAndBloatModifier);
PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {
  this.getValue = this.processKeys;
  this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
  this._isAnimated = !!this.amount.effectsSequence.length;
};

PuckerAndBloatModifier.prototype.processPath = function (path, amount) {
  var percent = amount / 100;
  var centerPoint = [0, 0];
  var pathLength = path._length;
  var i = 0;
  for (i = 0; i < pathLength; i += 1) {
    centerPoint[0] += path.v[i][0];
    centerPoint[1] += path.v[i][1];
  }
  centerPoint[0] /= pathLength;
  centerPoint[1] /= pathLength;
  var clonedPath = shapePool.newElement();
  clonedPath.c = path.c;
  var vX;
  var vY;
  var oX;
  var oY;
  var iX;
  var iY;
  for (i = 0; i < pathLength; i += 1) {
    vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
    vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
    oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
    oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
    iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
    iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
  }
  return clonedPath;
};

PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {
  var shapePaths;
  var i;
  var len = this.shapes.length;
  var j;
  var jLen;
  var amount = this.amount.v;

  if (amount !== 0) {
    var shapeData;
    var localShapeCollection;
    for (i = 0; i < len; i += 1) {
      shapeData = this.shapes[i];
      localShapeCollection = shapeData.localShapeCollection;
      if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
        localShapeCollection.releaseShapes();
        shapeData.shape._mdf = true;
        shapePaths = shapeData.shape.paths.shapes;
        jLen = shapeData.shape.paths._length;
        for (j = 0; j < jLen; j += 1) {
          localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
        }
      }
      shapeData.shape.paths = shapeData.localShapeCollection;
    }
  }
  if (!this.dynamicProperties.length) {
    this._mdf = false;
  }
};
ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);

/* global extendPrototype, ShapeModifier, TransformPropertyFactory, PropertyFactory, Matrix, ShapeModifiers */

function RepeaterModifier() {}
extendPrototype([ShapeModifier], RepeaterModifier);

RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
  this.getValue = this.processKeys;
  this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
  this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
  this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
  this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
  this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
  this.data = data;
  if (!this.dynamicProperties.length) {
    this.getValue(true);
  }
  this._isAnimated = !!this.dynamicProperties.length;
  this.pMatrix = new Matrix();
  this.rMatrix = new Matrix();
  this.sMatrix = new Matrix();
  this.tMatrix = new Matrix();
  this.matrix = new Matrix();
};

RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
  var dir = inv ? -1 : 1;
  var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
  var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
  pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
  rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
  rMatrix.rotate(-transform.r.v * dir * perc);
  rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
  sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
  sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
  sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
};

RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
  this.elem = elem;
  this.arr = arr;
  this.pos = pos;
  this.elemsData = elemsData;
  this._currentCopies = 0;
  this._elements = [];
  this._groups = [];
  this.frameId = -1;
  this.initDynamicPropertyContainer(elem);
  this.initModifierProperties(elem, arr[pos]);
  while (pos > 0) {
    pos -= 1;
    // this._elements.unshift(arr.splice(pos,1)[0]);
    this._elements.unshift(arr[pos]);
  }
  if (this.dynamicProperties.length) {
    this.k = true;
  } else {
    this.getValue(true);
  }
};

RepeaterModifier.prototype.resetElements = function (elements) {
  var i;
  var len = elements.length;
  for (i = 0; i < len; i += 1) {
    elements[i]._processed = false;
    if (elements[i].ty === 'gr') {
      this.resetElements(elements[i].it);
    }
  }
};

RepeaterModifier.prototype.cloneElements = function (elements) {
  var newElements = JSON.parse(JSON.stringify(elements));
  this.resetElements(newElements);
  return newElements;
};

RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
  var i;
  var len = elements.length;
  for (i = 0; i < len; i += 1) {
    elements[i]._render = renderFlag;
    if (elements[i].ty === 'gr') {
      this.changeGroupRender(elements[i].it, renderFlag);
    }
  }
};

RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
  var items;
  var itemsTransform;
  var i;
  var dir;
  var cont;
  var hasReloaded = false;
  if (this._mdf || _isFirstFrame) {
    var copies = Math.ceil(this.c.v);
    if (this._groups.length < copies) {
      while (this._groups.length < copies) {
        var group = {
          it: this.cloneElements(this._elements),
          ty: 'gr',
        };
        group.it.push({
          a: { a: 0, ix: 1, k: [0, 0] }, nm: 'Transform', o: { a: 0, ix: 7, k: 100 }, p: { a: 0, ix: 2, k: [0, 0] }, r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] }, s: { a: 0, ix: 3, k: [100, 100] }, sa: { a: 0, ix: 5, k: 0 }, sk: { a: 0, ix: 4, k: 0 }, ty: 'tr',
        });

        this.arr.splice(0, 0, group);
        this._groups.splice(0, 0, group);
        this._currentCopies += 1;
      }
      this.elem.reloadShapes();
      hasReloaded = true;
    }
    cont = 0;
    var renderFlag;
    for (i = 0; i <= this._groups.length - 1; i += 1) {
      renderFlag = cont < copies;
      this._groups[i]._render = renderFlag;
      this.changeGroupRender(this._groups[i].it, renderFlag);
      if (!renderFlag) {
        var elems = this.elemsData[i].it;
        var transformData = elems[elems.length - 1];
        if (transformData.transform.op.v !== 0) {
          transformData.transform.op._mdf = true;
          transformData.transform.op.v = 0;
        } else {
          transformData.transform.op._mdf = false;
        }
      }
      cont += 1;
    }

    this._currentCopies = copies;
    /// /

    var offset = this.o.v;
    var offsetModulo = offset % 1;
    var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
    var pProps = this.pMatrix.props;
    var rProps = this.rMatrix.props;
    var sProps = this.sMatrix.props;
    this.pMatrix.reset();
    this.rMatrix.reset();
    this.sMatrix.reset();
    this.tMatrix.reset();
    this.matrix.reset();
    var iteration = 0;

    if (offset > 0) {
      while (iteration < roundOffset) {
        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
        iteration += 1;
      }
      if (offsetModulo) {
        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
        iteration += offsetModulo;
      }
    } else if (offset < 0) {
      while (iteration > roundOffset) {
        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
        iteration -= 1;
      }
      if (offsetModulo) {
        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
        iteration -= offsetModulo;
      }
    }
    i = this.data.m === 1 ? 0 : this._currentCopies - 1;
    dir = this.data.m === 1 ? 1 : -1;
    cont = this._currentCopies;
    var j;
    var jLen;
    while (cont) {
      items = this.elemsData[i].it;
      itemsTransform = items[items.length - 1].transform.mProps.v.props;
      jLen = itemsTransform.length;
      items[items.length - 1].transform.mProps._mdf = true;
      items[items.length - 1].transform.op._mdf = true;
      items[items.length - 1].transform.op.v = this._currentCopies === 1
        ? this.so.v
        : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));

      if (iteration !== 0) {
        if ((i !== 0 && dir === 1) || (i !== this._currentCopies - 1 && dir === -1)) {
          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
        }
        this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
        this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
        this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);

        for (j = 0; j < jLen; j += 1) {
          itemsTransform[j] = this.matrix.props[j];
        }
        this.matrix.reset();
      } else {
        this.matrix.reset();
        for (j = 0; j < jLen; j += 1) {
          itemsTransform[j] = this.matrix.props[j];
        }
      }
      iteration += 1;
      cont -= 1;
      i += dir;
    }
  } else {
    cont = this._currentCopies;
    i = 0;
    dir = 1;
    while (cont) {
      items = this.elemsData[i].it;
      itemsTransform = items[items.length - 1].transform.mProps.v.props;
      items[items.length - 1].transform.mProps._mdf = false;
      items[items.length - 1].transform.op._mdf = false;
      cont -= 1;
      i += dir;
    }
  }
  return hasReloaded;
};

RepeaterModifier.prototype.addShape = function () {};

ShapeModifiers.registerModifier('rp', RepeaterModifier);

/* global createSizedArray, shapePool */

function ShapeCollection() {
  this._length = 0;
  this._maxLength = 4;
  this.shapes = createSizedArray(this._maxLength);
}

ShapeCollection.prototype.addShape = function (shapeData) {
  if (this._length === this._maxLength) {
    this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
    this._maxLength *= 2;
  }
  this.shapes[this._length] = shapeData;
  this._length += 1;
};

ShapeCollection.prototype.releaseShapes = function () {
  var i;
  for (i = 0; i < this._length; i += 1) {
    shapePool.release(this.shapes[i]);
  }
  this._length = 0;
};

/* global createSizedArray, createTypedArray, PropertyFactory, extendPrototype, DynamicPropertyContainer */

function DashProperty(elem, data, renderer, container) {
  this.elem = elem;
  this.frameId = -1;
  this.dataProps = createSizedArray(data.length);
  this.renderer = renderer;
  this.k = false;
  this.dashStr = '';
  this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
  this.dashoffset = createTypedArray('float32', 1);
  this.initDynamicPropertyContainer(container);
  var i;
  var len = data.length || 0;
  var prop;
  for (i = 0; i < len; i += 1) {
    prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
    this.k = prop.k || this.k;
    this.dataProps[i] = { n: data[i].n, p: prop };
  }
  if (!this.k) {
    this.getValue(true);
  }
  this._isAnimated = this.k;
}

DashProperty.prototype.getValue = function (forceRender) {
  if (this.elem.globalData.frameId === this.frameId && !forceRender) {
    return;
  }
  this.frameId = this.elem.globalData.frameId;
  this.iterateDynamicProperties();
  this._mdf = this._mdf || forceRender;
  if (this._mdf) {
    var i = 0;
    var len = this.dataProps.length;
    if (this.renderer === 'svg') {
      this.dashStr = '';
    }
    for (i = 0; i < len; i += 1) {
      if (this.dataProps[i].n !== 'o') {
        if (this.renderer === 'svg') {
          this.dashStr += ' ' + this.dataProps[i].p.v;
        } else {
          this.dashArray[i] = this.dataProps[i].p.v;
        }
      } else {
        this.dashoffset[0] = this.dataProps[i].p.v;
      }
    }
  }
};
extendPrototype([DynamicPropertyContainer], DashProperty);

/* global createTypedArray, PropertyFactory, extendPrototype, DynamicPropertyContainer */
function GradientProperty(elem, data, container) {
  this.data = data;
  this.c = createTypedArray('uint8c', data.p * 4);
  var cLength = data.k.k[0].s ? (data.k.k[0].s.length - data.p * 4) : data.k.k.length - data.p * 4;
  this.o = createTypedArray('float32', cLength);
  this._cmdf = false;
  this._omdf = false;
  this._collapsable = this.checkCollapsable();
  this._hasOpacity = cLength;
  this.initDynamicPropertyContainer(container);
  this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
  this.k = this.prop.k;
  this.getValue(true);
}

GradientProperty.prototype.comparePoints = function (values, points) {
  var i = 0;
  var len = this.o.length / 2;
  var diff;
  while (i < len) {
    diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
    if (diff > 0.01) {
      return false;
    }
    i += 1;
  }
  return true;
};

GradientProperty.prototype.checkCollapsable = function () {
  if (this.o.length / 2 !== this.c.length / 4) {
    return false;
  }
  if (this.data.k.k[0].s) {
    var i = 0;
    var len = this.data.k.k.length;
    while (i < len) {
      if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
        return false;
      }
      i += 1;
    }
  } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
    return false;
  }
  return true;
};

GradientProperty.prototype.getValue = function (forceRender) {
  this.prop.getValue();
  this._mdf = false;
  this._cmdf = false;
  this._omdf = false;
  if (this.prop._mdf || forceRender) {
    var i;
    var len = this.data.p * 4;
    var mult;
    var val;
    for (i = 0; i < len; i += 1) {
      mult = i % 4 === 0 ? 100 : 255;
      val = Math.round(this.prop.v[i] * mult);
      if (this.c[i] !== val) {
        this.c[i] = val;
        this._cmdf = !forceRender;
      }
    }
    if (this.o.length) {
      len = this.prop.v.length;
      for (i = this.data.p * 4; i < len; i += 1) {
        mult = i % 2 === 0 ? 100 : 1;
        val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
        if (this.o[i - this.data.p * 4] !== val) {
          this.o[i - this.data.p * 4] = val;
          this._omdf = !forceRender;
        }
      }
    }
    this._mdf = !forceRender;
  }
};

extendPrototype([DynamicPropertyContainer], GradientProperty);

/* exported buildShapeString */

var buildShapeString = function (pathNodes, length, closed, mat) {
  if (length === 0) {
    return '';
  }
  var _o = pathNodes.o;
  var _i = pathNodes.i;
  var _v = pathNodes.v;
  var i;
  var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
  for (i = 1; i < length; i += 1) {
    shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);
  }
  if (closed && length) {
    shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
    shapeString += 'z';
  }
  return shapeString;
};

/* global Howl */
/* exported audioControllerFactory */

var audioControllerFactory = (function () {
  function AudioController(audioFactory) {
    this.audios = [];
    this.audioFactory = audioFactory;
    this._volume = 1;
    this._isMuted = false;
  }

  AudioController.prototype = {
    addAudio: function (audio) {
      this.audios.push(audio);
    },
    pause: function () {
      var i;
      var len = this.audios.length;
      for (i = 0; i < len; i += 1) {
        this.audios[i].pause();
      }
    },
    resume: function () {
      var i;
      var len = this.audios.length;
      for (i = 0; i < len; i += 1) {
        this.audios[i].resume();
      }
    },
    setRate: function (rateValue) {
      var i;
      var len = this.audios.length;
      for (i = 0; i < len; i += 1) {
        this.audios[i].setRate(rateValue);
      }
    },
    createAudio: function (assetPath) {
      if (this.audioFactory) {
        return this.audioFactory(assetPath);
      } if (Howl) {
        return new Howl({
          src: [assetPath],
        });
      }
      return {
        isPlaying: false,
        play: function () { this.isPlaying = true; },
        seek: function () { this.isPlaying = false; },
        playing: function () {},
        rate: function () {},
        setVolume: function () {},
      };
    },
    setAudioFactory: function (audioFactory) {
      this.audioFactory = audioFactory;
    },
    setVolume: function (value) {
      this._volume = value;
      this._updateVolume();
    },
    mute: function () {
      this._isMuted = true;
      this._updateVolume();
    },
    unmute: function () {
      this._isMuted = false;
      this._updateVolume();
    },
    getVolume: function () {
      return this._volume;
    },
    _updateVolume: function () {
      var i;
      var len = this.audios.length;
      for (i = 0; i < len; i += 1) {
        this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
      }
    },
  };

  return function () {
    return new AudioController();
  };
}());

/* global createTag, createNS, isSafari, assetLoader */
/* exported ImagePreloader */

var ImagePreloader = (function () {
  var proxyImage = (function () {
    var canvas = createTag('canvas');
    canvas.width = 1;
    canvas.height = 1;
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, 1, 1);
    return canvas;
  }());

  function imageLoaded() {
    this.loadedAssets += 1;
    if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
      if (this.imagesLoadedCb) {
        this.imagesLoadedCb(null);
      }
    }
  }
  function footageLoaded() {
    this.loadedFootagesCount += 1;
    if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
      if (this.imagesLoadedCb) {
        this.imagesLoadedCb(null);
      }
    }
  }

  function getAssetsPath(assetData, assetsPath, originalPath) {
    var path = '';
    if (assetData.e) {
      path = assetData.p;
    } else if (assetsPath) {
      var imagePath = assetData.p;
      if (imagePath.indexOf('images/') !== -1) {
        imagePath = imagePath.split('/')[1];
      }
      path = assetsPath + imagePath;
    } else {
      path = originalPath;
      path += assetData.u ? assetData.u : '';
      path += assetData.p;
    }
    return path;
  }

  function testImageLoaded(img) {
    var _count = 0;
    var intervalId = setInterval(function () {
      var box = img.getBBox();
      if (box.width || _count > 500) {
        this._imageLoaded();
        clearInterval(intervalId);
      }
      _count += 1;
    }.bind(this), 50);
  }

  function createImageData(assetData) {
    var path = getAssetsPath(assetData, this.assetsPath, this.path);
    var img = createNS('image');
    if (isSafari) {
      this.testImageLoaded(img);
    } else {
      img.addEventListener('load', this._imageLoaded, false);
    }
    img.addEventListener('error', function () {
      ob.img = proxyImage;
      this._imageLoaded();
    }.bind(this), false);
    img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
    if (this._elementHelper.append) {
      this._elementHelper.append(img);
    } else {
      this._elementHelper.appendChild(img);
    }
    var ob = {
      img: img,
      assetData: assetData,
    };
    return ob;
  }

  function createImgData(assetData) {
    var path = getAssetsPath(assetData, this.assetsPath, this.path);
    var img = createTag('img');
    img.crossOrigin = 'anonymous';
    img.addEventListener('load', this._imageLoaded, false);
    img.addEventListener('error', function () {
      ob.img = proxyImage;
      this._imageLoaded();
    }.bind(this), false);
    img.src = path;
    var ob = {
      img: img,
      assetData: assetData,
    };
    return ob;
  }

  function createFootageData(data) {
    var ob = {
      assetData: data,
    };
    var path = getAssetsPath(data, this.assetsPath, this.path);
    assetLoader.load(path, function (footageData) {
      ob.img = footageData;
      this._footageLoaded();
    }.bind(this), function () {
      ob.img = {};
      this._footageLoaded();
    }.bind(this));
    return ob;
  }

  function loadAssets(assets, cb) {
    this.imagesLoadedCb = cb;
    var i;
    var len = assets.length;
    for (i = 0; i < len; i += 1) {
      if (!assets[i].layers) {
        if (!assets[i].t || assets[i].t === 'seq') {
          this.totalImages += 1;
          this.images.push(this._createImageData(assets[i]));
        } else if (assets[i].t === 3) {
          this.totalFootages += 1;
          this.images.push(this.createFootageData(assets[i]));
        }
      }
    }
  }

  function setPath(path) {
    this.path = path || '';
  }

  function setAssetsPath(path) {
    this.assetsPath = path || '';
  }

  function getAsset(assetData) {
    var i = 0;
    var len = this.images.length;
    while (i < len) {
      if (this.images[i].assetData === assetData) {
        return this.images[i].img;
      }
      i += 1;
    }
    return null;
  }

  function destroy() {
    this.imagesLoadedCb = null;
    this.images.length = 0;
  }

  function loadedImages() {
    return this.totalImages === this.loadedAssets;
  }

  function loadedFootages() {
    return this.totalFootages === this.loadedFootagesCount;
  }

  function setCacheType(type, elementHelper) {
    if (type === 'svg') {
      this._elementHelper = elementHelper;
      this._createImageData = this.createImageData.bind(this);
    } else {
      this._createImageData = this.createImgData.bind(this);
    }
  }

  function ImagePreloaderFactory() {
    this._imageLoaded = imageLoaded.bind(this);
    this._footageLoaded = footageLoaded.bind(this);
    this.testImageLoaded = testImageLoaded.bind(this);
    this.createFootageData = createFootageData.bind(this);
    this.assetsPath = '';
    this.path = '';
    this.totalImages = 0;
    this.totalFootages = 0;
    this.loadedAssets = 0;
    this.loadedFootagesCount = 0;
    this.imagesLoadedCb = null;
    this.images = [];
  }

  ImagePreloaderFactory.prototype = {
    loadAssets: loadAssets,
    setAssetsPath: setAssetsPath,
    setPath: setPath,
    loadedImages: loadedImages,
    loadedFootages: loadedFootages,
    destroy: destroy,
    getAsset: getAsset,
    createImgData: createImgData,
    createImageData: createImageData,
    imageLoaded: imageLoaded,
    footageLoaded: footageLoaded,
    setCacheType: setCacheType,
  };

  return ImagePreloaderFactory;
}());

/* exported featureSupport */

var featureSupport = (function () {
  var ob = {
    maskType: true,
  };
  if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
    ob.maskType = false;
  }
  return ob;
}());

/* global createNS */
/* exported filtersFactory */

var filtersFactory = (function () {
  var ob = {};
  ob.createFilter = createFilter;
  ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

  function createFilter(filId, skipCoordinates) {
    var fil = createNS('filter');
    fil.setAttribute('id', filId);
    if (skipCoordinates !== true) {
      fil.setAttribute('filterUnits', 'objectBoundingBox');
      fil.setAttribute('x', '0%');
      fil.setAttribute('y', '0%');
      fil.setAttribute('width', '100%');
      fil.setAttribute('height', '100%');
    }
    return fil;
  }

  function createAlphaToLuminanceFilter() {
    var feColorMatrix = createNS('feColorMatrix');
    feColorMatrix.setAttribute('type', 'matrix');
    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
    feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
    return feColorMatrix;
  }

  return ob;
}());

/* exported assetLoader */

var assetLoader = (function () {
  function formatResponse(xhr) {
    if (xhr.response && typeof xhr.response === 'object') {
      return xhr.response;
    } if (xhr.response && typeof xhr.response === 'string') {
      return JSON.parse(xhr.response);
    } if (xhr.responseText) {
      return JSON.parse(xhr.responseText);
    }
    return null;
  }

  function loadAsset(path, callback, errorCallback) {
    var response;
    var xhr = new XMLHttpRequest();
    // set responseType after calling open or IE will break.
    try {
      // This crashes on Android WebView prior to KitKat
      xhr.responseType = 'json';
    } catch (err) {} // eslint-disable-line no-empty
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          response = formatResponse(xhr);
          callback(response);
        } else {
          try {
            response = formatResponse(xhr);
            callback(response);
          } catch (err) {
            if (errorCallback) {
              errorCallback(err);
            }
          }
        }
      }
    };
    xhr.open('GET', path, true);
    xhr.send();
  }
  return {
    load: loadAsset,
  };
}());

/* global createSizedArray, PropertyFactory, TextAnimatorDataProperty, bez, addHueToRGB,
  addSaturationToRGB, addBrightnessToRGB, LetterProps, Matrix, extendPrototype, DynamicPropertyContainer */

function TextAnimatorProperty(textData, renderType, elem) {
  this._isFirstFrame = true;
  this._hasMaskedPath = false;
  this._frameId = -1;
  this._textData = textData;
  this._renderType = renderType;
  this._elem = elem;
  this._animatorsData = createSizedArray(this._textData.a.length);
  this._pathData = {};
  this._moreOptions = {
    alignment: {},
  };
  this.renderedLetters = [];
  this.lettersChangedFlag = false;
  this.initDynamicPropertyContainer(elem);
}

TextAnimatorProperty.prototype.searchProperties = function () {
  var i;
  var len = this._textData.a.length;
  var animatorProps;
  var getProp = PropertyFactory.getProp;
  for (i = 0; i < len; i += 1) {
    animatorProps = this._textData.a[i];
    this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
  }
  if (this._textData.p && 'm' in this._textData.p) {
    this._pathData = {
      a: getProp(this._elem, this._textData.p.a, 0, 0, this),
      f: getProp(this._elem, this._textData.p.f, 0, 0, this),
      l: getProp(this._elem, this._textData.p.l, 0, 0, this),
      r: getProp(this._elem, this._textData.p.r, 0, 0, this),
      p: getProp(this._elem, this._textData.p.p, 0, 0, this),
      m: this._elem.maskManager.getMaskProperty(this._textData.p.m),
    };
    this._hasMaskedPath = true;
  } else {
    this._hasMaskedPath = false;
  }
  this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
};

TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
  this.lettersChangedFlag = lettersChangedFlag;
  if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
    return;
  }
  this._isFirstFrame = false;
  var alignment = this._moreOptions.alignment.v;
  var animators = this._animatorsData;
  var textData = this._textData;
  var matrixHelper = this.mHelper;
  var renderType = this._renderType;
  var renderedLettersCount = this.renderedLetters.length;
  var xPos;
  var yPos;
  var i;
  var len;
  var letters = documentData.l;
  var pathInfo;
  var currentLength;
  var currentPoint;
  var segmentLength;
  var flag;
  var pointInd;
  var segmentInd;
  var prevPoint;
  var points;
  var segments;
  var partialLength;
  var totalLength;
  var perc;
  var tanAngle;
  var mask;
  if (this._hasMaskedPath) {
    mask = this._pathData.m;
    if (!this._pathData.n || this._pathData._mdf) {
      var paths = mask.v;
      if (this._pathData.r.v) {
        paths = paths.reverse();
      }
      // TODO: release bezier data cached from previous pathInfo: this._pathData.pi
      pathInfo = {
        tLength: 0,
        segments: [],
      };
      len = paths._length - 1;
      var bezierData;
      totalLength = 0;
      for (i = 0; i < len; i += 1) {
        bezierData = bez.buildBezierData(paths.v[i],
          paths.v[i + 1],
          [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
          [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
        pathInfo.tLength += bezierData.segmentLength;
        pathInfo.segments.push(bezierData);
        totalLength += bezierData.segmentLength;
      }
      i = len;
      if (mask.v.c) {
        bezierData = bez.buildBezierData(paths.v[i],
          paths.v[0],
          [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
          [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
        pathInfo.tLength += bezierData.segmentLength;
        pathInfo.segments.push(bezierData);
        totalLength += bezierData.segmentLength;
      }
      this._pathData.pi = pathInfo;
    }
    pathInfo = this._pathData.pi;

    currentLength = this._pathData.f.v;
    segmentInd = 0;
    pointInd = 1;
    segmentLength = 0;
    flag = true;
    segments = pathInfo.segments;
    if (currentLength < 0 && mask.v.c) {
      if (pathInfo.tLength < Math.abs(currentLength)) {
        currentLength = -Math.abs(currentLength) % pathInfo.tLength;
      }
      segmentInd = segments.length - 1;
      points = segments[segmentInd].points;
      pointInd = points.length - 1;
      while (currentLength < 0) {
        currentLength += points[pointInd].partialLength;
        pointInd -= 1;
        if (pointInd < 0) {
          segmentInd -= 1;
          points = segments[segmentInd].points;
          pointInd = points.length - 1;
        }
      }
    }
    points = segments[segmentInd].points;
    prevPoint = points[pointInd - 1];
    currentPoint = points[pointInd];
    partialLength = currentPoint.partialLength;
  }

  len = letters.length;
  xPos = 0;
  yPos = 0;
  var yOff = documentData.finalSize * 1.2 * 0.714;
  var firstLine = true;
  var animatorProps;
  var animatorSelector;
  var j;
  var jLen;
  var letterValue;

  jLen = animators.length;

  var mult;
  var ind = -1;
  var offf;
  var xPathPos;
  var yPathPos;
  var initPathPos = currentLength;
  var initSegmentInd = segmentInd;
  var initPointInd = pointInd;
  var currentLine = -1;
  var elemOpacity;
  var sc;
  var sw;
  var fc;
  var k;
  var letterSw;
  var letterSc;
  var letterFc;
  var letterM = '';
  var letterP = this.defaultPropsArray;
  var letterO;

  //
  if (documentData.j === 2 || documentData.j === 1) {
    var animatorJustifyOffset = 0;
    var animatorFirstCharOffset = 0;
    var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
    var lastIndex = 0;
    var isNewLine = true;

    for (i = 0; i < len; i += 1) {
      if (letters[i].n) {
        if (animatorJustifyOffset) {
          animatorJustifyOffset += animatorFirstCharOffset;
        }
        while (lastIndex < i) {
          letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
          lastIndex += 1;
        }
        animatorJustifyOffset = 0;
        isNewLine = true;
      } else {
        for (j = 0; j < jLen; j += 1) {
          animatorProps = animators[j].a;
          if (animatorProps.t.propType) {
            if (isNewLine && documentData.j === 2) {
              animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
            }
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
            if (mult.length) {
              animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
            } else {
              animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
            }
          }
        }
        isNewLine = false;
      }
    }
    if (animatorJustifyOffset) {
      animatorJustifyOffset += animatorFirstCharOffset;
    }
    while (lastIndex < i) {
      letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
      lastIndex += 1;
    }
  }
  //

  for (i = 0; i < len; i += 1) {
    matrixHelper.reset();
    elemOpacity = 1;
    if (letters[i].n) {
      xPos = 0;
      yPos += documentData.yOffset;
      yPos += firstLine ? 1 : 0;
      currentLength = initPathPos;
      firstLine = false;
      if (this._hasMaskedPath) {
        segmentInd = initSegmentInd;
        pointInd = initPointInd;
        points = segments[segmentInd].points;
        prevPoint = points[pointInd - 1];
        currentPoint = points[pointInd];
        partialLength = currentPoint.partialLength;
        segmentLength = 0;
      }
      letterM = '';
      letterFc = '';
      letterSw = '';
      letterO = '';
      letterP = this.defaultPropsArray;
    } else {
      if (this._hasMaskedPath) {
        if (currentLine !== letters[i].line) {
          switch (documentData.j) {
            case 1:
              currentLength += totalLength - documentData.lineWidths[letters[i].line];
              break;
            case 2:
              currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
              break;
            default:
              break;
          }
          currentLine = letters[i].line;
        }
        if (ind !== letters[i].ind) {
          if (letters[ind]) {
            currentLength += letters[ind].extra;
          }
          currentLength += letters[i].an / 2;
          ind = letters[i].ind;
        }
        currentLength += (alignment[0] * letters[i].an) * 0.005;
        var animatorOffset = 0;
        for (j = 0; j < jLen; j += 1) {
          animatorProps = animators[j].a;
          if (animatorProps.p.propType) {
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
            if (mult.length) {
              animatorOffset += animatorProps.p.v[0] * mult[0];
            } else {
              animatorOffset += animatorProps.p.v[0] * mult;
            }
          }
          if (animatorProps.a.propType) {
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
            if (mult.length) {
              animatorOffset += animatorProps.a.v[0] * mult[0];
            } else {
              animatorOffset += animatorProps.a.v[0] * mult;
            }
          }
        }
        flag = true;
        // Force alignment only works with a single line for now
        if (this._pathData.a.v) {
          currentLength = letters[0].an * 0.5 + ((totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind) / (len - 1);
          currentLength += this._pathData.f.v;
        }
        while (flag) {
          if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
            perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
            xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
            yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
            matrixHelper.translate((-alignment[0] * letters[i].an) * 0.005, -(alignment[1] * yOff) * 0.01);
            flag = false;
          } else if (points) {
            segmentLength += currentPoint.partialLength;
            pointInd += 1;
            if (pointInd >= points.length) {
              pointInd = 0;
              segmentInd += 1;
              if (!segments[segmentInd]) {
                if (mask.v.c) {
                  pointInd = 0;
                  segmentInd = 0;
                  points = segments[segmentInd].points;
                } else {
                  segmentLength -= currentPoint.partialLength;
                  points = null;
                }
              } else {
                points = segments[segmentInd].points;
              }
            }
            if (points) {
              prevPoint = currentPoint;
              currentPoint = points[pointInd];
              partialLength = currentPoint.partialLength;
            }
          }
        }
        offf = letters[i].an / 2 - letters[i].add;
        matrixHelper.translate(-offf, 0, 0);
      } else {
        offf = letters[i].an / 2 - letters[i].add;
        matrixHelper.translate(-offf, 0, 0);

        // Grouping alignment
        matrixHelper.translate((-alignment[0] * letters[i].an) * 0.005, (-alignment[1] * yOff) * 0.01, 0);
      }

      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;
        if (animatorProps.t.propType) {
          animatorSelector = animators[j].s;
          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
          // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
          if (xPos !== 0 || documentData.j !== 0) {
            if (this._hasMaskedPath) {
              if (mult.length) {
                currentLength += animatorProps.t.v * mult[0];
              } else {
                currentLength += animatorProps.t.v * mult;
              }
            } else if (mult.length) {
              xPos += animatorProps.t.v * mult[0];
            } else {
              xPos += animatorProps.t.v * mult;
            }
          }
        }
      }
      if (documentData.strokeWidthAnim) {
        sw = documentData.sw || 0;
      }
      if (documentData.strokeColorAnim) {
        if (documentData.sc) {
          sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
        } else {
          sc = [0, 0, 0];
        }
      }
      if (documentData.fillColorAnim && documentData.fc) {
        fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
      }
      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;
        if (animatorProps.a.propType) {
          animatorSelector = animators[j].s;
          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

          if (mult.length) {
            matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
          } else {
            matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
          }
        }
      }
      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;
        if (animatorProps.s.propType) {
          animatorSelector = animators[j].s;
          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
          if (mult.length) {
            matrixHelper.scale(1 + ((animatorProps.s.v[0] - 1) * mult[0]), 1 + ((animatorProps.s.v[1] - 1) * mult[1]), 1);
          } else {
            matrixHelper.scale(1 + ((animatorProps.s.v[0] - 1) * mult), 1 + ((animatorProps.s.v[1] - 1) * mult), 1);
          }
        }
      }
      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;
        animatorSelector = animators[j].s;
        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
        if (animatorProps.sk.propType) {
          if (mult.length) {
            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
          } else {
            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
          }
        }
        if (animatorProps.r.propType) {
          if (mult.length) {
            matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
          } else {
            matrixHelper.rotateZ(-animatorProps.r.v * mult);
          }
        }
        if (animatorProps.ry.propType) {
          if (mult.length) {
            matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
          } else {
            matrixHelper.rotateY(animatorProps.ry.v * mult);
          }
        }
        if (animatorProps.rx.propType) {
          if (mult.length) {
            matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
          } else {
            matrixHelper.rotateX(animatorProps.rx.v * mult);
          }
        }
        if (animatorProps.o.propType) {
          if (mult.length) {
            elemOpacity += ((animatorProps.o.v) * mult[0] - elemOpacity) * mult[0];
          } else {
            elemOpacity += ((animatorProps.o.v) * mult - elemOpacity) * mult;
          }
        }
        if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
          if (mult.length) {
            sw += animatorProps.sw.v * mult[0];
          } else {
            sw += animatorProps.sw.v * mult;
          }
        }
        if (documentData.strokeColorAnim && animatorProps.sc.propType) {
          for (k = 0; k < 3; k += 1) {
            if (mult.length) {
              sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
            } else {
              sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
            }
          }
        }
        if (documentData.fillColorAnim && documentData.fc) {
          if (animatorProps.fc.propType) {
            for (k = 0; k < 3; k += 1) {
              if (mult.length) {
                fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
              } else {
                fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
              }
            }
          }
          if (animatorProps.fh.propType) {
            if (mult.length) {
              fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
            } else {
              fc = addHueToRGB(fc, animatorProps.fh.v * mult);
            }
          }
          if (animatorProps.fs.propType) {
            if (mult.length) {
              fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
            } else {
              fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
            }
          }
          if (animatorProps.fb.propType) {
            if (mult.length) {
              fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
            } else {
              fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
            }
          }
        }
      }

      for (j = 0; j < jLen; j += 1) {
        animatorProps = animators[j].a;

        if (animatorProps.p.propType) {
          animatorSelector = animators[j].s;
          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
          if (this._hasMaskedPath) {
            if (mult.length) {
              matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
            } else {
              matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
            }
          } else if (mult.length) {
            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
          } else {
            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
          }
        }
      }
      if (documentData.strokeWidthAnim) {
        letterSw = sw < 0 ? 0 : sw;
      }
      if (documentData.strokeColorAnim) {
        letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
      }
      if (documentData.fillColorAnim && documentData.fc) {
        letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
      }

      if (this._hasMaskedPath) {
        matrixHelper.translate(0, -documentData.ls);

        matrixHelper.translate(0, (alignment[1] * yOff) * 0.01 + yPos, 0);
        if (this._pathData.p.v) {
          tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
          var rot = (Math.atan(tanAngle) * 180) / Math.PI;
          if (currentPoint.point[0] < prevPoint.point[0]) {
            rot += 180;
          }
          matrixHelper.rotate((-rot * Math.PI) / 180);
        }
        matrixHelper.translate(xPathPos, yPathPos, 0);
        currentLength -= (alignment[0] * letters[i].an) * 0.005;
        if (letters[i + 1] && ind !== letters[i + 1].ind) {
          currentLength += letters[i].an / 2;
          currentLength += (documentData.tr * 0.001) * documentData.finalSize;
        }
      } else {
        matrixHelper.translate(xPos, yPos, 0);

        if (documentData.ps) {
          // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
          matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
        }
        switch (documentData.j) {
          case 1:
            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
            break;
          case 2:
            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
            break;
          default:
            break;
        }
        matrixHelper.translate(0, -documentData.ls);
        matrixHelper.translate(offf, 0, 0);
        matrixHelper.translate((alignment[0] * letters[i].an) * 0.005, (alignment[1] * yOff) * 0.01, 0);
        xPos += letters[i].l + (documentData.tr * 0.001) * documentData.finalSize;
      }
      if (renderType === 'html') {
        letterM = matrixHelper.toCSS();
      } else if (renderType === 'svg') {
        letterM = matrixHelper.to2dCSS();
      } else {
        letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
      }
      letterO = elemOpacity;
    }

    if (renderedLettersCount <= i) {
      letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
      this.renderedLetters.push(letterValue);
      renderedLettersCount += 1;
      this.lettersChangedFlag = true;
    } else {
      letterValue = this.renderedLetters[i];
      this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
    }
  }
};

TextAnimatorProperty.prototype.getValue = function () {
  if (this._elem.globalData.frameId === this._frameId) {
    return;
  }
  this._frameId = this._elem.globalData.frameId;
  this.iterateDynamicProperties();
};

TextAnimatorProperty.prototype.mHelper = new Matrix();
TextAnimatorProperty.prototype.defaultPropsArray = [];
extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

/* global PropertyFactory, degToRads, TextSelectorProp */
/* exported TextAnimatorDataProperty */

function TextAnimatorDataProperty(elem, animatorProps, container) {
  var defaultData = { propType: false };
  var getProp = PropertyFactory.getProp;
  var textAnimatorAnimatables = animatorProps.a;
  this.a = {
    r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
    rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
    ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
    sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
    sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
    s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
    a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
    o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
    p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
    sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
    sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
    fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
    fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
    fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
    fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
    t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData,
  };

  this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
  this.s.t = animatorProps.s.t;
}

function LetterProps(o, sw, sc, fc, m, p) {
  this.o = o;
  this.sw = sw;
  this.sc = sc;
  this.fc = fc;
  this.m = m;
  this.p = p;
  this._mdf = {
    o: true,
    sw: !!sw,
    sc: !!sc,
    fc: !!fc,
    m: true,
    p: true,
  };
}

LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
  this._mdf.o = false;
  this._mdf.sw = false;
  this._mdf.sc = false;
  this._mdf.fc = false;
  this._mdf.m = false;
  this._mdf.p = false;
  var updated = false;

  if (this.o !== o) {
    this.o = o;
    this._mdf.o = true;
    updated = true;
  }
  if (this.sw !== sw) {
    this.sw = sw;
    this._mdf.sw = true;
    updated = true;
  }
  if (this.sc !== sc) {
    this.sc = sc;
    this._mdf.sc = true;
    updated = true;
  }
  if (this.fc !== fc) {
    this.fc = fc;
    this._mdf.fc = true;
    updated = true;
  }
  if (this.m !== m) {
    this.m = m;
    this._mdf.m = true;
    updated = true;
  }
  if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
    this.p = p;
    this._mdf.p = true;
    updated = true;
  }
  return updated;
};

/* global FontManager, initialDefaultFrame, getFontProperties */
/* exported TextProperty */

function TextProperty(elem, data) {
  this._frameId = initialDefaultFrame;
  this.pv = '';
  this.v = '';
  this.kf = false;
  this._isFirstFrame = true;
  this._mdf = false;
  this.data = data;
  this.elem = elem;
  this.comp = this.elem.comp;
  this.keysIndex = 0;
  this.canResize = false;
  this.minimumFontSize = 1;
  this.effectsSequence = [];
  this.currentData = {
    ascent: 0,
    boxWidth: this.defaultBoxWidth,
    f: '',
    fStyle: '',
    fWeight: '',
    fc: '',
    j: '',
    justifyOffset: '',
    l: [],
    lh: 0,
    lineWidths: [],
    ls: '',
    of: '',
    s: '',
    sc: '',
    sw: 0,
    t: 0,
    tr: 0,
    sz: 0,
    ps: null,
    fillColorAnim: false,
    strokeColorAnim: false,
    strokeWidthAnim: false,
    yOffset: 0,
    finalSize: 0,
    finalText: [],
    finalLineHeight: 0,
    __complete: false,

  };
  this.copyData(this.currentData, this.data.d.k[0].s);

  if (!this.searchProperty()) {
    this.completeTextData(this.currentData);
  }
}

TextProperty.prototype.defaultBoxWidth = [0, 0];

TextProperty.prototype.copyData = function (obj, data) {
  for (var s in data) {
    if (Object.prototype.hasOwnProperty.call(data, s)) {
      obj[s] = data[s];
    }
  }
  return obj;
};

TextProperty.prototype.setCurrentData = function (data) {
  if (!data.__complete) {
    this.completeTextData(data);
  }
  this.currentData = data;
  this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
  this._mdf = true;
};

TextProperty.prototype.searchProperty = function () {
  return this.searchKeyframes();
};

TextProperty.prototype.searchKeyframes = function () {
  this.kf = this.data.d.k.length > 1;
  if (this.kf) {
    this.addEffect(this.getKeyframeValue.bind(this));
  }
  return this.kf;
};

TextProperty.prototype.addEffect = function (effectFunction) {
  this.effectsSequence.push(effectFunction);
  this.elem.addDynamicProperty(this);
};

TextProperty.prototype.getValue = function (_finalValue) {
  if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
    return;
  }
  this.currentData.t = this.data.d.k[this.keysIndex].s.t;
  var currentValue = this.currentData;
  var currentIndex = this.keysIndex;
  if (this.lock) {
    this.setCurrentData(this.currentData);
    return;
  }
  this.lock = true;
  this._mdf = false;
  var i; var
    len = this.effectsSequence.length;
  var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
  for (i = 0; i < len; i += 1) {
    // Checking if index changed to prevent creating a new object every time the expression updates.
    if (currentIndex !== this.keysIndex) {
      finalValue = this.effectsSequence[i](finalValue, finalValue.t);
    } else {
      finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
    }
  }
  if (currentValue !== finalValue) {
    this.setCurrentData(finalValue);
  }
  this.v = this.currentData;
  this.pv = this.v;
  this.lock = false;
  this.frameId = this.elem.globalData.frameId;
};

TextProperty.prototype.getKeyframeValue = function () {
  var textKeys = this.data.d.k;
  var frameNum = this.elem.comp.renderedFrame;
  var i = 0; var
    len = textKeys.length;
  while (i <= len - 1) {
    if (i === len - 1 || textKeys[i + 1].t > frameNum) {
      break;
    }
    i += 1;
  }
  if (this.keysIndex !== i) {
    this.keysIndex = i;
  }
  return this.data.d.k[this.keysIndex].s;
};

TextProperty.prototype.buildFinalText = function (text) {
  var charactersArray = [];
  var i = 0;
  var len = text.length;
  var charCode;
  var secondCharCode;
  var shouldCombine = false;
  while (i < len) {
    charCode = text.charCodeAt(i);
    if (FontManager.isCombinedCharacter(charCode)) {
      charactersArray[charactersArray.length - 1] += text.charAt(i);
    } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      secondCharCode = text.charCodeAt(i + 1);
      if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {
        if (shouldCombine || FontManager.isModifier(charCode, secondCharCode)) {
          charactersArray[charactersArray.length - 1] += text.substr(i, 2);
          shouldCombine = false;
        } else {
          charactersArray.push(text.substr(i, 2));
        }
        i += 1;
      } else {
        charactersArray.push(text.charAt(i));
      }
    } else if (charCode > 0xDBFF) {
      secondCharCode = text.charCodeAt(i + 1);
      if (FontManager.isZeroWidthJoiner(charCode, secondCharCode)) {
        shouldCombine = true;
        charactersArray[charactersArray.length - 1] += text.substr(i, 2);
        i += 1;
      } else {
        charactersArray.push(text.charAt(i));
      }
    } else if (FontManager.isZeroWidthJoiner(charCode)) {
      charactersArray[charactersArray.length - 1] += text.charAt(i);
      shouldCombine = true;
    } else {
      charactersArray.push(text.charAt(i));
    }
    i += 1;
  }
  return charactersArray;
};

TextProperty.prototype.completeTextData = function (documentData) {
  documentData.__complete = true;
  var fontManager = this.elem.globalData.fontManager;
  var data = this.data;
  var letters = [];
  var i; var
    len;
  var newLineFlag; var index = 0; var
    val;
  var anchorGrouping = data.m.g;
  var currentSize = 0; var currentPos = 0; var currentLine = 0; var
    lineWidths = [];
  var lineWidth = 0;
  var maxLineWidth = 0;
  var j; var
    jLen;
  var fontData = fontManager.getFontByName(documentData.f);
  var charData; var
    cLength = 0;

  var fontProps = getFontProperties(fontData);
  documentData.fWeight = fontProps.weight;
  documentData.fStyle = fontProps.style;
  documentData.finalSize = documentData.s;
  documentData.finalText = this.buildFinalText(documentData.t);
  len = documentData.finalText.length;
  documentData.finalLineHeight = documentData.lh;
  var trackingOffset = (documentData.tr / 1000) * documentData.finalSize;
  var charCode;
  if (documentData.sz) {
    var flag = true;
    var boxWidth = documentData.sz[0];
    var boxHeight = documentData.sz[1];
    var currentHeight; var
      finalText;
    while (flag) {
      finalText = this.buildFinalText(documentData.t);
      currentHeight = 0;
      lineWidth = 0;
      len = finalText.length;
      trackingOffset = (documentData.tr / 1000) * documentData.finalSize;
      var lastSpaceIndex = -1;
      for (i = 0; i < len; i += 1) {
        charCode = finalText[i].charCodeAt(0);
        newLineFlag = false;
        if (finalText[i] === ' ') {
          lastSpaceIndex = i;
        } else if (charCode === 13 || charCode === 3) {
          lineWidth = 0;
          newLineFlag = true;
          currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
        }
        if (fontManager.chars) {
          charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
          cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100;
        } else {
          // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
          cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
        }
        if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
          if (lastSpaceIndex === -1) {
            len += 1;
          } else {
            i = lastSpaceIndex;
          }
          currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
          finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\r');
          // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
          lastSpaceIndex = -1;
          lineWidth = 0;
        } else {
          lineWidth += cLength;
          lineWidth += trackingOffset;
        }
      }
      currentHeight += (fontData.ascent * documentData.finalSize) / 100;
      if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
        documentData.finalSize -= 1;
        documentData.finalLineHeight = (documentData.finalSize * documentData.lh) / documentData.s;
      } else {
        documentData.finalText = finalText;
        len = documentData.finalText.length;
        flag = false;
      }
    }
  }
  lineWidth = -trackingOffset;
  cLength = 0;
  var uncollapsedSpaces = 0;
  var currentChar;
  for (i = 0; i < len; i += 1) {
    newLineFlag = false;
    currentChar = documentData.finalText[i];
    charCode = currentChar.charCodeAt(0);
    if (charCode === 13 || charCode === 3) {
      uncollapsedSpaces = 0;
      lineWidths.push(lineWidth);
      maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
      lineWidth = -2 * trackingOffset;
      val = '';
      newLineFlag = true;
      currentLine += 1;
    } else {
      val = currentChar;
    }
    if (fontManager.chars) {
      charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
      cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100;
    } else {
      // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
      // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
      cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
    }

    //
    if (currentChar === ' ') {
      uncollapsedSpaces += cLength + trackingOffset;
    } else {
      lineWidth += cLength + trackingOffset + uncollapsedSpaces;
      uncollapsedSpaces = 0;
    }
    letters.push({
      l: cLength, an: cLength, add: currentSize, n: newLineFlag, anIndexes: [], val: val, line: currentLine, animatorJustifyOffset: 0,
    });
    if (anchorGrouping == 2) { // eslint-disable-line eqeqeq
      currentSize += cLength;
      if (val === '' || val === ' ' || i === len - 1) {
        if (val === '' || val === ' ') {
          currentSize -= cLength;
        }
        while (currentPos <= i) {
          letters[currentPos].an = currentSize;
          letters[currentPos].ind = index;
          letters[currentPos].extra = cLength;
          currentPos += 1;
        }
        index += 1;
        currentSize = 0;
      }
    } else if (anchorGrouping == 3) { // eslint-disable-line eqeqeq
      currentSize += cLength;
      if (val === '' || i === len - 1) {
        if (val === '') {
          currentSize -= cLength;
        }
        while (currentPos <= i) {
          letters[currentPos].an = currentSize;
          letters[currentPos].ind = index;
          letters[currentPos].extra = cLength;
          currentPos += 1;
        }
        currentSize = 0;
        index += 1;
      }
    } else {
      letters[index].ind = index;
      letters[index].extra = 0;
      index += 1;
    }
  }
  documentData.l = letters;
  maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
  lineWidths.push(lineWidth);
  if (documentData.sz) {
    documentData.boxWidth = documentData.sz[0];
    documentData.justifyOffset = 0;
  } else {
    documentData.boxWidth = maxLineWidth;
    switch (documentData.j) {
      case 1:
        documentData.justifyOffset = -documentData.boxWidth;
        break;
      case 2:
        documentData.justifyOffset = -documentData.boxWidth / 2;
        break;
      default:
        documentData.justifyOffset = 0;
    }
  }
  documentData.lineWidths = lineWidths;

  var animators = data.a; var animatorData; var
    letterData;
  jLen = animators.length;
  var based; var ind; var
    indexes = [];
  for (j = 0; j < jLen; j += 1) {
    animatorData = animators[j];
    if (animatorData.a.sc) {
      documentData.strokeColorAnim = true;
    }
    if (animatorData.a.sw) {
      documentData.strokeWidthAnim = true;
    }
    if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
      documentData.fillColorAnim = true;
    }
    ind = 0;
    based = animatorData.s.b;
    for (i = 0; i < len; i += 1) {
      letterData = letters[i];
      letterData.anIndexes[j] = ind;
      if ((based == 1 && letterData.val !== '') || (based == 2 && letterData.val !== '' && letterData.val !== ' ') || (based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1)) || (based == 4 && (letterData.n || i == len - 1))) { // eslint-disable-line eqeqeq
        if (animatorData.s.rn === 1) {
          indexes.push(ind);
        }
        ind += 1;
      }
    }
    data.a[j].s.totalChars = ind;
    var currentInd = -1; var
      newInd;
    if (animatorData.s.rn === 1) {
      for (i = 0; i < len; i += 1) {
        letterData = letters[i];
        if (currentInd != letterData.anIndexes[j]) { // eslint-disable-line eqeqeq
          currentInd = letterData.anIndexes[j];
          newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
        }
        letterData.anIndexes[j] = newInd;
      }
    }
  }
  documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
  documentData.ls = documentData.ls || 0;
  documentData.ascent = (fontData.ascent * documentData.finalSize) / 100;
};

TextProperty.prototype.updateDocumentData = function (newData, index) {
  index = index === undefined ? this.keysIndex : index;
  var dData = this.copyData({}, this.data.d.k[index].s);
  dData = this.copyData(dData, newData);
  this.data.d.k[index].s = dData;
  this.recalculate(index);
  this.elem.addDynamicProperty(this);
};

TextProperty.prototype.recalculate = function (index) {
  var dData = this.data.d.k[index].s;
  dData.__complete = false;
  this.keysIndex = 0;
  this._isFirstFrame = true;
  this.getValue(dData);
};

TextProperty.prototype.canResizeFont = function (_canResize) {
  this.canResize = _canResize;
  this.recalculate(this.keysIndex);
  this.elem.addDynamicProperty(this);
};

TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
  this.minimumFontSize = Math.floor(_fontValue) || 1;
  this.recalculate(this.keysIndex);
  this.elem.addDynamicProperty(this);
};

/* global extendPrototype, BezierFactory, PropertyFactory, DynamicPropertyContainer */
/* exported TextSelectorProp */

var TextSelectorProp = (function () {
  var max = Math.max;
  var min = Math.min;
  var floor = Math.floor;

  function TextSelectorPropFactory(elem, data) {
    this._currentTextLength = -1;
    this.k = false;
    this.data = data;
    this.elem = elem;
    this.comp = elem.comp;
    this.finalS = 0;
    this.finalE = 0;
    this.initDynamicPropertyContainer(elem);
    this.s = PropertyFactory.getProp(elem, data.s || { k: 0 }, 0, 0, this);
    if ('e' in data) {
      this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
    } else {
      this.e = { v: 100 };
    }
    this.o = PropertyFactory.getProp(elem, data.o || { k: 0 }, 0, 0, this);
    this.xe = PropertyFactory.getProp(elem, data.xe || { k: 0 }, 0, 0, this);
    this.ne = PropertyFactory.getProp(elem, data.ne || { k: 0 }, 0, 0, this);
    this.sm = PropertyFactory.getProp(elem, data.sm || { k: 100 }, 0, 0, this);
    this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
    if (!this.dynamicProperties.length) {
      this.getValue();
    }
  }

  TextSelectorPropFactory.prototype = {
    getMult: function (ind) {
      if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
        this.getValue();
      }
      // var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);
      var x1 = 0;
      var y1 = 0;
      var x2 = 1;
      var y2 = 1;
      if (this.ne.v > 0) {
        x1 = this.ne.v / 100.0;
      } else {
        y1 = -this.ne.v / 100.0;
      }
      if (this.xe.v > 0) {
        x2 = 1.0 - this.xe.v / 100.0;
      } else {
        y2 = 1.0 + this.xe.v / 100.0;
      }
      var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;

      var mult = 0;
      var s = this.finalS;
      var e = this.finalE;
      var type = this.data.sh;
      if (type === 2) {
        if (e === s) {
          mult = ind >= e ? 1 : 0;
        } else {
          mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
        }
        mult = easer(mult);
      } else if (type === 3) {
        if (e === s) {
          mult = ind >= e ? 0 : 1;
        } else {
          mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
        }

        mult = easer(mult);
      } else if (type === 4) {
        if (e === s) {
          mult = 0;
        } else {
          mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
          if (mult < 0.5) {
            mult *= 2;
          } else {
            mult = 1 - 2 * (mult - 0.5);
          }
        }
        mult = easer(mult);
      } else if (type === 5) {
        if (e === s) {
          mult = 0;
        } else {
          var tot = e - s;
          /* ind += 0.5;
                    mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */
          ind = min(max(0, ind + 0.5 - s), e - s);
          var x = -tot / 2 + ind;
          var a = tot / 2;
          mult = Math.sqrt(1 - (x * x) / (a * a));
        }
        mult = easer(mult);
      } else if (type === 6) {
        if (e === s) {
          mult = 0;
        } else {
          ind = min(max(0, ind + 0.5 - s), e - s);
          mult = (1 + (Math.cos((Math.PI + Math.PI * 2 * (ind) / (e - s))))) / 2; // eslint-disable-line
        }
        mult = easer(mult);
      } else {
        if (ind >= floor(s)) {
          if (ind - s < 0) {
            mult = max(0, min(min(e, 1) - (s - ind), 1));
          } else {
            mult = max(0, min(e - ind, 1));
          }
        }
        mult = easer(mult);
      }
      // Smoothness implementation.
      // The smoothness represents a reduced range of the original [0; 1] range.
      // if smoothness is 25%, the new range will be [0.375; 0.625]
      // Steps are:
      // - find the lower value of the new range (threshold)
      // - if multiplier is smaller than that value, floor it to 0
      // - if it is larger,
      //     - subtract the threshold
      //     - divide it by the smoothness (this will return the range to [0; 1])
      // Note: If it doesn't work on some scenarios, consider applying it before the easer.
      if (this.sm.v !== 100) {
        var smoothness = this.sm.v * 0.01;
        if (smoothness === 0) {
          smoothness = 0.00000001;
        }
        var threshold = 0.5 - smoothness * 0.5;
        if (mult < threshold) {
          mult = 0;
        } else {
          mult = (mult - threshold) / smoothness;
          if (mult > 1) {
            mult = 1;
          }
        }
      }
      return mult * this.a.v;
    },
    getValue: function (newCharsFlag) {
      this.iterateDynamicProperties();
      this._mdf = newCharsFlag || this._mdf;
      this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
      if (newCharsFlag && this.data.r === 2) {
        this.e.v = this._currentTextLength;
      }
      var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
      var o = this.o.v / divisor;
      var s = this.s.v / divisor + o;
      var e = (this.e.v / divisor) + o;
      if (s > e) {
        var _s = s;
        s = e;
        e = _s;
      }
      this.finalS = s;
      this.finalE = e;
    },
  };
  extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);

  function getTextSelectorProp(elem, data, arr) {
    return new TextSelectorPropFactory(elem, data, arr);
  }

  return {
    getTextSelectorProp: getTextSelectorProp,
  };
}());

/* global createSizedArray, pooling */
/* exported poolFactory */

var poolFactory = (function () {
  return function (initialLength, _create, _release) {
    var _length = 0;
    var _maxLength = initialLength;
    var pool = createSizedArray(_maxLength);

    var ob = {
      newElement: newElement,
      release: release,
    };

    function newElement() {
      var element;
      if (_length) {
        _length -= 1;
        element = pool[_length];
      } else {
        element = _create();
      }
      return element;
    }

    function release(element) {
      if (_length === _maxLength) {
        pool = pooling.double(pool);
        _maxLength *= 2;
      }
      if (_release) {
        _release(element);
      }
      pool[_length] = element;
      _length += 1;
    }

    return ob;
  };
}());

/* global createSizedArray */
/* exported pooling */

var pooling = (function () {
  function double(arr) {
    return arr.concat(createSizedArray(arr.length));
  }

  return {
    double: double,
  };
}());

/* global createTypedArray, poolFactory */
/* exported pointPool */

var pointPool = (function () {
  function create() {
    return createTypedArray('float32', 2);
  }
  return poolFactory(8, create);
}());

/* global ShapePath, pointPool, poolFactory */
/* exported shapePool */

var shapePool = (function () {
  function create() {
    return new ShapePath();
  }

  function release(shapePath) {
    var len = shapePath._length;
    var i;
    for (i = 0; i < len; i += 1) {
      pointPool.release(shapePath.v[i]);
      pointPool.release(shapePath.i[i]);
      pointPool.release(shapePath.o[i]);
      shapePath.v[i] = null;
      shapePath.i[i] = null;
      shapePath.o[i] = null;
    }
    shapePath._length = 0;
    shapePath.c = false;
  }

  function clone(shape) {
    var cloned = factory.newElement();
    var i;
    var len = shape._length === undefined ? shape.v.length : shape._length;
    cloned.setLength(len);
    cloned.c = shape.c;

    for (i = 0; i < len; i += 1) {
      cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
    }
    return cloned;
  }

  var factory = poolFactory(4, create, release);
  factory.clone = clone;

  return factory;
}());

/* global createSizedArray, ShapeCollection, shapePool, pooling */
/* exported shapeCollectionPool */

var shapeCollectionPool = (function () {
  var ob = {
    newShapeCollection: newShapeCollection,
    release: release,
  };

  var _length = 0;
  var _maxLength = 4;
  var pool = createSizedArray(_maxLength);

  function newShapeCollection() {
    var shapeCollection;
    if (_length) {
      _length -= 1;
      shapeCollection = pool[_length];
    } else {
      shapeCollection = new ShapeCollection();
    }
    return shapeCollection;
  }

  function release(shapeCollection) {
    var i;
    var len = shapeCollection._length;
    for (i = 0; i < len; i += 1) {
      shapePool.release(shapeCollection.shapes[i]);
    }
    shapeCollection._length = 0;

    if (_length === _maxLength) {
      pool = pooling.double(pool);
      _maxLength *= 2;
    }
    pool[_length] = shapeCollection;
    _length += 1;
  }

  return ob;
}());

/* global poolFactory, bezierLengthPool */
/* exported segmentsLengthPool */

var segmentsLengthPool = (function () {
  function create() {
    return {
      lengths: [],
      totalLength: 0,
    };
  }

  function release(element) {
    var i;
    var len = element.lengths.length;
    for (i = 0; i < len; i += 1) {
      bezierLengthPool.release(element.lengths[i]);
    }
    element.lengths.length = 0;
  }

  return poolFactory(8, create, release);
}());

/* global createTypedArray, defaultCurveSegments, poolFactory */
/* exported bezierLengthPool */

var bezierLengthPool = (function () {
  function create() {
    return {
      addedLength: 0,
      percents: createTypedArray('float32', defaultCurveSegments),
      lengths: createTypedArray('float32', defaultCurveSegments),
    };
  }
  return poolFactory(8, create);
}());

/* exported markerParser */

var markerParser = (

  function () {
    function parsePayloadLines(payload) {
      var lines = payload.split('\r\n');
      var keys = {};
      var line;
      var keysCount = 0;
      for (var i = 0; i < lines.length; i += 1) {
        line = lines[i].split(':');
        if (line.length === 2) {
          keys[line[0]] = line[1].trim();
          keysCount += 1;
        }
      }
      if (keysCount === 0) {
        throw new Error();
      }
      return keys;
    }

    return function (_markers) {
      var markers = [];
      for (var i = 0; i < _markers.length; i += 1) {
        var _marker = _markers[i];
        var markerData = {
          time: _marker.tm,
          duration: _marker.dr,
        };
        try {
          markerData.payload = JSON.parse(_markers[i].cm);
        } catch (_) {
          try {
            markerData.payload = parsePayloadLines(_markers[i].cm);
          } catch (__) {
            markerData.payload = {
              name: _markers[i],
            };
          }
        }
        markers.push(markerData);
      }
      return markers;
    };
  }());

/* global AudioElement, FootageElement, FontManager */

function BaseRenderer() {}
BaseRenderer.prototype.checkLayers = function (num) {
  var i;
  var len = this.layers.length;
  var data;
  this.completeLayers = true;
  for (i = len - 1; i >= 0; i -= 1) {
    if (!this.elements[i]) {
      data = this.layers[i];
      if (data.ip - data.st <= (num - this.layers[i].st) && data.op - data.st > (num - this.layers[i].st)) {
        this.buildItem(i);
      }
    }
    this.completeLayers = this.elements[i] ? this.completeLayers : false;
  }
  this.checkPendingElements();
};

BaseRenderer.prototype.createItem = function (layer) {
  switch (layer.ty) {
    case 2:
      return this.createImage(layer);
    case 0:
      return this.createComp(layer);
    case 1:
      return this.createSolid(layer);
    case 3:
      return this.createNull(layer);
    case 4:
      return this.createShape(layer);
    case 5:
      return this.createText(layer);
    case 6:
      return this.createAudio(layer);
    case 13:
      return this.createCamera(layer);
    case 15:
      return this.createFootage(layer);
    default:
      return this.createNull(layer);
  }
};

BaseRenderer.prototype.createCamera = function () {
  throw new Error('You\'re using a 3d camera. Try the html renderer.');
};

BaseRenderer.prototype.createAudio = function (data) {
  return new AudioElement(data, this.globalData, this);
};

BaseRenderer.prototype.createFootage = function (data) {
  return new FootageElement(data, this.globalData, this);
};

BaseRenderer.prototype.buildAllItems = function () {
  var i;
  var len = this.layers.length;
  for (i = 0; i < len; i += 1) {
    this.buildItem(i);
  }
  this.checkPendingElements();
};

BaseRenderer.prototype.includeLayers = function (newLayers) {
  this.completeLayers = false;
  var i;
  var len = newLayers.length;
  var j;
  var jLen = this.layers.length;
  for (i = 0; i < len; i += 1) {
    j = 0;
    while (j < jLen) {
      if (this.layers[j].id === newLayers[i].id) {
        this.layers[j] = newLayers[i];
        break;
      }
      j += 1;
    }
  }
};

BaseRenderer.prototype.setProjectInterface = function (pInterface) {
  this.globalData.projectInterface = pInterface;
};

BaseRenderer.prototype.initItems = function () {
  if (!this.globalData.progressiveLoad) {
    this.buildAllItems();
  }
};
BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
  var elements = this.elements;
  var layers = this.layers;
  var i = 0;
  var len = layers.length;
  while (i < len) {
    if (layers[i].ind == parentName) { // eslint-disable-line eqeqeq
      if (!elements[i] || elements[i] === true) {
        this.buildItem(i);
        this.addPendingElement(element);
      } else {
        hierarchy.push(elements[i]);
        elements[i].setAsParent();
        if (layers[i].parent !== undefined) {
          this.buildElementParenting(element, layers[i].parent, hierarchy);
        } else {
          element.setHierarchy(hierarchy);
        }
      }
    }
    i += 1;
  }
};

BaseRenderer.prototype.addPendingElement = function (element) {
  this.pendingElements.push(element);
};

BaseRenderer.prototype.searchExtraCompositions = function (assets) {
  var i;
  var len = assets.length;
  for (i = 0; i < len; i += 1) {
    if (assets[i].xt) {
      var comp = this.createComp(assets[i]);
      comp.initExpressions();
      this.globalData.projectInterface.registerComposition(comp);
    }
  }
};

BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
  this.globalData.fontManager = new FontManager();
  this.globalData.fontManager.addChars(animData.chars);
  this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
  this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
  this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
  this.globalData.imageLoader = this.animationItem.imagePreloader;
  this.globalData.audioController = this.animationItem.audioController;
  this.globalData.frameId = 0;
  this.globalData.frameRate = animData.fr;
  this.globalData.nm = animData.nm;
  this.globalData.compSize = {
    w: animData.w,
    h: animData.h,
  };
};

/* global createElementID, extendPrototype, BaseRenderer, NullElement, SVGShapeElement, SVGTextLottieElement,
IImageElement, SVGCompElement, ISolidElement, createNS, locationHref, createSizedArray, expressionsPlugin */

function SVGRenderer(animationItem, config) {
  this.animationItem = animationItem;
  this.layers = null;
  this.renderedFrame = -1;
  this.svgElement = createNS('svg');
  var ariaLabel = '';
  if (config && config.title) {
    var titleElement = createNS('title');
    var titleId = createElementID();
    titleElement.setAttribute('id', titleId);
    titleElement.textContent = config.title;
    this.svgElement.appendChild(titleElement);
    ariaLabel += titleId;
  }
  if (config && config.description) {
    var descElement = createNS('desc');
    var descId = createElementID();
    descElement.setAttribute('id', descId);
    descElement.textContent = config.description;
    this.svgElement.appendChild(descElement);
    ariaLabel += ' ' + descId;
  }
  if (ariaLabel) {
    this.svgElement.setAttribute('aria-labelledby', ariaLabel);
  }
  var defs = createNS('defs');
  this.svgElement.appendChild(defs);
  var maskElement = createNS('g');
  this.svgElement.appendChild(maskElement);
  this.layerElement = maskElement;
  this.renderConfig = {
    preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
    progressiveLoad: (config && config.progressiveLoad) || false,
    hideOnTransparent: !((config && config.hideOnTransparent === false)),
    viewBoxOnly: (config && config.viewBoxOnly) || false,
    viewBoxSize: (config && config.viewBoxSize) || false,
    className: (config && config.className) || '',
    id: (config && config.id) || '',
    focusable: config && config.focusable,
    filterSize: {
      width: (config && config.filterSize && config.filterSize.width) || '100%',
      height: (config && config.filterSize && config.filterSize.height) || '100%',
      x: (config && config.filterSize && config.filterSize.x) || '0%',
      y: (config && config.filterSize && config.filterSize.y) || '0%',
    },
  };

  this.globalData = {
    _mdf: false,
    frameNum: -1,
    defs: defs,
    renderConfig: this.renderConfig,
  };
  this.elements = [];
  this.pendingElements = [];
  this.destroyed = false;
  this.rendererType = 'svg';
}

extendPrototype([BaseRenderer], SVGRenderer);

SVGRenderer.prototype.createNull = function (data) {
  return new NullElement(data, this.globalData, this);
};

SVGRenderer.prototype.createShape = function (data) {
  return new SVGShapeElement(data, this.globalData, this);
};

SVGRenderer.prototype.createText = function (data) {
  return new SVGTextLottieElement(data, this.globalData, this);
};

SVGRenderer.prototype.createImage = function (data) {
  return new IImageElement(data, this.globalData, this);
};

SVGRenderer.prototype.createComp = function (data) {
  return new SVGCompElement(data, this.globalData, this);
};

SVGRenderer.prototype.createSolid = function (data) {
  return new ISolidElement(data, this.globalData, this);
};

SVGRenderer.prototype.configAnimation = function (animData) {
  this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  if (this.renderConfig.viewBoxSize) {
    this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
  } else {
    this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
  }

  if (!this.renderConfig.viewBoxOnly) {
    this.svgElement.setAttribute('width', animData.w);
    this.svgElement.setAttribute('height', animData.h);
    this.svgElement.style.width = '100%';
    this.svgElement.style.height = '100%';
    this.svgElement.style.transform = 'translate3d(0,0,0)';
  }
  if (this.renderConfig.className) {
    this.svgElement.setAttribute('class', this.renderConfig.className);
  }
  if (this.renderConfig.id) {
    this.svgElement.setAttribute('id', this.renderConfig.id);
  }
  if (this.renderConfig.focusable !== undefined) {
    this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
  }
  this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio);
  // this.layerElement.style.transform = 'translate3d(0,0,0)';
  // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
  this.animationItem.wrapper.appendChild(this.svgElement);
  // Mask animation
  var defs = this.globalData.defs;

  this.setupGlobalData(animData, defs);
  this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
  this.data = animData;

  var maskElement = createNS('clipPath');
  var rect = createNS('rect');
  rect.setAttribute('width', animData.w);
  rect.setAttribute('height', animData.h);
  rect.setAttribute('x', 0);
  rect.setAttribute('y', 0);
  var maskId = createElementID();
  maskElement.setAttribute('id', maskId);
  maskElement.appendChild(rect);
  this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + maskId + ')');

  defs.appendChild(maskElement);
  this.layers = animData.layers;
  this.elements = createSizedArray(animData.layers.length);
};

SVGRenderer.prototype.destroy = function () {
  if (this.animationItem.wrapper) {
    this.animationItem.wrapper.innerText = '';
  }
  this.layerElement = null;
  this.globalData.defs = null;
  var i;
  var len = this.layers ? this.layers.length : 0;
  for (i = 0; i < len; i += 1) {
    if (this.elements[i]) {
      this.elements[i].destroy();
    }
  }
  this.elements.length = 0;
  this.destroyed = true;
  this.animationItem = null;
};

SVGRenderer.prototype.updateContainerSize = function () {
};

SVGRenderer.prototype.buildItem = function (pos) {
  var elements = this.elements;
  if (elements[pos] || this.layers[pos].ty === 99) {
    return;
  }
  elements[pos] = true;
  var element = this.createItem(this.layers[pos]);

  elements[pos] = element;
  if (expressionsPlugin) {
    if (this.layers[pos].ty === 0) {
      this.globalData.projectInterface.registerComposition(element);
    }
    element.initExpressions();
  }
  this.appendElementInPos(element, pos);
  if (this.layers[pos].tt) {
    if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
      this.buildItem(pos - 1);
      this.addPendingElement(element);
    } else {
      element.setMatte(elements[pos - 1].layerId);
    }
  }
};

SVGRenderer.prototype.checkPendingElements = function () {
  while (this.pendingElements.length) {
    var element = this.pendingElements.pop();
    element.checkParenting();
    if (element.data.tt) {
      var i = 0;
      var len = this.elements.length;
      while (i < len) {
        if (this.elements[i] === element) {
          element.setMatte(this.elements[i - 1].layerId);
          break;
        }
        i += 1;
      }
    }
  }
};

SVGRenderer.prototype.renderFrame = function (num) {
  if (this.renderedFrame === num || this.destroyed) {
    return;
  }
  if (num === null) {
    num = this.renderedFrame;
  } else {
    this.renderedFrame = num;
  }
  // console.log('-------');
  // console.log('FRAME ',num);
  this.globalData.frameNum = num;
  this.globalData.frameId += 1;
  this.globalData.projectInterface.currentFrame = num;
  this.globalData._mdf = false;
  var i;
  var len = this.layers.length;
  if (!this.completeLayers) {
    this.checkLayers(num);
  }
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].prepareFrame(num - this.layers[i].st);
    }
  }
  if (this.globalData._mdf) {
    for (i = 0; i < len; i += 1) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].renderFrame();
      }
    }
  }
};

SVGRenderer.prototype.appendElementInPos = function (element, pos) {
  var newElement = element.getBaseElement();
  if (!newElement) {
    return;
  }
  var i = 0;
  var nextElement;
  while (i < pos) {
    if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
      nextElement = this.elements[i].getBaseElement();
    }
    i += 1;
  }
  if (nextElement) {
    this.layerElement.insertBefore(newElement, nextElement);
  } else {
    this.layerElement.appendChild(newElement);
  }
};

SVGRenderer.prototype.hide = function () {
  this.layerElement.style.display = 'none';
};

SVGRenderer.prototype.show = function () {
  this.layerElement.style.display = 'block';
};

/* global CVContextData, Matrix, extendPrototype, BaseRenderer, CVShapeElement, CVTextElement,
CVImageElement, CVCompElement, CVSolidElement, SVGRenderer, createTag, createSizedArray */

function CanvasRenderer(animationItem, config) {
  this.animationItem = animationItem;
  this.renderConfig = {
    clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,
    context: (config && config.context) || null,
    progressiveLoad: (config && config.progressiveLoad) || false,
    preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
    className: (config && config.className) || '',
    id: (config && config.id) || '',
  };
  this.renderConfig.dpr = (config && config.dpr) || 1;
  if (this.animationItem.wrapper) {
    this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1;
  }
  this.renderedFrame = -1;
  this.globalData = {
    frameNum: -1,
    _mdf: false,
    renderConfig: this.renderConfig,
    currentGlobalAlpha: -1,
  };
  this.contextData = new CVContextData();
  this.elements = [];
  this.pendingElements = [];
  this.transformMat = new Matrix();
  this.completeLayers = false;
  this.rendererType = 'canvas';
}
extendPrototype([BaseRenderer], CanvasRenderer);

CanvasRenderer.prototype.createShape = function (data) {
  return new CVShapeElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createText = function (data) {
  return new CVTextElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createImage = function (data) {
  return new CVImageElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createComp = function (data) {
  return new CVCompElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createSolid = function (data) {
  return new CVSolidElement(data, this.globalData, this);
};

CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

CanvasRenderer.prototype.ctxTransform = function (props) {
  if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
    return;
  }
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
    return;
  }
  this.transformMat.cloneFromProps(props);
  var cProps = this.contextData.cTr.props;
  this.transformMat.transform(cProps[0], cProps[1], cProps[2], cProps[3], cProps[4], cProps[5], cProps[6], cProps[7], cProps[8], cProps[9], cProps[10], cProps[11], cProps[12], cProps[13], cProps[14], cProps[15]);
  // this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
  this.contextData.cTr.cloneFromProps(this.transformMat.props);
  var trProps = this.contextData.cTr.props;
  this.canvasContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
};

CanvasRenderer.prototype.ctxOpacity = function (op) {
  /* if(op === 1){
        return;
    } */
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
    this.globalData.currentGlobalAlpha = this.contextData.cO;
    return;
  }
  this.contextData.cO *= op < 0 ? 0 : op;
  if (this.globalData.currentGlobalAlpha !== this.contextData.cO) {
    this.canvasContext.globalAlpha = this.contextData.cO;
    this.globalData.currentGlobalAlpha = this.contextData.cO;
  }
};

CanvasRenderer.prototype.reset = function () {
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.restore();
    return;
  }
  this.contextData.reset();
};

CanvasRenderer.prototype.save = function (actionFlag) {
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.save();
    return;
  }
  if (actionFlag) {
    this.canvasContext.save();
  }
  var props = this.contextData.cTr.props;
  if (this.contextData._length <= this.contextData.cArrPos) {
    this.contextData.duplicate();
  }
  var i;
  var arr = this.contextData.saved[this.contextData.cArrPos];
  for (i = 0; i < 16; i += 1) {
    arr[i] = props[i];
  }
  this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
  this.contextData.cArrPos += 1;
};

CanvasRenderer.prototype.restore = function (actionFlag) {
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.restore();
    return;
  }
  if (actionFlag) {
    this.canvasContext.restore();
    this.globalData.blendMode = 'source-over';
  }
  this.contextData.cArrPos -= 1;
  var popped = this.contextData.saved[this.contextData.cArrPos];
  var i;
  var arr = this.contextData.cTr.props;
  for (i = 0; i < 16; i += 1) {
    arr[i] = popped[i];
  }
  this.canvasContext.setTransform(popped[0], popped[1], popped[4], popped[5], popped[12], popped[13]);
  popped = this.contextData.savedOp[this.contextData.cArrPos];
  this.contextData.cO = popped;
  if (this.globalData.currentGlobalAlpha !== popped) {
    this.canvasContext.globalAlpha = popped;
    this.globalData.currentGlobalAlpha = popped;
  }
};

CanvasRenderer.prototype.configAnimation = function (animData) {
  if (this.animationItem.wrapper) {
    this.animationItem.container = createTag('canvas');
    var containerStyle = this.animationItem.container.style;
    containerStyle.width = '100%';
    containerStyle.height = '100%';
    var origin = '0px 0px 0px';
    containerStyle.transformOrigin = origin;
    containerStyle.mozTransformOrigin = origin;
    containerStyle.webkitTransformOrigin = origin;
    containerStyle['-webkit-transform'] = origin;
    this.animationItem.wrapper.appendChild(this.animationItem.container);
    this.canvasContext = this.animationItem.container.getContext('2d');
    if (this.renderConfig.className) {
      this.animationItem.container.setAttribute('class', this.renderConfig.className);
    }
    if (this.renderConfig.id) {
      this.animationItem.container.setAttribute('id', this.renderConfig.id);
    }
  } else {
    this.canvasContext = this.renderConfig.context;
  }
  this.data = animData;
  this.layers = animData.layers;
  this.transformCanvas = {
    w: animData.w,
    h: animData.h,
    sx: 0,
    sy: 0,
    tx: 0,
    ty: 0,
  };
  this.setupGlobalData(animData, document.body);
  this.globalData.canvasContext = this.canvasContext;
  this.globalData.renderer = this;
  this.globalData.isDashed = false;
  this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
  this.globalData.transformCanvas = this.transformCanvas;
  this.elements = createSizedArray(animData.layers.length);

  this.updateContainerSize();
};

CanvasRenderer.prototype.updateContainerSize = function () {
  this.reset();
  var elementWidth;
  var elementHeight;
  if (this.animationItem.wrapper && this.animationItem.container) {
    elementWidth = this.animationItem.wrapper.offsetWidth;
    elementHeight = this.animationItem.wrapper.offsetHeight;
    this.animationItem.container.setAttribute('width', elementWidth * this.renderConfig.dpr);
    this.animationItem.container.setAttribute('height', elementHeight * this.renderConfig.dpr);
  } else {
    elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
    elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
  }
  var elementRel;
  var animationRel;
  if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
    var par = this.renderConfig.preserveAspectRatio.split(' ');
    var fillType = par[1] || 'meet';
    var pos = par[0] || 'xMidYMid';
    var xPos = pos.substr(0, 4);
    var yPos = pos.substr(4);
    elementRel = elementWidth / elementHeight;
    animationRel = this.transformCanvas.w / this.transformCanvas.h;
    if ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice')) {
      this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
      this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
    } else {
      this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
      this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
    }

    if (xPos === 'xMid' && ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))) {
      this.transformCanvas.tx = ((elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2) * this.renderConfig.dpr;
    } else if (xPos === 'xMax' && ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))) {
      this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
    } else {
      this.transformCanvas.tx = 0;
    }
    if (yPos === 'YMid' && ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))) {
      this.transformCanvas.ty = ((elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2) * this.renderConfig.dpr;
    } else if (yPos === 'YMax' && ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))) {
      this.transformCanvas.ty = ((elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w))) * this.renderConfig.dpr;
    } else {
      this.transformCanvas.ty = 0;
    }
  } else if (this.renderConfig.preserveAspectRatio === 'none') {
    this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
    this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
    this.transformCanvas.tx = 0;
    this.transformCanvas.ty = 0;
  } else {
    this.transformCanvas.sx = this.renderConfig.dpr;
    this.transformCanvas.sy = this.renderConfig.dpr;
    this.transformCanvas.tx = 0;
    this.transformCanvas.ty = 0;
  }
  this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
  /* var i, len = this.elements.length;
    for(i=0;i<len;i+=1){
        if(this.elements[i] && this.elements[i].data.ty === 0){
            this.elements[i].resize(this.globalData.transformCanvas);
        }
    } */
  this.ctxTransform(this.transformCanvas.props);
  this.canvasContext.beginPath();
  this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
  this.canvasContext.closePath();
  this.canvasContext.clip();

  this.renderFrame(this.renderedFrame, true);
};

CanvasRenderer.prototype.destroy = function () {
  if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
    this.animationItem.wrapper.innerText = '';
  }
  var i;
  var len = this.layers ? this.layers.length : 0;
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.elements[i]) {
      this.elements[i].destroy();
    }
  }
  this.elements.length = 0;
  this.globalData.canvasContext = null;
  this.animationItem.container = null;
  this.destroyed = true;
};

CanvasRenderer.prototype.renderFrame = function (num, forceRender) {
  if ((this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender) || this.destroyed || num === -1) {
    return;
  }
  this.renderedFrame = num;
  this.globalData.frameNum = num - this.animationItem._isFirstFrame;
  this.globalData.frameId += 1;
  this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
  this.globalData.projectInterface.currentFrame = num;

  // console.log('--------');
  // console.log('NEW: ',num);
  var i;
  var len = this.layers.length;
  if (!this.completeLayers) {
    this.checkLayers(num);
  }

  for (i = 0; i < len; i += 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].prepareFrame(num - this.layers[i].st);
    }
  }
  if (this.globalData._mdf) {
    if (this.renderConfig.clearCanvas === true) {
      this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
    } else {
      this.save();
    }
    for (i = len - 1; i >= 0; i -= 1) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].renderFrame();
      }
    }
    if (this.renderConfig.clearCanvas !== true) {
      this.restore();
    }
  }
};

CanvasRenderer.prototype.buildItem = function (pos) {
  var elements = this.elements;
  if (elements[pos] || this.layers[pos].ty === 99) {
    return;
  }
  var element = this.createItem(this.layers[pos], this, this.globalData);
  elements[pos] = element;
  element.initExpressions();
  /* if(this.layers[pos].ty === 0){
        element.resize(this.globalData.transformCanvas);
    } */
};

CanvasRenderer.prototype.checkPendingElements = function () {
  while (this.pendingElements.length) {
    var element = this.pendingElements.pop();
    element.checkParenting();
  }
};

CanvasRenderer.prototype.hide = function () {
  this.animationItem.container.style.display = 'none';
};

CanvasRenderer.prototype.show = function () {
  this.animationItem.container.style.display = 'block';
};

/* global extendPrototype, BaseRenderer, SVGRenderer, SVGShapeElement, HShapeElement, SVGTextLottieElement,
HTextElement, HCameraElement, IImageElement, HImageElement, SVGCompElement, HCompElement, ISolidElement,
HSolidElement, styleDiv, createTag, createNS */

function HybridRenderer(animationItem, config) {
  this.animationItem = animationItem;
  this.layers = null;
  this.renderedFrame = -1;
  this.renderConfig = {
    className: (config && config.className) || '',
    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
    hideOnTransparent: !(config && config.hideOnTransparent === false),
    filterSize: {
      width: (config && config.filterSize && config.filterSize.width) || '400%',
      height: (config && config.filterSize && config.filterSize.height) || '400%',
      x: (config && config.filterSize && config.filterSize.x) || '-100%',
      y: (config && config.filterSize && config.filterSize.y) || '-100%',
    },
  };
  this.globalData = {
    _mdf: false,
    frameNum: -1,
    renderConfig: this.renderConfig,
  };
  this.pendingElements = [];
  this.elements = [];
  this.threeDElements = [];
  this.destroyed = false;
  this.camera = null;
  this.supports3d = true;
  this.rendererType = 'html';
}

extendPrototype([BaseRenderer], HybridRenderer);

HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;

HybridRenderer.prototype.checkPendingElements = function () {
  while (this.pendingElements.length) {
    var element = this.pendingElements.pop();
    element.checkParenting();
  }
};

HybridRenderer.prototype.appendElementInPos = function (element, pos) {
  var newDOMElement = element.getBaseElement();
  if (!newDOMElement) {
    return;
  }
  var layer = this.layers[pos];
  if (!layer.ddd || !this.supports3d) {
    if (this.threeDElements) {
      this.addTo3dContainer(newDOMElement, pos);
    } else {
      var i = 0;
      var nextDOMElement;
      var nextLayer;
      var tmpDOMElement;
      while (i < pos) {
        if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
          nextLayer = this.elements[i];
          tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
          nextDOMElement = tmpDOMElement || nextDOMElement;
        }
        i += 1;
      }
      if (nextDOMElement) {
        if (!layer.ddd || !this.supports3d) {
          this.layerElement.insertBefore(newDOMElement, nextDOMElement);
        }
      } else if (!layer.ddd || !this.supports3d) {
        this.layerElement.appendChild(newDOMElement);
      }
    }
  } else {
    this.addTo3dContainer(newDOMElement, pos);
  }
};

HybridRenderer.prototype.createShape = function (data) {
  if (!this.supports3d) {
    return new SVGShapeElement(data, this.globalData, this);
  }
  return new HShapeElement(data, this.globalData, this);
};

HybridRenderer.prototype.createText = function (data) {
  if (!this.supports3d) {
    return new SVGTextLottieElement(data, this.globalData, this);
  }
  return new HTextElement(data, this.globalData, this);
};

HybridRenderer.prototype.createCamera = function (data) {
  this.camera = new HCameraElement(data, this.globalData, this);
  return this.camera;
};

HybridRenderer.prototype.createImage = function (data) {
  if (!this.supports3d) {
    return new IImageElement(data, this.globalData, this);
  }
  return new HImageElement(data, this.globalData, this);
};

HybridRenderer.prototype.createComp = function (data) {
  if (!this.supports3d) {
    return new SVGCompElement(data, this.globalData, this);
  }
  return new HCompElement(data, this.globalData, this);
};

HybridRenderer.prototype.createSolid = function (data) {
  if (!this.supports3d) {
    return new ISolidElement(data, this.globalData, this);
  }
  return new HSolidElement(data, this.globalData, this);
};

HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

HybridRenderer.prototype.getThreeDContainerByPos = function (pos) {
  var i = 0;
  var len = this.threeDElements.length;
  while (i < len) {
    if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
      return this.threeDElements[i].perspectiveElem;
    }
    i += 1;
  }
  return null;
};

HybridRenderer.prototype.createThreeDContainer = function (pos, type) {
  var perspectiveElem = createTag('div');
  var style;
  var containerStyle;
  styleDiv(perspectiveElem);
  var container = createTag('div');
  styleDiv(container);
  if (type === '3d') {
    style = perspectiveElem.style;
    style.width = this.globalData.compSize.w + 'px';
    style.height = this.globalData.compSize.h + 'px';
    var center = '50% 50%';
    style.webkitTransformOrigin = center;
    style.mozTransformOrigin = center;
    style.transformOrigin = center;
    containerStyle = container.style;
    var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
    containerStyle.transform = matrix;
    containerStyle.webkitTransform = matrix;
  }

  perspectiveElem.appendChild(container);
  // this.resizerElem.appendChild(perspectiveElem);
  var threeDContainerData = {
    container: container,
    perspectiveElem: perspectiveElem,
    startPos: pos,
    endPos: pos,
    type: type,
  };
  this.threeDElements.push(threeDContainerData);
  return threeDContainerData;
};

HybridRenderer.prototype.build3dContainers = function () {
  var i;
  var len = this.layers.length;
  var lastThreeDContainerData;
  var currentContainer = '';
  for (i = 0; i < len; i += 1) {
    if (this.layers[i].ddd && this.layers[i].ty !== 3) {
      if (currentContainer !== '3d') {
        currentContainer = '3d';
        lastThreeDContainerData = this.createThreeDContainer(i, '3d');
      }
      lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
    } else {
      if (currentContainer !== '2d') {
        currentContainer = '2d';
        lastThreeDContainerData = this.createThreeDContainer(i, '2d');
      }
      lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
    }
  }
  len = this.threeDElements.length;
  for (i = len - 1; i >= 0; i -= 1) {
    this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
  }
};

HybridRenderer.prototype.addTo3dContainer = function (elem, pos) {
  var i = 0;
  var len = this.threeDElements.length;
  while (i < len) {
    if (pos <= this.threeDElements[i].endPos) {
      var j = this.threeDElements[i].startPos;
      var nextElement;
      while (j < pos) {
        if (this.elements[j] && this.elements[j].getBaseElement) {
          nextElement = this.elements[j].getBaseElement();
        }
        j += 1;
      }
      if (nextElement) {
        this.threeDElements[i].container.insertBefore(elem, nextElement);
      } else {
        this.threeDElements[i].container.appendChild(elem);
      }
      break;
    }
    i += 1;
  }
};

HybridRenderer.prototype.configAnimation = function (animData) {
  var resizerElem = createTag('div');
  var wrapper = this.animationItem.wrapper;
  var style = resizerElem.style;
  style.width = animData.w + 'px';
  style.height = animData.h + 'px';
  this.resizerElem = resizerElem;
  styleDiv(resizerElem);
  style.transformStyle = 'flat';
  style.mozTransformStyle = 'flat';
  style.webkitTransformStyle = 'flat';
  if (this.renderConfig.className) {
    resizerElem.setAttribute('class', this.renderConfig.className);
  }
  wrapper.appendChild(resizerElem);

  style.overflow = 'hidden';
  var svg = createNS('svg');
  svg.setAttribute('width', '1');
  svg.setAttribute('height', '1');
  styleDiv(svg);
  this.resizerElem.appendChild(svg);
  var defs = createNS('defs');
  svg.appendChild(defs);
  this.data = animData;
  // Mask animation
  this.setupGlobalData(animData, svg);
  this.globalData.defs = defs;
  this.layers = animData.layers;
  this.layerElement = this.resizerElem;
  this.build3dContainers();
  this.updateContainerSize();
};

HybridRenderer.prototype.destroy = function () {
  if (this.animationItem.wrapper) {
    this.animationItem.wrapper.innerText = '';
  }
  this.animationItem.container = null;
  this.globalData.defs = null;
  var i;
  var len = this.layers ? this.layers.length : 0;
  for (i = 0; i < len; i += 1) {
    this.elements[i].destroy();
  }
  this.elements.length = 0;
  this.destroyed = true;
  this.animationItem = null;
};

HybridRenderer.prototype.updateContainerSize = function () {
  var elementWidth = this.animationItem.wrapper.offsetWidth;
  var elementHeight = this.animationItem.wrapper.offsetHeight;
  var elementRel = elementWidth / elementHeight;
  var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
  var sx;
  var sy;
  var tx;
  var ty;
  if (animationRel > elementRel) {
    sx = elementWidth / (this.globalData.compSize.w);
    sy = elementWidth / (this.globalData.compSize.w);
    tx = 0;
    ty = ((elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2);
  } else {
    sx = elementHeight / (this.globalData.compSize.h);
    sy = elementHeight / (this.globalData.compSize.h);
    tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
    ty = 0;
  }
  var style = this.resizerElem.style;
  style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
  style.transform = style.webkitTransform;
};

HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;

HybridRenderer.prototype.hide = function () {
  this.resizerElem.style.display = 'none';
};

HybridRenderer.prototype.show = function () {
  this.resizerElem.style.display = 'block';
};

HybridRenderer.prototype.initItems = function () {
  this.buildAllItems();
  if (this.camera) {
    this.camera.setup();
  } else {
    var cWidth = this.globalData.compSize.w;
    var cHeight = this.globalData.compSize.h;
    var i;
    var len = this.threeDElements.length;
    for (i = 0; i < len; i += 1) {
      var style = this.threeDElements[i].perspectiveElem.style;
      style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
      style.perspective = style.webkitPerspective;
    }
  }
};

HybridRenderer.prototype.searchExtraCompositions = function (assets) {
  var i;
  var len = assets.length;
  var floatingContainer = createTag('div');
  for (i = 0; i < len; i += 1) {
    if (assets[i].xt) {
      var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
      comp.initExpressions();
      this.globalData.projectInterface.registerComposition(comp);
    }
  }
};

/* global createSizedArray, createElementID, PropertyFactory, ShapePropertyFactory, createNS, locationHref */

function MaskElement(data, element, globalData) {
  this.data = data;
  this.element = element;
  this.globalData = globalData;
  this.storedData = [];
  this.masksProperties = this.data.masksProperties || [];
  this.maskElement = null;
  var defs = this.globalData.defs;
  var i;
  var len = this.masksProperties ? this.masksProperties.length : 0;
  this.viewData = createSizedArray(len);
  this.solidPath = '';

  var path;
  var properties = this.masksProperties;
  var count = 0;
  var currentMasks = [];
  var j;
  var jLen;
  var layerId = createElementID();
  var rect;
  var expansor;
  var feMorph;
  var x;
  var maskType = 'clipPath';
  var maskRef = 'clip-path';
  for (i = 0; i < len; i += 1) {
    if ((properties[i].mode !== 'a' && properties[i].mode !== 'n') || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
      maskType = 'mask';
      maskRef = 'mask';
    }

    if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {
      rect = createNS('rect');
      rect.setAttribute('fill', '#ffffff');
      rect.setAttribute('width', this.element.comp.data.w || 0);
      rect.setAttribute('height', this.element.comp.data.h || 0);
      currentMasks.push(rect);
    } else {
      rect = null;
    }

    path = createNS('path');
    if (properties[i].mode === 'n') {
      // TODO move this to a factory or to a constructor
      this.viewData[i] = {
        op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
        prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
        elem: path,
        lastPath: '',
      };
      defs.appendChild(path);
    } else {
      count += 1;

      path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
      path.setAttribute('clip-rule', 'nonzero');
      var filterID;

      if (properties[i].x.k !== 0) {
        maskType = 'mask';
        maskRef = 'mask';
        x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
        filterID = createElementID();
        expansor = createNS('filter');
        expansor.setAttribute('id', filterID);
        feMorph = createNS('feMorphology');
        feMorph.setAttribute('operator', 'erode');
        feMorph.setAttribute('in', 'SourceGraphic');
        feMorph.setAttribute('radius', '0');
        expansor.appendChild(feMorph);
        defs.appendChild(expansor);
        path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
      } else {
        feMorph = null;
        x = null;
      }

      // TODO move this to a factory or to a constructor
      this.storedData[i] = {
        elem: path,
        x: x,
        expan: feMorph,
        lastPath: '',
        lastOperator: '',
        filterId: filterID,
        lastRadius: 0,
      };
      if (properties[i].mode === 'i') {
        jLen = currentMasks.length;
        var g = createNS('g');
        for (j = 0; j < jLen; j += 1) {
          g.appendChild(currentMasks[j]);
        }
        var mask = createNS('mask');
        mask.setAttribute('mask-type', 'alpha');
        mask.setAttribute('id', layerId + '_' + count);
        mask.appendChild(path);
        defs.appendChild(mask);
        g.setAttribute('mask', 'url(' + locationHref + '#' + layerId + '_' + count + ')');

        currentMasks.length = 0;
        currentMasks.push(g);
      } else {
        currentMasks.push(path);
      }
      if (properties[i].inv && !this.solidPath) {
        this.solidPath = this.createLayerSolidPath();
      }
      // TODO move this to a factory or to a constructor
      this.viewData[i] = {
        elem: path,
        lastPath: '',
        op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
        prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
        invRect: rect,
      };
      if (!this.viewData[i].prop.k) {
        this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
      }
    }
  }

  this.maskElement = createNS(maskType);

  len = currentMasks.length;
  for (i = 0; i < len; i += 1) {
    this.maskElement.appendChild(currentMasks[i]);
  }

  if (count > 0) {
    this.maskElement.setAttribute('id', layerId);
    this.element.maskedElement.setAttribute(maskRef, 'url(' + locationHref + '#' + layerId + ')');
    defs.appendChild(this.maskElement);
  }
  if (this.viewData.length) {
    this.element.addRenderableComponent(this);
  }
}

MaskElement.prototype.getMaskProperty = function (pos) {
  return this.viewData[pos].prop;
};

MaskElement.prototype.renderFrame = function (isFirstFrame) {
  var finalMat = this.element.finalTransform.mat;
  var i;
  var len = this.masksProperties.length;
  for (i = 0; i < len; i += 1) {
    if (this.viewData[i].prop._mdf || isFirstFrame) {
      this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
    }
    if (this.viewData[i].op._mdf || isFirstFrame) {
      this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
    }
    if (this.masksProperties[i].mode !== 'n') {
      if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
        this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
      }
      if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
        var feMorph = this.storedData[i].expan;
        if (this.storedData[i].x.v < 0) {
          if (this.storedData[i].lastOperator !== 'erode') {
            this.storedData[i].lastOperator = 'erode';
            this.storedData[i].elem.setAttribute('filter', 'url(' + locationHref + '#' + this.storedData[i].filterId + ')');
          }
          feMorph.setAttribute('radius', -this.storedData[i].x.v);
        } else {
          if (this.storedData[i].lastOperator !== 'dilate') {
            this.storedData[i].lastOperator = 'dilate';
            this.storedData[i].elem.setAttribute('filter', null);
          }
          this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
        }
      }
    }
  }
};

MaskElement.prototype.getMaskelement = function () {
  return this.maskElement;
};

MaskElement.prototype.createLayerSolidPath = function () {
  var path = 'M0,0 ';
  path += ' h' + this.globalData.compSize.w;
  path += ' v' + this.globalData.compSize.h;
  path += ' h-' + this.globalData.compSize.w;
  path += ' v-' + this.globalData.compSize.h + ' ';
  return path;
};

MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
  var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
  var i;
  var len;
  len = pathNodes._length;
  for (i = 1; i < len; i += 1) {
    // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
    pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
  }
  // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
  if (pathNodes.c && len > 1) {
    pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
  }
  // pathNodes.__renderedString = pathString;

  if (viewData.lastPath !== pathString) {
    var pathShapeValue = '';
    if (viewData.elem) {
      if (pathNodes.c) {
        pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
      }
      viewData.elem.setAttribute('d', pathShapeValue);
    }
    viewData.lastPath = pathString;
  }
};

MaskElement.prototype.destroy = function () {
  this.element = null;
  this.globalData = null;
  this.maskElement = null;
  this.data = null;
  this.masksProperties = null;
};

/**
 * @file
 * Handles AE's layer parenting property.
 *
 */

function HierarchyElement() {}

HierarchyElement.prototype = {
  /**
     * @function
     * Initializes hierarchy properties
     *
     */
  initHierarchy: function () {
    // element's parent list
    this.hierarchy = [];
    // if element is parent of another layer _isParent will be true
    this._isParent = false;
    this.checkParenting();
  },
  /**
     * @function
     * Sets layer's hierarchy.
     * @param {array} hierarch
     * layer's parent list
     *
     */
  setHierarchy: function (hierarchy) {
    this.hierarchy = hierarchy;
  },
  /**
     * @function
     * Sets layer as parent.
     *
     */
  setAsParent: function () {
    this._isParent = true;
  },
  /**
     * @function
     * Searches layer's parenting chain
     *
     */
  checkParenting: function () {
    if (this.data.parent !== undefined) {
      this.comp.buildElementParenting(this, this.data.parent, []);
    }
  },
};

/**
 * @file
 * Handles element's layer frame update.
 * Checks layer in point and out point
 *
 */

function FrameElement() {}

FrameElement.prototype = {
  /**
     * @function
     * Initializes frame related properties.
     *
     */
  initFrame: function () {
    // set to true when inpoint is rendered
    this._isFirstFrame = false;
    // list of animated properties
    this.dynamicProperties = [];
    // If layer has been modified in current tick this will be true
    this._mdf = false;
  },
  /**
     * @function
     * Calculates all dynamic values
     *
     * @param {number} num
     * current frame number in Layer's time
     * @param {boolean} isVisible
     * if layers is currently in range
     *
     */
  prepareProperties: function (num, isVisible) {
    var i;
    var len = this.dynamicProperties.length;
    for (i = 0; i < len; i += 1) {
      if (isVisible || (this._isParent && this.dynamicProperties[i].propType === 'transform')) {
        this.dynamicProperties[i].getValue();
        if (this.dynamicProperties[i]._mdf) {
          this.globalData._mdf = true;
          this._mdf = true;
        }
      }
    }
  },
  addDynamicProperty: function (prop) {
    if (this.dynamicProperties.indexOf(prop) === -1) {
      this.dynamicProperties.push(prop);
    }
  },
};

/* global TransformPropertyFactory, Matrix */

function TransformElement() {}

TransformElement.prototype = {
  initTransform: function () {
    this.finalTransform = {
      mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 },
      _matMdf: false,
      _opMdf: false,
      mat: new Matrix(),
    };
    if (this.data.ao) {
      this.finalTransform.mProp.autoOriented = true;
    }

    // TODO: check TYPE 11: Guided elements
    if (this.data.ty !== 11) {
      // this.createElements();
    }
  },
  renderTransform: function () {
    this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
    this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;

    if (this.hierarchy) {
      var mat;
      var finalMat = this.finalTransform.mat;
      var i = 0;
      var len = this.hierarchy.length;
      // Checking if any of the transformation matrices in the hierarchy chain has changed.
      if (!this.finalTransform._matMdf) {
        while (i < len) {
          if (this.hierarchy[i].finalTransform.mProp._mdf) {
            this.finalTransform._matMdf = true;
            break;
          }
          i += 1;
        }
      }

      if (this.finalTransform._matMdf) {
        mat = this.finalTransform.mProp.v.props;
        finalMat.cloneFromProps(mat);
        for (i = 0; i < len; i += 1) {
          mat = this.hierarchy[i].finalTransform.mProp.v.props;
          finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
        }
      }
    }
  },
  globalToLocal: function (pt) {
    var transforms = [];
    transforms.push(this.finalTransform);
    var flag = true;
    var comp = this.comp;
    while (flag) {
      if (comp.finalTransform) {
        if (comp.data.hasMask) {
          transforms.splice(0, 0, comp.finalTransform);
        }
        comp = comp.comp;
      } else {
        flag = false;
      }
    }
    var i;
    var len = transforms.length;
    var ptNew;
    for (i = 0; i < len; i += 1) {
      ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
      // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
      pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
    }
    return pt;
  },
  mHelper: new Matrix(),
};

function RenderableElement() {

}

RenderableElement.prototype = {
  initRenderable: function () {
    // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
    this.isInRange = false;
    // layer's display state
    this.hidden = false;
    // If layer's transparency equals 0, it can be hidden
    this.isTransparent = false;
    // list of animated components
    this.renderableComponents = [];
  },
  addRenderableComponent: function (component) {
    if (this.renderableComponents.indexOf(component) === -1) {
      this.renderableComponents.push(component);
    }
  },
  removeRenderableComponent: function (component) {
    if (this.renderableComponents.indexOf(component) !== -1) {
      this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
    }
  },
  prepareRenderableFrame: function (num) {
    this.checkLayerLimits(num);
  },
  checkTransparency: function () {
    if (this.finalTransform.mProp.o.v <= 0) {
      if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
        this.isTransparent = true;
        this.hide();
      }
    } else if (this.isTransparent) {
      this.isTransparent = false;
      this.show();
    }
  },
  /**
     * @function
     * Initializes frame related properties.
     *
     * @param {number} num
     * current frame number in Layer's time
     *
     */
  checkLayerLimits: function (num) {
    if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
      if (this.isInRange !== true) {
        this.globalData._mdf = true;
        this._mdf = true;
        this.isInRange = true;
        this.show();
      }
    } else if (this.isInRange !== false) {
      this.globalData._mdf = true;
      this.isInRange = false;
      this.hide();
    }
  },
  renderRenderable: function () {
    var i;
    var len = this.renderableComponents.length;
    for (i = 0; i < len; i += 1) {
      this.renderableComponents[i].renderFrame(this._isFirstFrame);
    }
    /* this.maskManager.renderFrame(this.finalTransform.mat);
        this.renderableEffectsManager.renderFrame(this._isFirstFrame); */
  },
  sourceRectAtTime: function () {
    return {
      top: 0,
      left: 0,
      width: 100,
      height: 100,
    };
  },
  getLayerSize: function () {
    if (this.data.ty === 5) {
      return { w: this.data.textData.width, h: this.data.textData.height };
    }
    return { w: this.data.width, h: this.data.height };
  },
};

/* global extendPrototype, RenderableElement, createProxyFunction */

function RenderableDOMElement() {}

(function () {
  var _prototype = {
    initElement: function (data, globalData, comp) {
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.initTransform(data, globalData, comp);
      this.initHierarchy();
      this.initRenderable();
      this.initRendererElement();
      this.createContainerElements();
      this.createRenderableComponents();
      this.createContent();
      this.hide();
    },
    hide: function () {
      if (!this.hidden && (!this.isInRange || this.isTransparent)) {
        var elem = this.baseElement || this.layerElement;
        elem.style.display = 'none';
        this.hidden = true;
      }
    },
    show: function () {
      if (this.isInRange && !this.isTransparent) {
        if (!this.data.hd) {
          var elem = this.baseElement || this.layerElement;
          elem.style.display = 'block';
        }
        this.hidden = false;
        this._isFirstFrame = true;
      }
    },
    renderFrame: function () {
      // If it is exported as hidden (data.hd === true) no need to render
      // If it is not visible no need to render
      if (this.data.hd || this.hidden) {
        return;
      }
      this.renderTransform();
      this.renderRenderable();
      this.renderElement();
      this.renderInnerContent();
      if (this._isFirstFrame) {
        this._isFirstFrame = false;
      }
    },
    renderInnerContent: function () {},
    prepareFrame: function (num) {
      this._mdf = false;
      this.prepareRenderableFrame(num);
      this.prepareProperties(num, this.isInRange);
      this.checkTransparency();
    },
    destroy: function () {
      this.innerElem = null;
      this.destroyBaseElement();
    },
  };
  extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
}());

/* exported ProcessedElement */

function ProcessedElement(element, position) {
  this.elem = element;
  this.pos = position;
}

/* global createNS */

function SVGStyleData(data, level) {
  this.data = data;
  this.type = data.ty;
  this.d = '';
  this.lvl = level;
  this._mdf = false;
  this.closed = data.hd === true;
  this.pElem = createNS('path');
  this.msElem = null;
}

SVGStyleData.prototype.reset = function () {
  this.d = '';
  this._mdf = false;
};

function SVGShapeData(transformers, level, shape) {
  this.caches = [];
  this.styles = [];
  this.transformers = transformers;
  this.lStr = '';
  this.sh = shape;
  this.lvl = level;
  // TODO find if there are some cases where _isAnimated can be false.
  // For now, since shapes add up with other shapes. They have to be calculated every time.
  // One way of finding out is checking if all styles associated to this shape depend only of this shape
  this._isAnimated = !!shape.k;
  // TODO: commenting this for now since all shapes are animated
  var i = 0;
  var len = transformers.length;
  while (i < len) {
    if (transformers[i].mProps.dynamicProperties.length) {
      this._isAnimated = true;
      break;
    }
    i += 1;
  }
}

SVGShapeData.prototype.setAsAnimated = function () {
  this._isAnimated = true;
};

/* exported SVGTransformData */

function SVGTransformData(mProps, op, container) {
  this.transform = {
    mProps: mProps,
    op: op,
    container: container,
  };
  this.elements = [];
  this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
}

/* global DashProperty, PropertyFactory, extendPrototype, DynamicPropertyContainer */

function SVGStrokeStyleData(elem, data, styleOb) {
  this.initDynamicPropertyContainer(elem);
  this.getValue = this.iterateDynamicProperties;
  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
  this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
  this.d = new DashProperty(elem, data.d || {}, 'svg', this);
  this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
  this.style = styleOb;
  this._isAnimated = !!this._isAnimated;
}

extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

/* global PropertyFactory, extendPrototype, DynamicPropertyContainer */

function SVGFillStyleData(elem, data, styleOb) {
  this.initDynamicPropertyContainer(elem);
  this.getValue = this.iterateDynamicProperties;
  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
  this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
  this.style = styleOb;
}

extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

/* global PropertyFactory, degToRads, GradientProperty, createElementID, createNS, locationHref,
extendPrototype, DynamicPropertyContainer, lineCapEnum, lineJoinEnum */

function SVGGradientFillStyleData(elem, data, styleOb) {
  this.initDynamicPropertyContainer(elem);
  this.getValue = this.iterateDynamicProperties;
  this.initGradientData(elem, data, styleOb);
}

SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
  this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
  this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
  this.h = PropertyFactory.getProp(elem, data.h || { k: 0 }, 0, 0.01, this);
  this.a = PropertyFactory.getProp(elem, data.a || { k: 0 }, 0, degToRads, this);
  this.g = new GradientProperty(elem, data.g, this);
  this.style = styleOb;
  this.stops = [];
  this.setGradientData(styleOb.pElem, data);
  this.setGradientOpacity(data, styleOb);
  this._isAnimated = !!this._isAnimated;
};

SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
  var gradientId = createElementID();
  var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
  gfill.setAttribute('id', gradientId);
  gfill.setAttribute('spreadMethod', 'pad');
  gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
  var stops = [];
  var stop;
  var j;
  var jLen;
  jLen = data.g.p * 4;
  for (j = 0; j < jLen; j += 4) {
    stop = createNS('stop');
    gfill.appendChild(stop);
    stops.push(stop);
  }
  pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + gradientId + ')');
  this.gf = gfill;
  this.cst = stops;
};

SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
  if (this.g._hasOpacity && !this.g._collapsable) {
    var stop;
    var j;
    var jLen;
    var mask = createNS('mask');
    var maskElement = createNS('path');
    mask.appendChild(maskElement);
    var opacityId = createElementID();
    var maskId = createElementID();
    mask.setAttribute('id', maskId);
    var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
    opFill.setAttribute('id', opacityId);
    opFill.setAttribute('spreadMethod', 'pad');
    opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
    jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
    var stops = this.stops;
    for (j = data.g.p * 4; j < jLen; j += 2) {
      stop = createNS('stop');
      stop.setAttribute('stop-color', 'rgb(255,255,255)');
      opFill.appendChild(stop);
      stops.push(stop);
    }
    maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + opacityId + ')');
    if (data.ty === 'gs') {
      maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
      maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
      if (data.lj === 1) {
        maskElement.setAttribute('stroke-miterlimit', data.ml);
      }
    }
    this.of = opFill;
    this.ms = mask;
    this.ost = stops;
    this.maskId = maskId;
    styleOb.msElem = maskElement;
  }
};

extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

/* global PropertyFactory, DashProperty, extendPrototype, SVGGradientFillStyleData, DynamicPropertyContainer */

function SVGGradientStrokeStyleData(elem, data, styleOb) {
  this.initDynamicPropertyContainer(elem);
  this.getValue = this.iterateDynamicProperties;
  this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
  this.d = new DashProperty(elem, data.d || {}, 'svg', this);
  this.initGradientData(elem, data, styleOb);
  this._isAnimated = !!this._isAnimated;
}

extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

/* global createNS */
/* exported ShapeGroupData */

function ShapeGroupData() {
  this.it = [];
  this.prevViewData = [];
  this.gr = createNS('g');
}

/* global Matrix, buildShapeString, bmFloor */
/* exported SVGElementsRenderer */

var SVGElementsRenderer = (function () {
  var _identityMatrix = new Matrix();
  var _matrixHelper = new Matrix();

  var ob = {
    createRenderFunction: createRenderFunction,
  };

  function createRenderFunction(data) {
    switch (data.ty) {
      case 'fl':
        return renderFill;
      case 'gf':
        return renderGradient;
      case 'gs':
        return renderGradientStroke;
      case 'st':
        return renderStroke;
      case 'sh':
      case 'el':
      case 'rc':
      case 'sr':
        return renderPath;
      case 'tr':
        return renderContentTransform;
      default:
        return null;
    }
  }

  function renderContentTransform(styleData, itemData, isFirstFrame) {
    if (isFirstFrame || itemData.transform.op._mdf) {
      itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
    }
    if (isFirstFrame || itemData.transform.mProps._mdf) {
      itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
    }
  }

  function renderPath(styleData, itemData, isFirstFrame) {
    var j;
    var jLen;
    var pathStringTransformed;
    var redraw;
    var pathNodes;
    var l;
    var lLen = itemData.styles.length;
    var lvl = itemData.lvl;
    var paths;
    var mat;
    var props;
    var iterations;
    var k;
    for (l = 0; l < lLen; l += 1) {
      redraw = itemData.sh._mdf || isFirstFrame;
      if (itemData.styles[l].lvl < lvl) {
        mat = _matrixHelper.reset();
        iterations = lvl - itemData.styles[l].lvl;
        k = itemData.transformers.length - 1;
        while (!redraw && iterations > 0) {
          redraw = itemData.transformers[k].mProps._mdf || redraw;
          iterations -= 1;
          k -= 1;
        }
        if (redraw) {
          iterations = lvl - itemData.styles[l].lvl;
          k = itemData.transformers.length - 1;
          while (iterations > 0) {
            props = itemData.transformers[k].mProps.v.props;
            mat.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
            iterations -= 1;
            k -= 1;
          }
        }
      } else {
        mat = _identityMatrix;
      }
      paths = itemData.sh.paths;
      jLen = paths._length;
      if (redraw) {
        pathStringTransformed = '';
        for (j = 0; j < jLen; j += 1) {
          pathNodes = paths.shapes[j];
          if (pathNodes && pathNodes._length) {
            pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
          }
        }
        itemData.caches[l] = pathStringTransformed;
      } else {
        pathStringTransformed = itemData.caches[l];
      }
      itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
      itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
    }
  }

  function renderFill(styleData, itemData, isFirstFrame) {
    var styleElem = itemData.style;

    if (itemData.c._mdf || isFirstFrame) {
      styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
    }
    if (itemData.o._mdf || isFirstFrame) {
      styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
    }
  }

  function renderGradientStroke(styleData, itemData, isFirstFrame) {
    renderGradient(styleData, itemData, isFirstFrame);
    renderStroke(styleData, itemData, isFirstFrame);
  }

  function renderGradient(styleData, itemData, isFirstFrame) {
    var gfill = itemData.gf;
    var hasOpacity = itemData.g._hasOpacity;
    var pt1 = itemData.s.v;
    var pt2 = itemData.e.v;

    if (itemData.o._mdf || isFirstFrame) {
      var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
      itemData.style.pElem.setAttribute(attr, itemData.o.v);
    }
    if (itemData.s._mdf || isFirstFrame) {
      var attr1 = styleData.t === 1 ? 'x1' : 'cx';
      var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
      gfill.setAttribute(attr1, pt1[0]);
      gfill.setAttribute(attr2, pt1[1]);
      if (hasOpacity && !itemData.g._collapsable) {
        itemData.of.setAttribute(attr1, pt1[0]);
        itemData.of.setAttribute(attr2, pt1[1]);
      }
    }
    var stops;
    var i;
    var len;
    var stop;
    if (itemData.g._cmdf || isFirstFrame) {
      stops = itemData.cst;
      var cValues = itemData.g.c;
      len = stops.length;
      for (i = 0; i < len; i += 1) {
        stop = stops[i];
        stop.setAttribute('offset', cValues[i * 4] + '%');
        stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
      }
    }
    if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
      var oValues = itemData.g.o;
      if (itemData.g._collapsable) {
        stops = itemData.cst;
      } else {
        stops = itemData.ost;
      }
      len = stops.length;
      for (i = 0; i < len; i += 1) {
        stop = stops[i];
        if (!itemData.g._collapsable) {
          stop.setAttribute('offset', oValues[i * 2] + '%');
        }
        stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
      }
    }
    if (styleData.t === 1) {
      if (itemData.e._mdf || isFirstFrame) {
        gfill.setAttribute('x2', pt2[0]);
        gfill.setAttribute('y2', pt2[1]);
        if (hasOpacity && !itemData.g._collapsable) {
          itemData.of.setAttribute('x2', pt2[0]);
          itemData.of.setAttribute('y2', pt2[1]);
        }
      }
    } else {
      var rad;
      if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
        rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
        gfill.setAttribute('r', rad);
        if (hasOpacity && !itemData.g._collapsable) {
          itemData.of.setAttribute('r', rad);
        }
      }
      if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
        if (!rad) {
          rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
        }
        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

        var percent = itemData.h.v;
        if (percent >= 1) {
          percent = 0.99;
        } else if (percent <= -1) {
          percent = -0.99;
        }
        var dist = rad * percent;
        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
        gfill.setAttribute('fx', x);
        gfill.setAttribute('fy', y);
        if (hasOpacity && !itemData.g._collapsable) {
          itemData.of.setAttribute('fx', x);
          itemData.of.setAttribute('fy', y);
        }
      }
      // gfill.setAttribute('fy','200');
    }
  }

  function renderStroke(styleData, itemData, isFirstFrame) {
    var styleElem = itemData.style;
    var d = itemData.d;
    if (d && (d._mdf || isFirstFrame) && d.dashStr) {
      styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
      styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
    }
    if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
      styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
    }
    if (itemData.o._mdf || isFirstFrame) {
      styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
    }
    if (itemData.w._mdf || isFirstFrame) {
      styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
      if (styleElem.msElem) {
        styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
      }
    }
  }

  return ob;
}());

/* global Matrix */

function ShapeTransformManager() {
  this.sequences = {};
  this.sequenceList = [];
  this.transform_key_count = 0;
}

ShapeTransformManager.prototype = {
  addTransformSequence: function (transforms) {
    var i;
    var len = transforms.length;
    var key = '_';
    for (i = 0; i < len; i += 1) {
      key += transforms[i].transform.key + '_';
    }
    var sequence = this.sequences[key];
    if (!sequence) {
      sequence = {
        transforms: [].concat(transforms),
        finalTransform: new Matrix(),
        _mdf: false,
      };
      this.sequences[key] = sequence;
      this.sequenceList.push(sequence);
    }
    return sequence;
  },
  processSequence: function (sequence, isFirstFrame) {
    var i = 0;
    var len = sequence.transforms.length;
    var _mdf = isFirstFrame;
    while (i < len && !isFirstFrame) {
      if (sequence.transforms[i].transform.mProps._mdf) {
        _mdf = true;
        break;
      }
      i += 1;
    }
    if (_mdf) {
      var props;
      sequence.finalTransform.reset();
      for (i = len - 1; i >= 0; i -= 1) {
        props = sequence.transforms[i].transform.mProps.v.props;
        sequence.finalTransform.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
      }
    }
    sequence._mdf = _mdf;
  },
  processSequences: function (isFirstFrame) {
    var i;
    var len = this.sequenceList.length;
    for (i = 0; i < len; i += 1) {
      this.processSequence(this.sequenceList[i], isFirstFrame);
    }
  },
  getNewKey: function () {
    this.transform_key_count += 1;
    return '_' + this.transform_key_count;
  },
};

/* global ShapePropertyFactory, SVGShapeData */

function CVShapeData(element, data, styles, transformsManager) {
  this.styledShapes = [];
  this.tr = [0, 0, 0, 0, 0, 0];
  var ty = 4;
  if (data.ty === 'rc') {
    ty = 5;
  } else if (data.ty === 'el') {
    ty = 6;
  } else if (data.ty === 'sr') {
    ty = 7;
  }
  this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
  var i;
  var len = styles.length;
  var styledShape;
  for (i = 0; i < len; i += 1) {
    if (!styles[i].closed) {
      styledShape = {
        transforms: transformsManager.addTransformSequence(styles[i].transforms),
        trNodes: [],
      };
      this.styledShapes.push(styledShape);
      styles[i].elements.push(styledShape);
    }
  }
}

CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

/* global LayerExpressionInterface, EffectsExpressionInterface, CompExpressionInterface, ShapeExpressionInterface,
TextExpressionInterface, getBlendMode,createElementID, EffectsManager */

function BaseElement() {
}

BaseElement.prototype = {
  checkMasks: function () {
    if (!this.data.hasMask) {
      return false;
    }
    var i = 0;
    var len = this.data.masksProperties.length;
    while (i < len) {
      if ((this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false)) {
        return true;
      }
      i += 1;
    }
    return false;
  },
  initExpressions: function () {
    this.layerInterface = LayerExpressionInterface(this);
    if (this.data.hasMask && this.maskManager) {
      this.layerInterface.registerMaskInterface(this.maskManager);
    }
    var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
    this.layerInterface.registerEffectsInterface(effectsInterface);

    if (this.data.ty === 0 || this.data.xt) {
      this.compInterface = CompExpressionInterface(this);
    } else if (this.data.ty === 4) {
      this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
      this.layerInterface.content = this.layerInterface.shapeInterface;
    } else if (this.data.ty === 5) {
      this.layerInterface.textInterface = TextExpressionInterface(this);
      this.layerInterface.text = this.layerInterface.textInterface;
    }
  },
  setBlendMode: function () {
    var blendModeValue = getBlendMode(this.data.bm);
    var elem = this.baseElement || this.layerElement;

    elem.style['mix-blend-mode'] = blendModeValue;
  },
  initBaseData: function (data, globalData, comp) {
    this.globalData = globalData;
    this.comp = comp;
    this.data = data;
    this.layerId = createElementID();

    // Stretch factor for old animations missing this property.
    if (!this.data.sr) {
      this.data.sr = 1;
    }
    // effects manager
    this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
  },
  getType: function () {
    return this.type;
  },
  sourceRectAtTime: function () {},
};

/* global extendPrototype, BaseElement, TransformElement, HierarchyElement, FrameElement */

function NullElement(data, globalData, comp) {
  this.initFrame();
  this.initBaseData(data, globalData, comp);
  this.initFrame();
  this.initTransform(data, globalData, comp);
  this.initHierarchy();
}

NullElement.prototype.prepareFrame = function (num) {
  this.prepareProperties(num, true);
};

NullElement.prototype.renderFrame = function () {
};

NullElement.prototype.getBaseElement = function () {
  return null;
};

NullElement.prototype.destroy = function () {
};

NullElement.prototype.sourceRectAtTime = function () {
};

NullElement.prototype.hide = function () {
};

extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

/* global filtersFactory, featureSupport, filtersFactory, createElementID, createNS, MaskElement, SVGEffects, locationHref */

function SVGBaseElement() {
}

SVGBaseElement.prototype = {
  initRendererElement: function () {
    this.layerElement = createNS('g');
  },
  createContainerElements: function () {
    this.matteElement = createNS('g');
    this.transformedElement = this.layerElement;
    this.maskedElement = this.layerElement;
    this._sizeChanged = false;
    var layerElementParent = null;
    // If this layer acts as a mask for the following layer
    var filId;
    var fil;
    var gg;
    if (this.data.td) {
      if (this.data.td == 3 || this.data.td == 1) { // eslint-disable-line eqeqeq
        var masker = createNS('mask');
        masker.setAttribute('id', this.layerId);
        masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha'); // eslint-disable-line eqeqeq
        masker.appendChild(this.layerElement);
        layerElementParent = masker;
        this.globalData.defs.appendChild(masker);
        // This is only for IE and Edge when mask if of type alpha
        if (!featureSupport.maskType && this.data.td == 1) { // eslint-disable-line eqeqeq
          masker.setAttribute('mask-type', 'luminance');
          filId = createElementID();
          fil = filtersFactory.createFilter(filId);
          this.globalData.defs.appendChild(fil);
          fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
          gg = createNS('g');
          gg.appendChild(this.layerElement);
          layerElementParent = gg;
          masker.appendChild(gg);
          gg.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
        }
      } else if (this.data.td == 2) { // eslint-disable-line eqeqeq
        var maskGroup = createNS('mask');
        maskGroup.setAttribute('id', this.layerId);
        maskGroup.setAttribute('mask-type', 'alpha');
        var maskGrouper = createNS('g');
        maskGroup.appendChild(maskGrouper);
        filId = createElementID();
        fil = filtersFactory.createFilter(filId);
        /// /

        // This solution doesn't work on Android when meta tag with viewport attribute is set
        /* var feColorMatrix = createNS('feColorMatrix');
                feColorMatrix.setAttribute('type', 'matrix');
                feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
                feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
                fil.appendChild(feColorMatrix); */
        /// /
        var feCTr = createNS('feComponentTransfer');
        feCTr.setAttribute('in', 'SourceGraphic');
        fil.appendChild(feCTr);
        var feFunc = createNS('feFuncA');
        feFunc.setAttribute('type', 'table');
        feFunc.setAttribute('tableValues', '1.0 0.0');
        feCTr.appendChild(feFunc);
        /// /
        this.globalData.defs.appendChild(fil);
        var alphaRect = createNS('rect');
        alphaRect.setAttribute('width', this.comp.data.w);
        alphaRect.setAttribute('height', this.comp.data.h);
        alphaRect.setAttribute('x', '0');
        alphaRect.setAttribute('y', '0');
        alphaRect.setAttribute('fill', '#ffffff');
        alphaRect.setAttribute('opacity', '0');
        maskGrouper.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
        maskGrouper.appendChild(alphaRect);
        maskGrouper.appendChild(this.layerElement);
        layerElementParent = maskGrouper;
        if (!featureSupport.maskType) {
          maskGroup.setAttribute('mask-type', 'luminance');
          fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
          gg = createNS('g');
          maskGrouper.appendChild(alphaRect);
          gg.appendChild(this.layerElement);
          layerElementParent = gg;
          maskGrouper.appendChild(gg);
        }
        this.globalData.defs.appendChild(maskGroup);
      }
    } else if (this.data.tt) {
      this.matteElement.appendChild(this.layerElement);
      layerElementParent = this.matteElement;
      this.baseElement = this.matteElement;
    } else {
      this.baseElement = this.layerElement;
    }
    if (this.data.ln) {
      this.layerElement.setAttribute('id', this.data.ln);
    }
    if (this.data.cl) {
      this.layerElement.setAttribute('class', this.data.cl);
    }
    // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
    if (this.data.ty === 0 && !this.data.hd) {
      var cp = createNS('clipPath');
      var pt = createNS('path');
      pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
      var clipId = createElementID();
      cp.setAttribute('id', clipId);
      cp.appendChild(pt);
      this.globalData.defs.appendChild(cp);

      if (this.checkMasks()) {
        var cpGroup = createNS('g');
        cpGroup.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
        cpGroup.appendChild(this.layerElement);
        this.transformedElement = cpGroup;
        if (layerElementParent) {
          layerElementParent.appendChild(this.transformedElement);
        } else {
          this.baseElement = this.transformedElement;
        }
      } else {
        this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
      }
    }
    if (this.data.bm !== 0) {
      this.setBlendMode();
    }
  },
  renderElement: function () {
    if (this.finalTransform._matMdf) {
      this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS());
    }
    if (this.finalTransform._opMdf) {
      this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v);
    }
  },
  destroyBaseElement: function () {
    this.layerElement = null;
    this.matteElement = null;
    this.maskManager.destroy();
  },
  getBaseElement: function () {
    if (this.data.hd) {
      return null;
    }
    return this.baseElement;
  },
  createRenderableComponents: function () {
    this.maskManager = new MaskElement(this.data, this, this.globalData);
    this.renderableEffectsManager = new SVGEffects(this);
  },
  setMatte: function (id) {
    if (!this.matteElement) {
      return;
    }
    this.matteElement.setAttribute('mask', 'url(' + locationHref + '#' + id + ')');
  },
};

/* global ProcessedElement */

function IShapeElement() {
}

IShapeElement.prototype = {
  addShapeToModifiers: function (data) {
    var i;
    var len = this.shapeModifiers.length;
    for (i = 0; i < len; i += 1) {
      this.shapeModifiers[i].addShape(data);
    }
  },
  isShapeInAnimatedModifiers: function (data) {
    var i = 0;
    var len = this.shapeModifiers.length;
    while (i < len) {
      if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
        return true;
      }
    }
    return false;
  },
  renderModifiers: function () {
    if (!this.shapeModifiers.length) {
      return;
    }
    var i;
    var len = this.shapes.length;
    for (i = 0; i < len; i += 1) {
      this.shapes[i].sh.reset();
    }

    len = this.shapeModifiers.length;
    var shouldBreakProcess;
    for (i = len - 1; i >= 0; i -= 1) {
      shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);
      // workaround to fix cases where a repeater resets the shape so the following processes get called twice
      // TODO: find a better solution for this
      if (shouldBreakProcess) {
        break;
      }
    }
  },

  searchProcessedElement: function (elem) {
    var elements = this.processedElements;
    var i = 0;
    var len = elements.length;
    while (i < len) {
      if (elements[i].elem === elem) {
        return elements[i].pos;
      }
      i += 1;
    }
    return 0;
  },
  addProcessedElement: function (elem, pos) {
    var elements = this.processedElements;
    var i = elements.length;
    while (i) {
      i -= 1;
      if (elements[i].elem === elem) {
        elements[i].pos = pos;
        return;
      }
    }
    elements.push(new ProcessedElement(elem, pos));
  },
  prepareFrame: function (num) {
    this.prepareRenderableFrame(num);
    this.prepareProperties(num, this.isInRange);
  },
};

/* global TextProperty, TextAnimatorProperty, buildShapeString, LetterProps */

function ITextElement() {
}

ITextElement.prototype.initElement = function (data, globalData, comp) {
  this.lettersChangedFlag = true;
  this.initFrame();
  this.initBaseData(data, globalData, comp);
  this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
  this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
  this.initTransform(data, globalData, comp);
  this.initHierarchy();
  this.initRenderable();
  this.initRendererElement();
  this.createContainerElements();
  this.createRenderableComponents();
  this.createContent();
  this.hide();
  this.textAnimator.searchProperties(this.dynamicProperties);
};

ITextElement.prototype.prepareFrame = function (num) {
  this._mdf = false;
  this.prepareRenderableFrame(num);
  this.prepareProperties(num, this.isInRange);
  if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
    this.buildNewText();
    this.textProperty._isFirstFrame = false;
    this.textProperty._mdf = false;
  }
};

ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
  var j;
  var jLen = shapes.length;
  var pathNodes;
  var shapeStr = '';
  for (j = 0; j < jLen; j += 1) {
    pathNodes = shapes[j].ks.k;
    shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
  }
  return shapeStr;
};

ITextElement.prototype.updateDocumentData = function (newData, index) {
  this.textProperty.updateDocumentData(newData, index);
};

ITextElement.prototype.canResizeFont = function (_canResize) {
  this.textProperty.canResizeFont(_canResize);
};

ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
  this.textProperty.setMinimumFontSize(_fontSize);
};

ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
  if (documentData.ps) {
    matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
  }
  matrixHelper.translate(0, -documentData.ls, 0);
  switch (documentData.j) {
    case 1:
      matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
      break;
    case 2:
      matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
      break;
    default:
      break;
  }
  matrixHelper.translate(xPos, yPos, 0);
};

ITextElement.prototype.buildColor = function (colorData) {
  return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
};

ITextElement.prototype.emptyProp = new LetterProps();

ITextElement.prototype.destroy = function () {

};

/* global extendPrototype, BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement */

function ICompElement() {}

extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);

ICompElement.prototype.initElement = function (data, globalData, comp) {
  this.initFrame();
  this.initBaseData(data, globalData, comp);
  this.initTransform(data, globalData, comp);
  this.initRenderable();
  this.initHierarchy();
  this.initRendererElement();
  this.createContainerElements();
  this.createRenderableComponents();
  if (this.data.xt || !globalData.progressiveLoad) {
    this.buildAllItems();
  }
  this.hide();
};

/* ICompElement.prototype.hide = function(){
    if(!this.hidden){
        this.hideElement();
        var i,len = this.elements.length;
        for( i = 0; i < len; i+=1 ){
            if(this.elements[i]){
                this.elements[i].hide();
            }
        }
    }
}; */

ICompElement.prototype.prepareFrame = function (num) {
  this._mdf = false;
  this.prepareRenderableFrame(num);
  this.prepareProperties(num, this.isInRange);
  if (!this.isInRange && !this.data.xt) {
    return;
  }

  if (!this.tm._placeholder) {
    var timeRemapped = this.tm.v;
    if (timeRemapped === this.data.op) {
      timeRemapped = this.data.op - 1;
    }
    this.renderedFrame = timeRemapped;
  } else {
    this.renderedFrame = num / this.data.sr;
  }
  var i;
  var len = this.elements.length;
  if (!this.completeLayers) {
    this.checkLayers(this.renderedFrame);
  }
  // This iteration needs to be backwards because of how expressions connect between each other
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
      if (this.elements[i]._mdf) {
        this._mdf = true;
      }
    }
  }
};

ICompElement.prototype.renderInnerContent = function () {
  var i;
  var len = this.layers.length;
  for (i = 0; i < len; i += 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].renderFrame();
    }
  }
};

ICompElement.prototype.setElements = function (elems) {
  this.elements = elems;
};

ICompElement.prototype.getElements = function () {
  return this.elements;
};

ICompElement.prototype.destroyElements = function () {
  var i;
  var len = this.layers.length;
  for (i = 0; i < len; i += 1) {
    if (this.elements[i]) {
      this.elements[i].destroy();
    }
  }
};

ICompElement.prototype.destroy = function () {
  this.destroyElements();
  this.destroyBaseElement();
};

/* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, createNS */

function IImageElement(data, globalData, comp) {
  this.assetData = globalData.getAssetData(data.refId);
  this.initElement(data, globalData, comp);
  this.sourceRect = {
    top: 0, left: 0, width: this.assetData.w, height: this.assetData.h,
  };
}

extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);

IImageElement.prototype.createContent = function () {
  var assetPath = this.globalData.getAssetsPath(this.assetData);

  this.innerElem = createNS('image');
  this.innerElem.setAttribute('width', this.assetData.w + 'px');
  this.innerElem.setAttribute('height', this.assetData.h + 'px');
  this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
  this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);

  this.layerElement.appendChild(this.innerElem);
};

IImageElement.prototype.sourceRectAtTime = function () {
  return this.sourceRect;
};

/* global extendPrototype, IImageElement, createNS */

function ISolidElement(data, globalData, comp) {
  this.initElement(data, globalData, comp);
}
extendPrototype([IImageElement], ISolidElement);

ISolidElement.prototype.createContent = function () {
  var rect = createNS('rect');
  /// /rect.style.width = this.data.sw;
  /// /rect.style.height = this.data.sh;
  /// /rect.style.fill = this.data.sc;
  rect.setAttribute('width', this.data.sw);
  rect.setAttribute('height', this.data.sh);
  rect.setAttribute('fill', this.data.sc);
  this.layerElement.appendChild(rect);
};

/* global PropertyFactory, extendPrototype, RenderableElement, BaseElement, FrameElement */

function AudioElement(data, globalData, comp) {
  this.initFrame();
  this.initRenderable();
  this.assetData = globalData.getAssetData(data.refId);
  this.initBaseData(data, globalData, comp);
  this._isPlaying = false;
  this._canPlay = false;
  var assetPath = this.globalData.getAssetsPath(this.assetData);
  this.audio = this.globalData.audioController.createAudio(assetPath);
  this._currentTime = 0;
  this.globalData.audioController.addAudio(this);
  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
}

AudioElement.prototype.prepareFrame = function (num) {
  this.prepareRenderableFrame(num, true);
  this.prepareProperties(num, true);
  if (!this.tm._placeholder) {
    var timeRemapped = this.tm.v;
    this._currentTime = timeRemapped;
  } else {
    this._currentTime = num / this.data.sr;
  }
};

extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);

AudioElement.prototype.renderFrame = function () {
  if (this.isInRange && this._canPlay) {
    if (!this._isPlaying) {
      this.audio.play();
      this.audio.seek(this._currentTime / this.globalData.frameRate);
      this._isPlaying = true;
    } else if (!this.audio.playing()
      || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1
    ) {
      this.audio.seek(this._currentTime / this.globalData.frameRate);
    }
  }
};

AudioElement.prototype.show = function () {
  // this.audio.play()
};

AudioElement.prototype.hide = function () {
  this.audio.pause();
  this._isPlaying = false;
};

AudioElement.prototype.pause = function () {
  this.audio.pause();
  this._isPlaying = false;
  this._canPlay = false;
};

AudioElement.prototype.resume = function () {
  this._canPlay = true;
};

AudioElement.prototype.setRate = function (rateValue) {
  this.audio.rate(rateValue);
};

AudioElement.prototype.volume = function (volumeValue) {
  this.audio.volume(volumeValue);
};

AudioElement.prototype.getBaseElement = function () {
  return null;
};

AudioElement.prototype.destroy = function () {
};

AudioElement.prototype.sourceRectAtTime = function () {
};

AudioElement.prototype.initExpressions = function () {
};

/* global extendPrototype, RenderableElement, BaseElement, FrameElement, FootageInterface */

function FootageElement(data, globalData, comp) {
  this.initFrame();
  this.initRenderable();
  this.assetData = globalData.getAssetData(data.refId);
  this.footageData = globalData.imageLoader.getAsset(this.assetData);
  this.initBaseData(data, globalData, comp);
}

FootageElement.prototype.prepareFrame = function () {
};

extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);

FootageElement.prototype.getBaseElement = function () {
  return null;
};

FootageElement.prototype.renderFrame = function () {
};

FootageElement.prototype.destroy = function () {
};

FootageElement.prototype.initExpressions = function () {
  this.layerInterface = FootageInterface(this);
};

FootageElement.prototype.getFootageData = function () {
  return this.footageData;
};

/* global createSizedArray, PropertyFactory, extendPrototype, SVGRenderer, ICompElement, SVGBaseElement */

function SVGCompElement(data, globalData, comp) {
  this.layers = data.layers;
  this.supports3d = true;
  this.completeLayers = false;
  this.pendingElements = [];
  this.elements = this.layers ? createSizedArray(this.layers.length) : [];
  // this.layerElement = createNS('g');
  this.initElement(data, globalData, comp);
  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
}

extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);

/* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement,
RenderableDOMElement, ITextElement, createSizedArray, createNS */

function SVGTextLottieElement(data, globalData, comp) {
  this.textSpans = [];
  this.renderType = 'svg';
  this.initElement(data, globalData, comp);
}

extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);

SVGTextLottieElement.prototype.createContent = function () {
  if (this.data.singleShape && !this.globalData.fontManager.chars) {
    this.textContainer = createNS('text');
  }
};

SVGTextLottieElement.prototype.buildTextContents = function (textArray) {
  var i = 0;
  var len = textArray.length;
  var textContents = [];
  var currentTextContent = '';
  while (i < len) {
    if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
      textContents.push(currentTextContent);
      currentTextContent = '';
    } else {
      currentTextContent += textArray[i];
    }
    i += 1;
  }
  textContents.push(currentTextContent);
  return textContents;
};

SVGTextLottieElement.prototype.buildNewText = function () {
  var i;
  var len;

  var documentData = this.textProperty.currentData;
  this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
  if (documentData.fc) {
    this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
  } else {
    this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
  }
  if (documentData.sc) {
    this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
    this.layerElement.setAttribute('stroke-width', documentData.sw);
  }
  this.layerElement.setAttribute('font-size', documentData.finalSize);
  var fontData = this.globalData.fontManager.getFontByName(documentData.f);
  if (fontData.fClass) {
    this.layerElement.setAttribute('class', fontData.fClass);
  } else {
    this.layerElement.setAttribute('font-family', fontData.fFamily);
    var fWeight = documentData.fWeight;
    var fStyle = documentData.fStyle;
    this.layerElement.setAttribute('font-style', fStyle);
    this.layerElement.setAttribute('font-weight', fWeight);
  }
  this.layerElement.setAttribute('aria-label', documentData.t);

  var letters = documentData.l || [];
  var usesGlyphs = !!this.globalData.fontManager.chars;
  len = letters.length;

  var tSpan;
  var matrixHelper = this.mHelper;
  var shapes;
  var shapeStr = '';
  var singleShape = this.data.singleShape;
  var xPos = 0;
  var yPos = 0;
  var firstLine = true;
  var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
  if (singleShape && !usesGlyphs && !documentData.sz) {
    var tElement = this.textContainer;
    var justify = 'start';
    switch (documentData.j) {
      case 1:
        justify = 'end';
        break;
      case 2:
        justify = 'middle';
        break;
      default:
        justify = 'start';
        break;
    }
    tElement.setAttribute('text-anchor', justify);
    tElement.setAttribute('letter-spacing', trackingOffset);
    var textContent = this.buildTextContents(documentData.finalText);
    len = textContent.length;
    yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
    for (i = 0; i < len; i += 1) {
      tSpan = this.textSpans[i] || createNS('tspan');
      tSpan.textContent = textContent[i];
      tSpan.setAttribute('x', 0);
      tSpan.setAttribute('y', yPos);
      tSpan.style.display = 'inherit';
      tElement.appendChild(tSpan);
      this.textSpans[i] = tSpan;
      yPos += documentData.finalLineHeight;
    }

    this.layerElement.appendChild(tElement);
  } else {
    var cachedSpansLength = this.textSpans.length;
    var shapeData;
    var charData;
    for (i = 0; i < len; i += 1) {
      if (!usesGlyphs || !singleShape || i === 0) {
        tSpan = cachedSpansLength > i ? this.textSpans[i] : createNS(usesGlyphs ? 'path' : 'text');
        if (cachedSpansLength <= i) {
          tSpan.setAttribute('stroke-linecap', 'butt');
          tSpan.setAttribute('stroke-linejoin', 'round');
          tSpan.setAttribute('stroke-miterlimit', '4');
          this.textSpans[i] = tSpan;
          this.layerElement.appendChild(tSpan);
        }
        tSpan.style.display = 'inherit';
      }

      matrixHelper.reset();
      matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
      if (singleShape) {
        if (letters[i].n) {
          xPos = -trackingOffset;
          yPos += documentData.yOffset;
          yPos += firstLine ? 1 : 0;
          firstLine = false;
        }
        this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
        xPos += letters[i].l || 0;
        // xPos += letters[i].val === ' ' ? 0 : trackingOffset;
        xPos += trackingOffset;
      }
      if (usesGlyphs) {
        charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
        shapeData = (charData && charData.data) || {};
        shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
        if (!singleShape) {
          tSpan.setAttribute('d', this.createPathShape(matrixHelper, shapes));
        } else {
          shapeStr += this.createPathShape(matrixHelper, shapes);
        }
      } else {
        if (singleShape) {
          tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');
        }
        tSpan.textContent = letters[i].val;
        tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
      }
      //
    }
    if (singleShape && tSpan) {
      tSpan.setAttribute('d', shapeStr);
    }
  }
  while (i < this.textSpans.length) {
    this.textSpans[i].style.display = 'none';
    i += 1;
  }

  this._sizeChanged = true;
};

SVGTextLottieElement.prototype.sourceRectAtTime = function () {
  this.prepareFrame(this.comp.renderedFrame - this.data.st);
  this.renderInnerContent();
  if (this._sizeChanged) {
    this._sizeChanged = false;
    var textBox = this.layerElement.getBBox();
    this.bbox = {
      top: textBox.y,
      left: textBox.x,
      width: textBox.width,
      height: textBox.height,
    };
  }
  return this.bbox;
};

SVGTextLottieElement.prototype.renderInnerContent = function () {
  if (!this.data.singleShape) {
    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
    if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
      this._sizeChanged = true;
      var i;
      var len;
      var renderedLetters = this.textAnimator.renderedLetters;

      var letters = this.textProperty.currentData.l;

      len = letters.length;
      var renderedLetter;
      var textSpan;
      for (i = 0; i < len; i += 1) {
        if (!letters[i].n) {
          renderedLetter = renderedLetters[i];
          textSpan = this.textSpans[i];
          if (renderedLetter._mdf.m) {
            textSpan.setAttribute('transform', renderedLetter.m);
          }
          if (renderedLetter._mdf.o) {
            textSpan.setAttribute('opacity', renderedLetter.o);
          }
          if (renderedLetter._mdf.sw) {
            textSpan.setAttribute('stroke-width', renderedLetter.sw);
          }
          if (renderedLetter._mdf.sc) {
            textSpan.setAttribute('stroke', renderedLetter.sc);
          }
          if (renderedLetter._mdf.fc) {
            textSpan.setAttribute('fill', renderedLetter.fc);
          }
        }
      }
    }
  }
};

/* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement,
FrameElement, RenderableDOMElement, Matrix, SVGStyleData, SVGStrokeStyleData, SVGFillStyleData,
SVGGradientFillStyleData, SVGGradientStrokeStyleData, locationHref, getBlendMode, ShapeGroupData,
TransformPropertyFactory, SVGTransformData, ShapePropertyFactory, SVGShapeData, SVGElementsRenderer, ShapeModifiers,
lineCapEnum, lineJoinEnum */

function SVGShapeElement(data, globalData, comp) {
  // List of drawable elements
  this.shapes = [];
  // Full shape data
  this.shapesData = data.shapes;
  // List of styles that will be applied to shapes
  this.stylesList = [];
  // List of modifiers that will be applied to shapes
  this.shapeModifiers = [];
  // List of items in shape tree
  this.itemsData = [];
  // List of items in previous shape tree
  this.processedElements = [];
  // List of animated components
  this.animatedContents = [];
  this.initElement(data, globalData, comp);
  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
  // List of elements that have been created
  this.prevViewData = [];
  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
}

extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);

SVGShapeElement.prototype.initSecondaryElement = function () {
};

SVGShapeElement.prototype.identityMatrix = new Matrix();

SVGShapeElement.prototype.buildExpressionInterface = function () {};

SVGShapeElement.prototype.createContent = function () {
  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
  this.filterUniqueShapes();
};

/*
This method searches for multiple shapes that affect a single element and one of them is animated
*/
SVGShapeElement.prototype.filterUniqueShapes = function () {
  var i;
  var len = this.shapes.length;
  var shape;
  var j;
  var jLen = this.stylesList.length;
  var style;
  var tempShapes = [];
  var areAnimated = false;
  for (j = 0; j < jLen; j += 1) {
    style = this.stylesList[j];
    areAnimated = false;
    tempShapes.length = 0;
    for (i = 0; i < len; i += 1) {
      shape = this.shapes[i];
      if (shape.styles.indexOf(style) !== -1) {
        tempShapes.push(shape);
        areAnimated = shape._isAnimated || areAnimated;
      }
    }
    if (tempShapes.length > 1 && areAnimated) {
      this.setShapesAsAnimated(tempShapes);
    }
  }
};

SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
  var i;
  var len = shapes.length;
  for (i = 0; i < len; i += 1) {
    shapes[i].setAsAnimated();
  }
};

SVGShapeElement.prototype.createStyleElement = function (data, level) {
  // TODO: prevent drawing of hidden styles
  var elementData;
  var styleOb = new SVGStyleData(data, level);

  var pathElement = styleOb.pElem;
  if (data.ty === 'st') {
    elementData = new SVGStrokeStyleData(this, data, styleOb);
  } else if (data.ty === 'fl') {
    elementData = new SVGFillStyleData(this, data, styleOb);
  } else if (data.ty === 'gf' || data.ty === 'gs') {
    var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
    elementData = new GradientConstructor(this, data, styleOb);
    this.globalData.defs.appendChild(elementData.gf);
    if (elementData.maskId) {
      this.globalData.defs.appendChild(elementData.ms);
      this.globalData.defs.appendChild(elementData.of);
      pathElement.setAttribute('mask', 'url(' + locationHref + '#' + elementData.maskId + ')');
    }
  }

  if (data.ty === 'st' || data.ty === 'gs') {
    pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
    pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
    pathElement.setAttribute('fill-opacity', '0');
    if (data.lj === 1) {
      pathElement.setAttribute('stroke-miterlimit', data.ml);
    }
  }

  if (data.r === 2) {
    pathElement.setAttribute('fill-rule', 'evenodd');
  }

  if (data.ln) {
    pathElement.setAttribute('id', data.ln);
  }
  if (data.cl) {
    pathElement.setAttribute('class', data.cl);
  }
  if (data.bm) {
    pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
  }
  this.stylesList.push(styleOb);
  this.addToAnimatedContents(data, elementData);
  return elementData;
};

SVGShapeElement.prototype.createGroupElement = function (data) {
  var elementData = new ShapeGroupData();
  if (data.ln) {
    elementData.gr.setAttribute('id', data.ln);
  }
  if (data.cl) {
    elementData.gr.setAttribute('class', data.cl);
  }
  if (data.bm) {
    elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
  }
  return elementData;
};

SVGShapeElement.prototype.createTransformElement = function (data, container) {
  var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
  var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
  this.addToAnimatedContents(data, elementData);
  return elementData;
};

SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
  var ty = 4;
  if (data.ty === 'rc') {
    ty = 5;
  } else if (data.ty === 'el') {
    ty = 6;
  } else if (data.ty === 'sr') {
    ty = 7;
  }
  var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
  var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
  this.shapes.push(elementData);
  this.addShapeToModifiers(elementData);
  this.addToAnimatedContents(data, elementData);
  return elementData;
};

SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
  var i = 0;
  var len = this.animatedContents.length;
  while (i < len) {
    if (this.animatedContents[i].element === element) {
      return;
    }
    i += 1;
  }
  this.animatedContents.push({
    fn: SVGElementsRenderer.createRenderFunction(data),
    element: element,
    data: data,
  });
};

SVGShapeElement.prototype.setElementStyles = function (elementData) {
  var arr = elementData.styles;
  var j;
  var jLen = this.stylesList.length;
  for (j = 0; j < jLen; j += 1) {
    if (!this.stylesList[j].closed) {
      arr.push(this.stylesList[j]);
    }
  }
};

SVGShapeElement.prototype.reloadShapes = function () {
  this._isFirstFrame = true;
  var i;
  var len = this.itemsData.length;
  for (i = 0; i < len; i += 1) {
    this.prevViewData[i] = this.itemsData[i];
  }
  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
  this.filterUniqueShapes();
  len = this.dynamicProperties.length;
  for (i = 0; i < len; i += 1) {
    this.dynamicProperties[i].getValue();
  }
  this.renderModifiers();
};

SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
  var ownTransformers = [].concat(transformers);
  var i;
  var len = arr.length - 1;
  var j;
  var jLen;
  var ownStyles = [];
  var ownModifiers = [];
  var currentTransform;
  var modifier;
  var processedPos;
  for (i = len; i >= 0; i -= 1) {
    processedPos = this.searchProcessedElement(arr[i]);
    if (!processedPos) {
      arr[i]._render = render;
    } else {
      itemsData[i] = prevViewData[processedPos - 1];
    }
    if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
      if (!processedPos) {
        itemsData[i] = this.createStyleElement(arr[i], level);
      } else {
        itemsData[i].style.closed = false;
      }
      if (arr[i]._render) {
        container.appendChild(itemsData[i].style.pElem);
      }
      ownStyles.push(itemsData[i].style);
    } else if (arr[i].ty === 'gr') {
      if (!processedPos) {
        itemsData[i] = this.createGroupElement(arr[i]);
      } else {
        jLen = itemsData[i].it.length;
        for (j = 0; j < jLen; j += 1) {
          itemsData[i].prevViewData[j] = itemsData[i].it[j];
        }
      }
      this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
      if (arr[i]._render) {
        container.appendChild(itemsData[i].gr);
      }
    } else if (arr[i].ty === 'tr') {
      if (!processedPos) {
        itemsData[i] = this.createTransformElement(arr[i], container);
      }
      currentTransform = itemsData[i].transform;
      ownTransformers.push(currentTransform);
    } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
      if (!processedPos) {
        itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
      }
      this.setElementStyles(itemsData[i]);
    } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb') {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty);
        modifier.init(this, arr[i]);
        itemsData[i] = modifier;
        this.shapeModifiers.push(modifier);
      } else {
        modifier = itemsData[i];
        modifier.closed = false;
      }
      ownModifiers.push(modifier);
    } else if (arr[i].ty === 'rp') {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty);
        itemsData[i] = modifier;
        modifier.init(this, arr, i, itemsData);
        this.shapeModifiers.push(modifier);
        render = false;
      } else {
        modifier = itemsData[i];
        modifier.closed = true;
      }
      ownModifiers.push(modifier);
    }
    this.addProcessedElement(arr[i], i + 1);
  }
  len = ownStyles.length;
  for (i = 0; i < len; i += 1) {
    ownStyles[i].closed = true;
  }
  len = ownModifiers.length;
  for (i = 0; i < len; i += 1) {
    ownModifiers[i].closed = true;
  }
};

SVGShapeElement.prototype.renderInnerContent = function () {
  this.renderModifiers();
  var i;
  var len = this.stylesList.length;
  for (i = 0; i < len; i += 1) {
    this.stylesList[i].reset();
  }
  this.renderShape();

  for (i = 0; i < len; i += 1) {
    if (this.stylesList[i]._mdf || this._isFirstFrame) {
      if (this.stylesList[i].msElem) {
        this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
        // Adding M0 0 fixes same mask bug on all browsers
        this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
      }
      this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
    }
  }
};

SVGShapeElement.prototype.renderShape = function () {
  var i;
  var len = this.animatedContents.length;
  var animatedContent;
  for (i = 0; i < len; i += 1) {
    animatedContent = this.animatedContents[i];
    if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
      animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
    }
  }
};

SVGShapeElement.prototype.destroy = function () {
  this.destroyBaseElement();
  this.shapesData = null;
  this.itemsData = null;
};

/* global createNS */

function SVGTintFilter(filter, filterManager) {
  this.filterManager = filterManager;
  var feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
  feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
  feColorMatrix.setAttribute('result', 'f1');
  filter.appendChild(feColorMatrix);
  feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
  feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
  feColorMatrix.setAttribute('result', 'f2');
  filter.appendChild(feColorMatrix);
  this.matrixFilter = feColorMatrix;
  if (filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k) {
    var feMerge = createNS('feMerge');
    filter.appendChild(feMerge);
    var feMergeNode;
    feMergeNode = createNS('feMergeNode');
    feMergeNode.setAttribute('in', 'SourceGraphic');
    feMerge.appendChild(feMergeNode);
    feMergeNode = createNS('feMergeNode');
    feMergeNode.setAttribute('in', 'f2');
    feMerge.appendChild(feMergeNode);
  }
}

SVGTintFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var colorBlack = this.filterManager.effectElements[0].p.v;
    var colorWhite = this.filterManager.effectElements[1].p.v;
    var opacity = this.filterManager.effectElements[2].p.v / 100;
    this.matrixFilter.setAttribute('values', (colorWhite[0] - colorBlack[0]) + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 ' + opacity + ' 0');
  }
};

/* global createNS */

function SVGFillFilter(filter, filterManager) {
  this.filterManager = filterManager;
  var feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
  feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
  filter.appendChild(feColorMatrix);
  this.matrixFilter = feColorMatrix;
}
SVGFillFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var color = this.filterManager.effectElements[2].p.v;
    var opacity = this.filterManager.effectElements[6].p.v;
    this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
  }
};

/* global createNS */

function SVGGaussianBlurEffect(filter, filterManager) {
  // Outset the filter region by 100% on all sides to accommodate blur expansion.
  filter.setAttribute('x', '-100%');
  filter.setAttribute('y', '-100%');
  filter.setAttribute('width', '300%');
  filter.setAttribute('height', '300%');

  this.filterManager = filterManager;
  var feGaussianBlur = createNS('feGaussianBlur');
  filter.appendChild(feGaussianBlur);
  this.feGaussianBlur = feGaussianBlur;
}

SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    // Empirical value, matching AE's blur appearance.
    var kBlurrinessToSigma = 0.3;
    var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;

    // Dimensions mapping:
    //
    //   1 -> horizontal & vertical
    //   2 -> horizontal only
    //   3 -> vertical only
    //
    var dimensions = this.filterManager.effectElements[1].p.v;
    var sigmaX = (dimensions == 3) ? 0 : sigma; // eslint-disable-line eqeqeq
    var sigmaY = (dimensions == 2) ? 0 : sigma; // eslint-disable-line eqeqeq

    this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY);

    // Repeat edges mapping:
    //
    //   0 -> off -> duplicate
    //   1 -> on  -> wrap
    var edgeMode = (this.filterManager.effectElements[2].p.v == 1) ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq
    this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
  }
};

/* global createNS, createElementID, locationHref, bmFloor */

function SVGStrokeEffect(elem, filterManager) {
  this.initialized = false;
  this.filterManager = filterManager;
  this.elem = elem;
  this.paths = [];
}

SVGStrokeEffect.prototype.initialize = function () {
  var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
  var path;
  var groupPath;
  var i;
  var len;
  if (this.filterManager.effectElements[1].p.v === 1) {
    len = this.elem.maskManager.masksProperties.length;
    i = 0;
  } else {
    i = this.filterManager.effectElements[0].p.v - 1;
    len = i + 1;
  }
  groupPath = createNS('g');
  groupPath.setAttribute('fill', 'none');
  groupPath.setAttribute('stroke-linecap', 'round');
  groupPath.setAttribute('stroke-dashoffset', 1);
  for (i; i < len; i += 1) {
    path = createNS('path');
    groupPath.appendChild(path);
    this.paths.push({ p: path, m: i });
  }
  if (this.filterManager.effectElements[10].p.v === 3) {
    var mask = createNS('mask');
    var id = createElementID();
    mask.setAttribute('id', id);
    mask.setAttribute('mask-type', 'alpha');
    mask.appendChild(groupPath);
    this.elem.globalData.defs.appendChild(mask);
    var g = createNS('g');
    g.setAttribute('mask', 'url(' + locationHref + '#' + id + ')');
    while (elemChildren[0]) {
      g.appendChild(elemChildren[0]);
    }
    this.elem.layerElement.appendChild(g);
    this.masker = mask;
    groupPath.setAttribute('stroke', '#fff');
  } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
    if (this.filterManager.effectElements[10].p.v === 2) {
      elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
      while (elemChildren.length) {
        this.elem.layerElement.removeChild(elemChildren[0]);
      }
    }
    this.elem.layerElement.appendChild(groupPath);
    this.elem.layerElement.removeAttribute('mask');
    groupPath.setAttribute('stroke', '#fff');
  }
  this.initialized = true;
  this.pathMasker = groupPath;
};

SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
  if (!this.initialized) {
    this.initialize();
  }
  var i;
  var len = this.paths.length;
  var mask;
  var path;
  for (i = 0; i < len; i += 1) {
    if (this.paths[i].m !== -1) {
      mask = this.elem.maskManager.viewData[this.paths[i].m];
      path = this.paths[i].p;
      if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
        path.setAttribute('d', mask.lastPath);
      }
      if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
        var dasharrayValue;
        if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
          var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
          var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
          var l = path.getTotalLength();
          dasharrayValue = '0 0 0 ' + l * s + ' ';
          var lineLength = l * (e - s);
          var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
          var units = Math.floor(lineLength / segment);
          var j;
          for (j = 0; j < units; j += 1) {
            dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
          }
          dasharrayValue += '0 ' + l * 10 + ' 0 0';
        } else {
          dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
        }
        path.setAttribute('stroke-dasharray', dasharrayValue);
      }
    }
  }
  if (forceRender || this.filterManager.effectElements[4].p._mdf) {
    this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
  }

  if (forceRender || this.filterManager.effectElements[6].p._mdf) {
    this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
  }
  if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
    if (forceRender || this.filterManager.effectElements[3].p._mdf) {
      var color = this.filterManager.effectElements[3].p.v;
      this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
    }
  }
};

/* global createNS */

function SVGTritoneFilter(filter, filterManager) {
  this.filterManager = filterManager;
  var feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
  feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
  feColorMatrix.setAttribute('result', 'f1');
  filter.appendChild(feColorMatrix);
  var feComponentTransfer = createNS('feComponentTransfer');
  feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
  filter.appendChild(feComponentTransfer);
  this.matrixFilter = feComponentTransfer;
  var feFuncR = createNS('feFuncR');
  feFuncR.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFuncR);
  this.feFuncR = feFuncR;
  var feFuncG = createNS('feFuncG');
  feFuncG.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFuncG);
  this.feFuncG = feFuncG;
  var feFuncB = createNS('feFuncB');
  feFuncB.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFuncB);
  this.feFuncB = feFuncB;
}

SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var color1 = this.filterManager.effectElements[0].p.v;
    var color2 = this.filterManager.effectElements[1].p.v;
    var color3 = this.filterManager.effectElements[2].p.v;
    var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
    var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
    var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
    this.feFuncR.setAttribute('tableValues', tableR);
    this.feFuncG.setAttribute('tableValues', tableG);
    this.feFuncB.setAttribute('tableValues', tableB);
    // var opacity = this.filterManager.effectElements[2].p.v/100;
    // this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
  }
};

/* global createNS */

function SVGProLevelsFilter(filter, filterManager) {
  this.filterManager = filterManager;
  var effectElements = this.filterManager.effectElements;
  var feComponentTransfer = createNS('feComponentTransfer');

  if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
    this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
  }
  if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
    this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
  }
  if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
    this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
  }
  if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
    this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
  }

  if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
    filter.appendChild(feComponentTransfer);
    feComponentTransfer = createNS('feComponentTransfer');
  }

  if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
    filter.appendChild(feComponentTransfer);
    this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
    this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
    this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
  }
}

SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
  var feFunc = createNS(type);
  feFunc.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFunc);
  return feFunc;
};

SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
  var cnt = 0;
  var segments = 256;
  var perc;
  var min = Math.min(inputBlack, inputWhite);
  var max = Math.max(inputBlack, inputWhite);
  var table = Array.call(null, { length: segments });
  var colorValue;
  var pos = 0;
  var outputDelta = outputWhite - outputBlack;
  var inputDelta = inputWhite - inputBlack;
  while (cnt <= 256) {
    perc = cnt / 256;
    if (perc <= min) {
      colorValue = inputDelta < 0 ? outputWhite : outputBlack;
    } else if (perc >= max) {
      colorValue = inputDelta < 0 ? outputBlack : outputWhite;
    } else {
      colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));
    }
    table[pos] = colorValue;
    pos += 1;
    cnt += 256 / (segments - 1);
  }
  return table.join(' ');
};

SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var val;
    var effectElements = this.filterManager.effectElements;
    if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
      val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
      this.feFuncRComposed.setAttribute('tableValues', val);
      this.feFuncGComposed.setAttribute('tableValues', val);
      this.feFuncBComposed.setAttribute('tableValues', val);
    }

    if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
      val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
      this.feFuncR.setAttribute('tableValues', val);
    }

    if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
      val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
      this.feFuncG.setAttribute('tableValues', val);
    }

    if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
      val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
      this.feFuncB.setAttribute('tableValues', val);
    }

    if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
      val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
      this.feFuncA.setAttribute('tableValues', val);
    }
  }
};

/* global createNS, rgbToHex, degToRads */

function SVGDropShadowEffect(filter, filterManager) {
  var filterSize = filterManager.container.globalData.renderConfig.filterSize;
  filter.setAttribute('x', filterSize.x);
  filter.setAttribute('y', filterSize.y);
  filter.setAttribute('width', filterSize.width);
  filter.setAttribute('height', filterSize.height);
  this.filterManager = filterManager;

  var feGaussianBlur = createNS('feGaussianBlur');
  feGaussianBlur.setAttribute('in', 'SourceAlpha');
  feGaussianBlur.setAttribute('result', 'drop_shadow_1');
  feGaussianBlur.setAttribute('stdDeviation', '0');
  this.feGaussianBlur = feGaussianBlur;
  filter.appendChild(feGaussianBlur);

  var feOffset = createNS('feOffset');
  feOffset.setAttribute('dx', '25');
  feOffset.setAttribute('dy', '0');
  feOffset.setAttribute('in', 'drop_shadow_1');
  feOffset.setAttribute('result', 'drop_shadow_2');
  this.feOffset = feOffset;
  filter.appendChild(feOffset);
  var feFlood = createNS('feFlood');
  feFlood.setAttribute('flood-color', '#00ff00');
  feFlood.setAttribute('flood-opacity', '1');
  feFlood.setAttribute('result', 'drop_shadow_3');
  this.feFlood = feFlood;
  filter.appendChild(feFlood);

  var feComposite = createNS('feComposite');
  feComposite.setAttribute('in', 'drop_shadow_3');
  feComposite.setAttribute('in2', 'drop_shadow_2');
  feComposite.setAttribute('operator', 'in');
  feComposite.setAttribute('result', 'drop_shadow_4');
  filter.appendChild(feComposite);

  var feMerge = createNS('feMerge');
  filter.appendChild(feMerge);
  var feMergeNode;
  feMergeNode = createNS('feMergeNode');
  feMerge.appendChild(feMergeNode);
  feMergeNode = createNS('feMergeNode');
  feMergeNode.setAttribute('in', 'SourceGraphic');
  this.feMergeNode = feMergeNode;
  this.feMerge = feMerge;
  this.originalNodeAdded = false;
  feMerge.appendChild(feMergeNode);
}

SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    if (forceRender || this.filterManager.effectElements[4].p._mdf) {
      this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
    }
    if (forceRender || this.filterManager.effectElements[0].p._mdf) {
      var col = this.filterManager.effectElements[0].p.v;
      this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
    }
    if (forceRender || this.filterManager.effectElements[1].p._mdf) {
      this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
    }
    if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
      var distance = this.filterManager.effectElements[3].p.v;
      var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
      var x = distance * Math.cos(angle);
      var y = distance * Math.sin(angle);
      this.feOffset.setAttribute('dx', x);
      this.feOffset.setAttribute('dy', y);
    }
    /* if(forceRender || this.filterManager.effectElements[5].p._mdf){
            if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
                this.feMerge.removeChild(this.feMergeNode);
                this.originalNodeAdded = false;
            } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
                this.feMerge.appendChild(this.feMergeNode);
                this.originalNodeAdded = true;
            }
        } */
  }
};

/* global createElementID, createNS */

var _svgMatteSymbols = [];

function SVGMatte3Effect(filterElem, filterManager, elem) {
  this.initialized = false;
  this.filterManager = filterManager;
  this.filterElem = filterElem;
  this.elem = elem;
  elem.matteElement = createNS('g');
  elem.matteElement.appendChild(elem.layerElement);
  elem.matteElement.appendChild(elem.transformedElement);
  elem.baseElement = elem.matteElement;
}

SVGMatte3Effect.prototype.findSymbol = function (mask) {
  var i = 0;
  var len = _svgMatteSymbols.length;
  while (i < len) {
    if (_svgMatteSymbols[i] === mask) {
      return _svgMatteSymbols[i];
    }
    i += 1;
  }
  return null;
};

SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
  var parentNode = mask.layerElement.parentNode;
  if (!parentNode) {
    return;
  }
  var children = parentNode.children;
  var i = 0;
  var len = children.length;
  while (i < len) {
    if (children[i] === mask.layerElement) {
      break;
    }
    i += 1;
  }
  var nextChild;
  if (i <= len - 2) {
    nextChild = children[i + 1];
  }
  var useElem = createNS('use');
  useElem.setAttribute('href', '#' + symbolId);
  if (nextChild) {
    parentNode.insertBefore(useElem, nextChild);
  } else {
    parentNode.appendChild(useElem);
  }
};

SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
  if (!this.findSymbol(mask)) {
    var symbolId = createElementID();
    var masker = createNS('mask');
    masker.setAttribute('id', mask.layerId);
    masker.setAttribute('mask-type', 'alpha');
    _svgMatteSymbols.push(mask);
    var defs = elem.globalData.defs;
    defs.appendChild(masker);
    var symbol = createNS('symbol');
    symbol.setAttribute('id', symbolId);
    this.replaceInParent(mask, symbolId);
    symbol.appendChild(mask.layerElement);
    defs.appendChild(symbol);
    var useElem = createNS('use');
    useElem.setAttribute('href', '#' + symbolId);
    masker.appendChild(useElem);
    mask.data.hd = false;
    mask.show();
  }
  elem.setMatte(mask.layerId);
};

SVGMatte3Effect.prototype.initialize = function () {
  var ind = this.filterManager.effectElements[0].p.v;
  var elements = this.elem.comp.elements;
  var i = 0;
  var len = elements.length;
  while (i < len) {
    if (elements[i] && elements[i].data.ind === ind) {
      this.setElementAsMask(this.elem, elements[i]);
    }
    i += 1;
  }
  this.initialized = true;
};

SVGMatte3Effect.prototype.renderFrame = function () {
  if (!this.initialized) {
    this.initialize();
  }
};

/* global createElementID, filtersFactory, SVGTintFilter, SVGFillFilter, SVGStrokeEffect, SVGTritoneFilter,
SVGProLevelsFilter, SVGDropShadowEffect, SVGMatte3Effect, SVGGaussianBlurEffect, locationHref */

function SVGEffects(elem) {
  var i;
  var len = elem.data.ef ? elem.data.ef.length : 0;
  var filId = createElementID();
  var fil = filtersFactory.createFilter(filId, true);
  var count = 0;
  this.filters = [];
  var filterManager;
  for (i = 0; i < len; i += 1) {
    filterManager = null;
    if (elem.data.ef[i].ty === 20) {
      count += 1;
      filterManager = new SVGTintFilter(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 21) {
      count += 1;
      filterManager = new SVGFillFilter(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 22) {
      filterManager = new SVGStrokeEffect(elem, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 23) {
      count += 1;
      filterManager = new SVGTritoneFilter(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 24) {
      count += 1;
      filterManager = new SVGProLevelsFilter(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 25) {
      count += 1;
      filterManager = new SVGDropShadowEffect(fil, elem.effectsManager.effectElements[i]);
    } else if (elem.data.ef[i].ty === 28) {
      // count += 1;
      filterManager = new SVGMatte3Effect(fil, elem.effectsManager.effectElements[i], elem);
    } else if (elem.data.ef[i].ty === 29) {
      count += 1;
      filterManager = new SVGGaussianBlurEffect(fil, elem.effectsManager.effectElements[i]);
    }
    if (filterManager) {
      this.filters.push(filterManager);
    }
  }
  if (count) {
    elem.globalData.defs.appendChild(fil);
    elem.layerElement.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
  }
  if (this.filters.length) {
    elem.addRenderableComponent(this);
  }
}

SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
  var i;
  var len = this.filters.length;
  for (i = 0; i < len; i += 1) {
    this.filters[i].renderFrame(_isFirstFrame);
  }
};

/* global Matrix, createTypedArray */

function CVContextData() {
  this.saved = [];
  this.cArrPos = 0;
  this.cTr = new Matrix();
  this.cO = 1;
  var i;
  var len = 15;
  this.savedOp = createTypedArray('float32', len);
  for (i = 0; i < len; i += 1) {
    this.saved[i] = createTypedArray('float32', 16);
  }
  this._length = len;
}

CVContextData.prototype.duplicate = function () {
  var newLength = this._length * 2;
  var currentSavedOp = this.savedOp;
  this.savedOp = createTypedArray('float32', newLength);
  this.savedOp.set(currentSavedOp);
  var i = 0;
  for (i = this._length; i < newLength; i += 1) {
    this.saved[i] = createTypedArray('float32', 16);
  }
  this._length = newLength;
};

CVContextData.prototype.reset = function () {
  this.cArrPos = 0;
  this.cTr.reset();
  this.cO = 1;
};

/* global CVEffects, getBlendMode, CVMaskElement, Matrix */

function CVBaseElement() {
}

CVBaseElement.prototype = {
  createElements: function () {},
  initRendererElement: function () {},
  createContainerElements: function () {
    this.canvasContext = this.globalData.canvasContext;
    this.renderableEffectsManager = new CVEffects(this);
  },
  createContent: function () {},
  setBlendMode: function () {
    var globalData = this.globalData;
    if (globalData.blendMode !== this.data.bm) {
      globalData.blendMode = this.data.bm;
      var blendModeValue = getBlendMode(this.data.bm);
      globalData.canvasContext.globalCompositeOperation = blendModeValue;
    }
  },
  createRenderableComponents: function () {
    this.maskManager = new CVMaskElement(this.data, this);
  },
  hideElement: function () {
    if (!this.hidden && (!this.isInRange || this.isTransparent)) {
      this.hidden = true;
    }
  },
  showElement: function () {
    if (this.isInRange && !this.isTransparent) {
      this.hidden = false;
      this._isFirstFrame = true;
      this.maskManager._isFirstFrame = true;
    }
  },
  renderFrame: function () {
    if (this.hidden || this.data.hd) {
      return;
    }
    this.renderTransform();
    this.renderRenderable();
    this.setBlendMode();
    var forceRealStack = this.data.ty === 0;
    this.globalData.renderer.save(forceRealStack);
    this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
    this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);
    this.renderInnerContent();
    this.globalData.renderer.restore(forceRealStack);
    if (this.maskManager.hasMasks) {
      this.globalData.renderer.restore(true);
    }
    if (this._isFirstFrame) {
      this._isFirstFrame = false;
    }
  },
  destroy: function () {
    this.canvasContext = null;
    this.data = null;
    this.globalData = null;
    this.maskManager.destroy();
  },
  mHelper: new Matrix(),
};
CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

/* global extendPrototype, BaseElement, TransformElement, CVBaseElement,HierarchyElement, FrameElement,
RenderableElement, SVGShapeElement, IImageElement, createTag */

function CVImageElement(data, globalData, comp) {
  this.assetData = globalData.getAssetData(data.refId);
  this.img = globalData.imageLoader.getAsset(this.assetData);
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);

CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

CVImageElement.prototype.createContent = function () {
  if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
    var canvas = createTag('canvas');
    canvas.width = this.assetData.w;
    canvas.height = this.assetData.h;
    var ctx = canvas.getContext('2d');

    var imgW = this.img.width;
    var imgH = this.img.height;
    var imgRel = imgW / imgH;
    var canvasRel = this.assetData.w / this.assetData.h;
    var widthCrop;
    var heightCrop;
    var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
    if ((imgRel > canvasRel && par === 'xMidYMid slice') || (imgRel < canvasRel && par !== 'xMidYMid slice')) {
      heightCrop = imgH;
      widthCrop = heightCrop * canvasRel;
    } else {
      widthCrop = imgW;
      heightCrop = widthCrop / canvasRel;
    }
    ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
    this.img = canvas;
  }
};

CVImageElement.prototype.renderInnerContent = function () {
  this.canvasContext.drawImage(this.img, 0, 0);
};

CVImageElement.prototype.destroy = function () {
  this.img = null;
};

/* global createSizedArray, PropertyFactory, extendPrototype, CanvasRenderer, ICompElement, CVBaseElement */

function CVCompElement(data, globalData, comp) {
  this.completeLayers = false;
  this.layers = data.layers;
  this.pendingElements = [];
  this.elements = createSizedArray(this.layers.length);
  this.initElement(data, globalData, comp);
  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
}

extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement);

CVCompElement.prototype.renderInnerContent = function () {
  var ctx = this.canvasContext;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(this.data.w, 0);
  ctx.lineTo(this.data.w, this.data.h);
  ctx.lineTo(0, this.data.h);
  ctx.lineTo(0, 0);
  ctx.clip();
  var i;
  var len = this.layers.length;
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].renderFrame();
    }
  }
};

CVCompElement.prototype.destroy = function () {
  var i;
  var len = this.layers.length;
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.elements[i]) {
      this.elements[i].destroy();
    }
  }
  this.layers = null;
  this.elements = null;
};

/* global createSizedArray, ShapePropertyFactory, MaskElement */

function CVMaskElement(data, element) {
  this.data = data;
  this.element = element;
  this.masksProperties = this.data.masksProperties || [];
  this.viewData = createSizedArray(this.masksProperties.length);
  var i;
  var len = this.masksProperties.length;
  var hasMasks = false;
  for (i = 0; i < len; i += 1) {
    if (this.masksProperties[i].mode !== 'n') {
      hasMasks = true;
    }
    this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
  }
  this.hasMasks = hasMasks;
  if (hasMasks) {
    this.element.addRenderableComponent(this);
  }
}

CVMaskElement.prototype.renderFrame = function () {
  if (!this.hasMasks) {
    return;
  }
  var transform = this.element.finalTransform.mat;
  var ctx = this.element.canvasContext;
  var i;
  var len = this.masksProperties.length;
  var pt;
  var pts;
  var data;
  ctx.beginPath();
  for (i = 0; i < len; i += 1) {
    if (this.masksProperties[i].mode !== 'n') {
      if (this.masksProperties[i].inv) {
        ctx.moveTo(0, 0);
        ctx.lineTo(this.element.globalData.compSize.w, 0);
        ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
        ctx.lineTo(0, this.element.globalData.compSize.h);
        ctx.lineTo(0, 0);
      }
      data = this.viewData[i].v;
      pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
      ctx.moveTo(pt[0], pt[1]);
      var j;
      var jLen = data._length;
      for (j = 1; j < jLen; j += 1) {
        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
      }
      pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
      ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
    }
  }
  this.element.globalData.renderer.save(true);
  ctx.clip();
};

CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;

CVMaskElement.prototype.destroy = function () {
  this.element = null;
};

/* global ShapeTransformManager, extendPrototype, BaseElement, TransformElement, CVBaseElement, IShapeElement,
HierarchyElement, FrameElement, RenderableElement, RenderableDOMElement, PropertyFactory, degToRads, GradientProperty,
DashProperty, TransformPropertyFactory, CVShapeData, ShapeModifiers, bmFloor, lineCapEnum, lineJoinEnum */

function CVShapeElement(data, globalData, comp) {
  this.shapes = [];
  this.shapesData = data.shapes;
  this.stylesList = [];
  this.itemsData = [];
  this.prevViewData = [];
  this.shapeModifiers = [];
  this.processedElements = [];
  this.transformsManager = new ShapeTransformManager();
  this.initElement(data, globalData, comp);
}

extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);

CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;

CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: false };

CVShapeElement.prototype.dashResetter = [];

CVShapeElement.prototype.createContent = function () {
  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
};

CVShapeElement.prototype.createStyleElement = function (data, transforms) {
  var styleElem = {
    data: data,
    type: data.ty,
    preTransforms: this.transformsManager.addTransformSequence(transforms),
    transforms: [],
    elements: [],
    closed: data.hd === true,
  };
  var elementData = {};
  if (data.ty === 'fl' || data.ty === 'st') {
    elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
    if (!elementData.c.k) {
      styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';
    }
  } else if (data.ty === 'gf' || data.ty === 'gs') {
    elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
    elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
    elementData.h = PropertyFactory.getProp(this, data.h || { k: 0 }, 0, 0.01, this);
    elementData.a = PropertyFactory.getProp(this, data.a || { k: 0 }, 0, degToRads, this);
    elementData.g = new GradientProperty(this, data.g, this);
  }
  elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);
  if (data.ty === 'st' || data.ty === 'gs') {
    styleElem.lc = lineCapEnum[data.lc || 2];
    styleElem.lj = lineJoinEnum[data.lj || 2];
    if (data.lj == 1) { // eslint-disable-line eqeqeq
      styleElem.ml = data.ml;
    }
    elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
    if (!elementData.w.k) {
      styleElem.wi = elementData.w.v;
    }
    if (data.d) {
      var d = new DashProperty(this, data.d, 'canvas', this);
      elementData.d = d;
      if (!elementData.d.k) {
        styleElem.da = elementData.d.dashArray;
        styleElem.do = elementData.d.dashoffset[0];
      }
    }
  } else {
    styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
  }
  this.stylesList.push(styleElem);
  elementData.style = styleElem;
  return elementData;
};

CVShapeElement.prototype.createGroupElement = function () {
  var elementData = {
    it: [],
    prevViewData: [],
  };
  return elementData;
};

CVShapeElement.prototype.createTransformElement = function (data) {
  var elementData = {
    transform: {
      opacity: 1,
      _opMdf: false,
      key: this.transformsManager.getNewKey(),
      op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
      mProps: TransformPropertyFactory.getTransformProperty(this, data, this),
    },
  };
  return elementData;
};

CVShapeElement.prototype.createShapeElement = function (data) {
  var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);

  this.shapes.push(elementData);
  this.addShapeToModifiers(elementData);
  return elementData;
};

CVShapeElement.prototype.reloadShapes = function () {
  this._isFirstFrame = true;
  var i;
  var len = this.itemsData.length;
  for (i = 0; i < len; i += 1) {
    this.prevViewData[i] = this.itemsData[i];
  }
  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
  len = this.dynamicProperties.length;
  for (i = 0; i < len; i += 1) {
    this.dynamicProperties[i].getValue();
  }
  this.renderModifiers();
  this.transformsManager.processSequences(this._isFirstFrame);
};

CVShapeElement.prototype.addTransformToStyleList = function (transform) {
  var i;
  var len = this.stylesList.length;
  for (i = 0; i < len; i += 1) {
    if (!this.stylesList[i].closed) {
      this.stylesList[i].transforms.push(transform);
    }
  }
};

CVShapeElement.prototype.removeTransformFromStyleList = function () {
  var i;
  var len = this.stylesList.length;
  for (i = 0; i < len; i += 1) {
    if (!this.stylesList[i].closed) {
      this.stylesList[i].transforms.pop();
    }
  }
};

CVShapeElement.prototype.closeStyles = function (styles) {
  var i;
  var len = styles.length;
  for (i = 0; i < len; i += 1) {
    styles[i].closed = true;
  }
};

CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
  var i;
  var len = arr.length - 1;
  var j;
  var jLen;
  var ownStyles = [];
  var ownModifiers = [];
  var processedPos;
  var modifier;
  var currentTransform;
  var ownTransforms = [].concat(transforms);
  for (i = len; i >= 0; i -= 1) {
    processedPos = this.searchProcessedElement(arr[i]);
    if (!processedPos) {
      arr[i]._shouldRender = shouldRender;
    } else {
      itemsData[i] = prevViewData[processedPos - 1];
    }
    if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
      if (!processedPos) {
        itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
      } else {
        itemsData[i].style.closed = false;
      }

      ownStyles.push(itemsData[i].style);
    } else if (arr[i].ty === 'gr') {
      if (!processedPos) {
        itemsData[i] = this.createGroupElement(arr[i]);
      } else {
        jLen = itemsData[i].it.length;
        for (j = 0; j < jLen; j += 1) {
          itemsData[i].prevViewData[j] = itemsData[i].it[j];
        }
      }
      this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
    } else if (arr[i].ty === 'tr') {
      if (!processedPos) {
        currentTransform = this.createTransformElement(arr[i]);
        itemsData[i] = currentTransform;
      }
      ownTransforms.push(itemsData[i]);
      this.addTransformToStyleList(itemsData[i]);
    } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
      if (!processedPos) {
        itemsData[i] = this.createShapeElement(arr[i]);
      }
    } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb') {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty);
        modifier.init(this, arr[i]);
        itemsData[i] = modifier;
        this.shapeModifiers.push(modifier);
      } else {
        modifier = itemsData[i];
        modifier.closed = false;
      }
      ownModifiers.push(modifier);
    } else if (arr[i].ty === 'rp') {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty);
        itemsData[i] = modifier;
        modifier.init(this, arr, i, itemsData);
        this.shapeModifiers.push(modifier);
        shouldRender = false;
      } else {
        modifier = itemsData[i];
        modifier.closed = true;
      }
      ownModifiers.push(modifier);
    }
    this.addProcessedElement(arr[i], i + 1);
  }
  this.removeTransformFromStyleList();
  this.closeStyles(ownStyles);
  len = ownModifiers.length;
  for (i = 0; i < len; i += 1) {
    ownModifiers[i].closed = true;
  }
};

CVShapeElement.prototype.renderInnerContent = function () {
  this.transformHelper.opacity = 1;
  this.transformHelper._opMdf = false;
  this.renderModifiers();
  this.transformsManager.processSequences(this._isFirstFrame);
  this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
};

CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
  if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
    groupTransform.opacity = parentTransform.opacity;
    groupTransform.opacity *= groupTransform.op.v;
    groupTransform._opMdf = true;
  }
};

CVShapeElement.prototype.drawLayer = function () {
  var i;
  var len = this.stylesList.length;
  var j;
  var jLen;
  var k;
  var kLen;
  var elems;
  var nodes;
  var renderer = this.globalData.renderer;
  var ctx = this.globalData.canvasContext;
  var type;
  var currentStyle;
  for (i = 0; i < len; i += 1) {
    currentStyle = this.stylesList[i];
    type = currentStyle.type;

    // Skipping style when
    // Stroke width equals 0
    // style should not be rendered (extra unused repeaters)
    // current opacity equals 0
    // global opacity equals 0
    if (!(((type === 'st' || type === 'gs') && currentStyle.wi === 0) || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
      renderer.save();
      elems = currentStyle.elements;
      if (type === 'st' || type === 'gs') {
        ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
        ctx.lineWidth = currentStyle.wi;
        ctx.lineCap = currentStyle.lc;
        ctx.lineJoin = currentStyle.lj;
        ctx.miterLimit = currentStyle.ml || 0;
      } else {
        ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
      }
      renderer.ctxOpacity(currentStyle.coOp);
      if (type !== 'st' && type !== 'gs') {
        ctx.beginPath();
      }
      renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
      jLen = elems.length;
      for (j = 0; j < jLen; j += 1) {
        if (type === 'st' || type === 'gs') {
          ctx.beginPath();
          if (currentStyle.da) {
            ctx.setLineDash(currentStyle.da);
            ctx.lineDashOffset = currentStyle.do;
          }
        }
        nodes = elems[j].trNodes;
        kLen = nodes.length;

        for (k = 0; k < kLen; k += 1) {
          if (nodes[k].t === 'm') {
            ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
          } else if (nodes[k].t === 'c') {
            ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
          } else {
            ctx.closePath();
          }
        }
        if (type === 'st' || type === 'gs') {
          ctx.stroke();
          if (currentStyle.da) {
            ctx.setLineDash(this.dashResetter);
          }
        }
      }
      if (type !== 'st' && type !== 'gs') {
        ctx.fill(currentStyle.r);
      }
      renderer.restore();
    }
  }
};

CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
  var i;
  var len = items.length - 1;
  var groupTransform;
  groupTransform = parentTransform;
  for (i = len; i >= 0; i -= 1) {
    if (items[i].ty === 'tr') {
      groupTransform = data[i].transform;
      this.renderShapeTransform(parentTransform, groupTransform);
    } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {
      this.renderPath(items[i], data[i]);
    } else if (items[i].ty === 'fl') {
      this.renderFill(items[i], data[i], groupTransform);
    } else if (items[i].ty === 'st') {
      this.renderStroke(items[i], data[i], groupTransform);
    } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
      this.renderGradientFill(items[i], data[i], groupTransform);
    } else if (items[i].ty === 'gr') {
      this.renderShape(groupTransform, items[i].it, data[i].it);
    } else if (items[i].ty === 'tm') {
      //
    }
  }
  if (isMain) {
    this.drawLayer();
  }
};

CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
  if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
    var shapeNodes = styledShape.trNodes;
    var paths = shape.paths;
    var i;
    var len;
    var j;
    var jLen = paths._length;
    shapeNodes.length = 0;
    var groupTransformMat = styledShape.transforms.finalTransform;
    for (j = 0; j < jLen; j += 1) {
      var pathNodes = paths.shapes[j];
      if (pathNodes && pathNodes.v) {
        len = pathNodes._length;
        for (i = 1; i < len; i += 1) {
          if (i === 1) {
            shapeNodes.push({
              t: 'm',
              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
            });
          }
          shapeNodes.push({
            t: 'c',
            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i]),
          });
        }
        if (len === 1) {
          shapeNodes.push({
            t: 'm',
            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
          });
        }
        if (pathNodes.c && len) {
          shapeNodes.push({
            t: 'c',
            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0]),
          });
          shapeNodes.push({
            t: 'z',
          });
        }
      }
    }
    styledShape.trNodes = shapeNodes;
  }
};

CVShapeElement.prototype.renderPath = function (pathData, itemData) {
  if (pathData.hd !== true && pathData._shouldRender) {
    var i;
    var len = itemData.styledShapes.length;
    for (i = 0; i < len; i += 1) {
      this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
    }
  }
};

CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
  var styleElem = itemData.style;

  if (itemData.c._mdf || this._isFirstFrame) {
    styleElem.co = 'rgb('
        + bmFloor(itemData.c.v[0]) + ','
        + bmFloor(itemData.c.v[1]) + ','
        + bmFloor(itemData.c.v[2]) + ')';
  }
  if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
    styleElem.coOp = itemData.o.v * groupTransform.opacity;
  }
};

CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
  var styleElem = itemData.style;
  var grd;
  if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))) {
    var ctx = this.globalData.canvasContext;
    var pt1 = itemData.s.v;
    var pt2 = itemData.e.v;
    if (styleData.t === 1) {
      grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
    } else {
      var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
      var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

      var percent = itemData.h.v;
      if (percent >= 1) {
        percent = 0.99;
      } else if (percent <= -1) {
        percent = -0.99;
      }
      var dist = rad * percent;
      var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
      var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
      grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
    }

    var i;
    var len = styleData.g.p;
    var cValues = itemData.g.c;
    var opacity = 1;

    for (i = 0; i < len; i += 1) {
      if (itemData.g._hasOpacity && itemData.g._collapsable) {
        opacity = itemData.g.o[i * 2 + 1];
      }
      grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
    }
    styleElem.grd = grd;
  }
  styleElem.coOp = itemData.o.v * groupTransform.opacity;
};

CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
  var styleElem = itemData.style;
  var d = itemData.d;
  if (d && (d._mdf || this._isFirstFrame)) {
    styleElem.da = d.dashArray;
    styleElem.do = d.dashoffset[0];
  }
  if (itemData.c._mdf || this._isFirstFrame) {
    styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
  }
  if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
    styleElem.coOp = itemData.o.v * groupTransform.opacity;
  }
  if (itemData.w._mdf || this._isFirstFrame) {
    styleElem.wi = itemData.w.v;
  }
};

CVShapeElement.prototype.destroy = function () {
  this.shapesData = null;
  this.globalData = null;
  this.canvasContext = null;
  this.stylesList.length = 0;
  this.itemsData.length = 0;
};

/* global extendPrototype, BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement,
SVGShapeElement, IImageElement */

function CVSolidElement(data, globalData, comp) {
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);

CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

CVSolidElement.prototype.renderInnerContent = function () {
  var ctx = this.canvasContext;
  ctx.fillStyle = this.data.sc;
  ctx.fillRect(0, 0, this.data.sw, this.data.sh);
  //
};

/* global extendPrototype, BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement,
RenderableElement, ITextElement, createTag, createSizedArray */

function CVTextElement(data, globalData, comp) {
  this.textSpans = [];
  this.yOffset = 0;
  this.fillColorAnim = false;
  this.strokeColorAnim = false;
  this.strokeWidthAnim = false;
  this.stroke = false;
  this.fill = false;
  this.justifyOffset = 0;
  this.currentRender = null;
  this.renderType = 'canvas';
  this.values = {
    fill: 'rgba(0,0,0,0)',
    stroke: 'rgba(0,0,0,0)',
    sWidth: 0,
    fValue: '',
  };
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);

CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');

CVTextElement.prototype.buildNewText = function () {
  var documentData = this.textProperty.currentData;
  this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);

  var hasFill = false;
  if (documentData.fc) {
    hasFill = true;
    this.values.fill = this.buildColor(documentData.fc);
  } else {
    this.values.fill = 'rgba(0,0,0,0)';
  }
  this.fill = hasFill;
  var hasStroke = false;
  if (documentData.sc) {
    hasStroke = true;
    this.values.stroke = this.buildColor(documentData.sc);
    this.values.sWidth = documentData.sw;
  }
  var fontData = this.globalData.fontManager.getFontByName(documentData.f);
  var i;
  var len;
  var letters = documentData.l;
  var matrixHelper = this.mHelper;
  this.stroke = hasStroke;
  this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
  len = documentData.finalText.length;
  // this.tHelper.font = this.values.fValue;
  var charData;
  var shapeData;
  var k;
  var kLen;
  var shapes;
  var j;
  var jLen;
  var pathNodes;
  var commands;
  var pathArr;
  var singleShape = this.data.singleShape;
  var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
  var xPos = 0;
  var yPos = 0;
  var firstLine = true;
  var cnt = 0;
  for (i = 0; i < len; i += 1) {
    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
    shapeData = (charData && charData.data) || {};
    matrixHelper.reset();
    if (singleShape && letters[i].n) {
      xPos = -trackingOffset;
      yPos += documentData.yOffset;
      yPos += firstLine ? 1 : 0;
      firstLine = false;
    }

    shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
    jLen = shapes.length;
    matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
    if (singleShape) {
      this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
    }
    commands = createSizedArray(jLen);
    for (j = 0; j < jLen; j += 1) {
      kLen = shapes[j].ks.k.i.length;
      pathNodes = shapes[j].ks.k;
      pathArr = [];
      for (k = 1; k < kLen; k += 1) {
        if (k === 1) {
          pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
        }
        pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
      }
      pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
      commands[j] = pathArr;
    }
    if (singleShape) {
      xPos += letters[i].l;
      xPos += trackingOffset;
    }
    if (this.textSpans[cnt]) {
      this.textSpans[cnt].elem = commands;
    } else {
      this.textSpans[cnt] = { elem: commands };
    }
    cnt += 1;
  }
};

CVTextElement.prototype.renderInnerContent = function () {
  var ctx = this.canvasContext;
  ctx.font = this.values.fValue;
  ctx.lineCap = 'butt';
  ctx.lineJoin = 'miter';
  ctx.miterLimit = 4;

  if (!this.data.singleShape) {
    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
  }

  var i;
  var len;
  var j;
  var jLen;
  var k;
  var kLen;
  var renderedLetters = this.textAnimator.renderedLetters;

  var letters = this.textProperty.currentData.l;

  len = letters.length;
  var renderedLetter;
  var lastFill = null;
  var lastStroke = null;
  var lastStrokeW = null;
  var commands;
  var pathArr;
  for (i = 0; i < len; i += 1) {
    if (!letters[i].n) {
      renderedLetter = renderedLetters[i];
      if (renderedLetter) {
        this.globalData.renderer.save();
        this.globalData.renderer.ctxTransform(renderedLetter.p);
        this.globalData.renderer.ctxOpacity(renderedLetter.o);
      }
      if (this.fill) {
        if (renderedLetter && renderedLetter.fc) {
          if (lastFill !== renderedLetter.fc) {
            lastFill = renderedLetter.fc;
            ctx.fillStyle = renderedLetter.fc;
          }
        } else if (lastFill !== this.values.fill) {
          lastFill = this.values.fill;
          ctx.fillStyle = this.values.fill;
        }
        commands = this.textSpans[i].elem;
        jLen = commands.length;
        this.globalData.canvasContext.beginPath();
        for (j = 0; j < jLen; j += 1) {
          pathArr = commands[j];
          kLen = pathArr.length;
          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
          for (k = 2; k < kLen; k += 6) {
            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
          }
        }
        this.globalData.canvasContext.closePath();
        this.globalData.canvasContext.fill();
        /// ctx.fillText(this.textSpans[i].val,0,0);
      }
      if (this.stroke) {
        if (renderedLetter && renderedLetter.sw) {
          if (lastStrokeW !== renderedLetter.sw) {
            lastStrokeW = renderedLetter.sw;
            ctx.lineWidth = renderedLetter.sw;
          }
        } else if (lastStrokeW !== this.values.sWidth) {
          lastStrokeW = this.values.sWidth;
          ctx.lineWidth = this.values.sWidth;
        }
        if (renderedLetter && renderedLetter.sc) {
          if (lastStroke !== renderedLetter.sc) {
            lastStroke = renderedLetter.sc;
            ctx.strokeStyle = renderedLetter.sc;
          }
        } else if (lastStroke !== this.values.stroke) {
          lastStroke = this.values.stroke;
          ctx.strokeStyle = this.values.stroke;
        }
        commands = this.textSpans[i].elem;
        jLen = commands.length;
        this.globalData.canvasContext.beginPath();
        for (j = 0; j < jLen; j += 1) {
          pathArr = commands[j];
          kLen = pathArr.length;
          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
          for (k = 2; k < kLen; k += 6) {
            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
          }
        }
        this.globalData.canvasContext.closePath();
        this.globalData.canvasContext.stroke();
        /// ctx.strokeText(letters[i].val,0,0);
      }
      if (renderedLetter) {
        this.globalData.renderer.restore();
      }
    }
  }
};

function CVEffects() {

}
CVEffects.prototype.renderFrame = function () {};

/* global createTag, createNS, styleDiv, CVEffects, MaskElement, SVGBaseElement, HybridRenderer */

function HBaseElement() {}
HBaseElement.prototype = {
  checkBlendMode: function () {},
  initRendererElement: function () {
    this.baseElement = createTag(this.data.tg || 'div');
    if (this.data.hasMask) {
      this.svgElement = createNS('svg');
      this.layerElement = createNS('g');
      this.maskedElement = this.layerElement;
      this.svgElement.appendChild(this.layerElement);
      this.baseElement.appendChild(this.svgElement);
    } else {
      this.layerElement = this.baseElement;
    }
    styleDiv(this.baseElement);
  },
  createContainerElements: function () {
    this.renderableEffectsManager = new CVEffects(this);
    this.transformedElement = this.baseElement;
    this.maskedElement = this.layerElement;
    if (this.data.ln) {
      this.layerElement.setAttribute('id', this.data.ln);
    }
    if (this.data.cl) {
      this.layerElement.setAttribute('class', this.data.cl);
    }
    if (this.data.bm !== 0) {
      this.setBlendMode();
    }
  },
  renderElement: function () {
    var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
    if (this.finalTransform._matMdf) {
      var matrixValue = this.finalTransform.mat.toCSS();
      transformedElementStyle.transform = matrixValue;
      transformedElementStyle.webkitTransform = matrixValue;
    }
    if (this.finalTransform._opMdf) {
      transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
    }
  },
  renderFrame: function () {
    // If it is exported as hidden (data.hd === true) no need to render
    // If it is not visible no need to render
    if (this.data.hd || this.hidden) {
      return;
    }
    this.renderTransform();
    this.renderRenderable();
    this.renderElement();
    this.renderInnerContent();
    if (this._isFirstFrame) {
      this._isFirstFrame = false;
    }
  },
  destroy: function () {
    this.layerElement = null;
    this.transformedElement = null;
    if (this.matteElement) {
      this.matteElement = null;
    }
    if (this.maskManager) {
      this.maskManager.destroy();
      this.maskManager = null;
    }
  },
  createRenderableComponents: function () {
    this.maskManager = new MaskElement(this.data, this, this.globalData);
  },
  addEffects: function () {
  },
  setMatte: function () {},
};
HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;

/* global extendPrototype, BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement,
RenderableDOMElement, createNS, createTag */

function HSolidElement(data, globalData, comp) {
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);

HSolidElement.prototype.createContent = function () {
  var rect;
  if (this.data.hasMask) {
    rect = createNS('rect');
    rect.setAttribute('width', this.data.sw);
    rect.setAttribute('height', this.data.sh);
    rect.setAttribute('fill', this.data.sc);
    this.svgElement.setAttribute('width', this.data.sw);
    this.svgElement.setAttribute('height', this.data.sh);
  } else {
    rect = createTag('div');
    rect.style.width = this.data.sw + 'px';
    rect.style.height = this.data.sh + 'px';
    rect.style.backgroundColor = this.data.sc;
  }
  this.layerElement.appendChild(rect);
};

/* global createSizedArray, PropertyFactory, extendPrototype, HybridRenderer, ICompElement, HBaseElement */

function HCompElement(data, globalData, comp) {
  this.layers = data.layers;
  this.supports3d = !data.hasMask;
  this.completeLayers = false;
  this.pendingElements = [];
  this.elements = this.layers ? createSizedArray(this.layers.length) : [];
  this.initElement(data, globalData, comp);
  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
}

extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement);
HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;

HCompElement.prototype.createContainerElements = function () {
  this._createBaseContainerElements();
  // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
  if (this.data.hasMask) {
    this.svgElement.setAttribute('width', this.data.w);
    this.svgElement.setAttribute('height', this.data.h);
    this.transformedElement = this.baseElement;
  } else {
    this.transformedElement = this.layerElement;
  }
};

HCompElement.prototype.addTo3dContainer = function (elem, pos) {
  var j = 0;
  var nextElement;
  while (j < pos) {
    if (this.elements[j] && this.elements[j].getBaseElement) {
      nextElement = this.elements[j].getBaseElement();
    }
    j += 1;
  }
  if (nextElement) {
    this.layerElement.insertBefore(elem, nextElement);
  } else {
    this.layerElement.appendChild(elem);
  }
};

/* global createNS, extendPrototype, BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement,
HierarchyElement, FrameElement, RenderableElement, createNS, bmMin, bmSqrt, bmMin, bmMax, bmPow */

function HShapeElement(data, globalData, comp) {
  // List of drawable elements
  this.shapes = [];
  // Full shape data
  this.shapesData = data.shapes;
  // List of styles that will be applied to shapes
  this.stylesList = [];
  // List of modifiers that will be applied to shapes
  this.shapeModifiers = [];
  // List of items in shape tree
  this.itemsData = [];
  // List of items in previous shape tree
  this.processedElements = [];
  // List of animated components
  this.animatedContents = [];
  this.shapesContainer = createNS('g');
  this.initElement(data, globalData, comp);
  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
  // List of elements that have been created
  this.prevViewData = [];
  this.currentBBox = {
    x: 999999,
    y: -999999,
    h: 0,
    w: 0,
  };
}
extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;

HShapeElement.prototype.createContent = function () {
  var cont;
  this.baseElement.style.fontSize = 0;
  if (this.data.hasMask) {
    this.layerElement.appendChild(this.shapesContainer);
    cont = this.svgElement;
  } else {
    cont = createNS('svg');
    var size = this.comp.data ? this.comp.data : this.globalData.compSize;
    cont.setAttribute('width', size.w);
    cont.setAttribute('height', size.h);
    cont.appendChild(this.shapesContainer);
    this.layerElement.appendChild(cont);
  }

  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
  this.filterUniqueShapes();
  this.shapeCont = cont;
};

HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
  var i;
  var len = transformers.length;
  for (i = 0; i < len; i += 1) {
    point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
  }
  return point;
};

HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
  var shape = item.sh.v;
  var transformers = item.transformers;
  var i;
  var len = shape._length;
  var vPoint;
  var oPoint;
  var nextIPoint;
  var nextVPoint;
  if (len <= 1) {
    return;
  }
  for (i = 0; i < len - 1; i += 1) {
    vPoint = this.getTransformedPoint(transformers, shape.v[i]);
    oPoint = this.getTransformedPoint(transformers, shape.o[i]);
    nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
    nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
  }
  if (shape.c) {
    vPoint = this.getTransformedPoint(transformers, shape.v[i]);
    oPoint = this.getTransformedPoint(transformers, shape.o[i]);
    nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
    nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
  }
};

HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
  this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
  var bounds = this.shapeBoundingBox;
  boundingBox.x = bmMin(bounds.left, boundingBox.x);
  boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
  boundingBox.y = bmMin(bounds.top, boundingBox.y);
  boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
};

HShapeElement.prototype.shapeBoundingBox = {
  left: 0,
  right: 0,
  top: 0,
  bottom: 0,
};

HShapeElement.prototype.tempBoundingBox = {
  x: 0,
  xMax: 0,
  y: 0,
  yMax: 0,
  width: 0,
  height: 0,
};

HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
  var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];

  for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) { // eslint-disable-line no-plusplus
    b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
    a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
    c = 3 * p1[i] - 3 * p0[i];

    b |= 0; // eslint-disable-line no-bitwise
    a |= 0; // eslint-disable-line no-bitwise
    c |= 0; // eslint-disable-line no-bitwise

    if (a === 0 && b === 0) {
      //
    } else if (a === 0) {
      t = -c / b;

      if (t > 0 && t < 1) {
        bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
      }
    } else {
      b2ac = b * b - 4 * c * a;

      if (b2ac >= 0) {
        t1 = (-b + bmSqrt(b2ac)) / (2 * a);
        if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
        t2 = (-b - bmSqrt(b2ac)) / (2 * a);
        if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
      }
    }
  }

  this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
  this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
  this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
  this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
};

HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
  return bmPow(1 - t, 3) * p0[i]
        + 3 * bmPow(1 - t, 2) * t * p1[i]
        + 3 * (1 - t) * bmPow(t, 2) * p2[i]
        + bmPow(t, 3) * p3[i];
};

HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
  var i;
  var len = itemsData.length;
  for (i = 0; i < len; i += 1) {
    if (itemsData[i] && itemsData[i].sh) {
      this.calculateShapeBoundingBox(itemsData[i], boundingBox);
    } else if (itemsData[i] && itemsData[i].it) {
      this.calculateBoundingBox(itemsData[i].it, boundingBox);
    }
  }
};

HShapeElement.prototype.currentBoxContains = function (box) {
  return this.currentBBox.x <= box.x
    && this.currentBBox.y <= box.y
    && this.currentBBox.width + this.currentBBox.x >= box.x + box.width
    && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
};

HShapeElement.prototype.renderInnerContent = function () {
  this._renderShapeFrame();

  if (!this.hidden && (this._isFirstFrame || this._mdf)) {
    var tempBoundingBox = this.tempBoundingBox;
    var max = 999999;
    tempBoundingBox.x = max;
    tempBoundingBox.xMax = -max;
    tempBoundingBox.y = max;
    tempBoundingBox.yMax = -max;
    this.calculateBoundingBox(this.itemsData, tempBoundingBox);
    tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
    tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
    // var tempBoundingBox = this.shapeCont.getBBox();
    if (this.currentBoxContains(tempBoundingBox)) {
      return;
    }
    var changed = false;
    if (this.currentBBox.w !== tempBoundingBox.width) {
      this.currentBBox.w = tempBoundingBox.width;
      this.shapeCont.setAttribute('width', tempBoundingBox.width);
      changed = true;
    }
    if (this.currentBBox.h !== tempBoundingBox.height) {
      this.currentBBox.h = tempBoundingBox.height;
      this.shapeCont.setAttribute('height', tempBoundingBox.height);
      changed = true;
    }
    if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
      this.currentBBox.w = tempBoundingBox.width;
      this.currentBBox.h = tempBoundingBox.height;
      this.currentBBox.x = tempBoundingBox.x;
      this.currentBBox.y = tempBoundingBox.y;

      this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
      var shapeStyle = this.shapeCont.style;
      var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
      shapeStyle.transform = shapeTransform;
      shapeStyle.webkitTransform = shapeTransform;
    }
  }
};

/* global extendPrototype, BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement,
RenderableDOMElement, ITextElement, createSizedArray, createTag, styleDiv, createNS, lineJoinEnum, lineCapEnum */

function HTextElement(data, globalData, comp) {
  this.textSpans = [];
  this.textPaths = [];
  this.currentBBox = {
    x: 999999,
    y: -999999,
    h: 0,
    w: 0,
  };
  this.renderType = 'svg';
  this.isMasked = false;
  this.initElement(data, globalData, comp);
}
extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);

HTextElement.prototype.createContent = function () {
  this.isMasked = this.checkMasks();
  if (this.isMasked) {
    this.renderType = 'svg';
    this.compW = this.comp.data.w;
    this.compH = this.comp.data.h;
    this.svgElement.setAttribute('width', this.compW);
    this.svgElement.setAttribute('height', this.compH);
    var g = createNS('g');
    this.maskedElement.appendChild(g);
    this.innerElem = g;
  } else {
    this.renderType = 'html';
    this.innerElem = this.layerElement;
  }

  this.checkParenting();
};

HTextElement.prototype.buildNewText = function () {
  var documentData = this.textProperty.currentData;
  this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
  var innerElemStyle = this.innerElem.style;
  var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
  innerElemStyle.fill = textColor;
  innerElemStyle.color = textColor;
  if (documentData.sc) {
    innerElemStyle.stroke = this.buildColor(documentData.sc);
    innerElemStyle.strokeWidth = documentData.sw + 'px';
  }
  var fontData = this.globalData.fontManager.getFontByName(documentData.f);
  if (!this.globalData.fontManager.chars) {
    innerElemStyle.fontSize = documentData.finalSize + 'px';
    innerElemStyle.lineHeight = documentData.finalSize + 'px';
    if (fontData.fClass) {
      this.innerElem.className = fontData.fClass;
    } else {
      innerElemStyle.fontFamily = fontData.fFamily;
      var fWeight = documentData.fWeight;
      var fStyle = documentData.fStyle;
      innerElemStyle.fontStyle = fStyle;
      innerElemStyle.fontWeight = fWeight;
    }
  }
  var i;
  var len;

  var letters = documentData.l;
  len = letters.length;
  var tSpan;
  var tParent;
  var tCont;
  var matrixHelper = this.mHelper;
  var shapes;
  var shapeStr = '';
  var cnt = 0;
  for (i = 0; i < len; i += 1) {
    if (this.globalData.fontManager.chars) {
      if (!this.textPaths[cnt]) {
        tSpan = createNS('path');
        tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);
        tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);
        tSpan.setAttribute('stroke-miterlimit', '4');
      } else {
        tSpan = this.textPaths[cnt];
      }
      if (!this.isMasked) {
        if (this.textSpans[cnt]) {
          tParent = this.textSpans[cnt];
          tCont = tParent.children[0];
        } else {
          tParent = createTag('div');
          tParent.style.lineHeight = 0;
          tCont = createNS('svg');
          tCont.appendChild(tSpan);
          styleDiv(tParent);
        }
      }
    } else if (!this.isMasked) {
      if (this.textSpans[cnt]) {
        tParent = this.textSpans[cnt];
        tSpan = this.textPaths[cnt];
      } else {
        tParent = createTag('span');
        styleDiv(tParent);
        tSpan = createTag('span');
        styleDiv(tSpan);
        tParent.appendChild(tSpan);
      }
    } else {
      tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
    }
    // tSpan.setAttribute('visibility', 'hidden');
    if (this.globalData.fontManager.chars) {
      var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
      var shapeData;
      if (charData) {
        shapeData = charData.data;
      } else {
        shapeData = null;
      }
      matrixHelper.reset();
      if (shapeData && shapeData.shapes) {
        shapes = shapeData.shapes[0].it;
        matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
        shapeStr = this.createPathShape(matrixHelper, shapes);
        tSpan.setAttribute('d', shapeStr);
      }
      if (!this.isMasked) {
        this.innerElem.appendChild(tParent);
        if (shapeData && shapeData.shapes) {
          // document.body.appendChild is needed to get exact measure of shape
          document.body.appendChild(tCont);
          var boundingBox = tCont.getBBox();
          tCont.setAttribute('width', boundingBox.width + 2);
          tCont.setAttribute('height', boundingBox.height + 2);
          tCont.setAttribute('viewBox', (boundingBox.x - 1) + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
          var tContStyle = tCont.style;
          var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
          tContStyle.transform = tContTranslation;
          tContStyle.webkitTransform = tContTranslation;

          letters[i].yOffset = boundingBox.y - 1;
        } else {
          tCont.setAttribute('width', 1);
          tCont.setAttribute('height', 1);
        }
        tParent.appendChild(tCont);
      } else {
        this.innerElem.appendChild(tSpan);
      }
    } else {
      tSpan.textContent = letters[i].val;
      tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
      if (!this.isMasked) {
        this.innerElem.appendChild(tParent);
        //
        var tStyle = tSpan.style;
        var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
        tStyle.transform = tSpanTranslation;
        tStyle.webkitTransform = tSpanTranslation;
      } else {
        this.innerElem.appendChild(tSpan);
      }
    }
    //
    if (!this.isMasked) {
      this.textSpans[cnt] = tParent;
    } else {
      this.textSpans[cnt] = tSpan;
    }
    this.textSpans[cnt].style.display = 'block';
    this.textPaths[cnt] = tSpan;
    cnt += 1;
  }
  while (cnt < this.textSpans.length) {
    this.textSpans[cnt].style.display = 'none';
    cnt += 1;
  }
};

HTextElement.prototype.renderInnerContent = function () {
  var svgStyle;
  if (this.data.singleShape) {
    if (!this._isFirstFrame && !this.lettersChangedFlag) {
      return;
    } if (this.isMasked && this.finalTransform._matMdf) {
      // Todo Benchmark if using this is better than getBBox
      this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
      svgStyle = this.svgElement.style;
      var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
      svgStyle.transform = translation;
      svgStyle.webkitTransform = translation;
    }
  }

  this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
  if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
    return;
  }
  var i;
  var len;
  var count = 0;
  var renderedLetters = this.textAnimator.renderedLetters;

  var letters = this.textProperty.currentData.l;

  len = letters.length;
  var renderedLetter;
  var textSpan;
  var textPath;
  for (i = 0; i < len; i += 1) {
    if (letters[i].n) {
      count += 1;
    } else {
      textSpan = this.textSpans[i];
      textPath = this.textPaths[i];
      renderedLetter = renderedLetters[count];
      count += 1;
      if (renderedLetter._mdf.m) {
        if (!this.isMasked) {
          textSpan.style.webkitTransform = renderedLetter.m;
          textSpan.style.transform = renderedLetter.m;
        } else {
          textSpan.setAttribute('transform', renderedLetter.m);
        }
      }
      /// /textSpan.setAttribute('opacity',renderedLetter.o);
      textSpan.style.opacity = renderedLetter.o;
      if (renderedLetter.sw && renderedLetter._mdf.sw) {
        textPath.setAttribute('stroke-width', renderedLetter.sw);
      }
      if (renderedLetter.sc && renderedLetter._mdf.sc) {
        textPath.setAttribute('stroke', renderedLetter.sc);
      }
      if (renderedLetter.fc && renderedLetter._mdf.fc) {
        textPath.setAttribute('fill', renderedLetter.fc);
        textPath.style.color = renderedLetter.fc;
      }
    }
  }

  if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
    var boundingBox = this.innerElem.getBBox();

    if (this.currentBBox.w !== boundingBox.width) {
      this.currentBBox.w = boundingBox.width;
      this.svgElement.setAttribute('width', boundingBox.width);
    }
    if (this.currentBBox.h !== boundingBox.height) {
      this.currentBBox.h = boundingBox.height;
      this.svgElement.setAttribute('height', boundingBox.height);
    }

    var margin = 1;
    if (this.currentBBox.w !== (boundingBox.width + margin * 2) || this.currentBBox.h !== (boundingBox.height + margin * 2) || this.currentBBox.x !== (boundingBox.x - margin) || this.currentBBox.y !== (boundingBox.y - margin)) {
      this.currentBBox.w = boundingBox.width + margin * 2;
      this.currentBBox.h = boundingBox.height + margin * 2;
      this.currentBBox.x = boundingBox.x - margin;
      this.currentBBox.y = boundingBox.y - margin;

      this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
      svgStyle = this.svgElement.style;
      var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
      svgStyle.transform = svgTransform;
      svgStyle.webkitTransform = svgTransform;
    }
  }
};

/* global extendPrototype, BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement,
FrameElement, RenderableElement, createNS */

function HImageElement(data, globalData, comp) {
  this.assetData = globalData.getAssetData(data.refId);
  this.initElement(data, globalData, comp);
}

extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);

HImageElement.prototype.createContent = function () {
  var assetPath = this.globalData.getAssetsPath(this.assetData);
  var img = new Image();

  if (this.data.hasMask) {
    this.imageElem = createNS('image');
    this.imageElem.setAttribute('width', this.assetData.w + 'px');
    this.imageElem.setAttribute('height', this.assetData.h + 'px');
    this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
    this.layerElement.appendChild(this.imageElem);
    this.baseElement.setAttribute('width', this.assetData.w);
    this.baseElement.setAttribute('height', this.assetData.h);
  } else {
    this.layerElement.appendChild(img);
  }
  img.crossOrigin = 'anonymous';
  img.src = assetPath;
  if (this.data.ln) {
    this.baseElement.setAttribute('id', this.data.ln);
  }
};

/* global PropertyFactory, degToRads, Matrix, extendPrototype, BaseElement, FrameElement, HierarchyElement */

function HCameraElement(data, globalData, comp) {
  this.initFrame();
  this.initBaseData(data, globalData, comp);
  this.initHierarchy();
  var getProp = PropertyFactory.getProp;
  this.pe = getProp(this, data.pe, 0, 0, this);
  if (data.ks.p.s) {
    this.px = getProp(this, data.ks.p.x, 1, 0, this);
    this.py = getProp(this, data.ks.p.y, 1, 0, this);
    this.pz = getProp(this, data.ks.p.z, 1, 0, this);
  } else {
    this.p = getProp(this, data.ks.p, 1, 0, this);
  }
  if (data.ks.a) {
    this.a = getProp(this, data.ks.a, 1, 0, this);
  }
  if (data.ks.or.k.length && data.ks.or.k[0].to) {
    var i;
    var len = data.ks.or.k.length;
    for (i = 0; i < len; i += 1) {
      data.ks.or.k[i].to = null;
      data.ks.or.k[i].ti = null;
    }
  }
  this.or = getProp(this, data.ks.or, 1, degToRads, this);
  this.or.sh = true;
  this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
  this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
  this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
  this.mat = new Matrix();
  this._prevMat = new Matrix();
  this._isFirstFrame = true;

  // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
  this.finalTransform = {
    mProp: this,
  };
}
extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);

HCameraElement.prototype.setup = function () {
  var i;
  var len = this.comp.threeDElements.length;
  var comp;
  var perspectiveStyle;
  var containerStyle;
  for (i = 0; i < len; i += 1) {
    // [perspectiveElem,container]
    comp = this.comp.threeDElements[i];
    if (comp.type === '3d') {
      perspectiveStyle = comp.perspectiveElem.style;
      containerStyle = comp.container.style;
      var perspective = this.pe.v + 'px';
      var origin = '0px 0px 0px';
      var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
      perspectiveStyle.perspective = perspective;
      perspectiveStyle.webkitPerspective = perspective;
      containerStyle.transformOrigin = origin;
      containerStyle.mozTransformOrigin = origin;
      containerStyle.webkitTransformOrigin = origin;
      perspectiveStyle.transform = matrix;
      perspectiveStyle.webkitTransform = matrix;
    }
  }
};

HCameraElement.prototype.createElements = function () {
};

HCameraElement.prototype.hide = function () {
};

HCameraElement.prototype.renderFrame = function () {
  var _mdf = this._isFirstFrame;
  var i;
  var len;
  if (this.hierarchy) {
    len = this.hierarchy.length;
    for (i = 0; i < len; i += 1) {
      _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
    }
  }
  if (_mdf || this.pe._mdf || (this.p && this.p._mdf) || (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || (this.a && this.a._mdf)) {
    this.mat.reset();

    if (this.hierarchy) {
      len = this.hierarchy.length - 1;
      for (i = len; i >= 0; i -= 1) {
        var mTransf = this.hierarchy[i].finalTransform.mProp;
        this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
        this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
        this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
        this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
        this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
      }
    }
    if (this.p) {
      this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
    } else {
      this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
    }
    if (this.a) {
      var diffVector;
      if (this.p) {
        diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
      } else {
        diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
      }
      var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
      // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
      var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
      var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
      var mRotationX = (Math.atan2(lookDir[1], lookLengthOnXZ));
      var mRotationY = (Math.atan2(lookDir[0], -lookDir[2]));
      this.mat.rotateY(mRotationY).rotateX(-mRotationX);
    }
    this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
    this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
    this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
    this.mat.translate(0, 0, this.pe.v);

    var hasMatrixChanged = !this._prevMat.equals(this.mat);
    if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
      len = this.comp.threeDElements.length;
      var comp;
      var perspectiveStyle;
      var containerStyle;
      for (i = 0; i < len; i += 1) {
        comp = this.comp.threeDElements[i];
        if (comp.type === '3d') {
          if (hasMatrixChanged) {
            var matValue = this.mat.toCSS();
            containerStyle = comp.container.style;
            containerStyle.transform = matValue;
            containerStyle.webkitTransform = matValue;
          }
          if (this.pe._mdf) {
            perspectiveStyle = comp.perspectiveElem.style;
            perspectiveStyle.perspective = this.pe.v + 'px';
            perspectiveStyle.webkitPerspective = this.pe.v + 'px';
          }
        }
      }
      this.mat.clone(this._prevMat);
    }
  }
  this._isFirstFrame = false;
};

HCameraElement.prototype.prepareFrame = function (num) {
  this.prepareProperties(num, true);
};

HCameraElement.prototype.destroy = function () {
};
HCameraElement.prototype.getBaseElement = function () { return null; };

function HEffects() {
}
HEffects.prototype.renderFrame = function () {};

/* global createTag, AnimationItem */
/* exported animationManager */

var animationManager = (function () {
  var moduleOb = {};
  var registeredAnimations = [];
  var initTime = 0;
  var len = 0;
  var playingAnimationsNum = 0;
  var _stopped = true;
  var _isFrozen = false;

  function removeElement(ev) {
    var i = 0;
    var animItem = ev.target;
    while (i < len) {
      if (registeredAnimations[i].animation === animItem) {
        registeredAnimations.splice(i, 1);
        i -= 1;
        len -= 1;
        if (!animItem.isPaused) {
          subtractPlayingCount();
        }
      }
      i += 1;
    }
  }

  function registerAnimation(element, animationData) {
    if (!element) {
      return null;
    }
    var i = 0;
    while (i < len) {
      if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
        return registeredAnimations[i].animation;
      }
      i += 1;
    }
    var animItem = new AnimationItem();
    setupAnimation(animItem, element);
    animItem.setData(element, animationData);
    return animItem;
  }

  function getRegisteredAnimations() {
    var i;
    var lenAnims = registeredAnimations.length;
    var animations = [];
    for (i = 0; i < lenAnims; i += 1) {
      animations.push(registeredAnimations[i].animation);
    }
    return animations;
  }

  function addPlayingCount() {
    playingAnimationsNum += 1;
    activate();
  }

  function subtractPlayingCount() {
    playingAnimationsNum -= 1;
  }

  function setupAnimation(animItem, element) {
    animItem.addEventListener('destroy', removeElement);
    animItem.addEventListener('_active', addPlayingCount);
    animItem.addEventListener('_idle', subtractPlayingCount);
    registeredAnimations.push({ elem: element, animation: animItem });
    len += 1;
  }

  function loadAnimation(params) {
    var animItem = new AnimationItem();
    setupAnimation(animItem, null);
    animItem.setParams(params);
    return animItem;
  }

  function setSpeed(val, animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.setSpeed(val, animation);
    }
  }

  function setDirection(val, animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.setDirection(val, animation);
    }
  }

  function play(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.play(animation);
    }
  }
  function resume(nowTime) {
    var elapsedTime = nowTime - initTime;
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.advanceTime(elapsedTime);
    }
    initTime = nowTime;
    if (playingAnimationsNum && !_isFrozen) {
      window.requestAnimationFrame(resume);
    } else {
      _stopped = true;
    }
  }

  function first(nowTime) {
    initTime = nowTime;
    window.requestAnimationFrame(resume);
  }

  function pause(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.pause(animation);
    }
  }

  function goToAndStop(value, isFrame, animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
    }
  }

  function stop(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.stop(animation);
    }
  }

  function togglePause(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.togglePause(animation);
    }
  }

  function destroy(animation) {
    var i;
    for (i = (len - 1); i >= 0; i -= 1) {
      registeredAnimations[i].animation.destroy(animation);
    }
  }

  function searchAnimations(animationData, standalone, renderer) {
    var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')),
      [].slice.call(document.getElementsByClassName('bodymovin')));
    var i;
    var lenAnims = animElements.length;
    for (i = 0; i < lenAnims; i += 1) {
      if (renderer) {
        animElements[i].setAttribute('data-bm-type', renderer);
      }
      registerAnimation(animElements[i], animationData);
    }
    if (standalone && lenAnims === 0) {
      if (!renderer) {
        renderer = 'svg';
      }
      var body = document.getElementsByTagName('body')[0];
      body.innerText = '';
      var div = createTag('div');
      div.style.width = '100%';
      div.style.height = '100%';
      div.setAttribute('data-bm-type', renderer);
      body.appendChild(div);
      registerAnimation(div, animationData);
    }
  }

  function resize() {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.resize();
    }
  }

  function activate() {
    if (!_isFrozen && playingAnimationsNum) {
      if (_stopped) {
        window.requestAnimationFrame(first);
        _stopped = false;
      }
    }
  }

  function freeze() {
    _isFrozen = true;
  }

  function unfreeze() {
    _isFrozen = false;
    activate();
  }

  function setVolume(val, animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.setVolume(val, animation);
    }
  }

  function mute(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.mute(animation);
    }
  }

  function unmute(animation) {
    var i;
    for (i = 0; i < len; i += 1) {
      registeredAnimations[i].animation.unmute(animation);
    }
  }

  moduleOb.registerAnimation = registerAnimation;
  moduleOb.loadAnimation = loadAnimation;
  moduleOb.setSpeed = setSpeed;
  moduleOb.setDirection = setDirection;
  moduleOb.play = play;
  moduleOb.pause = pause;
  moduleOb.stop = stop;
  moduleOb.togglePause = togglePause;
  moduleOb.searchAnimations = searchAnimations;
  moduleOb.resize = resize;
  // moduleOb.start = start;
  moduleOb.goToAndStop = goToAndStop;
  moduleOb.destroy = destroy;
  moduleOb.freeze = freeze;
  moduleOb.unfreeze = unfreeze;
  moduleOb.setVolume = setVolume;
  moduleOb.mute = mute;
  moduleOb.unmute = unmute;
  moduleOb.getRegisteredAnimations = getRegisteredAnimations;
  return moduleOb;
}());

/* global createElementID, subframeEnabled, ProjectInterface, ImagePreloader, audioControllerFactory, extendPrototype, BaseEvent,
CanvasRenderer, SVGRenderer, HybridRenderer, assetLoader, dataManager, expressionsPlugin, BMEnterFrameEvent, BMCompleteLoopEvent,
BMCompleteEvent, BMSegmentStartEvent, BMDestroyEvent, BMEnterFrameEvent, BMCompleteLoopEvent, BMCompleteEvent, BMSegmentStartEvent,
BMDestroyEvent, BMRenderFrameErrorEvent, BMConfigErrorEvent, markerParser */

var AnimationItem = function () {
  this._cbs = [];
  this.name = '';
  this.path = '';
  this.isLoaded = false;
  this.currentFrame = 0;
  this.currentRawFrame = 0;
  this.firstFrame = 0;
  this.totalFrames = 0;
  this.frameRate = 0;
  this.frameMult = 0;
  this.playSpeed = 1;
  this.playDirection = 1;
  this.playCount = 0;
  this.animationData = {};
  this.assets = [];
  this.isPaused = true;
  this.autoplay = false;
  this.loop = true;
  this.renderer = null;
  this.animationID = createElementID();
  this.assetsPath = '';
  this.timeCompleted = 0;
  this.segmentPos = 0;
  this.isSubframeEnabled = subframeEnabled;
  this.segments = [];
  this._idle = true;
  this._completedLoop = false;
  this.projectInterface = ProjectInterface();
  this.imagePreloader = new ImagePreloader();
  this.audioController = audioControllerFactory();
  this.markers = [];
};

extendPrototype([BaseEvent], AnimationItem);

AnimationItem.prototype.setParams = function (params) {
  if (params.wrapper || params.container) {
    this.wrapper = params.wrapper || params.container;
  }
  var animType = 'svg';
  if (params.animType) {
    animType = params.animType;
  } else if (params.renderer) {
    animType = params.renderer;
  }
  switch (animType) {
    case 'canvas':
      this.renderer = new CanvasRenderer(this, params.rendererSettings);
      break;
    case 'svg':
      this.renderer = new SVGRenderer(this, params.rendererSettings);
      break;
    default:
      this.renderer = new HybridRenderer(this, params.rendererSettings);
      break;
  }
  this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
  this.renderer.setProjectInterface(this.projectInterface);
  this.animType = animType;
  if (params.loop === ''
        || params.loop === null
        || params.loop === undefined
        || params.loop === true) {
    this.loop = true;
  } else if (params.loop === false) {
    this.loop = false;
  } else {
    this.loop = parseInt(params.loop, 10);
  }
  this.autoplay = 'autoplay' in params ? params.autoplay : true;
  this.name = params.name ? params.name : '';
  this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;
  this.assetsPath = params.assetsPath;
  this.initialSegment = params.initialSegment;
  if (params.audioFactory) {
    this.audioController.setAudioFactory(params.audioFactory);
  }
  if (params.animationData) {
    this.configAnimation(params.animationData);
  } else if (params.path) {
    if (params.path.lastIndexOf('\\') !== -1) {
      this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
    } else {
      this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
    }
    this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
    this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));

    assetLoader.load(params.path, this.configAnimation.bind(this), function () {
      this.trigger('data_failed');
    }.bind(this));
  }
};

AnimationItem.prototype.setData = function (wrapper, animationData) {
  if (animationData) {
    if (typeof animationData !== 'object') {
      animationData = JSON.parse(animationData);
    }
  }
  var params = {
    wrapper: wrapper,
    animationData: animationData,
  };
  var wrapperAttributes = wrapper.attributes;

  params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-animation-path').value
    : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-path').value
      : wrapperAttributes.getNamedItem('bm-path')
        ? wrapperAttributes.getNamedItem('bm-path').value
        : '';
  params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-anim-type').value
    : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-type').value
      : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('bm-type').value
        : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary
          ? wrapperAttributes.getNamedItem('data-bm-renderer').value
          : wrapperAttributes.getNamedItem('bm-renderer')
            ? wrapperAttributes.getNamedItem('bm-renderer').value
            : 'canvas';

  var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-anim-loop').value
    : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-loop').value
      : wrapperAttributes.getNamedItem('bm-loop')
        ? wrapperAttributes.getNamedItem('bm-loop').value
        : '';
  if (loop === 'false') {
    params.loop = false;
  } else if (loop === 'true') {
    params.loop = true;
  } else if (loop !== '') {
    params.loop = parseInt(loop, 10);
  }
  var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-anim-autoplay').value
    : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-autoplay').value
      : wrapperAttributes.getNamedItem('bm-autoplay')
        ? wrapperAttributes.getNamedItem('bm-autoplay').value
        : true;
  params.autoplay = autoplay !== 'false';

  params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-name').value
    : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-name').value
      : wrapperAttributes.getNamedItem('bm-name')
        ? wrapperAttributes.getNamedItem('bm-name').value
        : '';
  var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary
    ? wrapperAttributes.getNamedItem('data-anim-prerender').value
    : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-prerender').value
      : wrapperAttributes.getNamedItem('bm-prerender')
        ? wrapperAttributes.getNamedItem('bm-prerender').value
        : '';

  if (prerender === 'false') {
    params.prerender = false;
  }
  this.setParams(params);
};

AnimationItem.prototype.includeLayers = function (data) {
  if (data.op > this.animationData.op) {
    this.animationData.op = data.op;
    this.totalFrames = Math.floor(data.op - this.animationData.ip);
  }
  var layers = this.animationData.layers;
  var i;
  var len = layers.length;
  var newLayers = data.layers;
  var j;
  var jLen = newLayers.length;
  for (j = 0; j < jLen; j += 1) {
    i = 0;
    while (i < len) {
      if (layers[i].id === newLayers[j].id) {
        layers[i] = newLayers[j];
        break;
      }
      i += 1;
    }
  }
  if (data.chars || data.fonts) {
    this.renderer.globalData.fontManager.addChars(data.chars);
    this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
  }
  if (data.assets) {
    len = data.assets.length;
    for (i = 0; i < len; i += 1) {
      this.animationData.assets.push(data.assets[i]);
    }
  }
  this.animationData.__complete = false;
  dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);
  this.renderer.includeLayers(data.layers);
  if (expressionsPlugin) {
    expressionsPlugin.initExpressions(this);
  }
  this.loadNextSegment();
};

AnimationItem.prototype.loadNextSegment = function () {
  var segments = this.animationData.segments;
  if (!segments || segments.length === 0 || !this.autoloadSegments) {
    this.trigger('data_ready');
    this.timeCompleted = this.totalFrames;
    return;
  }
  var segment = segments.shift();
  this.timeCompleted = segment.time * this.frameRate;
  var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
  this.segmentPos += 1;
  assetLoader.load(segmentPath, this.includeLayers.bind(this), function () {
    this.trigger('data_failed');
  }.bind(this));
};

AnimationItem.prototype.loadSegments = function () {
  var segments = this.animationData.segments;
  if (!segments) {
    this.timeCompleted = this.totalFrames;
  }
  this.loadNextSegment();
};

AnimationItem.prototype.imagesLoaded = function () {
  this.trigger('loaded_images');
  this.checkLoaded();
};

AnimationItem.prototype.preloadImages = function () {
  this.imagePreloader.setAssetsPath(this.assetsPath);
  this.imagePreloader.setPath(this.path);
  this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
};

AnimationItem.prototype.configAnimation = function (animData) {
  if (!this.renderer) {
    return;
  }
  try {
    this.animationData = animData;

    if (this.initialSegment) {
      this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
      this.firstFrame = Math.round(this.initialSegment[0]);
    } else {
      this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
      this.firstFrame = Math.round(this.animationData.ip);
    }
    this.renderer.configAnimation(animData);
    if (!animData.assets) {
      animData.assets = [];
    }

    this.assets = this.animationData.assets;
    this.frameRate = this.animationData.fr;
    this.frameMult = this.animationData.fr / 1000;
    this.renderer.searchExtraCompositions(animData.assets);
    this.markers = markerParser(animData.markers || []);
    this.trigger('config_ready');
    this.preloadImages();
    this.loadSegments();
    this.updaFrameModifier();
    this.waitForFontsLoaded();
    if (this.isPaused) {
      this.audioController.pause();
    }
  } catch (error) {
    this.triggerConfigError(error);
  }
};

AnimationItem.prototype.waitForFontsLoaded = function () {
  if (!this.renderer) {
    return;
  }
  if (this.renderer.globalData.fontManager.isLoaded) {
    this.checkLoaded();
  } else {
    setTimeout(this.waitForFontsLoaded.bind(this), 20);
  }
};

AnimationItem.prototype.checkLoaded = function () {
  if (!this.isLoaded
        && this.renderer.globalData.fontManager.isLoaded
        && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas')
        && (this.imagePreloader.loadedFootages())
  ) {
    this.isLoaded = true;
    dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);
    if (expressionsPlugin) {
      expressionsPlugin.initExpressions(this);
    }
    this.renderer.initItems();
    setTimeout(function () {
      this.trigger('DOMLoaded');
    }.bind(this), 0);
    this.gotoFrame();
    if (this.autoplay) {
      this.play();
    }
  }
};

AnimationItem.prototype.resize = function () {
  this.renderer.updateContainerSize();
};

AnimationItem.prototype.setSubframe = function (flag) {
  this.isSubframeEnabled = !!flag;
};

AnimationItem.prototype.gotoFrame = function () {
  this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

  if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
    this.currentFrame = this.timeCompleted;
  }
  this.trigger('enterFrame');
  this.renderFrame();
};

AnimationItem.prototype.renderFrame = function () {
  if (this.isLoaded === false || !this.renderer) {
    return;
  }
  try {
    this.renderer.renderFrame(this.currentFrame + this.firstFrame);
  } catch (error) {
    this.triggerRenderFrameError(error);
  }
};

AnimationItem.prototype.play = function (name) {
  if (name && this.name !== name) {
    return;
  }
  if (this.isPaused === true) {
    this.isPaused = false;
    this.audioController.resume();
    if (this._idle) {
      this._idle = false;
      this.trigger('_active');
    }
  }
};

AnimationItem.prototype.pause = function (name) {
  if (name && this.name !== name) {
    return;
  }
  if (this.isPaused === false) {
    this.isPaused = true;
    this._idle = true;
    this.trigger('_idle');
    this.audioController.pause();
  }
};

AnimationItem.prototype.togglePause = function (name) {
  if (name && this.name !== name) {
    return;
  }
  if (this.isPaused === true) {
    this.play();
  } else {
    this.pause();
  }
};

AnimationItem.prototype.stop = function (name) {
  if (name && this.name !== name) {
    return;
  }
  this.pause();
  this.playCount = 0;
  this._completedLoop = false;
  this.setCurrentRawFrameValue(0);
};

AnimationItem.prototype.getMarkerData = function (markerName) {
  var marker;
  for (var i = 0; i < this.markers.length; i += 1) {
    marker = this.markers[i];
    if (marker.payload && marker.payload.name === markerName) {
      return marker;
    }
  }
  return null;
};

AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
  if (name && this.name !== name) {
    return;
  }
  var numValue = Number(value);
  if (isNaN(numValue)) {
    var marker = this.getMarkerData(value);
    if (marker) {
      this.goToAndStop(marker.time, true);
    }
  } else if (isFrame) {
    this.setCurrentRawFrameValue(value);
  } else {
    this.setCurrentRawFrameValue(value * this.frameModifier);
  }
  this.pause();
};

AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
  if (name && this.name !== name) {
    return;
  }
  var numValue = Number(value);
  if (isNaN(numValue)) {
    var marker = this.getMarkerData(value);
    if (marker) {
      if (!marker.duration) {
        this.goToAndStop(marker.time, true);
      } else {
        this.playSegments([marker.time, marker.time + marker.duration], true);
      }
    }
  } else {
    this.goToAndStop(numValue, isFrame, name);
  }
  this.play();
};

AnimationItem.prototype.advanceTime = function (value) {
  if (this.isPaused === true || this.isLoaded === false) {
    return;
  }
  var nextValue = this.currentRawFrame + value * this.frameModifier;
  var _isComplete = false;
  // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
  // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
  if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
    if (!this.loop || this.playCount === this.loop) {
      if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
        _isComplete = true;
        nextValue = this.totalFrames - 1;
      }
    } else if (nextValue >= this.totalFrames) {
      this.playCount += 1;
      if (!this.checkSegments(nextValue % this.totalFrames)) {
        this.setCurrentRawFrameValue(nextValue % this.totalFrames);
        this._completedLoop = true;
        this.trigger('loopComplete');
      }
    } else {
      this.setCurrentRawFrameValue(nextValue);
    }
  } else if (nextValue < 0) {
    if (!this.checkSegments(nextValue % this.totalFrames)) {
      if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) { // eslint-disable-line no-plusplus
        this.setCurrentRawFrameValue(this.totalFrames + (nextValue % this.totalFrames));
        if (!this._completedLoop) {
          this._completedLoop = true;
        } else {
          this.trigger('loopComplete');
        }
      } else {
        _isComplete = true;
        nextValue = 0;
      }
    }
  } else {
    this.setCurrentRawFrameValue(nextValue);
  }
  if (_isComplete) {
    this.setCurrentRawFrameValue(nextValue);
    this.pause();
    this.trigger('complete');
  }
};

AnimationItem.prototype.adjustSegment = function (arr, offset) {
  this.playCount = 0;
  if (arr[1] < arr[0]) {
    if (this.frameModifier > 0) {
      if (this.playSpeed < 0) {
        this.setSpeed(-this.playSpeed);
      } else {
        this.setDirection(-1);
      }
    }
    this.totalFrames = arr[0] - arr[1];
    this.timeCompleted = this.totalFrames;
    this.firstFrame = arr[1];
    this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
  } else if (arr[1] > arr[0]) {
    if (this.frameModifier < 0) {
      if (this.playSpeed < 0) {
        this.setSpeed(-this.playSpeed);
      } else {
        this.setDirection(1);
      }
    }
    this.totalFrames = arr[1] - arr[0];
    this.timeCompleted = this.totalFrames;
    this.firstFrame = arr[0];
    this.setCurrentRawFrameValue(0.001 + offset);
  }
  this.trigger('segmentStart');
};
AnimationItem.prototype.setSegment = function (init, end) {
  var pendingFrame = -1;
  if (this.isPaused) {
    if (this.currentRawFrame + this.firstFrame < init) {
      pendingFrame = init;
    } else if (this.currentRawFrame + this.firstFrame > end) {
      pendingFrame = end - init;
    }
  }

  this.firstFrame = init;
  this.totalFrames = end - init;
  this.timeCompleted = this.totalFrames;
  if (pendingFrame !== -1) {
    this.goToAndStop(pendingFrame, true);
  }
};

AnimationItem.prototype.playSegments = function (arr, forceFlag) {
  if (forceFlag) {
    this.segments.length = 0;
  }
  if (typeof arr[0] === 'object') {
    var i;
    var len = arr.length;
    for (i = 0; i < len; i += 1) {
      this.segments.push(arr[i]);
    }
  } else {
    this.segments.push(arr);
  }
  if (this.segments.length && forceFlag) {
    this.adjustSegment(this.segments.shift(), 0);
  }
  if (this.isPaused) {
    this.play();
  }
};

AnimationItem.prototype.resetSegments = function (forceFlag) {
  this.segments.length = 0;
  this.segments.push([this.animationData.ip, this.animationData.op]);
  // this.segments.push([this.animationData.ip*this.frameRate,Math.floor(this.animationData.op - this.animationData.ip+this.animationData.ip*this.frameRate)]);
  if (forceFlag) {
    this.checkSegments(0);
  }
};
AnimationItem.prototype.checkSegments = function (offset) {
  if (this.segments.length) {
    this.adjustSegment(this.segments.shift(), offset);
    return true;
  }
  return false;
};

AnimationItem.prototype.destroy = function (name) {
  if ((name && this.name !== name) || !this.renderer) {
    return;
  }
  this.renderer.destroy();
  this.imagePreloader.destroy();
  this.trigger('destroy');
  this._cbs = null;
  this.onEnterFrame = null;
  this.onLoopComplete = null;
  this.onComplete = null;
  this.onSegmentStart = null;
  this.onDestroy = null;
  this.renderer = null;
  this.renderer = null;
  this.imagePreloader = null;
  this.projectInterface = null;
};

AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
  this.currentRawFrame = value;
  this.gotoFrame();
};

AnimationItem.prototype.setSpeed = function (val) {
  this.playSpeed = val;
  this.updaFrameModifier();
};

AnimationItem.prototype.setDirection = function (val) {
  this.playDirection = val < 0 ? -1 : 1;
  this.updaFrameModifier();
};

AnimationItem.prototype.setVolume = function (val, name) {
  if (name && this.name !== name) {
    return;
  }
  this.audioController.setVolume(val);
};

AnimationItem.prototype.getVolume = function () {
  return this.audioController.getVolume();
};

AnimationItem.prototype.mute = function (name) {
  if (name && this.name !== name) {
    return;
  }
  this.audioController.mute();
};

AnimationItem.prototype.unmute = function (name) {
  if (name && this.name !== name) {
    return;
  }
  this.audioController.unmute();
};

AnimationItem.prototype.updaFrameModifier = function () {
  this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
  this.audioController.setRate(this.playSpeed * this.playDirection);
};

AnimationItem.prototype.getPath = function () {
  return this.path;
};

AnimationItem.prototype.getAssetsPath = function (assetData) {
  var path = '';
  if (assetData.e) {
    path = assetData.p;
  } else if (this.assetsPath) {
    var imagePath = assetData.p;
    if (imagePath.indexOf('images/') !== -1) {
      imagePath = imagePath.split('/')[1];
    }
    path = this.assetsPath + imagePath;
  } else {
    path = this.path;
    path += assetData.u ? assetData.u : '';
    path += assetData.p;
  }
  return path;
};

AnimationItem.prototype.getAssetData = function (id) {
  var i = 0;
  var len = this.assets.length;
  while (i < len) {
    if (id === this.assets[i].id) {
      return this.assets[i];
    }
    i += 1;
  }
  return null;
};

AnimationItem.prototype.hide = function () {
  this.renderer.hide();
};

AnimationItem.prototype.show = function () {
  this.renderer.show();
};

AnimationItem.prototype.getDuration = function (isFrame) {
  return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
};

AnimationItem.prototype.trigger = function (name) {
  if (this._cbs && this._cbs[name]) {
    switch (name) {
      case 'enterFrame':
        this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
        break;
      case 'loopComplete':
        this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
        break;
      case 'complete':
        this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
        break;
      case 'segmentStart':
        this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
        break;
      case 'destroy':
        this.triggerEvent(name, new BMDestroyEvent(name, this));
        break;
      default:
        this.triggerEvent(name);
    }
  }
  if (name === 'enterFrame' && this.onEnterFrame) {
    this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
  }
  if (name === 'loopComplete' && this.onLoopComplete) {
    this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
  }
  if (name === 'complete' && this.onComplete) {
    this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
  }
  if (name === 'segmentStart' && this.onSegmentStart) {
    this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
  }
  if (name === 'destroy' && this.onDestroy) {
    this.onDestroy.call(this, new BMDestroyEvent(name, this));
  }
};

AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {
  var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
  this.triggerEvent('error', error);

  if (this.onError) {
    this.onError.call(this, error);
  }
};

AnimationItem.prototype.triggerConfigError = function (nativeError) {
  var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
  this.triggerEvent('error', error);

  if (this.onError) {
    this.onError.call(this, error);
  }
};

/* global CompExpressionInterface, expressionsPlugin: writable */
/* exported expressionsPlugin */

var Expressions = (function () {
  var ob = {};
  ob.initExpressions = initExpressions;

  function initExpressions(animation) {
    var stackCount = 0;
    var registers = [];

    function pushExpression() {
      stackCount += 1;
    }

    function popExpression() {
      stackCount -= 1;
      if (stackCount === 0) {
        releaseInstances();
      }
    }

    function registerExpressionProperty(expression) {
      if (registers.indexOf(expression) === -1) {
        registers.push(expression);
      }
    }

    function releaseInstances() {
      var i;
      var len = registers.length;
      for (i = 0; i < len; i += 1) {
        registers[i].release();
      }
      registers.length = 0;
    }

    animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
    animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
    animation.renderer.globalData.pushExpression = pushExpression;
    animation.renderer.globalData.popExpression = popExpression;
    animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
  }
  return ob;
}());

expressionsPlugin = Expressions;

/* eslint-disable camelcase, no-unused-vars */
/* global BMMath, BezierFactory, createTypedArray, degToRads, shapePool */

var ExpressionManager = (function () {
  'use strict';

  var ob = {};
  var Math = BMMath;
  var window = null;
  var document = null;
  var XMLHttpRequest = null;
  var fetch = null;

  function $bm_isInstanceOfArray(arr) {
    return arr.constructor === Array || arr.constructor === Float32Array;
  }

  function isNumerable(tOfV, v) {
    return tOfV === 'number' || tOfV === 'boolean' || tOfV === 'string' || v instanceof Number;
  }

  function $bm_neg(a) {
    var tOfA = typeof a;
    if (tOfA === 'number' || tOfA === 'boolean' || a instanceof Number) {
      return -a;
    }
    if ($bm_isInstanceOfArray(a)) {
      var i;
      var lenA = a.length;
      var retArr = [];
      for (i = 0; i < lenA; i += 1) {
        retArr[i] = -a[i];
      }
      return retArr;
    }
    if (a.propType) {
      return a.v;
    }
    return -a;
  }

  var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
  var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
  var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;

  function sum(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    if (tOfA === 'string' || tOfB === 'string') {
      return a + b;
    }
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      return a + b;
    }
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      a = a.slice(0);
      a[0] += b;
      return a;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      b = b.slice(0);
      b[0] = a + b[0];
      return b;
    }
    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
      var i = 0;
      var lenA = a.length;
      var lenB = b.length;
      var retArr = [];
      while (i < lenA || i < lenB) {
        if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
          retArr[i] = a[i] + b[i];
        } else {
          retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
        }
        i += 1;
      }
      return retArr;
    }
    return 0;
  }
  var add = sum;

  function sub(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      if (tOfA === 'string') {
        a = parseInt(a, 10);
      }
      if (tOfB === 'string') {
        b = parseInt(b, 10);
      }
      return a - b;
    }
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      a = a.slice(0);
      a[0] -= b;
      return a;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      b = b.slice(0);
      b[0] = a - b[0];
      return b;
    }
    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
      var i = 0;
      var lenA = a.length;
      var lenB = b.length;
      var retArr = [];
      while (i < lenA || i < lenB) {
        if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
          retArr[i] = a[i] - b[i];
        } else {
          retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
        }
        i += 1;
      }
      return retArr;
    }
    return 0;
  }

  function mul(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    var arr;
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      return a * b;
    }

    var i;
    var len;
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      len = a.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a[i] * b;
      }
      return arr;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      len = b.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a * b[i];
      }
      return arr;
    }
    return 0;
  }

  function div(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    var arr;
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      return a / b;
    }
    var i;
    var len;
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      len = a.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a[i] / b;
      }
      return arr;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      len = b.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a / b[i];
      }
      return arr;
    }
    return 0;
  }
  function mod(a, b) {
    if (typeof a === 'string') {
      a = parseInt(a, 10);
    }
    if (typeof b === 'string') {
      b = parseInt(b, 10);
    }
    return a % b;
  }
  var $bm_sum = sum;
  var $bm_sub = sub;
  var $bm_mul = mul;
  var $bm_div = div;
  var $bm_mod = mod;

  function clamp(num, min, max) {
    if (min > max) {
      var mm = max;
      max = min;
      min = mm;
    }
    return Math.min(Math.max(num, min), max);
  }

  function radiansToDegrees(val) {
    return val / degToRads;
  }
  var radians_to_degrees = radiansToDegrees;

  function degreesToRadians(val) {
    return val * degToRads;
  }
  var degrees_to_radians = radiansToDegrees;

  var helperLengthArray = [0, 0, 0, 0, 0, 0];

  function length(arr1, arr2) {
    if (typeof arr1 === 'number' || arr1 instanceof Number) {
      arr2 = arr2 || 0;
      return Math.abs(arr1 - arr2);
    }
    if (!arr2) {
      arr2 = helperLengthArray;
    }
    var i;
    var len = Math.min(arr1.length, arr2.length);
    var addedLength = 0;
    for (i = 0; i < len; i += 1) {
      addedLength += Math.pow(arr2[i] - arr1[i], 2);
    }
    return Math.sqrt(addedLength);
  }

  function normalize(vec) {
    return div(vec, length(vec));
  }

  function rgbToHsl(val) {
    var r = val[0]; var g = val[1]; var b = val[2];
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h;
    var s;
    var l = (max + min) / 2;

    if (max === min) {
      h = 0; // achromatic
      s = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
        default: break;
      }
      h /= 6;
    }

    return [h, s, l, val[3]];
  }

  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }

  function hslToRgb(val) {
    var h = val[0];
    var s = val[1];
    var l = val[2];

    var r;
    var g;
    var b;

    if (s === 0) {
      r = l; // achromatic
      b = l; // achromatic
      g = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r, g, b, val[3]];
  }

  function linear(t, tMin, tMax, value1, value2) {
    if (value1 === undefined || value2 === undefined) {
      value1 = tMin;
      value2 = tMax;
      tMin = 0;
      tMax = 1;
    }
    if (tMax < tMin) {
      var _tMin = tMax;
      tMax = tMin;
      tMin = _tMin;
    }
    if (t <= tMin) {
      return value1;
    } if (t >= tMax) {
      return value2;
    }
    var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
    if (!value1.length) {
      return value1 + (value2 - value1) * perc;
    }
    var i;
    var len = value1.length;
    var arr = createTypedArray('float32', len);
    for (i = 0; i < len; i += 1) {
      arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
    }
    return arr;
  }
  function random(min, max) {
    if (max === undefined) {
      if (min === undefined) {
        min = 0;
        max = 1;
      } else {
        max = min;
        min = undefined;
      }
    }
    if (max.length) {
      var i;
      var len = max.length;
      if (!min) {
        min = createTypedArray('float32', len);
      }
      var arr = createTypedArray('float32', len);
      var rnd = BMMath.random();
      for (i = 0; i < len; i += 1) {
        arr[i] = min[i] + rnd * (max[i] - min[i]);
      }
      return arr;
    }
    if (min === undefined) {
      min = 0;
    }
    var rndm = BMMath.random();
    return min + rndm * (max - min);
  }

  function createPath(points, inTangents, outTangents, closed) {
    var i;
    var len = points.length;
    var path = shapePool.newElement();
    path.setPathData(!!closed, len);
    var arrPlaceholder = [0, 0];
    var inVertexPoint;
    var outVertexPoint;
    for (i = 0; i < len; i += 1) {
      inVertexPoint = (inTangents && inTangents[i]) ? inTangents[i] : arrPlaceholder;
      outVertexPoint = (outTangents && outTangents[i]) ? outTangents[i] : arrPlaceholder;
      path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
    }
    return path;
  }

  function initiateExpression(elem, data, property) {
    var val = data.x;
    var needsVelocity = /velocity(?![\w\d])/.test(val);
    var _needsRandom = val.indexOf('random') !== -1;
    var elemType = elem.data.ty;
    var transform;
    var $bm_transform;
    var content;
    var effect;
    var thisProperty = property;
    thisProperty.valueAtTime = thisProperty.getValueAtTime;
    Object.defineProperty(thisProperty, 'value', {
      get: function () {
        return thisProperty.v;
      },
    });
    elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
    elem.comp.displayStartTime = 0;
    var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
    var outPoint = elem.data.op / elem.comp.globalData.frameRate;
    var width = elem.data.sw ? elem.data.sw : 0;
    var height = elem.data.sh ? elem.data.sh : 0;
    var name = elem.data.nm;
    var loopIn;
    var loop_in;
    var loopOut;
    var loop_out;
    var smooth;
    var toWorld;
    var fromWorld;
    var fromComp;
    var toComp;
    var fromCompToSurface;
    var position;
    var rotation;
    var anchorPoint;
    var scale;
    var thisLayer;
    var thisComp;
    var mask;
    var valueAtTime;
    var velocityAtTime;

    var scoped_bm_rt;
    // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls
    var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval
    var numKeys = property.kf ? data.k.length : 0;

    var active = !this.data || this.data.hd !== true;

    var wiggle = function wiggle(freq, amp) {
      var iWiggle;
      var j;
      var lenWiggle = this.pv.length ? this.pv.length : 1;
      var addedAmps = createTypedArray('float32', lenWiggle);
      freq = 5;
      var iterations = Math.floor(time * freq);
      iWiggle = 0;
      j = 0;
      while (iWiggle < iterations) {
        // var rnd = BMMath.random();
        for (j = 0; j < lenWiggle; j += 1) {
          addedAmps[j] += -amp + amp * 2 * BMMath.random();
          // addedAmps[j] += -amp + amp*2*rnd;
        }
        iWiggle += 1;
      }
      // var rnd2 = BMMath.random();
      var periods = time * freq;
      var perc = periods - Math.floor(periods);
      var arr = createTypedArray('float32', lenWiggle);
      if (lenWiggle > 1) {
        for (j = 0; j < lenWiggle; j += 1) {
          arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
          // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
          // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
        }
        return arr;
      }
      return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
    }.bind(this);

    if (thisProperty.loopIn) {
      loopIn = thisProperty.loopIn.bind(thisProperty);
      loop_in = loopIn;
    }

    if (thisProperty.loopOut) {
      loopOut = thisProperty.loopOut.bind(thisProperty);
      loop_out = loopOut;
    }

    if (thisProperty.smooth) {
      smooth = thisProperty.smooth.bind(thisProperty);
    }

    function loopInDuration(type, duration) {
      return loopIn(type, duration, true);
    }

    function loopOutDuration(type, duration) {
      return loopOut(type, duration, true);
    }

    if (this.getValueAtTime) {
      valueAtTime = this.getValueAtTime.bind(this);
    }

    if (this.getVelocityAtTime) {
      velocityAtTime = this.getVelocityAtTime.bind(this);
    }

    var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

    function lookAt(elem1, elem2) {
      var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
      var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
      var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
      return [yaw, pitch, 0];
    }

    function easeOut(t, tMin, tMax, val1, val2) {
      return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
    }

    function easeIn(t, tMin, tMax, val1, val2) {
      return applyEase(easeInBez, t, tMin, tMax, val1, val2);
    }

    function ease(t, tMin, tMax, val1, val2) {
      return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
    }

    function applyEase(fn, t, tMin, tMax, val1, val2) {
      if (val1 === undefined) {
        val1 = tMin;
        val2 = tMax;
      } else {
        t = (t - tMin) / (tMax - tMin);
      }
      if (t > 1) {
        t = 1;
      } else if (t < 0) {
        t = 0;
      }
      var mult = fn(t);
      if ($bm_isInstanceOfArray(val1)) {
        var iKey;
        var lenKey = val1.length;
        var arr = createTypedArray('float32', lenKey);
        for (iKey = 0; iKey < lenKey; iKey += 1) {
          arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
        }
        return arr;
      }
      return (val2 - val1) * mult + val1;
    }

    function nearestKey(time) {
      var iKey;
      var lenKey = data.k.length;
      var index;
      var keyTime;
      if (!data.k.length || typeof (data.k[0]) === 'number') {
        index = 0;
        keyTime = 0;
      } else {
        index = -1;
        time *= elem.comp.globalData.frameRate;
        if (time < data.k[0].t) {
          index = 1;
          keyTime = data.k[0].t;
        } else {
          for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
            if (time === data.k[iKey].t) {
              index = iKey + 1;
              keyTime = data.k[iKey].t;
              break;
            } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
              if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
                index = iKey + 2;
                keyTime = data.k[iKey + 1].t;
              } else {
                index = iKey + 1;
                keyTime = data.k[iKey].t;
              }
              break;
            }
          }
          if (index === -1) {
            index = iKey + 1;
            keyTime = data.k[iKey].t;
          }
        }
      }
      var obKey = {};
      obKey.index = index;
      obKey.time = keyTime / elem.comp.globalData.frameRate;
      return obKey;
    }

    function key(ind) {
      var obKey;
      var iKey;
      var lenKey;
      if (!data.k.length || typeof (data.k[0]) === 'number') {
        throw new Error('The property has no keyframe at index ' + ind);
      }
      ind -= 1;
      obKey = {
        time: data.k[ind].t / elem.comp.globalData.frameRate,
        value: [],
      };
      var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;

      lenKey = arr.length;
      for (iKey = 0; iKey < lenKey; iKey += 1) {
        obKey[iKey] = arr[iKey];
        obKey.value[iKey] = arr[iKey];
      }
      return obKey;
    }

    function framesToTime(frames, fps) {
      if (!fps) {
        fps = elem.comp.globalData.frameRate;
      }
      return frames / fps;
    }

    function timeToFrames(t, fps) {
      if (!t && t !== 0) {
        t = time;
      }
      if (!fps) {
        fps = elem.comp.globalData.frameRate;
      }
      return t * fps;
    }

    function seedRandom(seed) {
      BMMath.seedrandom(randSeed + seed);
    }

    function sourceRectAtTime() {
      return elem.sourceRectAtTime();
    }

    function substring(init, end) {
      if (typeof value === 'string') {
        if (end === undefined) {
          return value.substring(init);
        }
        return value.substring(init, end);
      }
      return '';
    }

    function substr(init, end) {
      if (typeof value === 'string') {
        if (end === undefined) {
          return value.substr(init);
        }
        return value.substr(init, end);
      }
      return '';
    }

    function posterizeTime(framesPerSecond) {
      time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
      value = valueAtTime(time);
    }

    var time;
    var velocity;
    var value;
    var text;
    var textIndex;
    var textTotal;
    var selectorValue;
    var index = elem.data.ind;
    var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
    var parent;
    var randSeed = Math.floor(Math.random() * 1000000);
    var globalData = elem.globalData;
    function executeExpression(_value) {
      // globalData.pushExpression();
      value = _value;
      if (_needsRandom) {
        seedRandom(randSeed);
      }
      if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
        return value;
      }
      if (this.propType === 'textSelector') {
        textIndex = this.textIndex;
        textTotal = this.textTotal;
        selectorValue = this.selectorValue;
      }
      if (!thisLayer) {
        text = elem.layerInterface.text;
        thisLayer = elem.layerInterface;
        thisComp = elem.comp.compInterface;
        toWorld = thisLayer.toWorld.bind(thisLayer);
        fromWorld = thisLayer.fromWorld.bind(thisLayer);
        fromComp = thisLayer.fromComp.bind(thisLayer);
        toComp = thisLayer.toComp.bind(thisLayer);
        mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
        fromCompToSurface = fromComp;
      }
      if (!transform) {
        transform = elem.layerInterface('ADBE Transform Group');
        $bm_transform = transform;
        if (transform) {
          anchorPoint = transform.anchorPoint;
          /* position = transform.position;
                    rotation = transform.rotation;
                    scale = transform.scale; */
        }
      }

      if (elemType === 4 && !content) {
        content = thisLayer('ADBE Root Vectors Group');
      }
      if (!effect) {
        effect = thisLayer(4);
      }
      hasParent = !!(elem.hierarchy && elem.hierarchy.length);
      if (hasParent && !parent) {
        parent = elem.hierarchy[0].layerInterface;
      }
      time = this.comp.renderedFrame / this.comp.globalData.frameRate;
      if (needsVelocity) {
        velocity = velocityAtTime(time);
      }
      expression_function();
      this.frameExpressionId = elem.globalData.frameId;

      // TODO: Check if it's possible to return on ShapeInterface the .v value
      if (scoped_bm_rt.propType === 'shape') {
        scoped_bm_rt = scoped_bm_rt.v;
      }
      // globalData.popExpression();
      return scoped_bm_rt;
    }
    return executeExpression;
  }

  ob.initiateExpression = initiateExpression;
  return ob;
}());

/* global ExpressionManager, createTypedArray */
/* exported expressionHelpers */

var expressionHelpers = (function () {
  function searchExpressions(elem, data, prop) {
    if (data.x) {
      prop.k = true;
      prop.x = true;
      prop.initiateExpression = ExpressionManager.initiateExpression;
      prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
    }
  }

  function getValueAtTime(frameNum) {
    frameNum *= this.elem.globalData.frameRate;
    frameNum -= this.offsetTime;
    if (frameNum !== this._cachingAtTime.lastFrame) {
      this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
      this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
      this._cachingAtTime.lastFrame = frameNum;
    }
    return this._cachingAtTime.value;
  }

  function getSpeedAtTime(frameNum) {
    var delta = -0.01;
    var v1 = this.getValueAtTime(frameNum);
    var v2 = this.getValueAtTime(frameNum + delta);
    var speed = 0;
    if (v1.length) {
      var i;
      for (i = 0; i < v1.length; i += 1) {
        speed += Math.pow(v2[i] - v1[i], 2);
      }
      speed = Math.sqrt(speed) * 100;
    } else {
      speed = 0;
    }
    return speed;
  }

  function getVelocityAtTime(frameNum) {
    if (this.vel !== undefined) {
      return this.vel;
    }
    var delta = -0.001;
    // frameNum += this.elem.data.st;
    var v1 = this.getValueAtTime(frameNum);
    var v2 = this.getValueAtTime(frameNum + delta);
    var velocity;
    if (v1.length) {
      velocity = createTypedArray('float32', v1.length);
      var i;
      for (i = 0; i < v1.length; i += 1) {
        // removing frameRate
        // if needed, don't add it here
        // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
        velocity[i] = (v2[i] - v1[i]) / delta;
      }
    } else {
      velocity = (v2 - v1) / delta;
    }
    return velocity;
  }

  function getStaticValueAtTime() {
    return this.pv;
  }

  function setGroupProperty(propertyGroup) {
    this.propertyGroup = propertyGroup;
  }

  return {
    searchExpressions: searchExpressions,
    getSpeedAtTime: getSpeedAtTime,
    getVelocityAtTime: getVelocityAtTime,
    getValueAtTime: getValueAtTime,
    getStaticValueAtTime: getStaticValueAtTime,
    setGroupProperty: setGroupProperty,
  };
}());

/* global createTypedArray, Matrix, TransformPropertyFactory, expressionHelpers, PropertyFactory, expressionHelpers,
initialDefaultFrame, shapePool, ShapePropertyFactory, bez, extendPrototype, ExpressionManager, createSizedArray */

(function addPropertyDecorator() {
  function loopOut(type, duration, durationFlag) {
    if (!this.k || !this.keyframes) {
      return this.pv;
    }
    type = type ? type.toLowerCase() : '';
    var currentFrame = this.comp.renderedFrame;
    var keyframes = this.keyframes;
    var lastKeyFrame = keyframes[keyframes.length - 1].t;
    if (currentFrame <= lastKeyFrame) {
      return this.pv;
    }
    var cycleDuration;
    var firstKeyFrame;
    if (!durationFlag) {
      if (!duration || duration > keyframes.length - 1) {
        duration = keyframes.length - 1;
      }
      firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
      cycleDuration = lastKeyFrame - firstKeyFrame;
    } else {
      if (!duration) {
        cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
      } else {
        cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
      }
      firstKeyFrame = lastKeyFrame - cycleDuration;
    }
    var i;
    var len;
    var ret;
    if (type === 'pingpong') {
      var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
      if (iterations % 2 !== 0) {
          return this.getValueAtTime(((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
      }
    } else if (type === 'offset') {
      var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
      var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
        var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
      var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
      if (this.pv.length) {
        ret = new Array(initV.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
          ret[i] = (endV[i] - initV[i]) * repeats + current[i];
        }
        return ret;
      }
      return (endV - initV) * repeats + current;
    } else if (type === 'continue') {
      var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
      var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
      if (this.pv.length) {
        ret = new Array(lastValue.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
            ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
        }
        return ret;
      }
      return lastValue + (lastValue - nextLastValue) * (((currentFrame - lastKeyFrame)) / 0.001);
    }
      return this.getValueAtTime((((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line

  }

  function loopIn(type, duration, durationFlag) {
    if (!this.k) {
      return this.pv;
    }
    type = type ? type.toLowerCase() : '';
    var currentFrame = this.comp.renderedFrame;
    var keyframes = this.keyframes;
    var firstKeyFrame = keyframes[0].t;
    if (currentFrame >= firstKeyFrame) {
      return this.pv;
    }
    var cycleDuration;
    var lastKeyFrame;
    if (!durationFlag) {
      if (!duration || duration > keyframes.length - 1) {
        duration = keyframes.length - 1;
      }
      lastKeyFrame = keyframes[duration].t;
      cycleDuration = lastKeyFrame - firstKeyFrame;
    } else {
      if (!duration) {
        cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
      } else {
        cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
      }
      lastKeyFrame = firstKeyFrame + cycleDuration;
    }
    var i;
    var len;
    var ret;
    if (type === 'pingpong') {
      var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
      if (iterations % 2 === 0) {
          return this.getValueAtTime((((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
      }
    } else if (type === 'offset') {
      var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
      var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
      var current = this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration) + firstKeyFrame) / this.comp.globalData.frameRate, 0);
      var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
      if (this.pv.length) {
        ret = new Array(initV.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
          ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
        }
        return ret;
      }
      return current - (endV - initV) * repeats;
    } else if (type === 'continue') {
      var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
      var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
      if (this.pv.length) {
        ret = new Array(firstValue.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
          ret[i] = firstValue[i] + ((firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame)) / 0.001;
        }
        return ret;
      }
      return firstValue + ((firstValue - nextFirstValue) * (firstKeyFrame - currentFrame)) / 0.001;
    }
      return this.getValueAtTime(((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame))) / this.comp.globalData.frameRate, 0); // eslint-disable-line

  }

  function smooth(width, samples) {
    if (!this.k) {
      return this.pv;
    }
    width = (width || 0.4) * 0.5;
    samples = Math.floor(samples || 5);
    if (samples <= 1) {
      return this.pv;
    }
    var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
    var initFrame = currentTime - width;
    var endFrame = currentTime + width;
    var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
    var i = 0;
    var j = 0;
    var value;
    if (this.pv.length) {
      value = createTypedArray('float32', this.pv.length);
    } else {
      value = 0;
    }
    var sampleValue;
    while (i < samples) {
      sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
      if (this.pv.length) {
        for (j = 0; j < this.pv.length; j += 1) {
          value[j] += sampleValue[j];
        }
      } else {
        value += sampleValue;
      }
      i += 1;
    }
    if (this.pv.length) {
      for (j = 0; j < this.pv.length; j += 1) {
        value[j] /= samples;
      }
    } else {
      value /= samples;
    }
    return value;
  }

  function getTransformValueAtTime(time) {
    if (!this._transformCachingAtTime) {
      this._transformCachingAtTime = {
        v: new Matrix(),
      };
    }
    /// /
    var matrix = this._transformCachingAtTime.v;
    matrix.cloneFromProps(this.pre.props);
    if (this.appliedTransformations < 1) {
      var anchor = this.a.getValueAtTime(time);
      matrix.translate(
        -anchor[0] * this.a.mult,
        -anchor[1] * this.a.mult,
        anchor[2] * this.a.mult
      );
    }
    if (this.appliedTransformations < 2) {
      var scale = this.s.getValueAtTime(time);
      matrix.scale(
        scale[0] * this.s.mult,
        scale[1] * this.s.mult,
        scale[2] * this.s.mult
      );
    }
    if (this.sk && this.appliedTransformations < 3) {
      var skew = this.sk.getValueAtTime(time);
      var skewAxis = this.sa.getValueAtTime(time);
      matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
    }
    if (this.r && this.appliedTransformations < 4) {
      var rotation = this.r.getValueAtTime(time);
      matrix.rotate(-rotation * this.r.mult);
    } else if (!this.r && this.appliedTransformations < 4) {
      var rotationZ = this.rz.getValueAtTime(time);
      var rotationY = this.ry.getValueAtTime(time);
      var rotationX = this.rx.getValueAtTime(time);
      var orientation = this.or.getValueAtTime(time);
      matrix.rotateZ(-rotationZ * this.rz.mult)
        .rotateY(rotationY * this.ry.mult)
        .rotateX(rotationX * this.rx.mult)
        .rotateZ(-orientation[2] * this.or.mult)
        .rotateY(orientation[1] * this.or.mult)
        .rotateX(orientation[0] * this.or.mult);
    }
    if (this.data.p && this.data.p.s) {
      var positionX = this.px.getValueAtTime(time);
      var positionY = this.py.getValueAtTime(time);
      if (this.data.p.z) {
        var positionZ = this.pz.getValueAtTime(time);
        matrix.translate(
          positionX * this.px.mult,
          positionY * this.py.mult,
          -positionZ * this.pz.mult
        );
      } else {
        matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
      }
    } else {
      var position = this.p.getValueAtTime(time);
      matrix.translate(
        position[0] * this.p.mult,
        position[1] * this.p.mult,
        -position[2] * this.p.mult
      );
    }
    return matrix;
    /// /
  }

  function getTransformStaticValueAtTime() {
    return this.v.clone(new Matrix());
  }

  var getTransformProperty = TransformPropertyFactory.getTransformProperty;
  TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
    var prop = getTransformProperty(elem, data, container);
    if (prop.dynamicProperties.length) {
      prop.getValueAtTime = getTransformValueAtTime.bind(prop);
    } else {
      prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
    }
    prop.setGroupProperty = expressionHelpers.setGroupProperty;
    return prop;
  };

  var propertyGetProp = PropertyFactory.getProp;
  PropertyFactory.getProp = function (elem, data, type, mult, container) {
    var prop = propertyGetProp(elem, data, type, mult, container);
    // prop.getVelocityAtTime = getVelocityAtTime;
    // prop.loopOut = loopOut;
    // prop.loopIn = loopIn;
    if (prop.kf) {
      prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
    } else {
      prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
    }
    prop.setGroupProperty = expressionHelpers.setGroupProperty;
    prop.loopOut = loopOut;
    prop.loopIn = loopIn;
    prop.smooth = smooth;
    prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
    prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
    prop.numKeys = data.a === 1 ? data.k.length : 0;
    prop.propertyIndex = data.ix;
    var value = 0;
    if (type !== 0) {
      value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
    }
    prop._cachingAtTime = {
      lastFrame: initialDefaultFrame,
      lastIndex: 0,
      value: value,
    };
    expressionHelpers.searchExpressions(elem, data, prop);
    if (prop.k) {
      container.addDynamicProperty(prop);
    }

    return prop;
  };

  function getShapeValueAtTime(frameNum) {
    // For now this caching object is created only when needed instead of creating it when the shape is initialized.
    if (!this._cachingAtTime) {
      this._cachingAtTime = {
        shapeValue: shapePool.clone(this.pv),
        lastIndex: 0,
        lastTime: initialDefaultFrame,
      };
    }

    frameNum *= this.elem.globalData.frameRate;
    frameNum -= this.offsetTime;
    if (frameNum !== this._cachingAtTime.lastTime) {
      this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
      this._cachingAtTime.lastTime = frameNum;
      this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
    }
    return this._cachingAtTime.shapeValue;
  }

  var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
  var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

  function ShapeExpressions() {}
  ShapeExpressions.prototype = {
    vertices: function (prop, time) {
      if (this.k) {
        this.getValue();
      }
      var shapePath = this.v;
      if (time !== undefined) {
        shapePath = this.getValueAtTime(time, 0);
      }
      var i;
      var len = shapePath._length;
      var vertices = shapePath[prop];
      var points = shapePath.v;
      var arr = createSizedArray(len);
      for (i = 0; i < len; i += 1) {
        if (prop === 'i' || prop === 'o') {
          arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
        } else {
          arr[i] = [vertices[i][0], vertices[i][1]];
        }
      }
      return arr;
    },
    points: function (time) {
      return this.vertices('v', time);
    },
    inTangents: function (time) {
      return this.vertices('i', time);
    },
    outTangents: function (time) {
      return this.vertices('o', time);
    },
    isClosed: function () {
      return this.v.c;
    },
    pointOnPath: function (perc, time) {
      var shapePath = this.v;
      if (time !== undefined) {
        shapePath = this.getValueAtTime(time, 0);
      }
      if (!this._segmentsLength) {
        this._segmentsLength = bez.getSegmentsLength(shapePath);
      }

      var segmentsLength = this._segmentsLength;
      var lengths = segmentsLength.lengths;
      var lengthPos = segmentsLength.totalLength * perc;
      var i = 0;
      var len = lengths.length;
      var accumulatedLength = 0;
      var pt;
      while (i < len) {
        if (accumulatedLength + lengths[i].addedLength > lengthPos) {
          var initIndex = i;
          var endIndex = (shapePath.c && i === len - 1) ? 0 : i + 1;
          var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
          pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
          break;
        } else {
          accumulatedLength += lengths[i].addedLength;
        }
        i += 1;
      }
      if (!pt) {
        pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
      }
      return pt;
    },
    vectorOnPath: function (perc, time, vectorType) {
      // perc doesn't use triple equality because it can be a Number object as well as a primitive.
      if (perc == 1) { // eslint-disable-line eqeqeq
        perc = this.v.c;
      } else if (perc == 0) { // eslint-disable-line eqeqeq
        perc = 0.999;
      }
      var pt1 = this.pointOnPath(perc, time);
      var pt2 = this.pointOnPath(perc + 0.001, time);
      var xLength = pt2[0] - pt1[0];
      var yLength = pt2[1] - pt1[1];
      var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
      if (magnitude === 0) {
        return [0, 0];
      }
      var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
      return unitVector;
    },
    tangentOnPath: function (perc, time) {
      return this.vectorOnPath(perc, time, 'tangent');
    },
    normalOnPath: function (perc, time) {
      return this.vectorOnPath(perc, time, 'normal');
    },
    setGroupProperty: expressionHelpers.setGroupProperty,
    getValueAtTime: expressionHelpers.getStaticValueAtTime,
  };
  extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
  extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
  KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
  KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;

  var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
  ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
    var prop = propertyGetShapeProp(elem, data, type, arr, trims);
    prop.propertyIndex = data.ix;
    prop.lock = false;
    if (type === 3) {
      expressionHelpers.searchExpressions(elem, data.pt, prop);
    } else if (type === 4) {
      expressionHelpers.searchExpressions(elem, data.ks, prop);
    }
    if (prop.k) {
      elem.addDynamicProperty(prop);
    }
    return prop;
  };
}());

/* global ExpressionManager, TextProperty */

(function addDecorator() {
  function searchExpressions() {
    if (this.data.d.x) {
      this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
      this.addEffect(this.getExpressionValue.bind(this));
      return true;
    }
    return null;
  }

  TextProperty.prototype.getExpressionValue = function (currentValue, text) {
    var newValue = this.calculateExpression(text);
    if (currentValue.t !== newValue) {
      var newData = {};
      this.copyData(newData, currentValue);
      newData.t = newValue.toString();
      newData.__complete = false;
      return newData;
    }
    return currentValue;
  };

  TextProperty.prototype.searchProperty = function () {
    var isKeyframed = this.searchKeyframes();
    var hasExpressions = this.searchExpressions();
    this.kf = isKeyframed || hasExpressions;
    return this.kf;
  };

  TextProperty.prototype.searchExpressions = searchExpressions;
}());

/* global propertyGroupFactory, PropertyInterface */
/* exported ShapePathInterface */

var ShapePathInterface = (

  function () {
    return function pathInterfaceFactory(shape, view, propertyGroup) {
      var prop = view.sh;

      function interfaceFunction(val) {
        if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
          return interfaceFunction.path;
        }
        return null;
      }

      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
      prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
      Object.defineProperties(interfaceFunction, {
        path: {
          get: function () {
            if (prop.k) {
              prop.getValue();
            }
            return prop;
          },
        },
        shape: {
          get: function () {
            if (prop.k) {
              prop.getValue();
            }
            return prop;
          },
        },
        _name: { value: shape.nm },
        ix: { value: shape.ix },
        propertyIndex: { value: shape.ix },
        mn: { value: shape.mn },
        propertyGroup: { value: propertyGroup },
      });
      return interfaceFunction;
    };
  }()
);

/* exported propertyGroupFactory */

var propertyGroupFactory = (function () {
  return function (interfaceFunction, parentPropertyGroup) {
    return function (val) {
      val = val === undefined ? 1 : val;
      if (val <= 0) {
        return interfaceFunction;
      }
      return parentPropertyGroup(val - 1);
    };
  };
}());

/* exported PropertyInterface */

var PropertyInterface = (function () {
  return function (propertyName, propertyGroup) {
    var interfaceFunction = {
      _name: propertyName,
    };

    function _propertyGroup(val) {
      val = val === undefined ? 1 : val;
      if (val <= 0) {
        return interfaceFunction;
      }
      return propertyGroup(val - 1);
    }

    return _propertyGroup;
  };
}());

/* global ExpressionPropertyInterface, PropertyInterface, propertyGroupFactory, ShapePathInterface */
/* exported ShapeExpressionInterface */

var ShapeExpressionInterface = (function () {
  function iterateElements(shapes, view, propertyGroup) {
    var arr = [];
    var i;
    var len = shapes ? shapes.length : 0;
    for (i = 0; i < len; i += 1) {
      if (shapes[i].ty === 'gr') {
        arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'fl') {
        arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'st') {
        arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'tm') {
        arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'tr') {
        // arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));
      } else if (shapes[i].ty === 'el') {
        arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'sr') {
        arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'sh') {
        arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'rc') {
        arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'rd') {
        arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'rp') {
        arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'gf') {
        arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else {
        arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));
      }
    }
    return arr;
  }

  function contentsInterfaceFactory(shape, view, propertyGroup) {
    var interfaces;
    var interfaceFunction = function _interfaceFunction(value) {
      var i = 0;
      var len = interfaces.length;
      while (i < len) {
        if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
          return interfaces[i];
        }
        i += 1;
      }
      if (typeof value === 'number') {
        return interfaces[value - 1];
      }
      return null;
    };

    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
    interfaceFunction.numProperties = interfaces.length;
    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
    interfaceFunction.transform = transformInterface;
    interfaceFunction.propertyIndex = shape.cix;
    interfaceFunction._name = shape.nm;

    return interfaceFunction;
  }

  function groupInterfaceFactory(shape, view, propertyGroup) {
    var interfaceFunction = function _interfaceFunction(value) {
      switch (value) {
        case 'ADBE Vectors Group':
        case 'Contents':
        case 2:
          return interfaceFunction.content;
          // Not necessary for now. Keeping them here in case a new case appears
          // case 'ADBE Vector Transform Group':
          // case 3:
        default:
          return interfaceFunction.transform;
      }
    };
    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
    interfaceFunction.content = content;
    interfaceFunction.transform = transformInterface;
    Object.defineProperty(interfaceFunction, '_name', {
      get: function () {
        return shape.nm;
      },
    });
    // interfaceFunction.content = interfaceFunction;
    interfaceFunction.numProperties = shape.np;
    interfaceFunction.propertyIndex = shape.ix;
    interfaceFunction.nm = shape.nm;
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function fillInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(val) {
      if (val === 'Color' || val === 'color') {
        return interfaceFunction.color;
      } if (val === 'Opacity' || val === 'opacity') {
        return interfaceFunction.opacity;
      }
      return null;
    }
    Object.defineProperties(interfaceFunction, {
      color: {
        get: ExpressionPropertyInterface(view.c),
      },
      opacity: {
        get: ExpressionPropertyInterface(view.o),
      },
      _name: { value: shape.nm },
      mn: { value: shape.mn },
    });

    view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
    return interfaceFunction;
  }

  function gradientFillInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(val) {
      if (val === 'Start Point' || val === 'start point') {
        return interfaceFunction.startPoint;
      }
      if (val === 'End Point' || val === 'end point') {
        return interfaceFunction.endPoint;
      }
      if (val === 'Opacity' || val === 'opacity') {
        return interfaceFunction.opacity;
      }
      return null;
    }
    Object.defineProperties(interfaceFunction, {
      startPoint: {
        get: ExpressionPropertyInterface(view.s),
      },
      endPoint: {
        get: ExpressionPropertyInterface(view.e),
      },
      opacity: {
        get: ExpressionPropertyInterface(view.o),
      },
      type: {
        get: function () {
          return 'a';
        },
      },
      _name: { value: shape.nm },
      mn: { value: shape.mn },
    });

    view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
    view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
    return interfaceFunction;
  }
  function defaultInterfaceFactory() {
    function interfaceFunction() {
      return null;
    }
    return interfaceFunction;
  }

  function strokeInterfaceFactory(shape, view, propertyGroup) {
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
    function addPropertyToDashOb(i) {
      Object.defineProperty(dashOb, shape.d[i].nm, {
        get: ExpressionPropertyInterface(view.d.dataProps[i].p),
      });
    }
    var i;
    var len = shape.d ? shape.d.length : 0;
    var dashOb = {};
    for (i = 0; i < len; i += 1) {
      addPropertyToDashOb(i);
      view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
    }

    function interfaceFunction(val) {
      if (val === 'Color' || val === 'color') {
        return interfaceFunction.color;
      } if (val === 'Opacity' || val === 'opacity') {
        return interfaceFunction.opacity;
      } if (val === 'Stroke Width' || val === 'stroke width') {
        return interfaceFunction.strokeWidth;
      }
      return null;
    }
    Object.defineProperties(interfaceFunction, {
      color: {
        get: ExpressionPropertyInterface(view.c),
      },
      opacity: {
        get: ExpressionPropertyInterface(view.o),
      },
      strokeWidth: {
        get: ExpressionPropertyInterface(view.w),
      },
      dash: {
        get: function () {
          return dashOb;
        },
      },
      _name: { value: shape.nm },
      mn: { value: shape.mn },
    });

    view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
    view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
    return interfaceFunction;
  }

  function trimInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(val) {
      if (val === shape.e.ix || val === 'End' || val === 'end') {
        return interfaceFunction.end;
      }
      if (val === shape.s.ix) {
        return interfaceFunction.start;
      }
      if (val === shape.o.ix) {
        return interfaceFunction.offset;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    interfaceFunction.propertyIndex = shape.ix;

    view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
    view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
    interfaceFunction.propertyIndex = shape.ix;
    interfaceFunction.propertyGroup = propertyGroup;

    Object.defineProperties(interfaceFunction, {
      start: {
        get: ExpressionPropertyInterface(view.s),
      },
      end: {
        get: ExpressionPropertyInterface(view.e),
      },
      offset: {
        get: ExpressionPropertyInterface(view.o),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function transformInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.a.ix === value || value === 'Anchor Point') {
        return interfaceFunction.anchorPoint;
      }
      if (shape.o.ix === value || value === 'Opacity') {
        return interfaceFunction.opacity;
      }
      if (shape.p.ix === value || value === 'Position') {
        return interfaceFunction.position;
      }
      if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
        return interfaceFunction.rotation;
      }
      if (shape.s.ix === value || value === 'Scale') {
        return interfaceFunction.scale;
      }
      if ((shape.sk && shape.sk.ix === value) || value === 'Skew') {
        return interfaceFunction.skew;
      }
      if ((shape.sa && shape.sa.ix === value) || value === 'Skew Axis') {
        return interfaceFunction.skewAxis;
      }
      return null;
    }
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
    view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
    view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
    view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
    view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
    if (view.transform.mProps.sk) {
      view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
      view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
    }
    view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
    Object.defineProperties(interfaceFunction, {
      opacity: {
        get: ExpressionPropertyInterface(view.transform.mProps.o),
      },
      position: {
        get: ExpressionPropertyInterface(view.transform.mProps.p),
      },
      anchorPoint: {
        get: ExpressionPropertyInterface(view.transform.mProps.a),
      },
      scale: {
        get: ExpressionPropertyInterface(view.transform.mProps.s),
      },
      rotation: {
        get: ExpressionPropertyInterface(view.transform.mProps.r),
      },
      skew: {
        get: ExpressionPropertyInterface(view.transform.mProps.sk),
      },
      skewAxis: {
        get: ExpressionPropertyInterface(view.transform.mProps.sa),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.ty = 'tr';
    interfaceFunction.mn = shape.mn;
    interfaceFunction.propertyGroup = propertyGroup;
    return interfaceFunction;
  }

  function ellipseInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.p.ix === value) {
        return interfaceFunction.position;
      }
      if (shape.s.ix === value) {
        return interfaceFunction.size;
      }
      return null;
    }
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    interfaceFunction.propertyIndex = shape.ix;
    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
    prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));

    Object.defineProperties(interfaceFunction, {
      size: {
        get: ExpressionPropertyInterface(prop.s),
      },
      position: {
        get: ExpressionPropertyInterface(prop.p),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function starInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.p.ix === value) {
        return interfaceFunction.position;
      }
      if (shape.r.ix === value) {
        return interfaceFunction.rotation;
      }
      if (shape.pt.ix === value) {
        return interfaceFunction.points;
      }
      if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
        return interfaceFunction.outerRadius;
      }
      if (shape.os.ix === value) {
        return interfaceFunction.outerRoundness;
      }
      if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
        return interfaceFunction.innerRadius;
      }
      if (shape.is && shape.is.ix === value) {
        return interfaceFunction.innerRoundness;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
    interfaceFunction.propertyIndex = shape.ix;
    prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
    prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
    prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
    prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
    if (shape.ir) {
      prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
      prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
    }

    Object.defineProperties(interfaceFunction, {
      position: {
        get: ExpressionPropertyInterface(prop.p),
      },
      rotation: {
        get: ExpressionPropertyInterface(prop.r),
      },
      points: {
        get: ExpressionPropertyInterface(prop.pt),
      },
      outerRadius: {
        get: ExpressionPropertyInterface(prop.or),
      },
      outerRoundness: {
        get: ExpressionPropertyInterface(prop.os),
      },
      innerRadius: {
        get: ExpressionPropertyInterface(prop.ir),
      },
      innerRoundness: {
        get: ExpressionPropertyInterface(prop.is),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function rectInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.p.ix === value) {
        return interfaceFunction.position;
      }
      if (shape.r.ix === value) {
        return interfaceFunction.roundness;
      }
      if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
        return interfaceFunction.size;
      }
      return null;
    }
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
    interfaceFunction.propertyIndex = shape.ix;
    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
    prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
    prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));

    Object.defineProperties(interfaceFunction, {
      position: {
        get: ExpressionPropertyInterface(prop.p),
      },
      roundness: {
        get: ExpressionPropertyInterface(prop.r),
      },
      size: {
        get: ExpressionPropertyInterface(prop.s),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function roundedInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.r.ix === value || value === 'Round Corners 1') {
        return interfaceFunction.radius;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var prop = view;
    interfaceFunction.propertyIndex = shape.ix;
    prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));

    Object.defineProperties(interfaceFunction, {
      radius: {
        get: ExpressionPropertyInterface(prop.rd),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function repeaterInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.c.ix === value || value === 'Copies') {
        return interfaceFunction.copies;
      } if (shape.o.ix === value || value === 'Offset') {
        return interfaceFunction.offset;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var prop = view;
    interfaceFunction.propertyIndex = shape.ix;
    prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
    prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
    Object.defineProperties(interfaceFunction, {
      copies: {
        get: ExpressionPropertyInterface(prop.c),
      },
      offset: {
        get: ExpressionPropertyInterface(prop.o),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  return function (shapes, view, propertyGroup) {
    var interfaces;
    function _interfaceFunction(value) {
      if (typeof value === 'number') {
        value = value === undefined ? 1 : value;
        if (value === 0) {
          return propertyGroup;
        }
        return interfaces[value - 1];
      }
      var i = 0;
      var len = interfaces.length;
      while (i < len) {
        if (interfaces[i]._name === value) {
          return interfaces[i];
        }
        i += 1;
      }
      return null;
    }
    function parentGroupWrapper() {
      return propertyGroup;
    }
    _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
    interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
    _interfaceFunction.numProperties = interfaces.length;
    _interfaceFunction._name = 'Contents';
    return _interfaceFunction;
  };
}());

/* exported TextExpressionInterface */

var TextExpressionInterface = (function () {
  return function (elem) {
    var _prevValue;
    var _sourceText;
    function _thisLayerFunction(name) {
      switch (name) {
        case 'ADBE Text Document':
          return _thisLayerFunction.sourceText;
        default:
          return null;
      }
    }
    Object.defineProperty(_thisLayerFunction, 'sourceText', {
      get: function () {
        elem.textProperty.getValue();
        var stringValue = elem.textProperty.currentData.t;
        if (stringValue !== _prevValue) {
          elem.textProperty.currentData.t = _prevValue;
          _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
          // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
          _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers
        }
        return _sourceText;
      },
    });
    return _thisLayerFunction;
  };
}());

/* global Matrix, MaskManagerInterface, TransformExpressionInterface, getDescriptor */
/* exported LayerExpressionInterface */

var LayerExpressionInterface = (function () {
  function getMatrix(time) {
    var toWorldMat = new Matrix();
    if (time !== undefined) {
      var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
      propMatrix.clone(toWorldMat);
    } else {
      var transformMat = this._elem.finalTransform.mProp;
      transformMat.applyToMatrix(toWorldMat);
    }
    return toWorldMat;
  }

  function toWorldVec(arr, time) {
    var toWorldMat = this.getMatrix(time);
    toWorldMat.props[12] = 0;
    toWorldMat.props[13] = 0;
    toWorldMat.props[14] = 0;
    return this.applyPoint(toWorldMat, arr);
  }

  function toWorld(arr, time) {
    var toWorldMat = this.getMatrix(time);
    return this.applyPoint(toWorldMat, arr);
  }

  function fromWorldVec(arr, time) {
    var toWorldMat = this.getMatrix(time);
    toWorldMat.props[12] = 0;
    toWorldMat.props[13] = 0;
    toWorldMat.props[14] = 0;
    return this.invertPoint(toWorldMat, arr);
  }

  function fromWorld(arr, time) {
    var toWorldMat = this.getMatrix(time);
    return this.invertPoint(toWorldMat, arr);
  }

  function applyPoint(matrix, arr) {
    if (this._elem.hierarchy && this._elem.hierarchy.length) {
      var i;
      var len = this._elem.hierarchy.length;
      for (i = 0; i < len; i += 1) {
        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
      }
    }
    return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
  }

  function invertPoint(matrix, arr) {
    if (this._elem.hierarchy && this._elem.hierarchy.length) {
      var i;
      var len = this._elem.hierarchy.length;
      for (i = 0; i < len; i += 1) {
        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
      }
    }
    return matrix.inversePoint(arr);
  }

  function fromComp(arr) {
    var toWorldMat = new Matrix();
    toWorldMat.reset();
    this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
    if (this._elem.hierarchy && this._elem.hierarchy.length) {
      var i;
      var len = this._elem.hierarchy.length;
      for (i = 0; i < len; i += 1) {
        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
      }
      return toWorldMat.inversePoint(arr);
    }
    return toWorldMat.inversePoint(arr);
  }

  function sampleImage() {
    return [1, 1, 1, 1];
  }

  return function (elem) {
    var transformInterface;

    function _registerMaskInterface(maskManager) {
      _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
    }
    function _registerEffectsInterface(effects) {
      _thisLayerFunction.effect = effects;
    }

    function _thisLayerFunction(name) {
      switch (name) {
        case 'ADBE Root Vectors Group':
        case 'Contents':
        case 2:
          return _thisLayerFunction.shapeInterface;
        case 1:
        case 6:
        case 'Transform':
        case 'transform':
        case 'ADBE Transform Group':
          return transformInterface;
        case 4:
        case 'ADBE Effect Parade':
        case 'effects':
        case 'Effects':
          return _thisLayerFunction.effect;
        case 'ADBE Text Properties':
          return _thisLayerFunction.textInterface;
        default:
          return null;
      }
    }
    _thisLayerFunction.getMatrix = getMatrix;
    _thisLayerFunction.invertPoint = invertPoint;
    _thisLayerFunction.applyPoint = applyPoint;
    _thisLayerFunction.toWorld = toWorld;
    _thisLayerFunction.toWorldVec = toWorldVec;
    _thisLayerFunction.fromWorld = fromWorld;
    _thisLayerFunction.fromWorldVec = fromWorldVec;
    _thisLayerFunction.toComp = toWorld;
    _thisLayerFunction.fromComp = fromComp;
    _thisLayerFunction.sampleImage = sampleImage;
    _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
    _thisLayerFunction._elem = elem;
    transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
    var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
    Object.defineProperties(_thisLayerFunction, {
      hasParent: {
        get: function () {
          return elem.hierarchy.length;
        },
      },
      parent: {
        get: function () {
          return elem.hierarchy[0].layerInterface;
        },
      },
      rotation: getDescriptor(transformInterface, 'rotation'),
      scale: getDescriptor(transformInterface, 'scale'),
      position: getDescriptor(transformInterface, 'position'),
      opacity: getDescriptor(transformInterface, 'opacity'),
      anchorPoint: anchorPointDescriptor,
      anchor_point: anchorPointDescriptor,
      transform: {
        get: function () {
          return transformInterface;
        },
      },
      active: {
        get: function () {
          return elem.isInRange;
        },
      },
    });

    _thisLayerFunction.startTime = elem.data.st;
    _thisLayerFunction.index = elem.data.ind;
    _thisLayerFunction.source = elem.data.refId;
    _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
    _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
    _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
    _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
    _thisLayerFunction._name = elem.data.nm;

    _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
    _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
    return _thisLayerFunction;
  };
}());

/* global */
/* exported FootageInterface */

var FootageInterface = (function () {
  var outlineInterfaceFactory = (function (elem) {
    var currentPropertyName = '';
    var currentProperty = elem.getFootageData();
    function init() {
      currentPropertyName = '';
      currentProperty = elem.getFootageData();
      return searchProperty;
    }
    function searchProperty(value) {
      if (currentProperty[value]) {
        currentPropertyName = value;
        currentProperty = currentProperty[value];
        if (typeof currentProperty === 'object') {
          return searchProperty;
        }
        return currentProperty;
      }
      var propertyNameIndex = value.indexOf(currentPropertyName);
      if (propertyNameIndex !== -1) {
        var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
        currentProperty = currentProperty[index];
        if (typeof currentProperty === 'object') {
          return searchProperty;
        }
        return currentProperty;
      }
      return '';
    }
    return init;
  });

  var dataInterfaceFactory = function (elem) {
    function interfaceFunction(value) {
      if (value === 'Outline') {
        return interfaceFunction.outlineInterface();
      }
      return null;
    }

    interfaceFunction._name = 'Outline';
    interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
    return interfaceFunction;
  };

  return function (elem) {
    function _interfaceFunction(value) {
      if (value === 'Data') {
        return _interfaceFunction.dataInterface;
      }
      return null;
    }

    _interfaceFunction._name = 'Data';
    _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
    return _interfaceFunction;
  };
}());

/* exported CompExpressionInterface */

var CompExpressionInterface = (function () {
  return function (comp) {
    function _thisLayerFunction(name) {
      var i = 0;
      var len = comp.layers.length;
      while (i < len) {
        if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
          return comp.elements[i].layerInterface;
        }
        i += 1;
      }
      return null;
      // return {active:false};
    }
    Object.defineProperty(_thisLayerFunction, '_name', { value: comp.data.nm });
    _thisLayerFunction.layer = _thisLayerFunction;
    _thisLayerFunction.pixelAspect = 1;
    _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
    _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
    _thisLayerFunction.pixelAspect = 1;
    _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
    _thisLayerFunction.displayStartTime = 0;
    _thisLayerFunction.numLayers = comp.layers.length;
    return _thisLayerFunction;
  };
}());

/* global ExpressionPropertyInterface */
/* exported TransformExpressionInterface */

var TransformExpressionInterface = (function () {
  return function (transform) {
    function _thisFunction(name) {
      switch (name) {
        case 'scale':
        case 'Scale':
        case 'ADBE Scale':
        case 6:
          return _thisFunction.scale;
        case 'rotation':
        case 'Rotation':
        case 'ADBE Rotation':
        case 'ADBE Rotate Z':
        case 10:
          return _thisFunction.rotation;
        case 'ADBE Rotate X':
          return _thisFunction.xRotation;
        case 'ADBE Rotate Y':
          return _thisFunction.yRotation;
        case 'position':
        case 'Position':
        case 'ADBE Position':
        case 2:
          return _thisFunction.position;
        case 'ADBE Position_0':
          return _thisFunction.xPosition;
        case 'ADBE Position_1':
          return _thisFunction.yPosition;
        case 'ADBE Position_2':
          return _thisFunction.zPosition;
        case 'anchorPoint':
        case 'AnchorPoint':
        case 'Anchor Point':
        case 'ADBE AnchorPoint':
        case 1:
          return _thisFunction.anchorPoint;
        case 'opacity':
        case 'Opacity':
        case 11:
          return _thisFunction.opacity;
        default:
          return null;
      }
    }
    Object.defineProperty(_thisFunction, 'rotation', {
      get: ExpressionPropertyInterface(transform.r || transform.rz),
    });

    Object.defineProperty(_thisFunction, 'zRotation', {
      get: ExpressionPropertyInterface(transform.rz || transform.r),
    });

    Object.defineProperty(_thisFunction, 'xRotation', {
      get: ExpressionPropertyInterface(transform.rx),
    });

    Object.defineProperty(_thisFunction, 'yRotation', {
      get: ExpressionPropertyInterface(transform.ry),
    });
    Object.defineProperty(_thisFunction, 'scale', {
      get: ExpressionPropertyInterface(transform.s),
    });
    var _px;
    var _py;
    var _pz;
    var _transformFactory;
    if (transform.p) {
      _transformFactory = ExpressionPropertyInterface(transform.p);
    } else {
      _px = ExpressionPropertyInterface(transform.px);
      _py = ExpressionPropertyInterface(transform.py);
      if (transform.pz) {
        _pz = ExpressionPropertyInterface(transform.pz);
      }
    }
    Object.defineProperty(_thisFunction, 'position', {
      get: function () {
        if (transform.p) {
          return _transformFactory();
        }
        return [
          _px(),
          _py(),
          _pz ? _pz() : 0];
      },
    });

    Object.defineProperty(_thisFunction, 'xPosition', {
      get: ExpressionPropertyInterface(transform.px),
    });

    Object.defineProperty(_thisFunction, 'yPosition', {
      get: ExpressionPropertyInterface(transform.py),
    });

    Object.defineProperty(_thisFunction, 'zPosition', {
      get: ExpressionPropertyInterface(transform.pz),
    });

    Object.defineProperty(_thisFunction, 'anchorPoint', {
      get: ExpressionPropertyInterface(transform.a),
    });

    Object.defineProperty(_thisFunction, 'opacity', {
      get: ExpressionPropertyInterface(transform.o),
    });

    Object.defineProperty(_thisFunction, 'skew', {
      get: ExpressionPropertyInterface(transform.sk),
    });

    Object.defineProperty(_thisFunction, 'skewAxis', {
      get: ExpressionPropertyInterface(transform.sa),
    });

    Object.defineProperty(_thisFunction, 'orientation', {
      get: ExpressionPropertyInterface(transform.or),
    });

    return _thisFunction;
  };
}());

/* exported ProjectInterface */

var ProjectInterface = (function () {
  function registerComposition(comp) {
    this.compositions.push(comp);
  }

  return function () {
    function _thisProjectFunction(name) {
      var i = 0;
      var len = this.compositions.length;
      while (i < len) {
        if (this.compositions[i].data && this.compositions[i].data.nm === name) {
          if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
            this.compositions[i].prepareFrame(this.currentFrame);
          }
          return this.compositions[i].compInterface;
        }
        i += 1;
      }
      return null;
    }

    _thisProjectFunction.compositions = [];
    _thisProjectFunction.currentFrame = 0;

    _thisProjectFunction.registerComposition = registerComposition;

    return _thisProjectFunction;
  };
}());

/* global propertyGroupFactory, ExpressionPropertyInterface, PropertyInterface */
/* exported EffectsExpressionInterface */

var EffectsExpressionInterface = (function () {
  var ob = {
    createEffectsInterface: createEffectsInterface,
  };

  function createEffectsInterface(elem, propertyGroup) {
    if (elem.effectsManager) {
      var effectElements = [];
      var effectsData = elem.data.ef;
      var i;
      var len = elem.effectsManager.effectElements.length;
      for (i = 0; i < len; i += 1) {
        effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
      }

      var effects = elem.data.ef || [];
      var groupInterface = function (name) {
        i = 0;
        len = effects.length;
        while (i < len) {
          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
            return effectElements[i];
          }
          i += 1;
        }
        return null;
      };
      Object.defineProperty(groupInterface, 'numProperties', {
        get: function () {
          return effects.length;
        },
      });
      return groupInterface;
    }
    return null;
  }

  function createGroupInterface(data, elements, propertyGroup, elem) {
    function groupInterface(name) {
      var effects = data.ef;
      var i = 0;
      var len = effects.length;
      while (i < len) {
        if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
          if (effects[i].ty === 5) {
            return effectElements[i];
          }
          return effectElements[i]();
        }
        i += 1;
      }
      throw new Error();
    }
    var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);

    var effectElements = [];
    var i;
    var len = data.ef.length;
    for (i = 0; i < len; i += 1) {
      if (data.ef[i].ty === 5) {
        effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
      } else {
        effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
      }
    }

    if (data.mn === 'ADBE Color Control') {
      Object.defineProperty(groupInterface, 'color', {
        get: function () {
          return effectElements[0]();
        },
      });
    }
    Object.defineProperties(groupInterface, {
      numProperties: {
        get: function () {
          return data.np;
        },
      },
      _name: { value: data.nm },
      propertyGroup: { value: _propertyGroup },
    });
    groupInterface.enabled = data.en !== 0;
    groupInterface.active = groupInterface.enabled;
    return groupInterface;
  }

  function createValueInterface(element, type, elem, propertyGroup) {
    var expressionProperty = ExpressionPropertyInterface(element.p);
    function interfaceFunction() {
      if (type === 10) {
        return elem.comp.compInterface(element.p.v);
      }
      return expressionProperty();
    }

    if (element.p.setGroupProperty) {
      element.p.setGroupProperty(PropertyInterface('', propertyGroup));
    }

    return interfaceFunction;
  }

  return ob;
}());

/* global createSizedArray */
/* exported MaskManagerInterface */

var MaskManagerInterface = (function () {
  function MaskInterface(mask, data) {
    this._mask = mask;
    this._data = data;
  }
  Object.defineProperty(MaskInterface.prototype, 'maskPath', {
    get: function () {
      if (this._mask.prop.k) {
        this._mask.prop.getValue();
      }
      return this._mask.prop;
    },
  });
  Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
    get: function () {
      if (this._mask.op.k) {
        this._mask.op.getValue();
      }
      return this._mask.op.v * 100;
    },
  });

  var MaskManager = function (maskManager) {
    var _masksInterfaces = createSizedArray(maskManager.viewData.length);
    var i;
    var len = maskManager.viewData.length;
    for (i = 0; i < len; i += 1) {
      _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
    }

    var maskFunction = function (name) {
      i = 0;
      while (i < len) {
        if (maskManager.masksProperties[i].nm === name) {
          return _masksInterfaces[i];
        }
        i += 1;
      }
      return null;
    };
    return maskFunction;
  };
  return MaskManager;
}());

/* global createTypedArray */
/* exported ExpressionPropertyInterface */

var ExpressionPropertyInterface = (function () {
  var defaultUnidimensionalValue = { pv: 0, v: 0, mult: 1 };
  var defaultMultidimensionalValue = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 };

  function completeProperty(expressionValue, property, type) {
    Object.defineProperty(expressionValue, 'velocity', {
      get: function () {
        return property.getVelocityAtTime(property.comp.currentFrame);
      },
    });
    expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
    expressionValue.key = function (pos) {
      if (!expressionValue.numKeys) {
        return 0;
      }
      var value = '';
      if ('s' in property.keyframes[pos - 1]) {
        value = property.keyframes[pos - 1].s;
      } else if ('e' in property.keyframes[pos - 2]) {
        value = property.keyframes[pos - 2].e;
      } else {
        value = property.keyframes[pos - 2].s;
      }
      var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers
      valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
      valueProp.value = type === 'unidimensional' ? value[0] : value;
      return valueProp;
    };
    expressionValue.valueAtTime = property.getValueAtTime;
    expressionValue.speedAtTime = property.getSpeedAtTime;
    expressionValue.velocityAtTime = property.getVelocityAtTime;
    expressionValue.propertyGroup = property.propertyGroup;
  }

  function UnidimensionalPropertyInterface(property) {
    if (!property || !('pv' in property)) {
      property = defaultUnidimensionalValue;
    }
    var mult = 1 / property.mult;
    var val = property.pv * mult;
    var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
    expressionValue.value = val;
    completeProperty(expressionValue, property, 'unidimensional');

    return function () {
      if (property.k) {
        property.getValue();
      }
      val = property.v * mult;
      if (expressionValue.value !== val) {
        expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
        expressionValue.value = val;
        completeProperty(expressionValue, property, 'unidimensional');
      }
      return expressionValue;
    };
  }

  function MultidimensionalPropertyInterface(property) {
    if (!property || !('pv' in property)) {
      property = defaultMultidimensionalValue;
    }
    var mult = 1 / property.mult;
    var len = (property.data && property.data.l) || property.pv.length;
    var expressionValue = createTypedArray('float32', len);
    var arrValue = createTypedArray('float32', len);
    expressionValue.value = arrValue;
    completeProperty(expressionValue, property, 'multidimensional');

    return function () {
      if (property.k) {
        property.getValue();
      }
      for (var i = 0; i < len; i += 1) {
        arrValue[i] = property.v[i] * mult;
        expressionValue[i] = arrValue[i];
      }
      return expressionValue;
    };
  }

  // TODO: try to avoid using this getter
  function defaultGetter() {
    return defaultUnidimensionalValue;
  }

  return function (property) {
    if (!property) {
      return defaultGetter;
    } if (property.propType === 'unidimensional') {
      return UnidimensionalPropertyInterface(property);
    }
    return MultidimensionalPropertyInterface(property);
  };
}());

/* global expressionHelpers, TextSelectorProp, ExpressionManager */
/* exported TextExpressionSelectorPropFactory */

var TextExpressionSelectorPropFactory = (function () { // eslint-disable-line no-unused-vars
  function getValueProxy(index, total) {
    this.textIndex = index + 1;
    this.textTotal = total;
    this.v = this.getValue() * this.mult;
    return this.v;
  }

  return function (elem, data) {
    this.pv = 1;
    this.comp = elem.comp;
    this.elem = elem;
    this.mult = 0.01;
    this.propType = 'textSelector';
    this.textTotal = data.totalChars;
    this.selectorValue = 100;
    this.lastValue = [1, 1, 1];
    this.k = true;
    this.x = true;
    this.getValue = ExpressionManager.initiateExpression.bind(this)(elem, data, this);
    this.getMult = getValueProxy;
    this.getVelocityAtTime = expressionHelpers.getVelocityAtTime;
    if (this.kf) {
      this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this);
    } else {
      this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this);
    }
    this.setGroupProperty = expressionHelpers.setGroupProperty;
  };
}());

var propertyGetTextProp = TextSelectorProp.getTextSelectorProp;
TextSelectorProp.getTextSelectorProp = function (elem, data, arr) {
  if (data.t === 1) {
    return new TextExpressionSelectorPropFactory(elem, data, arr); // eslint-disable-line no-undef
  }
  return propertyGetTextProp(elem, data, arr);
};

/* global PropertyFactory */
/* exported SliderEffect, AngleEffect, ColorEffect, PointEffect, LayerIndexEffect, MaskIndexEffect, CheckboxEffect, NoValueEffect */

function SliderEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function AngleEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function ColorEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
}
function PointEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
}
function LayerIndexEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function MaskIndexEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function CheckboxEffect(data, elem, container) {
  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
}
function NoValueEffect() {
  this.p = {};
}

/* global extendPrototype, SliderEffect, AngleEffect, ColorEffect, PointEffect, CheckboxEffect, LayerIndexEffect,
MaskIndexEffect, NoValueEffect, DynamicPropertyContainer */

function EffectsManager(data, element) {
  var effects = data.ef || [];
  this.effectElements = [];
  var i;
  var len = effects.length;
  var effectItem;
  for (i = 0; i < len; i += 1) {
    effectItem = new GroupEffect(effects[i], element);
    this.effectElements.push(effectItem);
  }
}

function GroupEffect(data, element) {
  this.init(data, element);
}

extendPrototype([DynamicPropertyContainer], GroupEffect);

GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;

GroupEffect.prototype.init = function (data, element) {
  this.data = data;
  this.effectElements = [];
  this.initDynamicPropertyContainer(element);
  var i;
  var len = this.data.ef.length;
  var eff;
  var effects = this.data.ef;
  for (i = 0; i < len; i += 1) {
    eff = null;
    switch (effects[i].ty) {
      case 0:
        eff = new SliderEffect(effects[i], element, this);
        break;
      case 1:
        eff = new AngleEffect(effects[i], element, this);
        break;
      case 2:
        eff = new ColorEffect(effects[i], element, this);
        break;
      case 3:
        eff = new PointEffect(effects[i], element, this);
        break;
      case 4:
      case 7:
        eff = new CheckboxEffect(effects[i], element, this);
        break;
      case 10:
        eff = new LayerIndexEffect(effects[i], element, this);
        break;
      case 11:
        eff = new MaskIndexEffect(effects[i], element, this);
        break;
      case 5:
        eff = new EffectsManager(effects[i], element, this);
        break;
        // case 6:
      default:
        eff = new NoValueEffect(effects[i], element, this);
        break;
    }
    if (eff) {
      this.effectElements.push(eff);
    }
  }
};


var lottie = {};

function setLocationHref(href) {
  locationHref = href;
}

function searchAnimations() {
  if (standalone === true) {
    animationManager.searchAnimations(animationData, standalone, renderer);
  } else {
    animationManager.searchAnimations();
  }
}

function setSubframeRendering(flag) {
  subframeEnabled = flag;
}

function setIDPrefix(prefix) {
  idPrefix = prefix;
}

function loadAnimation(params) {
  if (standalone === true) {
    params.animationData = JSON.parse(animationData);
  }
  return animationManager.loadAnimation(params);
}

function setQuality(value) {
  if (typeof value === 'string') {
    switch (value) {
      case 'high':
        defaultCurveSegments = 200;
        break;
      default:
      case 'medium':
        defaultCurveSegments = 50;
        break;
      case 'low':
        defaultCurveSegments = 10;
        break;
    }
  } else if (!isNaN(value) && value > 1) {
    defaultCurveSegments = value;
  }
  if (defaultCurveSegments >= 50) {
    roundValues(false);
  } else {
    roundValues(true);
  }
}

function inBrowser() {
  return typeof navigator !== 'undefined';
}

function installPlugin(type, plugin) {
  if (type === 'expressions') {
    expressionsPlugin = plugin;
  }
}

function getFactory(name) {
  switch (name) {
    case 'propertyFactory':
      return PropertyFactory;
    case 'shapePropertyFactory':
      return ShapePropertyFactory;
    case 'matrix':
      return Matrix;
    default:
      return null;
  }
}

lottie.play = animationManager.play;
lottie.pause = animationManager.pause;
lottie.setLocationHref = setLocationHref;
lottie.togglePause = animationManager.togglePause;
lottie.setSpeed = animationManager.setSpeed;
lottie.setDirection = animationManager.setDirection;
lottie.stop = animationManager.stop;
lottie.searchAnimations = searchAnimations;
lottie.registerAnimation = animationManager.registerAnimation;
lottie.loadAnimation = loadAnimation;
lottie.setSubframeRendering = setSubframeRendering;
lottie.resize = animationManager.resize;
// lottie.start = start;
lottie.goToAndStop = animationManager.goToAndStop;
lottie.destroy = animationManager.destroy;
lottie.setQuality = setQuality;
lottie.inBrowser = inBrowser;
lottie.installPlugin = installPlugin;
lottie.freeze = animationManager.freeze;
lottie.unfreeze = animationManager.unfreeze;
lottie.setVolume = animationManager.setVolume;
lottie.mute = animationManager.mute;
lottie.unmute = animationManager.unmute;
lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
lottie.setIDPrefix = setIDPrefix;
lottie.__getFactory = getFactory;
lottie.version = '5.7.14';

function checkReady() {
  if (document.readyState === 'complete') {
    clearInterval(readyStateCheckInterval);
    searchAnimations();
  }
}

function getQueryVariable(variable) {
  var vars = queryString.split('&');
  for (var i = 0; i < vars.length; i += 1) {
    var pair = vars[i].split('=');
    if (decodeURIComponent(pair[0]) == variable) { // eslint-disable-line eqeqeq
      return decodeURIComponent(pair[1]);
    }
  }
  return null;
}
var standalone = '__[STANDALONE]__';
var animationData = '__[ANIMATIONDATA]__';
var renderer = '';
var queryString;
if (standalone) {
  var scripts = document.getElementsByTagName('script');
  var index = scripts.length - 1;
  var myScript = scripts[index] || {
    src: '',
  };
  queryString = myScript.src.replace(/^[^\?]+\??/, ''); // eslint-disable-line no-useless-escape
  renderer = getQueryVariable('renderer');
}
var readyStateCheckInterval = setInterval(checkReady, 100);

return lottie;
}));;(function(){
  console.log('accordion');
  const accordions=document.querySelectorAll('.accordion__item');
  accordions.forEach(el => {
    el.addEventListener('click', (e) => {
      const self = e.currentTarget;
      const control = self.querySelector('.accordion__control');
      const content = self.querySelector('.accordion__content');
      self.classList.toggle('open');

      if( self.classList.contains('open')) {
        control.setAttribute('aria-expanded', true);
        content.setAttribute('aria-hidden', false);
        content.style.maxHeight = content.scrollHeight + 'px';
      } else {
        control.setAttribute('aria-expanded', false);
        content.setAttribute('aria-hidden', true);
        content.style.maxHeight = null;
      }
    })
  })
})()
;(function(){

  console.log('animation lottie');

  const anim = lottie

  // promote-lottie1

  anim.loadAnimation({
    container: document.querySelector('#promote-lottie1'),
    rendered: 'svg',
    loop: true,
    autoplay: true,
    path: './json/promote-lottie1.json',
  })

  anim.loadAnimation({
    container: document.querySelector('#promote-lottie2'),
    rendered: 'svg',
    loop: true,
    autoplay: true,
    path: './json/promote-lottie2.json',
  })

  anim.loadAnimation({
    container: document.querySelector('#promote-lottie3'),
    rendered: 'svg',
    loop: true,
    autoplay: true,
    path: './json/promote-lottie3.json',
  })

  anim.loadAnimation({
    container: document.querySelector('#promote-lottie4'),
    rendered: 'svg',
    loop: true,
    autoplay: true,
    path: './json/promote-lottie4.json',
  })


  anim.loadAnimation({
    container: document.querySelector('#sheme-lottie'),
    rendered: 'svg',
    loop: true,
    autoplay: true,
    path: './json/sheme-lottie.json',
  })


  anim.loadAnimation({
    container: document.querySelector('#opinion-lottie'),
    rendered: 'svg',
    loop: true,
    autoplay: true,
    path: './json/opinion-lottie.json',
  })

  anim.loadAnimation({
    container: document.querySelector('#staff-phone'),
    rendered: 'svg',
    loop: true,
    autoplay: true,
    path: './json/staff-phone.json',
  })


})();
;(function(){
  console.log('care parallax');

  careDevices = document.querySelector('.care__devices');

  if (careDevices) {

    carePhone = document.querySelector('.care__phone');
    careMacbook = document.querySelector('.care__macbook');


  careDevices.addEventListener('mouseover', (e) => {


    const el = e.target;


    runScale('care__phone', carePhone, true);
    runScale('care__macbook', careMacbook, false);

       function runScale(className, node, document) {

        let transform = document ? `transform: scale(1.1) rotate(-10deg)` : `transform: scale(1.1)`;


          if(el.classList.contains(`${className}`)) {
            node.style.cssText = transform;
          }
        }




  })

   careDevices.addEventListener('mouseout', (e) => {


    const el = e.target;


    stopScale('care__phone', carePhone);
    stopScale('care__macbook', careMacbook);

       function stopScale(className, node) {

          if(el.classList.contains(`${className}`)) {
            node.style.cssText = `transform: initial`;
          }
        }




  })
  }


})();
;(function(){
  console.log('hsm parallax');

  const wrapper = document.querySelector('.hsm__graph-wrap')

  if (wrapper) {
    const hsmSession = wrapper.querySelector('.hsm__session');
    const hsmClassementDemondes = wrapper.querySelector('.hsm__classement-demondes');
    const hsmTotal = wrapper.querySelector('.hsm__total');
    const hsmTaux = wrapper.querySelector('.hsm__taux');

    const hsmActionImpactLarge = wrapper.querySelector('.hsm__action-impact-large')
    const hsmTrained = wrapper.querySelector('.hsm__trained');
    const hsmReport= wrapper.querySelector('.hsm__report');

    const hsmLeaves = wrapper.querySelector('.hsm__leaves');
    const hsmPeoples = wrapper.querySelector('.hsm__peoples');
    const hsmCheck = wrapper.querySelector('.hsm__check');
    const hsmHome = wrapper.querySelector('.hsm__home');

    const hsmWoman = wrapper.querySelector('.hsm__woman');
    const hsmWoman2 = wrapper.querySelector('.hsm__woman2');
    const hsmMan = wrapper.querySelector('.hsm__man');

    wrapper.addEventListener('mouseover', (e) => {
      const el = e.target.parentNode;


     runScale('session', hsmSession, 3)
     runScale('classement-demondes', hsmClassementDemondes, 3)
     runScale('total', hsmTotal, 3)
     runScale('taux', hsmTaux, 2)
     runScale('action-impact-large', hsmActionImpactLarge, 2)
     runScale('hsm__trained', hsmTrained, 1)
     runScale('hsm__report', hsmReport, 1)
     runScale('hsm__leaves', hsmLeaves, 1)
     runScale('hsm__peoples', hsmPeoples, 1)
     runScale('hsm__check', hsmCheck, 1)
     runScale('hsm__home', hsmHome, 1)
     runScale('hsm__woman', hsmWoman, 1)
     runScale('hsm__woman2', hsmWoman2, 1)
     runScale('hsm__man', hsmMan, 1)

      function runScale(className, node, coefficient) {
        let scaleValue = '0.3';
        switch (coefficient) {
          case 1:
            scaleValue = '0.8';
            break;
          case 2:
            scaleValue = '0.7';
            break;
          case 3:
            scaleValue = '0.6';
            break;
          default:
            break;
        }


          if(el.classList.contains(`${className}`)) {
            node.style.cssText = `transform: scale(${scaleValue})`;
          };

        }


    })



    wrapper.addEventListener('mouseout', (e) => {
      const el = e.target.parentNode;

     stopScale('session', hsmSession)
     stopScale('classement-demondes', hsmClassementDemondes)
     stopScale('total', hsmTotal)
     stopScale('taux', hsmTaux)
     stopScale('action-impact-large', hsmActionImpactLarge)
     stopScale('hsm__trained', hsmTrained)
     stopScale('hsm__report', hsmReport)
     stopScale('hsm__leaves', hsmLeaves)
     stopScale('hsm__peoples', hsmPeoples)
     stopScale('hsm__check', hsmCheck)
     stopScale('hsm__home', hsmHome)
     stopScale('hsm__woman', hsmWoman)
     stopScale('hsm__woman2', hsmWoman2)
     stopScale('hsm__man', hsmMan)

        function stopScale(className, node) {

          if(el.classList.contains(`${className}`)) {
            node.style.cssText = `transform: initial`;
          }
        }




  })

  }
})()
;(function(){
  console.log('manage parallax');

  const wrapper = document.querySelector('.manage__graph-wrap')

  if (wrapper) {
    const manageEmployeer = wrapper.querySelector('.manage__employeer');
    const manageTrained = wrapper.querySelector('.manage__trained');
    const manageActionImpact = wrapper.querySelector('.manage__action-impact')
    const manageLastMonth = wrapper.querySelector('.manage__last-month')
    const manageClassementDemondes = wrapper.querySelector('.manage__classement-demondes');
    const manageTotal = wrapper.querySelector('.manage__total');

    const manageActionImpactLarge = wrapper.querySelector('.manage__action-impact-large')



    wrapper.addEventListener('mouseover', (e) => {
      const el = e.target.parentNode;


     runScale('manage__employeer', manageEmployeer, 1)
     runScale('manage__trained', manageTrained, 1)
     runScale('manage__action-impact', manageActionImpact, 1)
     runScale('manage__last-month', manageLastMonth, 1)
     runScale('classement-demondes', manageClassementDemondes, 3)
     runScale('total', manageTotal, 3)
     runScale('action-impact-large', manageActionImpactLarge, 2)



      function runScale(className, node, coefficient) {
        let scaleValue = '0.3';
        switch (coefficient) {
          case 1:
            scaleValue = '0.8';
            break;
          case 2:
            scaleValue = '0.7';
            break;
          case 3:
            scaleValue = '0.6';
            break;
          default:
            break;
        }


          if(el.classList.contains(`${className}`)) {
            node.style.cssText = `transform: scale(${scaleValue})`;
          };
        }



    wrapper.addEventListener('mouseout', (e) => {
      const el = e.target.parentNode;



     stopScale('manage__employeer', manageEmployeer)
     stopScale('manage__trained', manageTrained)
     stopScale('manage__action-impact', manageActionImpact)
     stopScale('manage__last-month', manageLastMonth)
     stopScale('classement-demondes', manageClassementDemondes)
     stopScale('total', manageTotal)
     stopScale('action-impact-large', manageActionImpactLarge)

    function stopScale(className, node) {

      if(el.classList.contains(`${className}`)) {
        node.style.cssText = `transform: initial`;
      }
    }

  })



    })

  }
})()
;(function() {
  console.log('menu');
  const menuToggle = document.querySelector('.menu__toggle');
  const menu = document.querySelector('.menu');
  const body = document.querySelector('body')

  menuToggle.addEventListener('click', (e) => {
    e.preventDefault();
    menu.classList.toggle('menu--opened')
    body.classList.toggle('body--locked')
  })
})();

(function() {
  // console.log('2');
  // const video = document.querySelector('.video');
  // const videoBtn = document.querySelector('.video__btn');
  // videoBtn.addEventListener('click', function() {

  //   // 2. This code loads the IFrame Player API code asynchronously.
  //   var tag = document.createElement('script');

  //   tag.src = "https://www.youtube.com/iframe_api";
  //   var firstScriptTag = document.getElementsByTagName('script')[0];

  //   console.log(firstScriptTag.parentNode);
  //   firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

  //   // 3. This function creates an <iframe> (and YouTube player)
  //   //    after the API code downloads.
  //   var player;

  //   function onYouTubeIframeAPIReady() {
  //     player = new YT.Player('video__player', {
  //       height: '360',
  //       width: '640',
  //       videoId: 'M7lc1UVf-VE',
  //       events: {
  //         'onReady': onPlayerReady,
  //         'onStateChange': onPlayerStateChange
  //       }
  //     });
  //   }

  //   // 4. The API will call this function when the video player is ready.
  //   function onPlayerReady(event) {
  //     event.target.playVideo();
  //   }

  //   // 5. The API calls this function when the player's state changes.
  //   //    The function indicates that when playing a video (state=1),
  //   //    the player should play for six seconds and then stop.
  //   var done = false;

  //   function onPlayerStateChange(event) {
  //     if (event.data == YT.PlayerState.PLAYING && !done) {
  //       setTimeout(stopVideo, 6000);
  //       done = true;
  //     }
  //   }

  //   function stopVideo() {
  //     player.stopVideo();
  //   }

  // })


})()
;(function() {
  console.log('possibilities-slider');
//Инициализируем слайдер
new Swiper('.possibilities-slider', {
  //Стрелки
  // navigation: {
  //   nextEl: '.swiper-button-next', //тут можем задать свои - в одних из блоков будут
  //   prevEl: '.swiper-button-prev',
  // },
  //Навигация

  // Буллеты, текущее положение, прогрессбар
  // pagination: {
  //   el: '.swiper-pagination',


    // // 1 тип: буллеты
    // type: 'bullets', //по умолчанию
    // clickable: true,
    // // динамические буллеты
    // dynamicBullets: true,
    // //кастомные буллеты
    // renderBullet: function(index, className) {
    //   return '<span class="' + className + '">' + (index + 1) + '</span>';
    // }

    //2 тип. фракция
    // type: 'fraction',
    //кастомный вывод фракции
    // renderFraction: function (currentClass, totalClass) {
    //   return 'Слайдер <span class="' + currentClass + '"></span>' + ' из ' + '<span class="' + totalClass + '"></span>';
    // }

    //3 тип. прогрессбар сверху
    // type: 'progressbar',

  // },

  //скролл
  // scrollbar: {
  //   el: '.swiper-scrollbar',
  //   //возможность перетаскивать скролл
  //   draggable: true
  // },

  //свайпы
  //включение / отключение перетаскивания на ПК
  simulateTouch: true, //false если нужно отключить

  //чувствительность свайпа
  // touchRatio: 1, //0 - отлючает свайпы везде
  //угол срабатывания свайпа
  // touchAngle: 45,
  //курсор перетаскивания
  // grabCursor: true,
  //переключение слайда при клике на него
  // slideToClickedSlide: true,

  // навигация по хешу для каждого слайда нужно задать   data-hash="slide-$"
  // hashNavigation: {
  //   //отслеживать состояние
  //   whatchState: true,
  // },

  //управление клавиатурой
  // keyboard: {
  //   //включить / выключить
  //   enabled: true,
  //   //включить / выключить только тогда когда слайдер в пределах viewport
  //   onlyInViewport: true,
  //   //включить / выключить управление  клавишами pageUp, pageDown
  //   pageUpDown: true,
  // }

  //управление колесом мыши
  // mousewheel: {
  //   //чувствительность колеса мыши
  //   sensitivity: 1,
  //   //класс объекта на котором будет срабатывать прокрутка мышью
  //   eventsTarget: ".possibilities-slider"
  // }

  //автовысота
  // autoHeight: 1,

  //количество слайдеров для показа
  slidesPerView: 'auto', //можно указать два с половиной 2.5 )) // 'auto' - свайпер сам сформирует, тогда с swiper-slide width: auto

  //отключение функционала если слайдов меньше чем указано в slidesPerView
  // whatchOverflow: true,

  //оступ между слайдами
  spaceBetween: 30,

  //количество пролистываемых слайдов
  slidesPerGroup: 1, //изменяет фракцию

  //активный слайд по центру
  centeredSlides: true,

  //стартовый слайд
  initialSlide: 3, //отсчёт с  0

  //мультирядность
  // slidesPerColumn: 2, //для корректной работы отключить автовысоту а также слайдеру задать height: 700 и сами слайдам height: calc((100% - 30px) /2); overflow:hidden;

  //бесконечный слайдер
  loop: true,

  //количество дублирующих слайдов для бесконечного слайдера если slidesPerView больше 1
  // loopedSlides: 3,

  //свободный режим
  // freeMode: true,

  //автопрокрутка
  autoplay: {
    //пауза между прокруткой
    delay: 1000,
    //закончить на последнем слайде если отключена бесконечный
    stopOnLastSlide: false,
    //отключить после ручного переключения
    disableOnInteraction: false,

  },

  //скорость переключения слайдов
  speed: 1500,

  //вертикальный слайдер
  // direction: 'vertical', // для этого нужно установить высоту всему слайдеру

  //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'fade',

  // //дополнительно к fade
  // fadeEffect: {
  //   //параллельная смена прозрачности
  //   crossFade: true
  // },

    //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'flip',

  // //дополнительно к flip
  // flipEffect: {
  //   //тень
  //   slideShadows: true,
  //   //показ только активного слайда
  //   limitRotation: true,
  // },

      //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'cube', //для этого эффекта нужно ограничить ширину всего слайдера width: 500px

  // //дополнительно к cube
  // cubeEffect: {
  //   //настройки тени
  //   slideShadows: true,
  //   shadow: true,
  //   shadowOffset: 20,
  //   shadowScale: 0.94
  // },



      //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'coverflow',

  // // //дополнительно к coverflow
  // coverflowEffect: {
  //   //угол
  //   rotate: 20,
  //   // наложение
  //   stretch: 50,
  //   // тень
  //   slideShadows: true,

  // },

  //эффекты переключения слайдов
  //стандартный эффект листание
  effect: 'slide',

  //брекпоинты (adaptive MOBILE FIRST)
  //ширина экрана
  // breakpoints: {
  //   320: {//от 320
  //     slidesPerView: 1,
  //   },
  //   768: {//от 480
  //     slidesPerView: 2,
  //   },
  //   1023: { //от 992
  //     slidesPerView: 3,
  //   }
  // },

  on: {
    init() {
  //остановить при наведении
      this.el.addEventListener('mouseenter', () => {
        this.autoplay.stop();
      });

  //возобновить при отведении
      this.el.addEventListener('mouseleave', () => {
        this.autoplay.start();
      });
    }
  },


});


// const swiper = new Swiper('.swiper', {
//   // Optional parameters
//   direction: 'vertical',
//   loop: true,





//   // And if we need scrollbar
})();
;(function () {
    //Инициализируем слайдер
  console.log('promote-slider');
new Swiper('.promote-slider', {
  //Стрелки
  navigation: {
    nextEl: '.promote-slider__button-next', //тут можем задать свои - в одних из блоков будут
    prevEl: '.promote-slider__button-prev',
  },
  //Навигация

  // Буллеты, текущее положение, прогрессбар
  pagination: {
    el: '.promote-slider__pagination',


    // // 1 тип: буллеты
    // type: 'bullets', //по умолчанию
    // clickable: true,
    // // динамические буллеты
    // dynamicBullets: true,
    // //кастомные буллеты
    // renderBullet: function(index, className) {
    //   return '<span class="' + className + '">' + (index + 1) + '</span>';
    // }

    //2 тип. фракция
    type: 'fraction',
    //кастомный вывод фракции
    // renderFraction: function (currentClass, totalClass) {
    //   return 'Слайдер <span class="' + currentClass + '"></span>' + ' из ' + '<span class="' + totalClass + '"></span>';
    // }

    //3 тип. прогрессбар сверху
    // type: 'progressbar',

  },

  //скролл
  // scrollbar: {
  //   el: '.swiper-scrollbar',
  //   //возможность перетаскивать скролл
  //   draggable: true
  // },

  //свайпы
  //включение / отключение перетаскивания на ПК
  // simulateTouch: true, //false если нужно отключить

  //чувствительность свайпа
  // touchRatio: 1, //0 - отлючает свайпы везде
  //угол срабатывания свайпа
  // touchAngle: 45,
  //курсор перетаскивания
  // grabCursor: true,
  //переключение слайда при клике на него
  // slideToClickedSlide: true,

  // навигация по хешу для каждого слайда нужно задать   data-hash="slide-$"
  // hashNavigation: {
  //   //отслеживать состояние
  //   whatchState: true,
  // },

  //управление клавиатурой
  // keyboard: {
  //   //включить / выключить
  //   enabled: true,
  //   //включить / выключить только тогда когда слайдер в пределах viewport
  //   onlyInViewport: true,
  //   //включить / выключить управление  клавишами pageUp, pageDown
  //   pageUpDown: true,
  // }

  //управление колесом мыши
  // mousewheel: {
  //   //чувствительность колеса мыши
  //   sensitivity: 1,
  //   //класс объекта на котором будет срабатывать прокрутка мышью
  //   eventsTarget: ".possibilities-slider"
  // }

  //автовысота
  // autoHeight: 1,

  //количество слайдеров для показа
  slidesPerView: 'auto', //можно указать два с половиной 2.5 )) // 'auto' - свайпер сам сформирует, тогда с swiper-slide width: auto

  //отключение функционала если слайдов меньше чем указано в slidesPerView
  // whatchOverflow: true,

  //оступ между слайдами
  spaceBetween: 0,

  //количество пролистываемых слайдов
  slidesPerGroup: 1, //изменяет фракцию

  //активный слайд по центру
  centeredSlides: true,

  //стартовый слайд
  // initialSlide: 0, //отсчёт с  0

  //мультирядность
  // slidesPerColumn: 2, //для корректной работы отключить автовысоту а также слайдеру задать height: 700 и сами слайдам height: calc((100% - 30px) /2); overflow:hidden;

  //бесконечный слайдер
  // loop: true,

  //количество дублирующих слайдов для бесконечного слайдера если slidesPerView больше 1
  // loopedSlides: 3,

  //свободный режим
  // freeMode: true,

  //автопрокрутка
  autoplay: {
    //пауза между прокруткой
    delay: 3000,
    //закончить на последнем слайде если отключена бесконечный
    // stopOnLastSlide: false,
    //отключить после ручного переключения
    // disableOnInteraction: false,

  },

  //скорость переключения слайдов
  speed: 800,

  //вертикальный слайдер
  // direction: 'vertical', // для этого нужно установить высоту всему слайдеру

  //эффекты переключения слайдов
  //смена прозрачности
  effect: 'fade',

  //дополнительно к fade
  fadeEffect: {
    //параллельная смена прозрачности
    crossFade: true
  },

    //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'flip',

  // //дополнительно к flip
  // flipEffect: {
  //   //тень
  //   slideShadows: true,
  //   //показ только активного слайда
  //   limitRotation: true,
  // },

      //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'cube', //для этого эффекта нужно ограничить ширину всего слайдера width: 500px

  // //дополнительно к cube
  // cubeEffect: {
  //   //настройки тени
  //   slideShadows: true,
  //   shadow: true,
  //   shadowOffset: 20,
  //   shadowScale: 0.94
  // },



      //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'coverflow',

  // // //дополнительно к coverflow
  // coverflowEffect: {
  //   //угол
  //   rotate: 20,
  //   // наложение
  //   stretch: 50,
  //   // тень
  //   slideShadows: true,

  // },

  //эффекты переключения слайдов
  //стандартный эффект листание
  // effect: 'slide',

  //брекпоинты (adaptive MOBILE FIRST)
  //ширина экрана
  // breakpoints: {
  //   320: {//от 320
  //     slidesPerView: 1,
  //   },
  //   768: {//от 480
  //     slidesPerView: 2,
  //   },
  //   1023: { //от 992
  //     slidesPerView: 3,
  //   }
  // },

  on: {
    init() {
  //остановить при наведении
      this.el.addEventListener('mouseenter', () => {
        this.autoplay.stop();
      });

  //возобновить при отведении
      this.el.addEventListener('mouseleave', () => {
        this.autoplay.start();
      });
    }
  },

});

})();
;(function() {
//Инициализируем слайдер
  console.log('ribbon-slider');
new Swiper('.ribbon-slider', {
  //Стрелки
  // navigation: {
  //   nextEl: '.swiper-button-next', //тут можем задать свои - в одних из блоков будут
  //   prevEl: '.swiper-button-prev',
  // },
  //Навигация

  // Буллеты, текущее положение, прогрессбар
  // pagination: {
  //   el: '.swiper-pagination',


    // // 1 тип: буллеты
    // type: 'bullets', //по умолчанию
    // clickable: true,
    // // динамические буллеты
    // dynamicBullets: true,
    // //кастомные буллеты
    // renderBullet: function(index, className) {
    //   return '<span class="' + className + '">' + (index + 1) + '</span>';
    // }

    //2 тип. фракция
    // type: 'fraction',
    //кастомный вывод фракции
    // renderFraction: function (currentClass, totalClass) {
    //   return 'Слайдер <span class="' + currentClass + '"></span>' + ' из ' + '<span class="' + totalClass + '"></span>';
    // }

    //3 тип. прогрессбар сверху
    // type: 'progressbar',

  // },

  //скролл
  // scrollbar: {
  //   el: '.swiper-scrollbar',
  //   //возможность перетаскивать скролл
  //   draggable: true
  // },

  //свайпы
  //включение / отключение перетаскивания на ПК
  simulateTouch: true, //false если нужно отключить

  //чувствительность свайпа
  // touchRatio: 1, //0 - отлючает свайпы везде
  //угол срабатывания свайпа
  // touchAngle: 45,
  //курсор перетаскивания
  grabCursor: true,
  //переключение слайда при клике на него
  // slideToClickedSlide: true,

  // навигация по хешу для каждого слайда нужно задать   data-hash="slide-$"
  // hashNavigation: {
  //   //отслеживать состояние
  //   whatchState: true,
  // },

  //управление клавиатурой
  // keyboard: {
  //   //включить / выключить
  //   enabled: true,
  //   //включить / выключить только тогда когда слайдер в пределах viewport
  //   onlyInViewport: true,
  //   //включить / выключить управление  клавишами pageUp, pageDown
  //   pageUpDown: true,
  // }

  //управление колесом мыши
  // mousewheel: {
  //   //чувствительность колеса мыши
  //   sensitivity: 1,
  //   //класс объекта на котором будет срабатывать прокрутка мышью
  //   eventsTarget: ".possibilities-slider"
  // }

  //автовысота
  // autoHeight: 1,

  //количество слайдеров для показа
  slidesPerView: 'auto', //можно указать два с половиной 2.5 )) // 'auto' - свайпер сам сформирует, тогда с swiper-slide width: auto

  //отключение функционала если слайдов меньше чем указано в slidesPerView
  // whatchOverflow: true,

  //оступ между слайдами
  spaceBetween: 0,

  //количество пролистываемых слайдов
  slidesPerGroup: 1, //изменяет фракцию

  //активный слайд по центру
  centeredSlides: true,

  //стартовый слайд
  initialSlide: 3, //отсчёт с  0

  //мультирядность
  // slidesPerColumn: 2, //для корректной работы отключить автовысоту а также слайдеру задать height: 700 и сами слайдам height: calc((100% - 30px) /2); overflow:hidden;

  //бесконечный слайдер
  loop: true,

  //количество дублирующих слайдов для бесконечного слайдера если slidesPerView больше 1
  // loopedSlides: 3,

  //свободный режим
  // freeMode: true,

  //автопрокрутка
  autoplay: {
    //пауза между прокруткой
    delay: 3000,
    //закончить на последнем слайде если отключена бесконечный
    // stopOnLastSlide: false,
    //отключить после ручного переключения
    disableOnInteraction: false,

  },

  //скорость переключения слайдов
  speed: 800,

  //вертикальный слайдер
  // direction: 'vertical', // для этого нужно установить высоту всему слайдеру

  //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'fade',

  // //дополнительно к fade
  // fadeEffect: {
  //   //параллельная смена прозрачности
  //   crossFade: true
  // },

    //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'flip',

  // //дополнительно к flip
  // flipEffect: {
  //   //тень
  //   slideShadows: true,
  //   //показ только активного слайда
  //   limitRotation: true,
  // },

      //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'cube', //для этого эффекта нужно ограничить ширину всего слайдера width: 500px

  // //дополнительно к cube
  // cubeEffect: {
  //   //настройки тени
  //   slideShadows: true,
  //   shadow: true,
  //   shadowOffset: 20,
  //   shadowScale: 0.94
  // },



      //эффекты переключения слайдов
  //смена прозрачности
  // effect: 'coverflow',

  // // //дополнительно к coverflow
  // coverflowEffect: {
  //   //угол
  //   rotate: 20,
  //   // наложение
  //   stretch: 50,
  //   // тень
  //   slideShadows: true,

  // },

  //эффекты переключения слайдов
  //стандартный эффект листание
  effect: 'slide',

  //брекпоинты (adaptive MOBILE FIRST)
  //ширина экрана
  // breakpoints: {
  //   320: {//от 320
  //     slidesPerView: 1,
  //   },
  //   768: {//от 480
  //     slidesPerView: 2,
  //   },
  //   1023: { //от 992
  //     slidesPerView: 3,
  //   }
  // },

  on: {
    init() {
  //остановить при наведении
      this.el.addEventListener('mouseenter', () => {
        this.autoplay.stop();
      });

  //возобновить при отведении
      this.el.addEventListener('mouseleave', () => {
        this.autoplay.start();
      });
    }
  },

});

})();

;(function() {

  console.log('scroll animation');
   const animItems = document.querySelectorAll('._anim-items');



  if (animItems.length > 0) {
    window.addEventListener('scroll', animOnScroll)
    function animOnScroll() {
      for (let i = 0; i < animItems.length; i++) {
        const animItem = animItems[i];

        const animItemHeight = animItem.offsetHeight; //высота элемента 182
        const animItemOffset = offset(animItem).top; //позиция объекта относительно вверха окна
        const animStart = 6; // коэффициент регулирования начала анимация

        let animItemPoint = window.innerHeight - animItemHeight / animStart; // 700 - 200 /4 = 750
        if ( animItemHeight > window.innerHeight) {
          animItemPoint = window.innerHeight - window.innerHeight / animStart;; // 800 - 800 / 4 = 1000
        }

        if ((pageYOffset > animItemOffset - animItemPoint) && (pageYOffset < animItemOffset + animItemHeight)) //возвращает количество пикселей, на которое прокручен документ по вертикали
        {
          animItem.classList.add('_active');


          if (animItem.classList.contains('technology__wrap') && !animItem.classList.contains('_one')) {

            const technologyLottie = lottie.loadAnimation({
              container: document.querySelector('#technology__lottie'),
              rendered: 'svg',
              loop: false,
              autoplay: false,
              path: './json/technology__lottie.json',
            })

            console.log(technologyLottie.play());
            animItem.classList.add('_one');
          }



        } else {
          if (!animItem.classList.contains('_anim-no-hide')) {
            animItem.classList.remove('_active');
          }
        }

      }
    }


    function offset(el) {

      const rect = el.getBoundingClientRect(); // размер элемента и его позицию относительно  viewport

      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
      // pageXOffset - текущая прокрутка слева ,
      // document.documentElement - html,
      // scrollTop - сколько прокручено вверх
      const scrollTop = window.pageXOffset || document.documentElement.scrollTop;


      return {
        top: rect.top + scrollTop,
        left: rect.left + scrollLeft
      }

    }


    setTimeout(() => {
      animOnScroll()
    }, 400);

  }
})()
;(function() {
  console.log('tabs');

  const tabs = document.querySelector('.tabs');
  const tabsBtn = document.querySelectorAll('.tabs__btn');
  const tabsContent = document.querySelectorAll('.tabs__content');

  if(tabs) {
    tabs.addEventListener('click', (e) => {
      if (e.target.classList.contains('tabs__btn')) {
        const tabsPath = e.target.dataset.tabsPath;
        tabsHandler(tabsPath);
      }
    });
  };

  const tabsHandler = (path) => {
    tabsBtn.forEach( el => { el.classList.remove('tabs__btn--active')});
    tabs.querySelector(`[data-tabs-path="${path}"]`).classList.add('tabs__btn--active');


    tabsContent.forEach( el => { el.classList.remove('tabs__content--active')});
    tabs.querySelector(`[data-tabs-target="${path}"]`).classList.add('tabs__content--active');
  }

})()

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInN3aXBlci1idW5kbGUuanMiLCJsb3R0aWUuanMiLCJhY2NvcmRpb24uanMiLCJhbmltYXRpb25zLmpzIiwiY2FyZS1wYXJhbGxheC5qcyIsImhzbS1wYXJhbGxheC5qcyIsIm1hbmFnZS1wYXJhbGxheC5qcyIsIm1lbnUuanMiLCJwb3NzaWJpbGl0aWVzLXNsaWRlci5qcyIsInByb21vdGUtc2xpZGVyLmpzIiwicmliYm9uLXNsaWRlci5qcyIsInNjcm9sbC1hbmltYXRpb24uanMiLCJ0YWJzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENDcDFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0NqZ2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0MzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0NuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0NyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0N2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0MzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFN3aXBlciA3LjIuMFxuICogTW9zdCBtb2Rlcm4gbW9iaWxlIHRvdWNoIHNsaWRlciBhbmQgZnJhbWV3b3JrIHdpdGggaGFyZHdhcmUgYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnNcbiAqIGh0dHBzOi8vc3dpcGVyanMuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAyMSBWbGFkaW1pciBLaGFybGFtcGlkaVxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICpcbiAqIFJlbGVhc2VkIG9uOiBPY3RvYmVyIDI3LCAyMDIxXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuU3dpcGVyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogU1NSIFdpbmRvdyA0LjAuMVxuICAgICAqIEJldHRlciBoYW5kbGluZyBmb3Igd2luZG93IG9iamVjdCBpbiBTU1IgZW52aXJvbm1lbnRcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9saW1pdHM0d2ViL3Nzci13aW5kb3dcbiAgICAgKlxuICAgICAqIENvcHlyaWdodCAyMDIxLCBWbGFkaW1pciBLaGFybGFtcGlkaVxuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgTUlUXG4gICAgICpcbiAgICAgKiBSZWxlYXNlZCBvbjogT2N0b2JlciAyNywgMjAyMVxuICAgICAqL1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCQxKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAnY29uc3RydWN0b3InIGluIG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQkMSh0YXJnZXQgPSB7fSwgc3JjID0ge30pIHtcbiAgICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldID09PSAndW5kZWZpbmVkJykgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtlbHNlIGlmIChpc09iamVjdCQxKHNyY1trZXldKSAmJiBpc09iamVjdCQxKHRhcmdldFtrZXldKSAmJiBPYmplY3Qua2V5cyhzcmNba2V5XSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGV4dGVuZCQxKHRhcmdldFtrZXldLCBzcmNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNzckRvY3VtZW50ID0ge1xuICAgICAgYm9keToge30sXG5cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSxcblxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9LFxuXG4gICAgICBhY3RpdmVFbGVtZW50OiB7XG4gICAgICAgIGJsdXIoKSB7fSxcblxuICAgICAgICBub2RlTmFtZTogJydcbiAgICAgIH0sXG5cbiAgICAgIHF1ZXJ5U2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcblxuICAgICAgcXVlcnlTZWxlY3RvckFsbCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSxcblxuICAgICAgZ2V0RWxlbWVudEJ5SWQoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcblxuICAgICAgY3JlYXRlRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5pdEV2ZW50KCkge31cblxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgY3JlYXRlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgc3R5bGU6IHt9LFxuXG4gICAgICAgICAgc2V0QXR0cmlidXRlKCkge30sXG5cbiAgICAgICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZUVsZW1lbnROUygpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcblxuICAgICAgaW1wb3J0Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuXG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBoYXNoOiAnJyxcbiAgICAgICAgaG9zdDogJycsXG4gICAgICAgIGhvc3RuYW1lOiAnJyxcbiAgICAgICAgaHJlZjogJycsXG4gICAgICAgIG9yaWdpbjogJycsXG4gICAgICAgIHBhdGhuYW1lOiAnJyxcbiAgICAgICAgcHJvdG9jb2w6ICcnLFxuICAgICAgICBzZWFyY2g6ICcnXG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge307XG4gICAgICBleHRlbmQkMShkb2MsIHNzckRvY3VtZW50KTtcbiAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuXG4gICAgY29uc3Qgc3NyV2luZG93ID0ge1xuICAgICAgZG9jdW1lbnQ6IHNzckRvY3VtZW50LFxuICAgICAgbmF2aWdhdG9yOiB7XG4gICAgICAgIHVzZXJBZ2VudDogJydcbiAgICAgIH0sXG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBoYXNoOiAnJyxcbiAgICAgICAgaG9zdDogJycsXG4gICAgICAgIGhvc3RuYW1lOiAnJyxcbiAgICAgICAgaHJlZjogJycsXG4gICAgICAgIG9yaWdpbjogJycsXG4gICAgICAgIHBhdGhuYW1lOiAnJyxcbiAgICAgICAgcHJvdG9jb2w6ICcnLFxuICAgICAgICBzZWFyY2g6ICcnXG4gICAgICB9LFxuICAgICAgaGlzdG9yeToge1xuICAgICAgICByZXBsYWNlU3RhdGUoKSB7fSxcblxuICAgICAgICBwdXNoU3RhdGUoKSB7fSxcblxuICAgICAgICBnbygpIHt9LFxuXG4gICAgICAgIGJhY2soKSB7fVxuXG4gICAgICB9LFxuICAgICAgQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSxcblxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9LFxuXG4gICAgICBnZXRDb21wdXRlZFN0eWxlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGdldFByb3BlcnR5VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICBJbWFnZSgpIHt9LFxuXG4gICAgICBEYXRlKCkge30sXG5cbiAgICAgIHNjcmVlbjoge30sXG5cbiAgICAgIHNldFRpbWVvdXQoKSB7fSxcblxuICAgICAgY2xlYXJUaW1lb3V0KCkge30sXG5cbiAgICAgIG1hdGNoTWVkaWEoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0sXG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICAgIH0sXG5cbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgICAgIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG4gICAgICBleHRlbmQkMSh3aW4sIHNzcldpbmRvdyk7XG4gICAgICByZXR1cm4gd2luO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvbTcgNC4wLjFcbiAgICAgKiBNaW5pbWFsaXN0aWMgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBET00gbWFuaXB1bGF0aW9uLCB3aXRoIGEgalF1ZXJ5LWNvbXBhdGlibGUgQVBJXG4gICAgICogaHR0cHM6Ly9mcmFtZXdvcms3LmlvL2RvY3MvZG9tNy5odG1sXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgMjAyMSwgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICAgICAqXG4gICAgICogUmVsZWFzZWQgb246IE9jdG9iZXIgMjcsIDIwMjFcbiAgICAgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4gICAgZnVuY3Rpb24gbWFrZVJlYWN0aXZlKG9iaikge1xuICAgICAgY29uc3QgcHJvdG8gPSBvYmouX19wcm90b19fO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ19fcHJvdG9fXycsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBwcm90by5fX3Byb3RvX18gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGFzcyBEb203IGV4dGVuZHMgQXJyYXkge1xuICAgICAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICAgICAgc3VwZXIoLi4uKGl0ZW1zIHx8IFtdKSk7XG4gICAgICAgIG1ha2VSZWFjdGl2ZSh0aGlzKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFycmF5RmxhdChhcnIgPSBbXSkge1xuICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICBhcnIuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgICAgIHJlcy5wdXNoKC4uLmFycmF5RmxhdChlbCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFyciwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoYXJyLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJyYXlVbmlxdWUoYXJyKSB7XG4gICAgICBjb25zdCB1bmlxdWVBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodW5pcXVlQXJyYXkuaW5kZXhPZihhcnJbaV0pID09PSAtMSkgdW5pcXVlQXJyYXkucHVzaChhcnJbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5pcXVlQXJyYXk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBxc2Eoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbc2VsZWN0b3JdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhID0gW107XG4gICAgICBjb25zdCByZXMgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhLnB1c2gocmVzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICBsZXQgYXJyID0gW107XG5cbiAgICAgIGlmICghY29udGV4dCAmJiBzZWxlY3RvciBpbnN0YW5jZW9mIERvbTcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9tNyhhcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBodG1sID0gc2VsZWN0b3IudHJpbSgpO1xuXG4gICAgICAgIGlmIChodG1sLmluZGV4T2YoJzwnKSA+PSAwICYmIGh0bWwuaW5kZXhPZignPicpID49IDApIHtcbiAgICAgICAgICBsZXQgdG9DcmVhdGUgPSAnZGl2JztcbiAgICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8bGknKSA9PT0gMCkgdG9DcmVhdGUgPSAndWwnO1xuICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0cicpID09PSAwKSB0b0NyZWF0ZSA9ICd0Ym9keSc7XG4gICAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPHRkJykgPT09IDAgfHwgaHRtbC5pbmRleE9mKCc8dGgnKSA9PT0gMCkgdG9DcmVhdGUgPSAndHInO1xuICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0Ym9keScpID09PSAwKSB0b0NyZWF0ZSA9ICd0YWJsZSc7XG4gICAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPG9wdGlvbicpID09PSAwKSB0b0NyZWF0ZSA9ICdzZWxlY3QnO1xuICAgICAgICAgIGNvbnN0IHRlbXBQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRvQ3JlYXRlKTtcbiAgICAgICAgICB0ZW1wUGFyZW50LmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBQYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYXJyLnB1c2godGVtcFBhcmVudC5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyID0gcXNhKHNlbGVjdG9yLnRyaW0oKSwgY29udGV4dCB8fCBkb2N1bWVudCk7XG4gICAgICAgIH0gLy8gYXJyID0gcXNhKHNlbGVjdG9yLCBkb2N1bWVudCk7XG5cbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3Iubm9kZVR5cGUgfHwgc2VsZWN0b3IgPT09IHdpbmRvdyB8fCBzZWxlY3RvciA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgYXJyLnB1c2goc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdG9yKSkge1xuICAgICAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBEb203KSByZXR1cm4gc2VsZWN0b3I7XG4gICAgICAgIGFyciA9IHNlbGVjdG9yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERvbTcoYXJyYXlVbmlxdWUoYXJyKSk7XG4gICAgfVxuXG4gICAgJC5mbiA9IERvbTcucHJvdG90eXBlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuICAgIGZ1bmN0aW9uIGFkZENsYXNzKC4uLmNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBhcnJheUZsYXQoY2xhc3Nlcy5tYXAoYyA9PiBjLnNwbGl0KCcgJykpKTtcbiAgICAgIHRoaXMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKC4uLmNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBhcnJheUZsYXQoY2xhc3Nlcy5tYXAoYyA9PiBjLnNwbGl0KCcgJykpKTtcbiAgICAgIHRoaXMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKC4uLmNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBhcnJheUZsYXQoY2xhc3Nlcy5tYXAoYyA9PiBjLnNwbGl0KCcgJykpKTtcbiAgICAgIHRoaXMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGNsYXNzTmFtZXMuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gYXJyYXlGbGF0KGNsYXNzZXMubWFwKGMgPT4gYy5zcGxpdCgnICcpKSk7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIodGhpcywgZWwgPT4ge1xuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcy5maWx0ZXIoY2xhc3NOYW1lID0+IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKS5sZW5ndGggPiAwO1xuICAgICAgfSkubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdHRyKGF0dHJzLCB2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBHZXQgYXR0clxuICAgICAgICBpZiAodGhpc1swXSkgcmV0dXJuIHRoaXNbMF0uZ2V0QXR0cmlidXRlKGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gU2V0IGF0dHJzXG5cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgLy8gU3RyaW5nXG4gICAgICAgICAgdGhpc1tpXS5zZXRBdHRyaWJ1dGUoYXR0cnMsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgICAgICB0aGlzW2ldW2F0dHJOYW1lXSA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgIHRoaXNbaV0uc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyc1thdHRyTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVBdHRyKGF0dHIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0aGlzW2ldLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRoaXNbaV0uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uJDEoZHVyYXRpb24pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0aGlzW2ldLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiAhPT0gJ3N0cmluZycgPyBgJHtkdXJhdGlvbn1tc2AgOiBkdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb24oLi4uYXJncykge1xuICAgICAgbGV0IFtldmVudFR5cGUsIHRhcmdldFNlbGVjdG9yLCBsaXN0ZW5lciwgY2FwdHVyZV0gPSBhcmdzO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgW2V2ZW50VHlwZSwgbGlzdGVuZXIsIGNhcHR1cmVdID0gYXJncztcbiAgICAgICAgdGFyZ2V0U2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2FwdHVyZSkgY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVMaXZlRXZlbnQoZSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gZS50YXJnZXQuZG9tN0V2ZW50RGF0YSB8fCBbXTtcblxuICAgICAgICBpZiAoZXZlbnREYXRhLmluZGV4T2YoZSkgPCAwKSB7XG4gICAgICAgICAgZXZlbnREYXRhLnVuc2hpZnQoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJCh0YXJnZXQpLmlzKHRhcmdldFNlbGVjdG9yKSkgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBldmVudERhdGEpO2Vsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhcmVudHMgPSAkKHRhcmdldCkucGFyZW50cygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHBhcmVudHMubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICAgIGlmICgkKHBhcmVudHNba10pLmlzKHRhcmdldFNlbGVjdG9yKSkgbGlzdGVuZXIuYXBwbHkocGFyZW50c1trXSwgZXZlbnREYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlRXZlbnQoZSkge1xuICAgICAgICBjb25zdCBldmVudERhdGEgPSBlICYmIGUudGFyZ2V0ID8gZS50YXJnZXQuZG9tN0V2ZW50RGF0YSB8fCBbXSA6IFtdO1xuXG4gICAgICAgIGlmIChldmVudERhdGEuaW5kZXhPZihlKSA8IDApIHtcbiAgICAgICAgICBldmVudERhdGEudW5zaGlmdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IGV2ZW50VHlwZS5zcGxpdCgnICcpO1xuICAgICAgbGV0IGo7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXNbaV07XG5cbiAgICAgICAgaWYgKCF0YXJnZXRTZWxlY3Rvcikge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBldmVudHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2pdO1xuICAgICAgICAgICAgaWYgKCFlbC5kb203TGlzdGVuZXJzKSBlbC5kb203TGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICBpZiAoIWVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdKSBlbC5kb203TGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgZWwuZG9tN0xpc3RlbmVyc1tldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICBwcm94eUxpc3RlbmVyOiBoYW5kbGVFdmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVFdmVudCwgY2FwdHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExpdmUgZXZlbnRzXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGV2ZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbal07XG4gICAgICAgICAgICBpZiAoIWVsLmRvbTdMaXZlTGlzdGVuZXJzKSBlbC5kb203TGl2ZUxpc3RlbmVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFlbC5kb203TGl2ZUxpc3RlbmVyc1tldmVudF0pIGVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgZWwuZG9tN0xpdmVMaXN0ZW5lcnNbZXZlbnRdLnB1c2goe1xuICAgICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgcHJveHlMaXN0ZW5lcjogaGFuZGxlTGl2ZUV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZUxpdmVFdmVudCwgY2FwdHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZiguLi5hcmdzKSB7XG4gICAgICBsZXQgW2V2ZW50VHlwZSwgdGFyZ2V0U2VsZWN0b3IsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBbZXZlbnRUeXBlLCBsaXN0ZW5lciwgY2FwdHVyZV0gPSBhcmdzO1xuICAgICAgICB0YXJnZXRTZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYXB0dXJlKSBjYXB0dXJlID0gZmFsc2U7XG4gICAgICBjb25zdCBldmVudHMgPSBldmVudFR5cGUuc3BsaXQoJyAnKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0aGlzW2pdO1xuICAgICAgICAgIGxldCBoYW5kbGVycztcblxuICAgICAgICAgIGlmICghdGFyZ2V0U2VsZWN0b3IgJiYgZWwuZG9tN0xpc3RlbmVycykge1xuICAgICAgICAgICAgaGFuZGxlcnMgPSBlbC5kb203TGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFNlbGVjdG9yICYmIGVsLmRvbTdMaXZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBoYW5kbGVycyA9IGVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gaGFuZGxlcnMubGVuZ3RoIC0gMTsgayA+PSAwOyBrIC09IDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW2tdO1xuXG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lciAmJiBoYW5kbGVyLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIucHJveHlMaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGssIDEpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyICYmIGhhbmRsZXIubGlzdGVuZXIgJiYgaGFuZGxlci5saXN0ZW5lci5kb203cHJveHkgJiYgaGFuZGxlci5saXN0ZW5lci5kb203cHJveHkgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlci5wcm94eUxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlci5wcm94eUxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlciguLi5hcmdzKSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGFyZ3NbMF0uc3BsaXQoJyAnKTtcbiAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGFyZ3NbMV07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2ldO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIGNvbnN0IGVsID0gdGhpc1tqXTtcblxuICAgICAgICAgIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgICAgICAgZGV0YWlsOiBldmVudERhdGEsXG4gICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWwuZG9tN0V2ZW50RGF0YSA9IGFyZ3MuZmlsdGVyKChkYXRhLCBkYXRhSW5kZXgpID0+IGRhdGFJbmRleCA+IDApO1xuICAgICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICAgICAgZWwuZG9tN0V2ZW50RGF0YSA9IFtdO1xuICAgICAgICAgICAgZGVsZXRlIGVsLmRvbTdFdmVudERhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQkMShjYWxsYmFjaykge1xuICAgICAgY29uc3QgZG9tID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gZmlyZUNhbGxCYWNrKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZSk7XG4gICAgICAgIGRvbS5vZmYoJ3RyYW5zaXRpb25lbmQnLCBmaXJlQ2FsbEJhY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgZG9tLm9uKCd0cmFuc2l0aW9uZW5kJywgZmlyZUNhbGxCYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0ZXJXaWR0aChpbmNsdWRlTWFyZ2lucykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLnN0eWxlcygpO1xuICAgICAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRoICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0ZXJIZWlnaHQoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluY2x1ZGVNYXJnaW5zKSB7XG4gICAgICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5zdHlsZXMoKTtcbiAgICAgICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXNbMF07XG4gICAgICAgIGNvbnN0IGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgY29uc3QgY2xpZW50VG9wID0gZWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gICAgICAgIGNvbnN0IGNsaWVudExlZnQgPSBlbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFkgOiBlbC5zY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IHNjcm9sbExlZnQgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFggOiBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcCxcbiAgICAgICAgICBsZWZ0OiBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjc3MocHJvcHMsIHZhbHVlKSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGxldCBpO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIC5jc3MoJ3dpZHRoJylcbiAgICAgICAgICBpZiAodGhpc1swXSkgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIC5jc3MoeyB3aWR0aDogJzEwMHB4JyB9KVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgdGhpc1tpXS5zdHlsZVtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gLmNzcygnd2lkdGgnLCAnMTAwcHgnKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXNbaV0uc3R5bGVbcHJvcHNdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xuICAgICAgICBjYWxsYmFjay5hcHBseShlbCwgW2VsLCBpbmRleF0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFycmF5RmlsdGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiAkKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHRtbChodG1sKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5pbm5lckhUTUwgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdGhpc1tpXS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXh0KHRleHQpIHtcbiAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdLnRleHRDb250ZW50LnRyaW0oKSA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0aGlzW2ldLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3QgZWwgPSB0aGlzWzBdO1xuICAgICAgbGV0IGNvbXBhcmVXaXRoO1xuICAgICAgbGV0IGk7XG4gICAgICBpZiAoIWVsIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMpIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIGlmIChlbC5tc01hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgY29tcGFyZVdpdGggPSAkKHNlbGVjdG9yKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcGFyZVdpdGgubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZVdpdGhbaV0gPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yID09PSBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZWwgPT09IGRvY3VtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0b3IgPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gZWwgPT09IHdpbmRvdztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yLm5vZGVUeXBlIHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgRG9tNykge1xuICAgICAgICBjb21wYXJlV2l0aCA9IHNlbGVjdG9yLm5vZGVUeXBlID8gW3NlbGVjdG9yXSA6IHNlbGVjdG9yO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wYXJlV2l0aC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChjb21wYXJlV2l0aFtpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZXgoKSB7XG4gICAgICBsZXQgY2hpbGQgPSB0aGlzWzBdO1xuICAgICAgbGV0IGk7XG5cbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBpID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgd2hpbGUgKChjaGlsZCA9IGNoaWxkLnByZXZpb3VzU2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxKGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHRoaXM7XG4gICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gJChbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgY29uc3QgcmV0dXJuSW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICAgICAgaWYgKHJldHVybkluZGV4IDwgMCkgcmV0dXJuICQoW10pO1xuICAgICAgICByZXR1cm4gJChbdGhpc1tyZXR1cm5JbmRleF1dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoW3RoaXNbaW5kZXhdXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kKC4uLmVscykge1xuICAgICAgbGV0IG5ld0NoaWxkO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGVscy5sZW5ndGg7IGsgKz0gMSkge1xuICAgICAgICBuZXdDaGlsZCA9IGVsc1trXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBuZXdDaGlsZDtcblxuICAgICAgICAgICAgd2hpbGUgKHRlbXBEaXYuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICB0aGlzW2ldLmFwcGVuZENoaWxkKHRlbXBEaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZCBpbnN0YW5jZW9mIERvbTcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmV3Q2hpbGQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZChuZXdDaGlsZFtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbaV0uYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwZW5kKG5ld0NoaWxkKSB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IG5ld0NoaWxkO1xuXG4gICAgICAgICAgZm9yIChqID0gdGVtcERpdi5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZSh0ZW1wRGl2LmNoaWxkTm9kZXNbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tNykge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuZXdDaGlsZC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdGhpc1tpXS5pbnNlcnRCZWZvcmUobmV3Q2hpbGRbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbaV0uaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCB0aGlzW2ldLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHQoc2VsZWN0b3IpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nICYmICQodGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuICQoW3RoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICQoW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKSByZXR1cm4gJChbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgcmV0dXJuICQoW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChbXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dEFsbChzZWxlY3Rvcikge1xuICAgICAgY29uc3QgbmV4dEVscyA9IFtdO1xuICAgICAgbGV0IGVsID0gdGhpc1swXTtcbiAgICAgIGlmICghZWwpIHJldHVybiAkKFtdKTtcblxuICAgICAgd2hpbGUgKGVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICBjb25zdCBuZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKCQobmV4dCkuaXMoc2VsZWN0b3IpKSBuZXh0RWxzLnB1c2gobmV4dCk7XG4gICAgICAgIH0gZWxzZSBuZXh0RWxzLnB1c2gobmV4dCk7XG5cbiAgICAgICAgZWwgPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChuZXh0RWxzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmV2KHNlbGVjdG9yKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpc1swXTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZyAmJiAkKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuICQoW2VsLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJChbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykgcmV0dXJuICQoW2VsLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgcmV0dXJuICQoW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChbXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJldkFsbChzZWxlY3Rvcikge1xuICAgICAgY29uc3QgcHJldkVscyA9IFtdO1xuICAgICAgbGV0IGVsID0gdGhpc1swXTtcbiAgICAgIGlmICghZWwpIHJldHVybiAkKFtdKTtcblxuICAgICAgd2hpbGUgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoJChwcmV2KS5pcyhzZWxlY3RvcikpIHByZXZFbHMucHVzaChwcmV2KTtcbiAgICAgICAgfSBlbHNlIHByZXZFbHMucHVzaChwcmV2KTtcblxuICAgICAgICBlbCA9IHByZXY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKHByZXZFbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpc1tpXS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzW2ldLnBhcmVudE5vZGUpLmlzKHNlbGVjdG9yKSkgcGFyZW50cy5wdXNoKHRoaXNbaV0ucGFyZW50Tm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaCh0aGlzW2ldLnBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChwYXJlbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzW2ldLnBhcmVudE5vZGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoJChwYXJlbnQpLmlzKHNlbGVjdG9yKSkgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKHBhcmVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcbiAgICAgIGxldCBjbG9zZXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gJChbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2xvc2VzdC5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgY2xvc2VzdCA9IGNsb3Nlc3QucGFyZW50cyhzZWxlY3RvcikuZXEoMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGZvdW5kRWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gdGhpc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgZm91bmRFbGVtZW50cy5wdXNoKGZvdW5kW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChmb3VuZEVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXNbaV0uY2hpbGRyZW47XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCAkKGNoaWxkTm9kZXNbal0pLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZE5vZGVzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpc1tpXS5wYXJlbnROb2RlKSB0aGlzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IE1ldGhvZHMgPSB7XG4gICAgICBhZGRDbGFzcyxcbiAgICAgIHJlbW92ZUNsYXNzLFxuICAgICAgaGFzQ2xhc3MsXG4gICAgICB0b2dnbGVDbGFzcyxcbiAgICAgIGF0dHIsXG4gICAgICByZW1vdmVBdHRyLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiQxLFxuICAgICAgb24sXG4gICAgICBvZmYsXG4gICAgICB0cmlnZ2VyLFxuICAgICAgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCQxLFxuICAgICAgb3V0ZXJXaWR0aCxcbiAgICAgIG91dGVySGVpZ2h0LFxuICAgICAgc3R5bGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgY3NzLFxuICAgICAgZWFjaCxcbiAgICAgIGh0bWwsXG4gICAgICB0ZXh0LFxuICAgICAgaXMsXG4gICAgICBpbmRleCxcbiAgICAgIGVxLFxuICAgICAgYXBwZW5kLFxuICAgICAgcHJlcGVuZCxcbiAgICAgIG5leHQsXG4gICAgICBuZXh0QWxsLFxuICAgICAgcHJldixcbiAgICAgIHByZXZBbGwsXG4gICAgICBwYXJlbnQsXG4gICAgICBwYXJlbnRzLFxuICAgICAgY2xvc2VzdCxcbiAgICAgIGZpbmQsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZpbHRlcixcbiAgICAgIHJlbW92ZVxuICAgIH07XG4gICAgT2JqZWN0LmtleXMoTWV0aG9kcykuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkLmZuLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIHZhbHVlOiBNZXRob2RzW21ldGhvZE5hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBkZWxldGVQcm9wcyhvYmopIHtcbiAgICAgIGNvbnN0IG9iamVjdCA9IG9iajtcbiAgICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gbnVsbDtcbiAgICAgICAgfSBjYXRjaCAoZSkgey8vIG5vIGdldHRlciBmb3Igb2JqZWN0XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlbGV0ZSBvYmplY3Rba2V5XTtcbiAgICAgICAgfSBjYXRjaCAoZSkgey8vIHNvbWV0aGluZyBnb3Qgd3JvbmdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dFRpY2soY2FsbGJhY2ssIGRlbGF5ID0gMCkge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWwpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgbGV0IHN0eWxlO1xuXG4gICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3R5bGUgJiYgZWwuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2xhdGUoZWwsIGF4aXMgPSAneCcpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgbGV0IG1hdHJpeDtcbiAgICAgIGxldCBjdXJUcmFuc2Zvcm07XG4gICAgICBsZXQgdHJhbnNmb3JtTWF0cml4O1xuICAgICAgY29uc3QgY3VyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWwpO1xuXG4gICAgICBpZiAod2luZG93LldlYktpdENTU01hdHJpeCkge1xuICAgICAgICBjdXJUcmFuc2Zvcm0gPSBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUud2Via2l0VHJhbnNmb3JtO1xuXG4gICAgICAgIGlmIChjdXJUcmFuc2Zvcm0uc3BsaXQoJywnKS5sZW5ndGggPiA2KSB7XG4gICAgICAgICAgY3VyVHJhbnNmb3JtID0gY3VyVHJhbnNmb3JtLnNwbGl0KCcsICcpLm1hcChhID0+IGEucmVwbGFjZSgnLCcsICcuJykpLmpvaW4oJywgJyk7XG4gICAgICAgIH0gLy8gU29tZSBvbGQgdmVyc2lvbnMgb2YgV2Via2l0IGNob2tlIHdoZW4gJ25vbmUnIGlzIHBhc3NlZDsgcGFzc1xuICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaW5zdGVhZCBpbiB0aGlzIGNhc2VcblxuXG4gICAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KGN1clRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBjdXJUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNmb3JtTWF0cml4ID0gY3VyU3R5bGUuTW96VHJhbnNmb3JtIHx8IGN1clN0eWxlLk9UcmFuc2Zvcm0gfHwgY3VyU3R5bGUuTXNUcmFuc2Zvcm0gfHwgY3VyU3R5bGUubXNUcmFuc2Zvcm0gfHwgY3VyU3R5bGUudHJhbnNmb3JtIHx8IGN1clN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3RyYW5zZm9ybScpLnJlcGxhY2UoJ3RyYW5zbGF0ZSgnLCAnbWF0cml4KDEsIDAsIDAsIDEsJyk7XG4gICAgICAgIG1hdHJpeCA9IHRyYW5zZm9ybU1hdHJpeC50b1N0cmluZygpLnNwbGl0KCcsJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgICAgLy8gTGF0ZXN0IENocm9tZSBhbmQgd2Via2l0cyBGaXhcbiAgICAgICAgaWYgKHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgpIGN1clRyYW5zZm9ybSA9IHRyYW5zZm9ybU1hdHJpeC5tNDE7IC8vIENyYXp5IElFMTAgTWF0cml4XG4gICAgICAgIGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPT09IDE2KSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFsxMl0pOyAvLyBOb3JtYWwgQnJvd3NlcnNcbiAgICAgICAgZWxzZSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFs0XSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgICAgLy8gTGF0ZXN0IENocm9tZSBhbmQgd2Via2l0cyBGaXhcbiAgICAgICAgaWYgKHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgpIGN1clRyYW5zZm9ybSA9IHRyYW5zZm9ybU1hdHJpeC5tNDI7IC8vIENyYXp5IElFMTAgTWF0cml4XG4gICAgICAgIGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPT09IDE2KSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFsxM10pOyAvLyBOb3JtYWwgQnJvd3NlcnNcbiAgICAgICAgZWxzZSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFs1XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJUcmFuc2Zvcm0gfHwgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChvKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8gIT09IG51bGwgJiYgby5jb25zdHJ1Y3RvciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IDEgfHwgbm9kZS5ub2RlVHlwZSA9PT0gMTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZCguLi5hcmdzKSB7XG4gICAgICBjb25zdCB0byA9IE9iamVjdChhcmdzWzBdKTtcbiAgICAgIGNvbnN0IG5vRXh0ZW5kID0gWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ107XG5cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBuZXh0U291cmNlID0gYXJnc1tpXTtcblxuICAgICAgICBpZiAobmV4dFNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIG5leHRTb3VyY2UgIT09IG51bGwgJiYgIWlzTm9kZShuZXh0U291cmNlKSkge1xuICAgICAgICAgIGNvbnN0IGtleXNBcnJheSA9IE9iamVjdC5rZXlzKE9iamVjdChuZXh0U291cmNlKSkuZmlsdGVyKGtleSA9PiBub0V4dGVuZC5pbmRleE9mKGtleSkgPCAwKTtcblxuICAgICAgICAgIGZvciAobGV0IG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuXG4gICAgICAgICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodG9bbmV4dEtleV0pICYmIGlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTb3VyY2VbbmV4dEtleV0uX19zd2lwZXJfXykge1xuICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHRlbmQodG9bbmV4dEtleV0sIG5leHRTb3VyY2VbbmV4dEtleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNPYmplY3QodG9bbmV4dEtleV0pICYmIGlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0U291cmNlW25leHRLZXldLl9fc3dpcGVyX18pIHtcbiAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXh0ZW5kKHRvW25leHRLZXldLCBuZXh0U291cmNlW25leHRLZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDU1NQcm9wZXJ0eShlbCwgdmFyTmFtZSwgdmFyVmFsdWUpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KHZhck5hbWUsIHZhclZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbmltYXRlQ1NTTW9kZVNjcm9sbCh7XG4gICAgICBzd2lwZXIsXG4gICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgIHNpZGVcbiAgICB9KSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgIGxldCBzdGFydFRpbWUgPSBudWxsO1xuICAgICAgbGV0IHRpbWU7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gJ25vbmUnO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHN3aXBlci5jc3NNb2RlRnJhbWVJRCk7XG4gICAgICBjb25zdCBkaXIgPSB0YXJnZXRQb3NpdGlvbiA+IHN0YXJ0UG9zaXRpb24gPyAnbmV4dCcgOiAncHJldic7XG5cbiAgICAgIGNvbnN0IGlzT3V0T2ZCb3VuZCA9IChjdXJyZW50LCB0YXJnZXQpID0+IHtcbiAgICAgICAgcmV0dXJuIGRpciA9PT0gJ25leHQnICYmIGN1cnJlbnQgPj0gdGFyZ2V0IHx8IGRpciA9PT0gJ3ByZXYnICYmIGN1cnJlbnQgPD0gdGFyZ2V0O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgICAgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1heChNYXRoLm1pbigodGltZSAtIHN0YXJ0VGltZSkgLyBkdXJhdGlvbiwgMSksIDApO1xuICAgICAgICBjb25zdCBlYXNlUHJvZ3Jlc3MgPSAwLjUgLSBNYXRoLmNvcyhwcm9ncmVzcyAqIE1hdGguUEkpIC8gMjtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gKyBlYXNlUHJvZ3Jlc3MgKiAodGFyZ2V0UG9zaXRpb24gLSBzdGFydFBvc2l0aW9uKTtcblxuICAgICAgICBpZiAoaXNPdXRPZkJvdW5kKGN1cnJlbnRQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24pKSB7XG4gICAgICAgICAgY3VycmVudFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIud3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgICBbc2lkZV06IGN1cnJlbnRQb3NpdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaXNPdXRPZkJvdW5kKGN1cnJlbnRQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24pKSB7XG4gICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAnJztcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICBbc2lkZV06IGN1cnJlbnRQb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHN3aXBlci5jc3NNb2RlRnJhbWVJRCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmNzc01vZGVGcmFtZUlEID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgIH07XG5cbiAgICAgIGFuaW1hdGUoKTtcbiAgICB9XG5cbiAgICBsZXQgc3VwcG9ydDtcblxuICAgIGZ1bmN0aW9uIGNhbGNTdXBwb3J0KCkge1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzbW9vdGhTY3JvbGw6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAnc2Nyb2xsQmVoYXZpb3InIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgICAgICAgdG91Y2g6ICEhKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSxcbiAgICAgICAgcGFzc2l2ZUxpc3RlbmVyOiBmdW5jdGlvbiBjaGVja1Bhc3NpdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgICBsZXQgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUxpc3RlbmVyJywgbnVsbCwgb3B0cyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkgey8vIE5vIHN1cHBvcnRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlO1xuICAgICAgICB9KCksXG4gICAgICAgIGdlc3R1cmVzOiBmdW5jdGlvbiBjaGVja0dlc3R1cmVzKCkge1xuICAgICAgICAgIHJldHVybiAnb25nZXN0dXJlc3RhcnQnIGluIHdpbmRvdztcbiAgICAgICAgfSgpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN1cHBvcnQoKSB7XG4gICAgICBpZiAoIXN1cHBvcnQpIHtcbiAgICAgICAgc3VwcG9ydCA9IGNhbGNTdXBwb3J0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBwb3J0O1xuICAgIH1cblxuICAgIGxldCBkZXZpY2VDYWNoZWQ7XG5cbiAgICBmdW5jdGlvbiBjYWxjRGV2aWNlKHtcbiAgICAgIHVzZXJBZ2VudFxuICAgIH0gPSB7fSkge1xuICAgICAgY29uc3Qgc3VwcG9ydCA9IGdldFN1cHBvcnQoKTtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgcGxhdGZvcm0gPSB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtO1xuICAgICAgY29uc3QgdWEgPSB1c2VyQWdlbnQgfHwgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICBjb25zdCBkZXZpY2UgPSB7XG4gICAgICAgIGlvczogZmFsc2UsXG4gICAgICAgIGFuZHJvaWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NyZWVuV2lkdGggPSB3aW5kb3cuc2NyZWVuLndpZHRoO1xuICAgICAgY29uc3Qgc2NyZWVuSGVpZ2h0ID0gd2luZG93LnNjcmVlbi5oZWlnaHQ7XG4gICAgICBjb25zdCBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIGxldCBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgICAgIGNvbnN0IGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICAgICAgY29uc3QgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPU3xpT1MpXFxzKFtcXGRfXSspLyk7XG4gICAgICBjb25zdCB3aW5kb3dzID0gcGxhdGZvcm0gPT09ICdXaW4zMic7XG4gICAgICBsZXQgbWFjb3MgPSBwbGF0Zm9ybSA9PT0gJ01hY0ludGVsJzsgLy8gaVBhZE9zIDEzIGZpeFxuXG4gICAgICBjb25zdCBpUGFkU2NyZWVucyA9IFsnMTAyNHgxMzY2JywgJzEzNjZ4MTAyNCcsICc4MzR4MTE5NCcsICcxMTk0eDgzNCcsICc4MzR4MTExMicsICcxMTEyeDgzNCcsICc3Njh4MTAyNCcsICcxMDI0eDc2OCcsICc4MjB4MTE4MCcsICcxMTgweDgyMCcsICc4MTB4MTA4MCcsICcxMDgweDgxMCddO1xuXG4gICAgICBpZiAoIWlwYWQgJiYgbWFjb3MgJiYgc3VwcG9ydC50b3VjaCAmJiBpUGFkU2NyZWVucy5pbmRleE9mKGAke3NjcmVlbldpZHRofXgke3NjcmVlbkhlaWdodH1gKSA+PSAwKSB7XG4gICAgICAgIGlwYWQgPSB1YS5tYXRjaCgvKFZlcnNpb24pXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIGlmICghaXBhZCkgaXBhZCA9IFswLCAxLCAnMTNfMF8wJ107XG4gICAgICAgIG1hY29zID0gZmFsc2U7XG4gICAgICB9IC8vIEFuZHJvaWRcblxuXG4gICAgICBpZiAoYW5kcm9pZCAmJiAhd2luZG93cykge1xuICAgICAgICBkZXZpY2Uub3MgPSAnYW5kcm9pZCc7XG4gICAgICAgIGRldmljZS5hbmRyb2lkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlwYWQgfHwgaXBob25lIHx8IGlwb2QpIHtcbiAgICAgICAgZGV2aWNlLm9zID0gJ2lvcyc7XG4gICAgICAgIGRldmljZS5pb3MgPSB0cnVlO1xuICAgICAgfSAvLyBFeHBvcnQgb2JqZWN0XG5cblxuICAgICAgcmV0dXJuIGRldmljZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREZXZpY2Uob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgIGlmICghZGV2aWNlQ2FjaGVkKSB7XG4gICAgICAgIGRldmljZUNhY2hlZCA9IGNhbGNEZXZpY2Uob3ZlcnJpZGVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldmljZUNhY2hlZDtcbiAgICB9XG5cbiAgICBsZXQgYnJvd3NlcjtcblxuICAgIGZ1bmN0aW9uIGNhbGNCcm93c2VyKCkge1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgICAgICBjb25zdCB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB1YS5pbmRleE9mKCdzYWZhcmknKSA+PSAwICYmIHVhLmluZGV4T2YoJ2Nocm9tZScpIDwgMCAmJiB1YS5pbmRleE9mKCdhbmRyb2lkJykgPCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1NhZmFyaTogaXNTYWZhcmkoKSxcbiAgICAgICAgaXNXZWJWaWV3OiAvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG4gICAgICBpZiAoIWJyb3dzZXIpIHtcbiAgICAgICAgYnJvd3NlciA9IGNhbGNCcm93c2VyKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlc2l6ZSh7XG4gICAgICBzd2lwZXIsXG4gICAgICBvbixcbiAgICAgIGVtaXRcbiAgICB9KSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGxldCBvYnNlcnZlciA9IG51bGw7XG5cbiAgICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgICAgICBlbWl0KCdiZWZvcmVSZXNpemUnKTtcbiAgICAgICAgZW1pdCgncmVzaXplJyk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjcmVhdGVPYnNlcnZlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgICAgIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgICBsZXQgbmV3V2lkdGggPSB3aWR0aDtcbiAgICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoe1xuICAgICAgICAgICAgY29udGVudEJveFNpemUsXG4gICAgICAgICAgICBjb250ZW50UmVjdCxcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBzd2lwZXIuZWwpIHJldHVybjtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gY29udGVudFJlY3QgPyBjb250ZW50UmVjdC53aWR0aCA6IChjb250ZW50Qm94U2l6ZVswXSB8fCBjb250ZW50Qm94U2l6ZSkuaW5saW5lU2l6ZTtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3QuaGVpZ2h0IDogKGNvbnRlbnRCb3hTaXplWzBdIHx8IGNvbnRlbnRCb3hTaXplKS5ibG9ja1NpemU7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobmV3V2lkdGggIT09IHdpZHRoIHx8IG5ld0hlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXNpemVIYW5kbGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShzd2lwZXIuZWwpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVtb3ZlT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChvYnNlcnZlciAmJiBvYnNlcnZlci51bm9ic2VydmUgJiYgc3dpcGVyLmVsKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHN3aXBlci5lbCk7XG4gICAgICAgICAgb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgICAgICBlbWl0KCdvcmllbnRhdGlvbmNoYW5nZScpO1xuICAgICAgfTtcblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnJlc2l6ZU9ic2VydmVyICYmIHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZW1vdmVPYnNlcnZlcigpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPYnNlcnZlcih7XG4gICAgICBzd2lwZXIsXG4gICAgICBleHRlbmRQYXJhbXMsXG4gICAgICBvbixcbiAgICAgIGVtaXRcbiAgICB9KSB7XG4gICAgICBjb25zdCBvYnNlcnZlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuXG4gICAgICBjb25zdCBhdHRhY2ggPSAodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgT2JzZXJ2ZXJGdW5jID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYmtpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE9ic2VydmVyRnVuYyhtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgIC8vIFRoZSBvYnNlcnZlclVwZGF0ZSBldmVudCBzaG91bGQgb25seSBiZSB0cmlnZ2VyZWRcbiAgICAgICAgICAvLyBvbmNlIGRlc3BpdGUgdGhlIG51bWJlciBvZiBtdXRhdGlvbnMuICBBZGRpdGlvbmFsXG4gICAgICAgICAgLy8gdHJpZ2dlcnMgYXJlIHJlZHVuZGFudCBhbmQgYXJlIHZlcnkgY29zdGx5XG4gICAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGVtaXQoJ29ic2VydmVyVXBkYXRlJywgbXV0YXRpb25zWzBdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvYnNlcnZlclVwZGF0ZSA9IGZ1bmN0aW9uIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgICAgICAgZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KG9ic2VydmVyVXBkYXRlLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgICAgICBjaGlsZExpc3Q6IHR5cGVvZiBvcHRpb25zLmNoaWxkTGlzdCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGlsZExpc3QsXG4gICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHlwZW9mIG9wdGlvbnMuY2hhcmFjdGVyRGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGFyYWN0ZXJEYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMub2JzZXJ2ZXIpIHJldHVybjtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5vYnNlcnZlUGFyZW50cykge1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclBhcmVudHMgPSBzd2lwZXIuJGVsLnBhcmVudHMoKTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVyUGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYXR0YWNoKGNvbnRhaW5lclBhcmVudHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPYnNlcnZlIGNvbnRhaW5lclxuXG5cbiAgICAgICAgYXR0YWNoKHN3aXBlci4kZWxbMF0sIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHN3aXBlci5wYXJhbXMub2JzZXJ2ZVNsaWRlQ2hpbGRyZW5cbiAgICAgICAgfSk7IC8vIE9ic2VydmUgd3JhcHBlclxuXG4gICAgICAgIGF0dGFjaChzd2lwZXIuJHdyYXBwZXJFbFswXSwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9ic2VydmVycy5zcGxpY2UoMCwgb2JzZXJ2ZXJzLmxlbmd0aCk7XG4gICAgICB9O1xuXG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBvYnNlcnZlcjogZmFsc2UsXG4gICAgICAgIG9ic2VydmVQYXJlbnRzOiBmYWxzZSxcbiAgICAgICAgb2JzZXJ2ZVNsaWRlQ2hpbGRyZW46IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG9uKCdpbml0JywgaW5pdCk7XG4gICAgICBvbignZGVzdHJveScsIGRlc3Ryb3kpO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG4gICAgdmFyIGV2ZW50c0VtaXR0ZXIgPSB7XG4gICAgICBvbihldmVudHMsIGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBwcmlvcml0eSA/ICd1bnNoaWZ0JyA6ICdwdXNoJztcbiAgICAgICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XVttZXRob2RdKGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9LFxuXG4gICAgICBvbmNlKGV2ZW50cywgaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XG5cbiAgICAgICAgZnVuY3Rpb24gb25jZUhhbmRsZXIoLi4uYXJncykge1xuICAgICAgICAgIHNlbGYub2ZmKGV2ZW50cywgb25jZUhhbmRsZXIpO1xuXG4gICAgICAgICAgaWYgKG9uY2VIYW5kbGVyLl9fZW1pdHRlclByb3h5KSB7XG4gICAgICAgICAgICBkZWxldGUgb25jZUhhbmRsZXIuX19lbWl0dGVyUHJveHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uY2VIYW5kbGVyLl9fZW1pdHRlclByb3h5ID0gaGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIHNlbGYub24oZXZlbnRzLCBvbmNlSGFuZGxlciwgcHJpb3JpdHkpO1xuICAgICAgfSxcblxuICAgICAgb25BbnkoaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHByaW9yaXR5ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xuXG4gICAgICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpIDwgMCkge1xuICAgICAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzW21ldGhvZF0oaGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG5cbiAgICAgIG9mZkFueShoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzQW55TGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfSxcblxuICAgICAgb2ZmKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycykgcmV0dXJuIHNlbGY7XG4gICAgICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaCgoZXZlbnRIYW5kbGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyID09PSBoYW5kbGVyIHx8IGV2ZW50SGFuZGxlci5fX2VtaXR0ZXJQcm94eSAmJiBldmVudEhhbmRsZXIuX19lbWl0dGVyUHJveHkgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9LFxuXG4gICAgICBlbWl0KC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMpIHJldHVybiBzZWxmO1xuICAgICAgICBsZXQgZXZlbnRzO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgbGV0IGNvbnRleHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgZXZlbnRzID0gYXJnc1swXTtcbiAgICAgICAgICBkYXRhID0gYXJncy5zbGljZSgxLCBhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgY29udGV4dCA9IHNlbGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRzID0gYXJnc1swXS5ldmVudHM7XG4gICAgICAgICAgZGF0YSA9IGFyZ3NbMF0uZGF0YTtcbiAgICAgICAgICBjb250ZXh0ID0gYXJnc1swXS5jb250ZXh0IHx8IHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnVuc2hpZnQoY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGV2ZW50c0FycmF5ID0gQXJyYXkuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KCcgJyk7XG4gICAgICAgIGV2ZW50c0FycmF5LmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycyAmJiBzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzLmZvckVhY2goZXZlbnRIYW5kbGVyID0+IHtcbiAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIFtldmVudCwgLi4uZGF0YV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYuZXZlbnRzTGlzdGVuZXJzICYmIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdLmZvckVhY2goZXZlbnRIYW5kbGVyID0+IHtcbiAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBsZXQgd2lkdGg7XG4gICAgICBsZXQgaGVpZ2h0O1xuICAgICAgY29uc3QgJGVsID0gc3dpcGVyLiRlbDtcblxuICAgICAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSAndW5kZWZpbmVkJyAmJiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSBudWxsKSB7XG4gICAgICAgIHdpZHRoID0gc3dpcGVyLnBhcmFtcy53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gJGVsWzBdLmNsaWVudFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMuaGVpZ2h0ICE9PSAndW5kZWZpbmVkJyAmJiBzd2lwZXIucGFyYW1zLmhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICBoZWlnaHQgPSBzd2lwZXIucGFyYW1zLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlaWdodCA9ICRlbFswXS5jbGllbnRIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aWR0aCA9PT0gMCAmJiBzd2lwZXIuaXNIb3Jpem9udGFsKCkgfHwgaGVpZ2h0ID09PSAwICYmIHN3aXBlci5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBTdWJ0cmFjdCBwYWRkaW5nc1xuXG5cbiAgICAgIHdpZHRoID0gd2lkdGggLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLWxlZnQnKSB8fCAwLCAxMCkgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCwgMTApO1xuICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFyc2VJbnQoJGVsLmNzcygncGFkZGluZy10b3AnKSB8fCAwLCAxMCkgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLWJvdHRvbScpIHx8IDAsIDEwKTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4od2lkdGgpKSB3aWR0aCA9IDA7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGhlaWdodCkpIGhlaWdodCA9IDA7XG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBzaXplOiBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB3aWR0aCA6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2xpZGVzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uTGFiZWwocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICAgICAgfSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJ3dpZHRoJzogJ2hlaWdodCcsXG4gICAgICAgICAgJ21hcmdpbi10b3AnOiAnbWFyZ2luLWxlZnQnLFxuICAgICAgICAgICdtYXJnaW4tYm90dG9tICc6ICdtYXJnaW4tcmlnaHQnLFxuICAgICAgICAgICdtYXJnaW4tbGVmdCc6ICdtYXJnaW4tdG9wJyxcbiAgICAgICAgICAnbWFyZ2luLXJpZ2h0JzogJ21hcmdpbi1ib3R0b20nLFxuICAgICAgICAgICdwYWRkaW5nLWxlZnQnOiAncGFkZGluZy10b3AnLFxuICAgICAgICAgICdwYWRkaW5nLXJpZ2h0JzogJ3BhZGRpbmctYm90dG9tJyxcbiAgICAgICAgICAnbWFyZ2luUmlnaHQnOiAnbWFyZ2luQm90dG9tJ1xuICAgICAgICB9W3Byb3BlcnR5XTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShub2RlLCBsYWJlbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChub2RlLmdldFByb3BlcnR5VmFsdWUoZ2V0RGlyZWN0aW9uTGFiZWwobGFiZWwpKSB8fCAwKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgc2l6ZTogc3dpcGVyU2l6ZSxcbiAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgIHdyb25nUlRMXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICAgICAgY29uc3Qgc2xpZGVzID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWApO1xuICAgICAgY29uc3Qgc2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHNsaWRlcy5sZW5ndGg7XG4gICAgICBsZXQgc25hcEdyaWQgPSBbXTtcbiAgICAgIGNvbnN0IHNsaWRlc0dyaWQgPSBbXTtcbiAgICAgIGNvbnN0IHNsaWRlc1NpemVzR3JpZCA9IFtdO1xuICAgICAgbGV0IG9mZnNldEJlZm9yZSA9IHBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmU7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0QmVmb3JlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9mZnNldEJlZm9yZSA9IHBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmUuY2FsbChzd2lwZXIpO1xuICAgICAgfVxuXG4gICAgICBsZXQgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXI7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0QWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXIuY2FsbChzd2lwZXIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmV2aW91c1NuYXBHcmlkTGVuZ3RoID0gc3dpcGVyLnNuYXBHcmlkLmxlbmd0aDtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCA9IHN3aXBlci5zbGlkZXNHcmlkLmxlbmd0aDtcbiAgICAgIGxldCBzcGFjZUJldHdlZW4gPSBwYXJhbXMuc3BhY2VCZXR3ZWVuO1xuICAgICAgbGV0IHNsaWRlUG9zaXRpb24gPSAtb2Zmc2V0QmVmb3JlO1xuICAgICAgbGV0IHByZXZTbGlkZVNpemUgPSAwO1xuICAgICAgbGV0IGluZGV4ID0gMDtcblxuICAgICAgaWYgKHR5cGVvZiBzd2lwZXJTaXplID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJyAmJiBzcGFjZUJldHdlZW4uaW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgc3BhY2VCZXR3ZWVuID0gcGFyc2VGbG9hdChzcGFjZUJldHdlZW4ucmVwbGFjZSgnJScsICcnKSkgLyAxMDAgKiBzd2lwZXJTaXplO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIudmlydHVhbFNpemUgPSAtc3BhY2VCZXR3ZWVuOyAvLyByZXNldCBtYXJnaW5zXG5cbiAgICAgIGlmIChydGwpIHNsaWRlcy5jc3Moe1xuICAgICAgICBtYXJnaW5MZWZ0OiAnJyxcbiAgICAgICAgbWFyZ2luQm90dG9tOiAnJyxcbiAgICAgICAgbWFyZ2luVG9wOiAnJ1xuICAgICAgfSk7ZWxzZSBzbGlkZXMuY3NzKHtcbiAgICAgICAgbWFyZ2luUmlnaHQ6ICcnLFxuICAgICAgICBtYXJnaW5Cb3R0b206ICcnLFxuICAgICAgICBtYXJnaW5Ub3A6ICcnXG4gICAgICB9KTsgLy8gcmVzZXQgY3NzTW9kZSBvZmZzZXRzXG5cbiAgICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgc2V0Q1NTUHJvcGVydHkoc3dpcGVyLndyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmUnLCAnJyk7XG4gICAgICAgIHNldENTU1Byb3BlcnR5KHN3aXBlci53cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYWZ0ZXInLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdyaWRFbmFibGVkID0gcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDEgJiYgc3dpcGVyLmdyaWQ7XG5cbiAgICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuZ3JpZC5pbml0U2xpZGVzKHNsaWRlc0xlbmd0aCk7XG4gICAgICB9IC8vIENhbGMgc2xpZGVzXG5cblxuICAgICAgbGV0IHNsaWRlU2l6ZTtcbiAgICAgIGNvbnN0IHNob3VsZFJlc2V0U2xpZGVTaXplID0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiBwYXJhbXMuYnJlYWtwb2ludHMgJiYgT2JqZWN0LmtleXMocGFyYW1zLmJyZWFrcG9pbnRzKS5maWx0ZXIoa2V5ID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXJhbXMuYnJlYWtwb2ludHNba2V5XS5zbGlkZXNQZXJWaWV3ICE9PSAndW5kZWZpbmVkJztcbiAgICAgIH0pLmxlbmd0aCA+IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc2xpZGVTaXplID0gMDtcbiAgICAgICAgY29uc3Qgc2xpZGUgPSBzbGlkZXMuZXEoaSk7XG5cbiAgICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgICAgc3dpcGVyLmdyaWQudXBkYXRlU2xpZGUoaSwgc2xpZGUsIHNsaWRlc0xlbmd0aCwgZ2V0RGlyZWN0aW9uTGFiZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNsaWRlLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkUmVzZXRTbGlkZVNpemUpIHtcbiAgICAgICAgICAgIHNsaWRlc1tpXS5zdHlsZVtnZXREaXJlY3Rpb25MYWJlbCgnd2lkdGgnKV0gPSBgYDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzbGlkZVN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoc2xpZGVbMF0pO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBzbGlkZVswXS5zdHlsZS50cmFuc2Zvcm07XG4gICAgICAgICAgY29uc3QgY3VycmVudFdlYktpdFRyYW5zZm9ybSA9IHNsaWRlWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybTtcblxuICAgICAgICAgIGlmIChjdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBzbGlkZVswXS5zdHlsZS50cmFuc2Zvcm0gPSAnbm9uZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHNsaWRlWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdub25lJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykge1xuICAgICAgICAgICAgc2xpZGVTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gc2xpZGUub3V0ZXJXaWR0aCh0cnVlKSA6IHNsaWRlLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ3dpZHRoJyk7XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nTGVmdCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICdwYWRkaW5nLWxlZnQnKTtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICAgICAgICBjb25zdCBtYXJnaW5MZWZ0ID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ21hcmdpbi1sZWZ0Jyk7XG4gICAgICAgICAgICBjb25zdCBtYXJnaW5SaWdodCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICdtYXJnaW4tcmlnaHQnKTtcbiAgICAgICAgICAgIGNvbnN0IGJveFNpemluZyA9IHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2JveC1zaXppbmcnKTtcblxuICAgICAgICAgICAgaWYgKGJveFNpemluZyAmJiBib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xuICAgICAgICAgICAgICBzbGlkZVNpemUgPSB3aWR0aCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBvZmZzZXRXaWR0aFxuICAgICAgICAgICAgICB9ID0gc2xpZGVbMF07XG4gICAgICAgICAgICAgIHNsaWRlU2l6ZSA9IHdpZHRoICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQgKyBtYXJnaW5MZWZ0ICsgbWFyZ2luUmlnaHQgKyAob2Zmc2V0V2lkdGggLSBjbGllbnRXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHNsaWRlWzBdLnN0eWxlLnRyYW5zZm9ybSA9IGN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHNsaWRlWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbGlkZVNpemUgPSAoc3dpcGVyU2l6ZSAtIChwYXJhbXMuc2xpZGVzUGVyVmlldyAtIDEpICogc3BhY2VCZXR3ZWVuKSAvIHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZVNpemUgPSBNYXRoLmZsb29yKHNsaWRlU2l6ZSk7XG5cbiAgICAgICAgICBpZiAoc2xpZGVzW2ldKSB7XG4gICAgICAgICAgICBzbGlkZXNbaV0uc3R5bGVbZ2V0RGlyZWN0aW9uTGFiZWwoJ3dpZHRoJyldID0gYCR7c2xpZGVTaXplfXB4YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2xpZGVzW2ldKSB7XG4gICAgICAgICAgc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNsaWRlc1NpemVzR3JpZC5wdXNoKHNsaWRlU2l6ZSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgc2xpZGVTaXplIC8gMiArIHByZXZTbGlkZVNpemUgLyAyICsgc3BhY2VCZXR3ZWVuO1xuICAgICAgICAgIGlmIChwcmV2U2xpZGVTaXplID09PSAwICYmIGkgIT09IDApIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uIC0gc3dpcGVyU2l6ZSAvIDIgLSBzcGFjZUJldHdlZW47XG4gICAgICAgICAgaWYgKGkgPT09IDApIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uIC0gc3dpcGVyU2l6ZSAvIDIgLSBzcGFjZUJldHdlZW47XG4gICAgICAgICAgaWYgKE1hdGguYWJzKHNsaWRlUG9zaXRpb24pIDwgMSAvIDEwMDApIHNsaWRlUG9zaXRpb24gPSAwO1xuICAgICAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZVBvc2l0aW9uID0gTWF0aC5mbG9vcihzbGlkZVBvc2l0aW9uKTtcbiAgICAgICAgICBpZiAoaW5kZXggJSBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDApIHNuYXBHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XG4gICAgICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZVBvc2l0aW9uID0gTWF0aC5mbG9vcihzbGlkZVBvc2l0aW9uKTtcbiAgICAgICAgICBpZiAoKGluZGV4IC0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGluZGV4KSkgJSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgICAgIHNsaWRlc0dyaWQucHVzaChzbGlkZVBvc2l0aW9uKTtcbiAgICAgICAgICBzbGlkZVBvc2l0aW9uID0gc2xpZGVQb3NpdGlvbiArIHNsaWRlU2l6ZSArIHNwYWNlQmV0d2VlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci52aXJ0dWFsU2l6ZSArPSBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgICAgIHByZXZTbGlkZVNpemUgPSBzbGlkZVNpemU7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KHN3aXBlci52aXJ0dWFsU2l6ZSwgc3dpcGVyU2l6ZSkgKyBvZmZzZXRBZnRlcjtcblxuICAgICAgaWYgKHJ0bCAmJiB3cm9uZ1JUTCAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnY292ZXJmbG93JykpIHtcbiAgICAgICAgJHdyYXBwZXJFbC5jc3Moe1xuICAgICAgICAgIHdpZHRoOiBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5zZXRXcmFwcGVyU2l6ZSkge1xuICAgICAgICAkd3JhcHBlckVsLmNzcyh7XG4gICAgICAgICAgW2dldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXTogYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbn1weGBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuZ3JpZC51cGRhdGVXcmFwcGVyU2l6ZShzbGlkZVNpemUsIHNuYXBHcmlkLCBnZXREaXJlY3Rpb25MYWJlbCk7XG4gICAgICB9IC8vIFJlbW92ZSBsYXN0IGdyaWQgZWxlbWVudHMgZGVwZW5kaW5nIG9uIHdpZHRoXG5cblxuICAgICAgaWYgKCFwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgY29uc3QgbmV3U2xpZGVzR3JpZCA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc25hcEdyaWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBsZXQgc2xpZGVzR3JpZEl0ZW0gPSBzbmFwR3JpZFtpXTtcbiAgICAgICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVzR3JpZEl0ZW0gPSBNYXRoLmZsb29yKHNsaWRlc0dyaWRJdGVtKTtcblxuICAgICAgICAgIGlmIChzbmFwR3JpZFtpXSA8PSBzd2lwZXIudmlydHVhbFNpemUgLSBzd2lwZXJTaXplKSB7XG4gICAgICAgICAgICBuZXdTbGlkZXNHcmlkLnB1c2goc2xpZGVzR3JpZEl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNuYXBHcmlkID0gbmV3U2xpZGVzR3JpZDtcblxuICAgICAgICBpZiAoTWF0aC5mbG9vcihzd2lwZXIudmlydHVhbFNpemUgLSBzd2lwZXJTaXplKSAtIE1hdGguZmxvb3Ioc25hcEdyaWRbc25hcEdyaWQubGVuZ3RoIC0gMV0pID4gMSkge1xuICAgICAgICAgIHNuYXBHcmlkLnB1c2goc3dpcGVyLnZpcnR1YWxTaXplIC0gc3dpcGVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNuYXBHcmlkLmxlbmd0aCA9PT0gMCkgc25hcEdyaWQgPSBbMF07XG5cbiAgICAgIGlmIChwYXJhbXMuc3BhY2VCZXR3ZWVuICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHN3aXBlci5pc0hvcml6b250YWwoKSAmJiBydGwgPyAnbWFyZ2luTGVmdCcgOiBnZXREaXJlY3Rpb25MYWJlbCgnbWFyZ2luUmlnaHQnKTtcbiAgICAgICAgc2xpZGVzLmZpbHRlcigoXywgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgICAgIGlmICghcGFyYW1zLmNzc01vZGUpIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgaWYgKHNsaWRlSW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLmNzcyh7XG4gICAgICAgICAgW2tleV06IGAke3NwYWNlQmV0d2Vlbn1weGBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XG4gICAgICAgIGxldCBhbGxTbGlkZXNTaXplID0gMDtcbiAgICAgICAgc2xpZGVzU2l6ZXNHcmlkLmZvckVhY2goc2xpZGVTaXplVmFsdWUgPT4ge1xuICAgICAgICAgIGFsbFNsaWRlc1NpemUgKz0gc2xpZGVTaXplVmFsdWUgKyAocGFyYW1zLnNwYWNlQmV0d2VlbiA/IHBhcmFtcy5zcGFjZUJldHdlZW4gOiAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFsbFNsaWRlc1NpemUgLT0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcbiAgICAgICAgY29uc3QgbWF4U25hcCA9IGFsbFNsaWRlc1NpemUgLSBzd2lwZXJTaXplO1xuICAgICAgICBzbmFwR3JpZCA9IHNuYXBHcmlkLm1hcChzbmFwID0+IHtcbiAgICAgICAgICBpZiAoc25hcCA8IDApIHJldHVybiAtb2Zmc2V0QmVmb3JlO1xuICAgICAgICAgIGlmIChzbmFwID4gbWF4U25hcCkgcmV0dXJuIG1heFNuYXAgKyBvZmZzZXRBZnRlcjtcbiAgICAgICAgICByZXR1cm4gc25hcDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuY2VudGVySW5zdWZmaWNpZW50U2xpZGVzKSB7XG4gICAgICAgIGxldCBhbGxTbGlkZXNTaXplID0gMDtcbiAgICAgICAgc2xpZGVzU2l6ZXNHcmlkLmZvckVhY2goc2xpZGVTaXplVmFsdWUgPT4ge1xuICAgICAgICAgIGFsbFNsaWRlc1NpemUgKz0gc2xpZGVTaXplVmFsdWUgKyAocGFyYW1zLnNwYWNlQmV0d2VlbiA/IHBhcmFtcy5zcGFjZUJldHdlZW4gOiAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFsbFNsaWRlc1NpemUgLT0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcblxuICAgICAgICBpZiAoYWxsU2xpZGVzU2l6ZSA8IHN3aXBlclNpemUpIHtcbiAgICAgICAgICBjb25zdCBhbGxTbGlkZXNPZmZzZXQgPSAoc3dpcGVyU2l6ZSAtIGFsbFNsaWRlc1NpemUpIC8gMjtcbiAgICAgICAgICBzbmFwR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgICAgIHNuYXBHcmlkW3NuYXBJbmRleF0gPSBzbmFwIC0gYWxsU2xpZGVzT2Zmc2V0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNsaWRlc0dyaWQuZm9yRWFjaCgoc25hcCwgc25hcEluZGV4KSA9PiB7XG4gICAgICAgICAgICBzbGlkZXNHcmlkW3NuYXBJbmRleF0gPSBzbmFwICsgYWxsU2xpZGVzT2Zmc2V0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICAgIHNsaWRlcyxcbiAgICAgICAgc25hcEdyaWQsXG4gICAgICAgIHNsaWRlc0dyaWQsXG4gICAgICAgIHNsaWRlc1NpemVzR3JpZFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNzc01vZGUgJiYgIXBhcmFtcy5jZW50ZXJlZFNsaWRlc0JvdW5kcykge1xuICAgICAgICBzZXRDU1NQcm9wZXJ0eShzd2lwZXIud3JhcHBlckVsLCAnLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWJlZm9yZScsIGAkey1zbmFwR3JpZFswXX1weGApO1xuICAgICAgICBzZXRDU1NQcm9wZXJ0eShzd2lwZXIud3JhcHBlckVsLCAnLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWFmdGVyJywgYCR7c3dpcGVyLnNpemUgLyAyIC0gc2xpZGVzU2l6ZXNHcmlkW3NsaWRlc1NpemVzR3JpZC5sZW5ndGggLSAxXSAvIDJ9cHhgKTtcbiAgICAgICAgY29uc3QgYWRkVG9TbmFwR3JpZCA9IC1zd2lwZXIuc25hcEdyaWRbMF07XG4gICAgICAgIGNvbnN0IGFkZFRvU2xpZGVzR3JpZCA9IC1zd2lwZXIuc2xpZGVzR3JpZFswXTtcbiAgICAgICAgc3dpcGVyLnNuYXBHcmlkID0gc3dpcGVyLnNuYXBHcmlkLm1hcCh2ID0+IHYgKyBhZGRUb1NuYXBHcmlkKTtcbiAgICAgICAgc3dpcGVyLnNsaWRlc0dyaWQgPSBzd2lwZXIuc2xpZGVzR3JpZC5tYXAodiA9PiB2ICsgYWRkVG9TbGlkZXNHcmlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNsaWRlc0xlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNMZW5ndGgpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3NsaWRlc0xlbmd0aENoYW5nZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc25hcEdyaWQubGVuZ3RoICE9PSBwcmV2aW91c1NuYXBHcmlkTGVuZ3RoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cpIHN3aXBlci5jaGVja092ZXJmbG93KCk7XG4gICAgICAgIHN3aXBlci5lbWl0KCdzbmFwR3JpZExlbmd0aENoYW5nZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2xpZGVzR3JpZC5sZW5ndGggIT09IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCkge1xuICAgICAgICBzd2lwZXIuZW1pdCgnc2xpZGVzR3JpZExlbmd0aENoYW5nZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc09mZnNldCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUF1dG9IZWlnaHQoc3BlZWQpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBhY3RpdmVTbGlkZXMgPSBbXTtcbiAgICAgIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgICAgbGV0IG5ld0hlaWdodCA9IDA7XG4gICAgICBsZXQgaTtcblxuICAgICAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzd2lwZXIucGFyYW1zLnNwZWVkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ2V0U2xpZGVCeUluZGV4ID0gaW5kZXggPT4ge1xuICAgICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZXMuZmlsdGVyKGVsID0+IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApID09PSBpbmRleClbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3dpcGVyLnNsaWRlcy5lcShpbmRleClbMF07XG4gICAgICB9OyAvLyBGaW5kIHNsaWRlcyBjdXJyZW50bHkgaW4gdmlld1xuXG5cbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgIT09ICdhdXRvJyAmJiBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXMuZWFjaChzbGlkZSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVTbGlkZXMucHVzaChzbGlkZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IE1hdGguY2VpbChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcpOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4ICsgaTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoICYmICFpc1ZpcnR1YWwpIGJyZWFrO1xuICAgICAgICAgICAgYWN0aXZlU2xpZGVzLnB1c2goZ2V0U2xpZGVCeUluZGV4KGluZGV4KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVTbGlkZXMucHVzaChnZXRTbGlkZUJ5SW5kZXgoc3dpcGVyLmFjdGl2ZUluZGV4KSk7XG4gICAgICB9IC8vIEZpbmQgbmV3IGhlaWdodCBmcm9tIGhpZ2hlc3Qgc2xpZGUgaW4gdmlld1xuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmVTbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3RpdmVTbGlkZXNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYWN0aXZlU2xpZGVzW2ldLm9mZnNldEhlaWdodDtcbiAgICAgICAgICBuZXdIZWlnaHQgPSBoZWlnaHQgPiBuZXdIZWlnaHQgPyBoZWlnaHQgOiBuZXdIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVXBkYXRlIEhlaWdodFxuXG5cbiAgICAgIGlmIChuZXdIZWlnaHQpIHN3aXBlci4kd3JhcHBlckVsLmNzcygnaGVpZ2h0JywgYCR7bmV3SGVpZ2h0fXB4YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2xpZGVzT2Zmc2V0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHNsaWRlcyA9IHN3aXBlci5zbGlkZXM7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHNsaWRlc1tpXS5zd2lwZXJTbGlkZU9mZnNldCA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHNsaWRlc1tpXS5vZmZzZXRMZWZ0IDogc2xpZGVzW2ldLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXNQcm9ncmVzcyh0cmFuc2xhdGUgPSB0aGlzICYmIHRoaXMudHJhbnNsYXRlIHx8IDApIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbGlkZXMsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgICBzbmFwR3JpZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmIChzbGlkZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcbiAgICAgIGxldCBvZmZzZXRDZW50ZXIgPSAtdHJhbnNsYXRlO1xuICAgICAgaWYgKHJ0bCkgb2Zmc2V0Q2VudGVyID0gdHJhbnNsYXRlOyAvLyBWaXNpYmxlIFNsaWRlc1xuXG4gICAgICBzbGlkZXMucmVtb3ZlQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcbiAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcyA9IFtdO1xuICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc2xpZGUgPSBzbGlkZXNbaV07XG4gICAgICAgIGxldCBzbGlkZU9mZnNldCA9IHNsaWRlLnN3aXBlclNsaWRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgICBzbGlkZU9mZnNldCAtPSBzbGlkZXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzbGlkZVByb2dyZXNzID0gKG9mZnNldENlbnRlciArIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBzd2lwZXIubWluVHJhbnNsYXRlKCkgOiAwKSAtIHNsaWRlT2Zmc2V0KSAvIChzbGlkZS5zd2lwZXJTbGlkZVNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVuKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTbGlkZVByb2dyZXNzID0gKG9mZnNldENlbnRlciAtIHNuYXBHcmlkWzBdICsgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5taW5UcmFuc2xhdGUoKSA6IDApIC0gc2xpZGVPZmZzZXQpIC8gKHNsaWRlLnN3aXBlclNsaWRlU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW4pO1xuICAgICAgICBjb25zdCBzbGlkZUJlZm9yZSA9IC0ob2Zmc2V0Q2VudGVyIC0gc2xpZGVPZmZzZXQpO1xuICAgICAgICBjb25zdCBzbGlkZUFmdGVyID0gc2xpZGVCZWZvcmUgKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW2ldO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBzbGlkZUJlZm9yZSA+PSAwICYmIHNsaWRlQmVmb3JlIDwgc3dpcGVyLnNpemUgLSAxIHx8IHNsaWRlQWZ0ZXIgPiAxICYmIHNsaWRlQWZ0ZXIgPD0gc3dpcGVyLnNpemUgfHwgc2xpZGVCZWZvcmUgPD0gMCAmJiBzbGlkZUFmdGVyID49IHN3aXBlci5zaXplO1xuXG4gICAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgICBzd2lwZXIudmlzaWJsZVNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgICAgICBzd2lwZXIudmlzaWJsZVNsaWRlc0luZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICBzbGlkZXMuZXEoaSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNsaWRlLnByb2dyZXNzID0gcnRsID8gLXNsaWRlUHJvZ3Jlc3MgOiBzbGlkZVByb2dyZXNzO1xuICAgICAgICBzbGlkZS5vcmlnaW5hbFByb2dyZXNzID0gcnRsID8gLW9yaWdpbmFsU2xpZGVQcm9ncmVzcyA6IG9yaWdpbmFsU2xpZGVQcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXMgPSAkKHN3aXBlci52aXNpYmxlU2xpZGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyh0cmFuc2xhdGUpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgdHJhbnNsYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IC0xIDogMTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgdHJhbnNsYXRlID0gc3dpcGVyICYmIHN3aXBlci50cmFuc2xhdGUgJiYgc3dpcGVyLnRyYW5zbGF0ZSAqIG11bHRpcGxpZXIgfHwgMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgbGV0IHtcbiAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgIGlzQmVnaW5uaW5nLFxuICAgICAgICBpc0VuZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGNvbnN0IHdhc0JlZ2lubmluZyA9IGlzQmVnaW5uaW5nO1xuICAgICAgY29uc3Qgd2FzRW5kID0gaXNFbmQ7XG5cbiAgICAgIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgICAgICBwcm9ncmVzcyA9IDA7XG4gICAgICAgIGlzQmVnaW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaXNFbmQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xuICAgICAgICBpc0JlZ2lubmluZyA9IHByb2dyZXNzIDw9IDA7XG4gICAgICAgIGlzRW5kID0gcHJvZ3Jlc3MgPj0gMTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgIGlzQmVnaW5uaW5nLFxuICAgICAgICBpc0VuZFxuICAgICAgfSk7XG4gICAgICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHBhcmFtcy5hdXRvSGVpZ2h0KSBzd2lwZXIudXBkYXRlU2xpZGVzUHJvZ3Jlc3ModHJhbnNsYXRlKTtcblxuICAgICAgaWYgKGlzQmVnaW5uaW5nICYmICF3YXNCZWdpbm5pbmcpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3JlYWNoQmVnaW5uaW5nIHRvRWRnZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFbmQgJiYgIXdhc0VuZCkge1xuICAgICAgICBzd2lwZXIuZW1pdCgncmVhY2hFbmQgdG9FZGdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3YXNCZWdpbm5pbmcgJiYgIWlzQmVnaW5uaW5nIHx8IHdhc0VuZCAmJiAhaXNFbmQpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2Zyb21FZGdlJyk7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KCdwcm9ncmVzcycsIHByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXNDbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2xpZGVzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICByZWFsSW5kZXhcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgICAgc2xpZGVzLnJlbW92ZUNsYXNzKGAke3BhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzfSAke3BhcmFtcy5zbGlkZU5leHRDbGFzc30gJHtwYXJhbXMuc2xpZGVQcmV2Q2xhc3N9ICR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3N9ICR7cGFyYW1zLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzfSAke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzc31gKTtcbiAgICAgIGxldCBhY3RpdmVTbGlkZTtcblxuICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICBhY3RpdmVTbGlkZSA9IHN3aXBlci4kd3JhcHBlckVsLmZpbmQoYC4ke3BhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7YWN0aXZlSW5kZXh9XCJdYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVTbGlkZSA9IHNsaWRlcy5lcShhY3RpdmVJbmRleCk7XG4gICAgICB9IC8vIEFjdGl2ZSBjbGFzc2VzXG5cblxuICAgICAgYWN0aXZlU2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgLy8gRHVwbGljYXRlIHRvIGFsbCBsb29wZWQgc2xpZGVzXG4gICAgICAgIGlmIChhY3RpdmVTbGlkZS5oYXNDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc306bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl1gKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyZWFsSW5kZXh9XCJdYCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9IC8vIE5leHQgU2xpZGVcblxuXG4gICAgICBsZXQgbmV4dFNsaWRlID0gYWN0aXZlU2xpZGUubmV4dEFsbChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCkuZXEoMCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcblxuICAgICAgaWYgKHBhcmFtcy5sb29wICYmIG5leHRTbGlkZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbmV4dFNsaWRlID0gc2xpZGVzLmVxKDApO1xuICAgICAgICBuZXh0U2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcbiAgICAgIH0gLy8gUHJldiBTbGlkZVxuXG5cbiAgICAgIGxldCBwcmV2U2xpZGUgPSBhY3RpdmVTbGlkZS5wcmV2QWxsKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKS5lcSgwKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcHJldlNsaWRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwcmV2U2xpZGUgPSBzbGlkZXMuZXEoLTEpO1xuICAgICAgICBwcmV2U2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlUHJldkNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgIC8vIER1cGxpY2F0ZSB0byBhbGwgbG9vcGVkIHNsaWRlc1xuICAgICAgICBpZiAobmV4dFNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICAgICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7bmV4dFNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XCJdYCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke25leHRTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICAgICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cHJldlNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XCJdYCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3ByZXZTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXRTbGlkZXNDbGFzc2VzKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQWN0aXZlSW5kZXgobmV3QWN0aXZlSW5kZXgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbGlkZXNHcmlkLFxuICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBhY3RpdmVJbmRleDogcHJldmlvdXNJbmRleCxcbiAgICAgICAgcmVhbEluZGV4OiBwcmV2aW91c1JlYWxJbmRleCxcbiAgICAgICAgc25hcEluZGV4OiBwcmV2aW91c1NuYXBJbmRleFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGxldCBhY3RpdmVJbmRleCA9IG5ld0FjdGl2ZUluZGV4O1xuICAgICAgbGV0IHNuYXBJbmRleDtcblxuICAgICAgaWYgKHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyAxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSAmJiB0cmFuc2xhdGUgPCBzbGlkZXNHcmlkW2kgKyAxXSAtIChzbGlkZXNHcmlkW2kgKyAxXSAtIHNsaWRlc0dyaWRbaV0pIC8gMikge1xuICAgICAgICAgICAgICBhY3RpdmVJbmRleCA9IGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldICYmIHRyYW5zbGF0ZSA8IHNsaWRlc0dyaWRbaSArIDFdKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSkge1xuICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBOb3JtYWxpemUgc2xpZGVJbmRleFxuXG5cbiAgICAgICAgaWYgKHBhcmFtcy5ub3JtYWxpemVTbGlkZUluZGV4KSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZUluZGV4IDwgMCB8fCB0eXBlb2YgYWN0aXZlSW5kZXggPT09ICd1bmRlZmluZWQnKSBhY3RpdmVJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKSA+PSAwKSB7XG4gICAgICAgIHNuYXBJbmRleCA9IHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNraXAgPSBNYXRoLm1pbihwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBhY3RpdmVJbmRleCk7XG4gICAgICAgIHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChhY3RpdmVJbmRleCAtIHNraXApIC8gcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNuYXBJbmRleCA+PSBzbmFwR3JpZC5sZW5ndGgpIHNuYXBJbmRleCA9IHNuYXBHcmlkLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICBpZiAoc25hcEluZGV4ICE9PSBwcmV2aW91c1NuYXBJbmRleCkge1xuICAgICAgICAgIHN3aXBlci5zbmFwSW5kZXggPSBzbmFwSW5kZXg7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ3NuYXBJbmRleENoYW5nZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBHZXQgcmVhbCBpbmRleFxuXG5cbiAgICAgIGNvbnN0IHJlYWxJbmRleCA9IHBhcnNlSW50KHN3aXBlci5zbGlkZXMuZXEoYWN0aXZlSW5kZXgpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgfHwgYWN0aXZlSW5kZXgsIDEwKTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICAgIHNuYXBJbmRleCxcbiAgICAgICAgcmVhbEluZGV4LFxuICAgICAgICBwcmV2aW91c0luZGV4LFxuICAgICAgICBhY3RpdmVJbmRleFxuICAgICAgfSk7XG4gICAgICBzd2lwZXIuZW1pdCgnYWN0aXZlSW5kZXhDaGFuZ2UnKTtcbiAgICAgIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcblxuICAgICAgaWYgKHByZXZpb3VzUmVhbEluZGV4ICE9PSByZWFsSW5kZXgpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3JlYWxJbmRleENoYW5nZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLmluaXRpYWxpemVkIHx8IHN3aXBlci5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0KSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCdzbGlkZUNoYW5nZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNsaWNrZWRTbGlkZShlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgICAgIGNvbnN0IHNsaWRlID0gJChlLnRhcmdldCkuY2xvc2VzdChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YClbMF07XG4gICAgICBsZXQgc2xpZGVGb3VuZCA9IGZhbHNlO1xuICAgICAgbGV0IHNsaWRlSW5kZXg7XG5cbiAgICAgIGlmIChzbGlkZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlci5zbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnNsaWRlc1tpXSA9PT0gc2xpZGUpIHtcbiAgICAgICAgICAgIHNsaWRlRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgc2xpZGVJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNsaWRlICYmIHNsaWRlRm91bmQpIHtcbiAgICAgICAgc3dpcGVyLmNsaWNrZWRTbGlkZSA9IHNsaWRlO1xuXG4gICAgICAgIGlmIChzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgICAgICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSBwYXJzZUludCgkKHNsaWRlKS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHNsaWRlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5jbGlja2VkU2xpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5zbGlkZVRvQ2xpY2tlZFNsaWRlICYmIHN3aXBlci5jbGlja2VkSW5kZXggIT09IHVuZGVmaW5lZCAmJiBzd2lwZXIuY2xpY2tlZEluZGV4ICE9PSBzd2lwZXIuYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG9DbGlja2VkU2xpZGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgdXBkYXRlU2l6ZSxcbiAgICAgIHVwZGF0ZVNsaWRlcyxcbiAgICAgIHVwZGF0ZUF1dG9IZWlnaHQsXG4gICAgICB1cGRhdGVTbGlkZXNPZmZzZXQsXG4gICAgICB1cGRhdGVTbGlkZXNQcm9ncmVzcyxcbiAgICAgIHVwZGF0ZVByb2dyZXNzLFxuICAgICAgdXBkYXRlU2xpZGVzQ2xhc3NlcyxcbiAgICAgIHVwZGF0ZUFjdGl2ZUluZGV4LFxuICAgICAgdXBkYXRlQ2xpY2tlZFNsaWRlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFN3aXBlclRyYW5zbGF0ZShheGlzID0gdGhpcy5pc0hvcml6b250YWwoKSA/ICd4JyA6ICd5Jykge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICAkd3JhcHBlckVsXG4gICAgICB9ID0gc3dpcGVyO1xuXG4gICAgICBpZiAocGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUpIHtcbiAgICAgICAgcmV0dXJuIHJ0bCA/IC10cmFuc2xhdGUgOiB0cmFuc2xhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlO1xuICAgICAgfVxuXG4gICAgICBsZXQgY3VycmVudFRyYW5zbGF0ZSA9IGdldFRyYW5zbGF0ZSgkd3JhcHBlckVsWzBdLCBheGlzKTtcbiAgICAgIGlmIChydGwpIGN1cnJlbnRUcmFuc2xhdGUgPSAtY3VycmVudFRyYW5zbGF0ZTtcbiAgICAgIHJldHVybiBjdXJyZW50VHJhbnNsYXRlIHx8IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSwgYnlDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAkd3JhcHBlckVsLFxuICAgICAgICB3cmFwcGVyRWwsXG4gICAgICAgIHByb2dyZXNzXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgbGV0IHggPSAwO1xuICAgICAgbGV0IHkgPSAwO1xuICAgICAgY29uc3QgeiA9IDA7XG5cbiAgICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgeCA9IHJ0bCA/IC10cmFuc2xhdGUgOiB0cmFuc2xhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ID0gdHJhbnNsYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykge1xuICAgICAgICB4ID0gTWF0aC5mbG9vcih4KTtcbiAgICAgICAgeSA9IE1hdGguZmxvb3IoeSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICB3cmFwcGVyRWxbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gLXggOiAteTtcbiAgICAgIH0gZWxzZSBpZiAoIXBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlKSB7XG4gICAgICAgICR3cmFwcGVyRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgJHt6fXB4KWApO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIucHJldmlvdXNUcmFuc2xhdGUgPSBzd2lwZXIudHJhbnNsYXRlO1xuICAgICAgc3dpcGVyLnRyYW5zbGF0ZSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHggOiB5OyAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSBwcm9ncmVzc1xuXG4gICAgICBsZXQgbmV3UHJvZ3Jlc3M7XG4gICAgICBjb25zdCB0cmFuc2xhdGVzRGlmZiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKTtcblxuICAgICAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XG4gICAgICAgIG5ld1Byb2dyZXNzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Byb2dyZXNzID0gKHRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgLyB0cmFuc2xhdGVzRGlmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1Byb2dyZXNzICE9PSBwcm9ncmVzcykge1xuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXQoJ3NldFRyYW5zbGF0ZScsIHN3aXBlci50cmFuc2xhdGUsIGJ5Q29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWluVHJhbnNsYXRlKCkge1xuICAgICAgcmV0dXJuIC10aGlzLnNuYXBHcmlkWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heFRyYW5zbGF0ZSgpIHtcbiAgICAgIHJldHVybiAtdGhpcy5zbmFwR3JpZFt0aGlzLnNuYXBHcmlkLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVRvKHRyYW5zbGF0ZSA9IDAsIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIHRyYW5zbGF0ZUJvdW5kcyA9IHRydWUsIGludGVybmFsKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHdyYXBwZXJFbFxuICAgICAgfSA9IHN3aXBlcjtcblxuICAgICAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1pblRyYW5zbGF0ZSA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgICAgIGNvbnN0IG1heFRyYW5zbGF0ZSA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgICAgIGxldCBuZXdUcmFuc2xhdGU7XG4gICAgICBpZiAodHJhbnNsYXRlQm91bmRzICYmIHRyYW5zbGF0ZSA+IG1pblRyYW5zbGF0ZSkgbmV3VHJhbnNsYXRlID0gbWluVHJhbnNsYXRlO2Vsc2UgaWYgKHRyYW5zbGF0ZUJvdW5kcyAmJiB0cmFuc2xhdGUgPCBtYXhUcmFuc2xhdGUpIG5ld1RyYW5zbGF0ZSA9IG1heFRyYW5zbGF0ZTtlbHNlIG5ld1RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTsgLy8gVXBkYXRlIHByb2dyZXNzXG5cbiAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdUcmFuc2xhdGUpO1xuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgY29uc3QgaXNIID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xuXG4gICAgICAgIGlmIChzcGVlZCA9PT0gMCkge1xuICAgICAgICAgIHdyYXBwZXJFbFtpc0ggPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSAtbmV3VHJhbnNsYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghc3dpcGVyLnN1cHBvcnQuc21vb3RoU2Nyb2xsKSB7XG4gICAgICAgICAgICBhbmltYXRlQ1NTTW9kZVNjcm9sbCh7XG4gICAgICAgICAgICAgIHN3aXBlcixcbiAgICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb246IC1uZXdUcmFuc2xhdGUsXG4gICAgICAgICAgICAgIHNpZGU6IGlzSCA/ICdsZWZ0JyA6ICd0b3AnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdyYXBwZXJFbC5zY3JvbGxUbyh7XG4gICAgICAgICAgICBbaXNIID8gJ2xlZnQnIDogJ3RvcCddOiAtbmV3VHJhbnNsYXRlLFxuICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1RyYW5zbGF0ZSk7XG5cbiAgICAgICAgaWYgKHJ1bkNhbGxiYWNrcykge1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHNwZWVkKTtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xuXG4gICAgICAgIGlmIChydW5DYWxsYmFja3MpIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvblN0YXJ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICghc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkge1xuICAgICAgICAgICAgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoZSkge1xuICAgICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICAgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IG51bGw7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kO1xuXG4gICAgICAgICAgICAgIGlmIChydW5DYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvbkVuZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zbGF0ZSA9IHtcbiAgICAgIGdldFRyYW5zbGF0ZTogZ2V0U3dpcGVyVHJhbnNsYXRlLFxuICAgICAgc2V0VHJhbnNsYXRlLFxuICAgICAgbWluVHJhbnNsYXRlLFxuICAgICAgbWF4VHJhbnNsYXRlLFxuICAgICAgdHJhbnNsYXRlVG9cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2V0VHJhbnNpdGlvbihkdXJhdGlvbiwgYnlDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC50cmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXQoJ3NldFRyYW5zaXRpb24nLCBkdXJhdGlvbiwgYnlDb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRW1pdCh7XG4gICAgICBzd2lwZXIsXG4gICAgICBydW5DYWxsYmFja3MsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBzdGVwXG4gICAgfSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgcHJldmlvdXNJbmRleFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGxldCBkaXIgPSBkaXJlY3Rpb247XG5cbiAgICAgIGlmICghZGlyKSB7XG4gICAgICAgIGlmIChhY3RpdmVJbmRleCA+IHByZXZpb3VzSW5kZXgpIGRpciA9ICduZXh0JztlbHNlIGlmIChhY3RpdmVJbmRleCA8IHByZXZpb3VzSW5kZXgpIGRpciA9ICdwcmV2JztlbHNlIGRpciA9ICdyZXNldCc7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KGB0cmFuc2l0aW9uJHtzdGVwfWApO1xuXG4gICAgICBpZiAocnVuQ2FsbGJhY2tzICYmIGFjdGl2ZUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIGlmIChkaXIgPT09ICdyZXNldCcpIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdChgc2xpZGVSZXNldFRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmVtaXQoYHNsaWRlQ2hhbmdlVHJhbnNpdGlvbiR7c3RlcH1gKTtcblxuICAgICAgICBpZiAoZGlyID09PSAnbmV4dCcpIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdChgc2xpZGVOZXh0VHJhbnNpdGlvbiR7c3RlcH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdChgc2xpZGVQcmV2VHJhbnNpdGlvbiR7c3RlcH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MgPSB0cnVlLCBkaXJlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtc1xuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuXG4gICAgICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbkVtaXQoe1xuICAgICAgICBzd2lwZXIsXG4gICAgICAgIHJ1bkNhbGxiYWNrcyxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBzdGVwOiAnU3RhcnQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcyA9IHRydWUsIGRpcmVjdGlvbikge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKHBhcmFtcy5jc3NNb2RlKSByZXR1cm47XG4gICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcbiAgICAgIHRyYW5zaXRpb25FbWl0KHtcbiAgICAgICAgc3dpcGVyLFxuICAgICAgICBydW5DYWxsYmFja3MsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgc3RlcDogJ0VuZCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2l0aW9uID0ge1xuICAgICAgc2V0VHJhbnNpdGlvbixcbiAgICAgIHRyYW5zaXRpb25TdGFydCxcbiAgICAgIHRyYW5zaXRpb25FbmRcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2xpZGVUbyhpbmRleCA9IDAsIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsLCBpbml0aWFsKSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgaW5kZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICdpbmRleCcgYXJndW1lbnQgY2Fubm90IGhhdmUgdHlwZSBvdGhlciB0aGFuICdudW1iZXInIG9yICdzdHJpbmcnLiBbJHt0eXBlb2YgaW5kZXh9XSBnaXZlbi5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgaW5kZXhgIGFyZ3VtZW50IGNvbnZlcnRlZCBmcm9tIGBzdHJpbmdgIHRvIGBudW1iZXJgLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaW5kZXhBc051bWJlciA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGBpbmRleGAgYXJndW1lbnQgaXMgYSB2YWxpZCBgbnVtYmVyYFxuICAgICAgICAgKiBhZnRlciBiZWluZyBjb252ZXJ0ZWQgZnJvbSB0aGUgYHN0cmluZ2AgdHlwZS5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbnN0IGlzVmFsaWROdW1iZXIgPSBpc0Zpbml0ZShpbmRleEFzTnVtYmVyKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWROdW1iZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYXNzZWQtaW4gJ2luZGV4JyAoc3RyaW5nKSBjb3VsZG4ndCBiZSBjb252ZXJ0ZWQgdG8gJ251bWJlcicuIFske2luZGV4fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH0gLy8gS25vd2luZyB0aGF0IHRoZSBjb252ZXJ0ZWQgYGluZGV4YCBpcyBhIHZhbGlkIG51bWJlcixcbiAgICAgICAgLy8gd2UgY2FuIHVwZGF0ZSB0aGUgb3JpZ2luYWwgYXJndW1lbnQncyB2YWx1ZS5cblxuXG4gICAgICAgIGluZGV4ID0gaW5kZXhBc051bWJlcjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGxldCBzbGlkZUluZGV4ID0gaW5kZXg7XG4gICAgICBpZiAoc2xpZGVJbmRleCA8IDApIHNsaWRlSW5kZXggPSAwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHNuYXBHcmlkLFxuICAgICAgICBzbGlkZXNHcmlkLFxuICAgICAgICBwcmV2aW91c0luZGV4LFxuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgIHdyYXBwZXJFbCxcbiAgICAgICAgZW5hYmxlZFxuICAgICAgfSA9IHN3aXBlcjtcblxuICAgICAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbiB8fCAhZW5hYmxlZCAmJiAhaW50ZXJuYWwgJiYgIWluaXRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBza2lwID0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIHNsaWRlSW5kZXgpO1xuICAgICAgbGV0IHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChzbGlkZUluZGV4IC0gc2tpcCkgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgICAgIGlmIChzbmFwSW5kZXggPj0gc25hcEdyaWQubGVuZ3RoKSBzbmFwSW5kZXggPSBzbmFwR3JpZC5sZW5ndGggLSAxO1xuXG4gICAgICBpZiAoKGFjdGl2ZUluZGV4IHx8IHBhcmFtcy5pbml0aWFsU2xpZGUgfHwgMCkgPT09IChwcmV2aW91c0luZGV4IHx8IDApICYmIHJ1bkNhbGxiYWNrcykge1xuICAgICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlU2xpZGVDaGFuZ2VTdGFydCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSAtc25hcEdyaWRbc25hcEluZGV4XTsgLy8gVXBkYXRlIHByb2dyZXNzXG5cbiAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyh0cmFuc2xhdGUpOyAvLyBOb3JtYWxpemUgc2xpZGVJbmRleFxuXG4gICAgICBpZiAocGFyYW1zLm5vcm1hbGl6ZVNsaWRlSW5kZXgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFRyYW5zbGF0ZSA9IC1NYXRoLmZsb29yKHRyYW5zbGF0ZSAqIDEwMCk7XG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEdyaWQgPSBNYXRoLmZsb29yKHNsaWRlc0dyaWRbaV0gKiAxMDApO1xuICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRHcmlkTmV4dCA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZFtpICsgMV0gKiAxMDApO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyAxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkICYmIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPCBub3JtYWxpemVkR3JpZE5leHQgLSAobm9ybWFsaXplZEdyaWROZXh0IC0gbm9ybWFsaXplZEdyaWQpIC8gMikge1xuICAgICAgICAgICAgICBzbGlkZUluZGV4ID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZFRyYW5zbGF0ZSA+PSBub3JtYWxpemVkR3JpZCAmJiBub3JtYWxpemVkVHJhbnNsYXRlIDwgbm9ybWFsaXplZEdyaWROZXh0KSB7XG4gICAgICAgICAgICAgIHNsaWRlSW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gbm9ybWFsaXplZEdyaWQpIHtcbiAgICAgICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBEaXJlY3Rpb25zIGxvY2tzXG5cblxuICAgICAgaWYgKHN3aXBlci5pbml0aWFsaXplZCAmJiBzbGlkZUluZGV4ICE9PSBhY3RpdmVJbmRleCkge1xuICAgICAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiB0cmFuc2xhdGUgPCBzd2lwZXIudHJhbnNsYXRlICYmIHRyYW5zbGF0ZSA8IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmIHRyYW5zbGF0ZSA+IHN3aXBlci50cmFuc2xhdGUgJiYgdHJhbnNsYXRlID4gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgaWYgKChhY3RpdmVJbmRleCB8fCAwKSAhPT0gc2xpZGVJbmRleCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBkaXJlY3Rpb247XG4gICAgICBpZiAoc2xpZGVJbmRleCA+IGFjdGl2ZUluZGV4KSBkaXJlY3Rpb24gPSAnbmV4dCc7ZWxzZSBpZiAoc2xpZGVJbmRleCA8IGFjdGl2ZUluZGV4KSBkaXJlY3Rpb24gPSAncHJldic7ZWxzZSBkaXJlY3Rpb24gPSAncmVzZXQnOyAvLyBVcGRhdGUgSW5kZXhcblxuICAgICAgaWYgKHJ0bCAmJiAtdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlIHx8ICFydGwgJiYgdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlKSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTsgLy8gVXBkYXRlIEhlaWdodFxuXG4gICAgICAgIGlmIChwYXJhbXMuYXV0b0hlaWdodCkge1xuICAgICAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuXG4gICAgICAgIGlmIChwYXJhbXMuZWZmZWN0ICE9PSAnc2xpZGUnKSB7XG4gICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gJ3Jlc2V0Jykge1xuICAgICAgICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIGNvbnN0IGlzSCA9IHN3aXBlci5pc0hvcml6b250YWwoKTtcbiAgICAgICAgY29uc3QgdCA9IHJ0bCA/IHRyYW5zbGF0ZSA6IC10cmFuc2xhdGU7XG5cbiAgICAgICAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG5cbiAgICAgICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gJ25vbmUnO1xuICAgICAgICAgICAgc3dpcGVyLl9pbW1lZGlhdGVWaXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3cmFwcGVyRWxbaXNIID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddID0gdDtcblxuICAgICAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAnJztcbiAgICAgICAgICAgICAgc3dpcGVyLl9zd2lwZXJJbW1lZGlhdGVWaXJ0dWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzd2lwZXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgICAgIGFuaW1hdGVDU1NNb2RlU2Nyb2xsKHtcbiAgICAgICAgICAgICAgc3dpcGVyLFxuICAgICAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogdCxcbiAgICAgICAgICAgICAgc2lkZTogaXNIID8gJ2xlZnQnIDogJ3RvcCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgICAgIFtpc0ggPyAnbGVmdCcgOiAndG9wJ106IHQsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xuICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHNwZWVkKTtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGUpO1xuICAgICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoc2xpZGVJbmRleCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgICAgICBzd2lwZXIudHJhbnNpdGlvblN0YXJ0KHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICghc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSB7XG4gICAgICAgICAgICBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgICBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBudWxsO1xuICAgICAgICAgICAgICBkZWxldGUgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kO1xuICAgICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNsaWRlVG9Mb29wKGluZGV4ID0gMCwgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZCwgcnVuQ2FsbGJhY2tzID0gdHJ1ZSwgaW50ZXJuYWwpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBsZXQgbmV3SW5kZXggPSBpbmRleDtcblxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICBuZXdJbmRleCArPSBzd2lwZXIubG9vcGVkU2xpZGVzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3dpcGVyLnNsaWRlVG8obmV3SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbiAgICBmdW5jdGlvbiBzbGlkZU5leHQoc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZCwgcnVuQ2FsbGJhY2tzID0gdHJ1ZSwgaW50ZXJuYWwpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuaW1hdGluZyxcbiAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgcGFyYW1zXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm4gc3dpcGVyO1xuICAgICAgbGV0IHBlckdyb3VwID0gcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuXG4gICAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDEgJiYgcGFyYW1zLnNsaWRlc1Blckdyb3VwQXV0bykge1xuICAgICAgICBwZXJHcm91cCA9IE1hdGgubWF4KHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygnY3VycmVudCcsIHRydWUpLCAxKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5jcmVtZW50ID0gc3dpcGVyLmFjdGl2ZUluZGV4IDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBwZXJHcm91cDtcblxuICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgIGlmIChhbmltYXRpbmcgJiYgcGFyYW1zLmxvb3BQcmV2ZW50c1NsaWRlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN3aXBlci5sb29wRml4KCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gICAgICAgIHN3aXBlci5fY2xpZW50TGVmdCA9IHN3aXBlci4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBpbmNyZW1lbnQsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbiAgICBmdW5jdGlvbiBzbGlkZVByZXYoc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZCwgcnVuQ2FsbGJhY2tzID0gdHJ1ZSwgaW50ZXJuYWwpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgYW5pbWF0aW5nLFxuICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgc2xpZGVzR3JpZCxcbiAgICAgICAgcnRsVHJhbnNsYXRlLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm4gc3dpcGVyO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgaWYgKGFuaW1hdGluZyAmJiBwYXJhbXMubG9vcFByZXZlbnRzU2xpZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhbnNsYXRlID0gcnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuXG4gICAgICBmdW5jdGlvbiBub3JtYWxpemUodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPCAwKSByZXR1cm4gLU1hdGguZmxvb3IoTWF0aC5hYnModmFsKSk7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUcmFuc2xhdGUgPSBub3JtYWxpemUodHJhbnNsYXRlKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTbmFwR3JpZCA9IHNuYXBHcmlkLm1hcCh2YWwgPT4gbm9ybWFsaXplKHZhbCkpO1xuICAgICAgbGV0IHByZXZTbmFwID0gc25hcEdyaWRbbm9ybWFsaXplZFNuYXBHcmlkLmluZGV4T2Yobm9ybWFsaXplZFRyYW5zbGF0ZSkgLSAxXTtcblxuICAgICAgaWYgKHR5cGVvZiBwcmV2U25hcCA9PT0gJ3VuZGVmaW5lZCcgJiYgcGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgbGV0IHByZXZTbmFwSW5kZXg7XG4gICAgICAgIHNuYXBHcmlkLmZvckVhY2goKHNuYXAsIHNuYXBJbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IHNuYXApIHtcbiAgICAgICAgICAgIC8vIHByZXZTbmFwID0gc25hcDtcbiAgICAgICAgICAgIHByZXZTbmFwSW5kZXggPSBzbmFwSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodHlwZW9mIHByZXZTbmFwSW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcHJldlNuYXAgPSBzbmFwR3JpZFtwcmV2U25hcEluZGV4ID4gMCA/IHByZXZTbmFwSW5kZXggLSAxIDogcHJldlNuYXBJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHByZXZJbmRleCA9IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJldlNuYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByZXZJbmRleCA9IHNsaWRlc0dyaWQuaW5kZXhPZihwcmV2U25hcCk7XG4gICAgICAgIGlmIChwcmV2SW5kZXggPCAwKSBwcmV2SW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggLSAxO1xuXG4gICAgICAgIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXBBdXRvKSB7XG4gICAgICAgICAgcHJldkluZGV4ID0gcHJldkluZGV4IC0gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCdwcmV2aW91cycsIHRydWUpICsgMTtcbiAgICAgICAgICBwcmV2SW5kZXggPSBNYXRoLm1heChwcmV2SW5kZXgsIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbyhwcmV2SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbiAgICBmdW5jdGlvbiBzbGlkZVJlc2V0KHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuICAgIGZ1bmN0aW9uIHNsaWRlVG9DbG9zZXN0KHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsLCB0aHJlc2hvbGQgPSAwLjUpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBsZXQgaW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XG4gICAgICBjb25zdCBza2lwID0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGluZGV4KTtcbiAgICAgIGNvbnN0IHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChpbmRleCAtIHNraXApIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuXG4gICAgICBpZiAodHJhbnNsYXRlID49IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXhdKSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHRyYW5zbGF0ZSBpcyBvbiBvciBhZnRlciB0aGUgY3VycmVudCBzbmFwIGluZGV4LCBzbyB0aGUgY2hvaWNlXG4gICAgICAgIC8vIGlzIGJldHdlZW4gdGhlIGN1cnJlbnQgaW5kZXggYW5kIHRoZSBvbmUgYWZ0ZXIgaXQuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleF07XG4gICAgICAgIGNvbnN0IG5leHRTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleCArIDFdO1xuXG4gICAgICAgIGlmICh0cmFuc2xhdGUgLSBjdXJyZW50U25hcCA+IChuZXh0U25hcCAtIGN1cnJlbnRTbmFwKSAqIHRocmVzaG9sZCkge1xuICAgICAgICAgIGluZGV4ICs9IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHRyYW5zbGF0ZSBpcyBiZWZvcmUgdGhlIGN1cnJlbnQgc25hcCBpbmRleCwgc28gdGhlIGNob2ljZVxuICAgICAgICAvLyBpcyBiZXR3ZWVuIHRoZSBjdXJyZW50IGluZGV4IGFuZCB0aGUgb25lIGJlZm9yZSBpdC5cbiAgICAgICAgY29uc3QgcHJldlNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4IC0gMV07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleF07XG5cbiAgICAgICAgaWYgKHRyYW5zbGF0ZSAtIHByZXZTbmFwIDw9IChjdXJyZW50U25hcCAtIHByZXZTbmFwKSAqIHRocmVzaG9sZCkge1xuICAgICAgICAgIGluZGV4IC09IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCBzd2lwZXIuc2xpZGVzR3JpZC5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbyhpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNsaWRlVG9DbGlja2VkU2xpZGUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgICR3cmFwcGVyRWxcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBjb25zdCBzbGlkZXNQZXJWaWV3ID0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogcGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gICAgICBsZXQgc2xpZGVUb0luZGV4ID0gc3dpcGVyLmNsaWNrZWRJbmRleDtcbiAgICAgIGxldCByZWFsSW5kZXg7XG5cbiAgICAgIGlmIChwYXJhbXMubG9vcCkge1xuICAgICAgICBpZiAoc3dpcGVyLmFuaW1hdGluZykgcmV0dXJuO1xuICAgICAgICByZWFsSW5kZXggPSBwYXJzZUludCgkKHN3aXBlci5jbGlja2VkU2xpZGUpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcblxuICAgICAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgaWYgKHNsaWRlVG9JbmRleCA8IHN3aXBlci5sb29wZWRTbGlkZXMgLSBzbGlkZXNQZXJWaWV3IC8gMiB8fCBzbGlkZVRvSW5kZXggPiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIHN3aXBlci5sb29wZWRTbGlkZXMgKyBzbGlkZXNQZXJWaWV3IC8gMikge1xuICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgIHNsaWRlVG9JbmRleCA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cmVhbEluZGV4fVwiXTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KWApLmVxKDApLmluZGV4KCk7XG4gICAgICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2xpZGVUb0luZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggLSBzbGlkZXNQZXJWaWV3KSB7XG4gICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICBzbGlkZVRvSW5kZXggPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl06bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlgKS5lcSgwKS5pbmRleCgpO1xuICAgICAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2xpZGUgPSB7XG4gICAgICBzbGlkZVRvLFxuICAgICAgc2xpZGVUb0xvb3AsXG4gICAgICBzbGlkZU5leHQsXG4gICAgICBzbGlkZVByZXYsXG4gICAgICBzbGlkZVJlc2V0LFxuICAgICAgc2xpZGVUb0Nsb3Nlc3QsXG4gICAgICBzbGlkZVRvQ2xpY2tlZFNsaWRlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvb3BDcmVhdGUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgICR3cmFwcGVyRWxcbiAgICAgIH0gPSBzd2lwZXI7IC8vIFJlbW92ZSBkdXBsaWNhdGVkIHNsaWRlc1xuXG4gICAgICBjb25zdCAkc2VsZWN0b3IgPSAkKCR3cmFwcGVyRWwuY2hpbGRyZW4oKVswXS5wYXJlbnROb2RlKTtcbiAgICAgICRzZWxlY3Rvci5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9YCkucmVtb3ZlKCk7XG4gICAgICBsZXQgc2xpZGVzID0gJHNlbGVjdG9yLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKTtcblxuICAgICAgaWYgKHBhcmFtcy5sb29wRmlsbEdyb3VwV2l0aEJsYW5rKSB7XG4gICAgICAgIGNvbnN0IGJsYW5rU2xpZGVzTnVtID0gcGFyYW1zLnNsaWRlc1Blckdyb3VwIC0gc2xpZGVzLmxlbmd0aCAlIHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcblxuICAgICAgICBpZiAoYmxhbmtTbGlkZXNOdW0gIT09IHBhcmFtcy5zbGlkZXNQZXJHcm91cCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxhbmtTbGlkZXNOdW07IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgYmxhbmtOb2RlID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkuYWRkQ2xhc3MoYCR7cGFyYW1zLnNsaWRlQ2xhc3N9ICR7cGFyYW1zLnNsaWRlQmxhbmtDbGFzc31gKTtcbiAgICAgICAgICAgICRzZWxlY3Rvci5hcHBlbmQoYmxhbmtOb2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzbGlkZXMgPSAkc2VsZWN0b3IuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmICFwYXJhbXMubG9vcGVkU2xpZGVzKSBwYXJhbXMubG9vcGVkU2xpZGVzID0gc2xpZGVzLmxlbmd0aDtcbiAgICAgIHN3aXBlci5sb29wZWRTbGlkZXMgPSBNYXRoLmNlaWwocGFyc2VGbG9hdChwYXJhbXMubG9vcGVkU2xpZGVzIHx8IHBhcmFtcy5zbGlkZXNQZXJWaWV3LCAxMCkpO1xuICAgICAgc3dpcGVyLmxvb3BlZFNsaWRlcyArPSBwYXJhbXMubG9vcEFkZGl0aW9uYWxTbGlkZXM7XG5cbiAgICAgIGlmIChzd2lwZXIubG9vcGVkU2xpZGVzID4gc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICBzd2lwZXIubG9vcGVkU2xpZGVzID0gc2xpZGVzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJlcGVuZFNsaWRlcyA9IFtdO1xuICAgICAgY29uc3QgYXBwZW5kU2xpZGVzID0gW107XG4gICAgICBzbGlkZXMuZWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHNsaWRlID0gJChlbCk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgc3dpcGVyLmxvb3BlZFNsaWRlcykge1xuICAgICAgICAgIGFwcGVuZFNsaWRlcy5wdXNoKGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IHNsaWRlcy5sZW5ndGggJiYgaW5kZXggPj0gc2xpZGVzLmxlbmd0aCAtIHN3aXBlci5sb29wZWRTbGlkZXMpIHtcbiAgICAgICAgICBwcmVwZW5kU2xpZGVzLnB1c2goZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2xpZGUuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnLCBpbmRleCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcHBlbmRTbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgJHNlbGVjdG9yLmFwcGVuZCgkKGFwcGVuZFNsaWRlc1tpXS5jbG9uZU5vZGUodHJ1ZSkpLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSBwcmVwZW5kU2xpZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICRzZWxlY3Rvci5wcmVwZW5kKCQocHJlcGVuZFNsaWRlc1tpXS5jbG9uZU5vZGUodHJ1ZSkpLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcEZpeCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlTG9vcEZpeCcpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgc2xpZGVzLFxuICAgICAgICBsb29wZWRTbGlkZXMsXG4gICAgICAgIGFsbG93U2xpZGVQcmV2LFxuICAgICAgICBhbGxvd1NsaWRlTmV4dCxcbiAgICAgICAgc25hcEdyaWQsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gdHJ1ZTtcbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG4gICAgICBjb25zdCBzbmFwVHJhbnNsYXRlID0gLXNuYXBHcmlkW2FjdGl2ZUluZGV4XTtcbiAgICAgIGNvbnN0IGRpZmYgPSBzbmFwVHJhbnNsYXRlIC0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpOyAvLyBGaXggRm9yIE5lZ2F0aXZlIE92ZXJzbGlkaW5nXG5cbiAgICAgIGlmIChhY3RpdmVJbmRleCA8IGxvb3BlZFNsaWRlcykge1xuICAgICAgICBuZXdJbmRleCA9IHNsaWRlcy5sZW5ndGggLSBsb29wZWRTbGlkZXMgKiAzICsgYWN0aXZlSW5kZXg7XG4gICAgICAgIG5ld0luZGV4ICs9IGxvb3BlZFNsaWRlcztcbiAgICAgICAgY29uc3Qgc2xpZGVDaGFuZ2VkID0gc3dpcGVyLnNsaWRlVG8obmV3SW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcblxuICAgICAgICBpZiAoc2xpZGVDaGFuZ2VkICYmIGRpZmYgIT09IDApIHtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKChydGwgPyAtc3dpcGVyLnRyYW5zbGF0ZSA6IHN3aXBlci50cmFuc2xhdGUpIC0gZGlmZik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZlSW5kZXggPj0gc2xpZGVzLmxlbmd0aCAtIGxvb3BlZFNsaWRlcykge1xuICAgICAgICAvLyBGaXggRm9yIFBvc2l0aXZlIE92ZXJzbGlkaW5nXG4gICAgICAgIG5ld0luZGV4ID0gLXNsaWRlcy5sZW5ndGggKyBhY3RpdmVJbmRleCArIGxvb3BlZFNsaWRlcztcbiAgICAgICAgbmV3SW5kZXggKz0gbG9vcGVkU2xpZGVzO1xuICAgICAgICBjb25zdCBzbGlkZUNoYW5nZWQgPSBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIGlmIChzbGlkZUNoYW5nZWQgJiYgZGlmZiAhPT0gMCkge1xuICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoKHJ0bCA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZSkgLSBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xuICAgICAgc3dpcGVyLmVtaXQoJ2xvb3BGaXgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wRGVzdHJveSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgc2xpZGVzXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9LC4ke3BhcmFtcy5zbGlkZUNsYXNzfS4ke3BhcmFtcy5zbGlkZUJsYW5rQ2xhc3N9YCkucmVtb3ZlKCk7XG4gICAgICBzbGlkZXMucmVtb3ZlQXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgICB9XG5cbiAgICB2YXIgbG9vcCA9IHtcbiAgICAgIGxvb3BDcmVhdGUsXG4gICAgICBsb29wRml4LFxuICAgICAgbG9vcERlc3Ryb3lcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2V0R3JhYkN1cnNvcihtb3ZpbmcpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnN1cHBvcnQudG91Y2ggfHwgIXN3aXBlci5wYXJhbXMuc2ltdWxhdGVUb3VjaCB8fCBzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmlzTG9ja2VkIHx8IHN3aXBlci5wYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuICAgICAgY29uc3QgZWwgPSBzd2lwZXIucGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID09PSAnY29udGFpbmVyJyA/IHN3aXBlci5lbCA6IHN3aXBlci53cmFwcGVyRWw7XG4gICAgICBlbC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gICAgICBlbC5zdHlsZS5jdXJzb3IgPSBtb3ZpbmcgPyAnLXdlYmtpdC1ncmFiYmluZycgOiAnLXdlYmtpdC1ncmFiJztcbiAgICAgIGVsLnN0eWxlLmN1cnNvciA9IG1vdmluZyA/ICctbW96LWdyYWJiaW4nIDogJy1tb3otZ3JhYic7XG4gICAgICBlbC5zdHlsZS5jdXJzb3IgPSBtb3ZpbmcgPyAnZ3JhYmJpbmcnIDogJ2dyYWInO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuc2V0R3JhYkN1cnNvcigpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICAgIGlmIChzd2lwZXIuc3VwcG9ydC50b3VjaCB8fCBzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmlzTG9ja2VkIHx8IHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXBlcltzd2lwZXIucGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID09PSAnY29udGFpbmVyJyA/ICdlbCcgOiAnd3JhcHBlckVsJ10uc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIGdyYWJDdXJzb3IgPSB7XG4gICAgICBzZXRHcmFiQ3Vyc29yLFxuICAgICAgdW5zZXRHcmFiQ3Vyc29yXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50KHNlbGVjdG9yLCBiYXNlID0gdGhpcykge1xuICAgICAgZnVuY3Rpb24gX19jbG9zZXN0RnJvbShlbCkge1xuICAgICAgICBpZiAoIWVsIHx8IGVsID09PSBnZXREb2N1bWVudCgpIHx8IGVsID09PSBnZXRXaW5kb3coKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChlbC5hc3NpZ25lZFNsb3QpIGVsID0gZWwuYXNzaWduZWRTbG90O1xuICAgICAgICBjb25zdCBmb3VuZCA9IGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZm91bmQgfHwgX19jbG9zZXN0RnJvbShlbC5nZXRSb290Tm9kZSgpLmhvc3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX19jbG9zZXN0RnJvbShiYXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHRvdWNoZXMsXG4gICAgICAgIGVuYWJsZWRcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcblxuICAgICAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMuY3NzTW9kZSAmJiBwYXJhbXMubG9vcCkge1xuICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgZSA9IGV2ZW50O1xuICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgICAgIGxldCAkdGFyZ2V0RWwgPSAkKGUudGFyZ2V0KTtcblxuICAgICAgaWYgKHBhcmFtcy50b3VjaEV2ZW50c1RhcmdldCA9PT0gJ3dyYXBwZXInKSB7XG4gICAgICAgIGlmICghJHRhcmdldEVsLmNsb3Nlc3Qoc3dpcGVyLndyYXBwZXJFbCkubGVuZ3RoKSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEuaXNUb3VjaEV2ZW50ID0gZS50eXBlID09PSAndG91Y2hzdGFydCc7XG4gICAgICBpZiAoIWRhdGEuaXNUb3VjaEV2ZW50ICYmICd3aGljaCcgaW4gZSAmJiBlLndoaWNoID09PSAzKSByZXR1cm47XG4gICAgICBpZiAoIWRhdGEuaXNUb3VjaEV2ZW50ICYmICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gPiAwKSByZXR1cm47XG4gICAgICBpZiAoZGF0YS5pc1RvdWNoZWQgJiYgZGF0YS5pc01vdmVkKSByZXR1cm47IC8vIGNoYW5nZSB0YXJnZXQgZWwgZm9yIHNoYWRvdyByb290IGNvbXBvbmVudFxuXG4gICAgICBjb25zdCBzd2lwaW5nQ2xhc3NIYXNWYWx1ZSA9ICEhcGFyYW1zLm5vU3dpcGluZ0NsYXNzICYmIHBhcmFtcy5ub1N3aXBpbmdDbGFzcyAhPT0gJyc7XG5cbiAgICAgIGlmIChzd2lwaW5nQ2xhc3NIYXNWYWx1ZSAmJiBlLnRhcmdldCAmJiBlLnRhcmdldC5zaGFkb3dSb290ICYmIGV2ZW50LnBhdGggJiYgZXZlbnQucGF0aFswXSkge1xuICAgICAgICAkdGFyZ2V0RWwgPSAkKGV2ZW50LnBhdGhbMF0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub1N3aXBpbmdTZWxlY3RvciA9IHBhcmFtcy5ub1N3aXBpbmdTZWxlY3RvciA/IHBhcmFtcy5ub1N3aXBpbmdTZWxlY3RvciA6IGAuJHtwYXJhbXMubm9Td2lwaW5nQ2xhc3N9YDtcbiAgICAgIGNvbnN0IGlzVGFyZ2V0U2hhZG93ID0gISEoZS50YXJnZXQgJiYgZS50YXJnZXQuc2hhZG93Um9vdCk7IC8vIHVzZSBjbG9zZXN0RWxlbWVudCBmb3Igc2hhZG93IHJvb3QgZWxlbWVudCB0byBnZXQgdGhlIGFjdHVhbCBjbG9zZXN0IGZvciBuZXN0ZWQgc2hhZG93IHJvb3QgZWxlbWVudFxuXG4gICAgICBpZiAocGFyYW1zLm5vU3dpcGluZyAmJiAoaXNUYXJnZXRTaGFkb3cgPyBjbG9zZXN0RWxlbWVudChub1N3aXBpbmdTZWxlY3RvciwgZS50YXJnZXQpIDogJHRhcmdldEVsLmNsb3Nlc3Qobm9Td2lwaW5nU2VsZWN0b3IpWzBdKSkge1xuICAgICAgICBzd2lwZXIuYWxsb3dDbGljayA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5zd2lwZUhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCEkdGFyZ2V0RWwuY2xvc2VzdChwYXJhbXMuc3dpcGVIYW5kbGVyKVswXSkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b3VjaGVzLmN1cnJlbnRYID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgdG91Y2hlcy5jdXJyZW50WSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICAgIGNvbnN0IHN0YXJ0WCA9IHRvdWNoZXMuY3VycmVudFg7XG4gICAgICBjb25zdCBzdGFydFkgPSB0b3VjaGVzLmN1cnJlbnRZOyAvLyBEbyBOT1Qgc3RhcnQgaWYgaU9TIGVkZ2Ugc3dpcGUgaXMgZGV0ZWN0ZWQuIE90aGVyd2lzZSBpT1MgYXBwIGNhbm5vdCBzd2lwZS10by1nby1iYWNrIGFueW1vcmVcblxuICAgICAgY29uc3QgZWRnZVN3aXBlRGV0ZWN0aW9uID0gcGFyYW1zLmVkZ2VTd2lwZURldGVjdGlvbiB8fCBwYXJhbXMuaU9TRWRnZVN3aXBlRGV0ZWN0aW9uO1xuICAgICAgY29uc3QgZWRnZVN3aXBlVGhyZXNob2xkID0gcGFyYW1zLmVkZ2VTd2lwZVRocmVzaG9sZCB8fCBwYXJhbXMuaU9TRWRnZVN3aXBlVGhyZXNob2xkO1xuXG4gICAgICBpZiAoZWRnZVN3aXBlRGV0ZWN0aW9uICYmIChzdGFydFggPD0gZWRnZVN3aXBlVGhyZXNob2xkIHx8IHN0YXJ0WCA+PSB3aW5kb3cuaW5uZXJXaWR0aCAtIGVkZ2VTd2lwZVRocmVzaG9sZCkpIHtcbiAgICAgICAgaWYgKGVkZ2VTd2lwZURldGVjdGlvbiA9PT0gJ3ByZXZlbnQnKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICAgIGlzVG91Y2hlZDogdHJ1ZSxcbiAgICAgICAgaXNNb3ZlZDogZmFsc2UsXG4gICAgICAgIGFsbG93VG91Y2hDYWxsYmFja3M6IHRydWUsXG4gICAgICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0TW92aW5nOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgdG91Y2hlcy5zdGFydFggPSBzdGFydFg7XG4gICAgICB0b3VjaGVzLnN0YXJ0WSA9IHN0YXJ0WTtcbiAgICAgIGRhdGEudG91Y2hTdGFydFRpbWUgPSBub3coKTtcbiAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgIHN3aXBlci51cGRhdGVTaXplKCk7XG4gICAgICBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gZmFsc2U7XG5cbiAgICAgIGlmIChlLnR5cGUgIT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICBsZXQgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICBpZiAoJHRhcmdldEVsLmlzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpKSBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuaXMoZGF0YS5mb2N1c2FibGVFbGVtZW50cykgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gJHRhcmdldEVsWzBdKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaG91bGRQcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0ICYmIHN3aXBlci5hbGxvd1RvdWNoTW92ZSAmJiBwYXJhbXMudG91Y2hTdGFydFByZXZlbnREZWZhdWx0O1xuXG4gICAgICAgIGlmICgocGFyYW1zLnRvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0IHx8IHNob3VsZFByZXZlbnREZWZhdWx0KSAmJiAhJHRhcmdldEVsWzBdLmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KCd0b3VjaFN0YXJ0JywgZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB0b3VjaGVzLFxuICAgICAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICAgICAgZW5hYmxlZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgbGV0IGUgPSBldmVudDtcbiAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgIGlmICghZGF0YS5pc1RvdWNoZWQpIHtcbiAgICAgICAgaWYgKGRhdGEuc3RhcnRNb3ZpbmcgJiYgZGF0YS5pc1Njcm9sbGluZykge1xuICAgICAgICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5pc1RvdWNoRXZlbnQgJiYgZS50eXBlICE9PSAndG91Y2htb3ZlJykgcmV0dXJuO1xuICAgICAgY29uc3QgdGFyZ2V0VG91Y2ggPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnICYmIGUudGFyZ2V0VG91Y2hlcyAmJiAoZS50YXJnZXRUb3VjaGVzWzBdIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgY29uc3QgcGFnZVggPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gdGFyZ2V0VG91Y2gucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgY29uc3QgcGFnZVkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gdGFyZ2V0VG91Y2gucGFnZVkgOiBlLnBhZ2VZO1xuXG4gICAgICBpZiAoZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcikge1xuICAgICAgICB0b3VjaGVzLnN0YXJ0WCA9IHBhZ2VYO1xuICAgICAgICB0b3VjaGVzLnN0YXJ0WSA9IHBhZ2VZO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghc3dpcGVyLmFsbG93VG91Y2hNb3ZlKSB7XG4gICAgICAgIC8vIGlzTW92ZWQgPSB0cnVlO1xuICAgICAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChkYXRhLmlzVG91Y2hlZCkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odG91Y2hlcywge1xuICAgICAgICAgICAgc3RhcnRYOiBwYWdlWCxcbiAgICAgICAgICAgIHN0YXJ0WTogcGFnZVksXG4gICAgICAgICAgICBjdXJyZW50WDogcGFnZVgsXG4gICAgICAgICAgICBjdXJyZW50WTogcGFnZVlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYXRhLnRvdWNoU3RhcnRUaW1lID0gbm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBwYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcyAmJiAhcGFyYW1zLmxvb3ApIHtcbiAgICAgICAgaWYgKHN3aXBlci5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgICAgICAvLyBWZXJ0aWNhbFxuICAgICAgICAgIGlmIChwYWdlWSA8IHRvdWNoZXMuc3RhcnRZICYmIHN3aXBlci50cmFuc2xhdGUgPD0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIHx8IHBhZ2VZID4gdG91Y2hlcy5zdGFydFkgJiYgc3dpcGVyLnRyYW5zbGF0ZSA+PSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcbiAgICAgICAgICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFnZVggPCB0b3VjaGVzLnN0YXJ0WCAmJiBzd2lwZXIudHJhbnNsYXRlIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSB8fCBwYWdlWCA+IHRvdWNoZXMuc3RhcnRYICYmIHN3aXBlci50cmFuc2xhdGUgPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAkKGUudGFyZ2V0KS5pcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSkge1xuICAgICAgICAgIGRhdGEuaXNNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgICAgICBzd2lwZXIuZW1pdCgndG91Y2hNb3ZlJywgZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHJldHVybjtcbiAgICAgIHRvdWNoZXMuY3VycmVudFggPSBwYWdlWDtcbiAgICAgIHRvdWNoZXMuY3VycmVudFkgPSBwYWdlWTtcbiAgICAgIGNvbnN0IGRpZmZYID0gdG91Y2hlcy5jdXJyZW50WCAtIHRvdWNoZXMuc3RhcnRYO1xuICAgICAgY29uc3QgZGlmZlkgPSB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy50aHJlc2hvbGQgJiYgTWF0aC5zcXJ0KGRpZmZYICoqIDIgKyBkaWZmWSAqKiAyKSA8IHN3aXBlci5wYXJhbXMudGhyZXNob2xkKSByZXR1cm47XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YS5pc1Njcm9sbGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV0IHRvdWNoQW5nbGU7XG5cbiAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSAmJiB0b3VjaGVzLmN1cnJlbnRZID09PSB0b3VjaGVzLnN0YXJ0WSB8fCBzd2lwZXIuaXNWZXJ0aWNhbCgpICYmIHRvdWNoZXMuY3VycmVudFggPT09IHRvdWNoZXMuc3RhcnRYKSB7XG4gICAgICAgICAgZGF0YS5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgIGlmIChkaWZmWCAqIGRpZmZYICsgZGlmZlkgKiBkaWZmWSA+PSAyNSkge1xuICAgICAgICAgICAgdG91Y2hBbmdsZSA9IE1hdGguYXRhbjIoTWF0aC5hYnMoZGlmZlkpLCBNYXRoLmFicyhkaWZmWCkpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgICAgIGRhdGEuaXNTY3JvbGxpbmcgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaEFuZ2xlID4gcGFyYW1zLnRvdWNoQW5nbGUgOiA5MCAtIHRvdWNoQW5nbGUgPiBwYXJhbXMudG91Y2hBbmdsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZU9wcG9zaXRlJywgZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YS5zdGFydE1vdmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHRvdWNoZXMuY3VycmVudFggIT09IHRvdWNoZXMuc3RhcnRYIHx8IHRvdWNoZXMuY3VycmVudFkgIT09IHRvdWNoZXMuc3RhcnRZKSB7XG4gICAgICAgICAgZGF0YS5zdGFydE1vdmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEuc3RhcnRNb3ZpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xuXG4gICAgICBpZiAoIXBhcmFtcy5jc3NNb2RlICYmIGUuY2FuY2VsYWJsZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMudG91Y2hNb3ZlU3RvcFByb3BhZ2F0aW9uICYmICFwYXJhbXMubmVzdGVkKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YS5pc01vdmVkKSB7XG4gICAgICAgIGlmIChwYXJhbXMubG9vcCAmJiAhcGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5zdGFydFRyYW5zbGF0ZSA9IHN3aXBlci5nZXRUcmFuc2xhdGUoKTtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC50cmlnZ2VyKCd3ZWJraXRUcmFuc2l0aW9uRW5kIHRyYW5zaXRpb25lbmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuYWxsb3dNb21lbnR1bUJvdW5jZSA9IGZhbHNlOyAvLyBHcmFiIEN1cnNvclxuXG4gICAgICAgIGlmIChwYXJhbXMuZ3JhYkN1cnNvciAmJiAoc3dpcGVyLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlIHx8IHN3aXBlci5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcih0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5lbWl0KCdzbGlkZXJGaXJzdE1vdmUnLCBlKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXQoJ3NsaWRlck1vdmUnLCBlKTtcbiAgICAgIGRhdGEuaXNNb3ZlZCA9IHRydWU7XG4gICAgICBsZXQgZGlmZiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IGRpZmZYIDogZGlmZlk7XG4gICAgICB0b3VjaGVzLmRpZmYgPSBkaWZmO1xuICAgICAgZGlmZiAqPSBwYXJhbXMudG91Y2hSYXRpbztcbiAgICAgIGlmIChydGwpIGRpZmYgPSAtZGlmZjtcbiAgICAgIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9IGRpZmYgPiAwID8gJ3ByZXYnIDogJ25leHQnO1xuICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGlmZiArIGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICBsZXQgZGlzYWJsZVBhcmVudFN3aXBlciA9IHRydWU7XG4gICAgICBsZXQgcmVzaXN0YW5jZVJhdGlvID0gcGFyYW1zLnJlc2lzdGFuY2VSYXRpbztcblxuICAgICAgaWYgKHBhcmFtcy50b3VjaFJlbGVhc2VPbkVkZ2VzKSB7XG4gICAgICAgIHJlc2lzdGFuY2VSYXRpbyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmID4gMCAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPiBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcbiAgICAgICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgICAgICBpZiAocGFyYW1zLnJlc2lzdGFuY2UpIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci5taW5UcmFuc2xhdGUoKSAtIDEgKyAoLXN3aXBlci5taW5UcmFuc2xhdGUoKSArIGRhdGEuc3RhcnRUcmFuc2xhdGUgKyBkaWZmKSAqKiByZXNpc3RhbmNlUmF0aW87XG4gICAgICB9IGVsc2UgaWYgKGRpZmYgPCAwICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xuICAgICAgICBkaXNhYmxlUGFyZW50U3dpcGVyID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpICsgMSAtIChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBkYXRhLnN0YXJ0VHJhbnNsYXRlIC0gZGlmZikgKiogcmVzaXN0YW5jZVJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlzYWJsZVBhcmVudFN3aXBlcikge1xuICAgICAgICBlLnByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyID0gdHJ1ZTtcbiAgICAgIH0gLy8gRGlyZWN0aW9ucyBsb2Nrc1xuXG5cbiAgICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAncHJldicgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlID4gZGF0YS5zdGFydFRyYW5zbGF0ZSkge1xuICAgICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlUHJldiAmJiAhc3dpcGVyLmFsbG93U2xpZGVOZXh0KSB7XG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICB9IC8vIFRocmVzaG9sZFxuXG5cbiAgICAgIGlmIChwYXJhbXMudGhyZXNob2xkID4gMCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZikgPiBwYXJhbXMudGhyZXNob2xkIHx8IGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlKSB7XG4gICAgICAgICAgaWYgKCFkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xuICAgICAgICAgICAgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgdG91Y2hlcy5zdGFydFggPSB0b3VjaGVzLmN1cnJlbnRYO1xuICAgICAgICAgICAgdG91Y2hlcy5zdGFydFkgPSB0b3VjaGVzLmN1cnJlbnRZO1xuICAgICAgICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgICAgICAgICAgIHRvdWNoZXMuZGlmZiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHRvdWNoZXMuY3VycmVudFggLSB0b3VjaGVzLnN0YXJ0WCA6IHRvdWNoZXMuY3VycmVudFkgLSB0b3VjaGVzLnN0YXJ0WTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMuZm9sbG93RmluZ2VyIHx8IHBhcmFtcy5jc3NNb2RlKSByZXR1cm47IC8vIFVwZGF0ZSBhY3RpdmUgaW5kZXggaW4gZnJlZSBtb2RlXG5cbiAgICAgIGlmIChwYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgc3dpcGVyLmZyZWVNb2RlIHx8IHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzKSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiBzd2lwZXIuZnJlZU1vZGUpIHtcbiAgICAgICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hNb3ZlKCk7XG4gICAgICB9IC8vIFVwZGF0ZSBwcm9ncmVzc1xuXG5cbiAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhkYXRhLmN1cnJlbnRUcmFuc2xhdGUpOyAvLyBVcGRhdGUgdHJhbnNsYXRlXG5cbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRvdWNoRW5kKGV2ZW50KSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgZGF0YSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGE7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgdG91Y2hlcyxcbiAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgIHNsaWRlc0dyaWQsXG4gICAgICAgIGVuYWJsZWRcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICAgIGxldCBlID0gZXZlbnQ7XG4gICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAoZGF0YS5hbGxvd1RvdWNoQ2FsbGJhY2tzKSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCd0b3VjaEVuZCcsIGUpO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmFsbG93VG91Y2hDYWxsYmFja3MgPSBmYWxzZTtcblxuICAgICAgaWYgKCFkYXRhLmlzVG91Y2hlZCkge1xuICAgICAgICBpZiAoZGF0YS5pc01vdmVkICYmIHBhcmFtcy5ncmFiQ3Vyc29yKSB7XG4gICAgICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICAgIGRhdGEuc3RhcnRNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBSZXR1cm4gR3JhYiBDdXJzb3JcblxuXG4gICAgICBpZiAocGFyYW1zLmdyYWJDdXJzb3IgJiYgZGF0YS5pc01vdmVkICYmIGRhdGEuaXNUb3VjaGVkICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xuICAgICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcihmYWxzZSk7XG4gICAgICB9IC8vIFRpbWUgZGlmZlxuXG5cbiAgICAgIGNvbnN0IHRvdWNoRW5kVGltZSA9IG5vdygpO1xuICAgICAgY29uc3QgdGltZURpZmYgPSB0b3VjaEVuZFRpbWUgLSBkYXRhLnRvdWNoU3RhcnRUaW1lOyAvLyBUYXAsIGRvdWJsZVRhcCwgQ2xpY2tcblxuICAgICAgaWYgKHN3aXBlci5hbGxvd0NsaWNrKSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVDbGlja2VkU2xpZGUoZSk7XG4gICAgICAgIHN3aXBlci5lbWl0KCd0YXAgY2xpY2snLCBlKTtcblxuICAgICAgICBpZiAodGltZURpZmYgPCAzMDAgJiYgdG91Y2hFbmRUaW1lIC0gZGF0YS5sYXN0Q2xpY2tUaW1lIDwgMzAwKSB7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2RvdWJsZVRhcCBkb3VibGVDbGljaycsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRhdGEubGFzdENsaWNrVGltZSA9IG5vdygpO1xuICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5kZXN0cm95ZWQpIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWRhdGEuaXNUb3VjaGVkIHx8ICFkYXRhLmlzTW92ZWQgfHwgIXN3aXBlci5zd2lwZURpcmVjdGlvbiB8fCB0b3VjaGVzLmRpZmYgPT09IDAgfHwgZGF0YS5jdXJyZW50VHJhbnNsYXRlID09PSBkYXRhLnN0YXJ0VHJhbnNsYXRlKSB7XG4gICAgICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuICAgICAgbGV0IGN1cnJlbnRQb3M7XG5cbiAgICAgIGlmIChwYXJhbXMuZm9sbG93RmluZ2VyKSB7XG4gICAgICAgIGN1cnJlbnRQb3MgPSBydGwgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UG9zID0gLWRhdGEuY3VycmVudFRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hFbmQoe1xuICAgICAgICAgIGN1cnJlbnRQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRmluZCBjdXJyZW50IHNsaWRlXG5cblxuICAgICAgbGV0IHN0b3BJbmRleCA9IDA7XG4gICAgICBsZXQgZ3JvdXBTaXplID0gc3dpcGVyLnNsaWRlc1NpemVzR3JpZFswXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSBpIDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBwYXJhbXMuc2xpZGVzUGVyR3JvdXApIHtcbiAgICAgICAgY29uc3QgaW5jcmVtZW50ID0gaSA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgLSAxID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcblxuICAgICAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIGluY3JlbWVudF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRQb3MgPj0gc2xpZGVzR3JpZFtpXSAmJiBjdXJyZW50UG9zIDwgc2xpZGVzR3JpZFtpICsgaW5jcmVtZW50XSkge1xuICAgICAgICAgICAgc3RvcEluZGV4ID0gaTtcbiAgICAgICAgICAgIGdyb3VwU2l6ZSA9IHNsaWRlc0dyaWRbaSArIGluY3JlbWVudF0gLSBzbGlkZXNHcmlkW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0pIHtcbiAgICAgICAgICBzdG9wSW5kZXggPSBpO1xuICAgICAgICAgIGdyb3VwU2l6ZSA9IHNsaWRlc0dyaWRbc2xpZGVzR3JpZC5sZW5ndGggLSAxXSAtIHNsaWRlc0dyaWRbc2xpZGVzR3JpZC5sZW5ndGggLSAyXTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBGaW5kIGN1cnJlbnQgc2xpZGUgc2l6ZVxuXG5cbiAgICAgIGNvbnN0IHJhdGlvID0gKGN1cnJlbnRQb3MgLSBzbGlkZXNHcmlkW3N0b3BJbmRleF0pIC8gZ3JvdXBTaXplO1xuICAgICAgY29uc3QgaW5jcmVtZW50ID0gc3RvcEluZGV4IDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCAtIDEgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuXG4gICAgICBpZiAodGltZURpZmYgPiBwYXJhbXMubG9uZ1N3aXBlc01zKSB7XG4gICAgICAgIC8vIExvbmcgdG91Y2hlc1xuICAgICAgICBpZiAoIXBhcmFtcy5sb25nU3dpcGVzKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAnbmV4dCcpIHtcbiAgICAgICAgICBpZiAocmF0aW8gPj0gcGFyYW1zLmxvbmdTd2lwZXNSYXRpbykgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgaW5jcmVtZW50KTtlbHNlIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAncHJldicpIHtcbiAgICAgICAgICBpZiAocmF0aW8gPiAxIC0gcGFyYW1zLmxvbmdTd2lwZXNSYXRpbykgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgaW5jcmVtZW50KTtlbHNlIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNob3J0IHN3aXBlc1xuICAgICAgICBpZiAoIXBhcmFtcy5zaG9ydFN3aXBlcykge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNOYXZCdXR0b25UYXJnZXQgPSBzd2lwZXIubmF2aWdhdGlvbiAmJiAoZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCB8fCBlLnRhcmdldCA9PT0gc3dpcGVyLm5hdmlnYXRpb24ucHJldkVsKTtcblxuICAgICAgICBpZiAoIWlzTmF2QnV0dG9uVGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXggKyBpbmNyZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBlbFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmIChlbCAmJiBlbC5vZmZzZXRXaWR0aCA9PT0gMCkgcmV0dXJuOyAvLyBCcmVha3BvaW50c1xuXG4gICAgICBpZiAocGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICAgIHN3aXBlci5zZXRCcmVha3BvaW50KCk7XG4gICAgICB9IC8vIFNhdmUgbG9ja3NcblxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93U2xpZGVOZXh0LFxuICAgICAgICBhbGxvd1NsaWRlUHJldixcbiAgICAgICAgc25hcEdyaWRcbiAgICAgIH0gPSBzd2lwZXI7IC8vIERpc2FibGUgbG9ja3Mgb24gcmVzaXplXG5cbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG4gICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSB0cnVlO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG5cbiAgICAgIGlmICgocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkge1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkucnVuKCk7XG4gICAgICB9IC8vIFJldHVybiBsb2NrcyBhZnRlciByZXNpemVcblxuXG4gICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHNuYXBHcmlkICE9PSBzd2lwZXIuc25hcEdyaWQpIHtcbiAgICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghc3dpcGVyLmFsbG93Q2xpY2spIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMucHJldmVudENsaWNrcykgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbiAmJiBzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3cmFwcGVyRWwsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZSxcbiAgICAgICAgZW5hYmxlZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgc3dpcGVyLnByZXZpb3VzVHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcblxuICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICBzd2lwZXIudHJhbnNsYXRlID0gLXdyYXBwZXJFbC5zY3JvbGxMZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnRyYW5zbGF0ZSA9IC13cmFwcGVyRWwuc2Nyb2xsVG9wO1xuICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuXG4gICAgICBpZiAoc3dpcGVyLnRyYW5zbGF0ZSA9PT0gLTApIHN3aXBlci50cmFuc2xhdGUgPSAwO1xuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgICAgbGV0IG5ld1Byb2dyZXNzO1xuICAgICAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG5cbiAgICAgIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgICAgICBuZXdQcm9ncmVzcyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdQcm9ncmVzcyA9IChzd2lwZXIudHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3UHJvZ3Jlc3MgIT09IHN3aXBlci5wcm9ncmVzcykge1xuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MocnRsVHJhbnNsYXRlID8gLXN3aXBlci50cmFuc2xhdGUgOiBzd2lwZXIudHJhbnNsYXRlKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXQoJ3NldFRyYW5zbGF0ZScsIHN3aXBlci50cmFuc2xhdGUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBsZXQgZHVtbXlFdmVudEF0dGFjaGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBkdW1teUV2ZW50TGlzdGVuZXIoKSB7fVxuXG4gICAgY29uc3QgZXZlbnRzID0gKHN3aXBlciwgbWV0aG9kKSA9PiB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgdG91Y2hFdmVudHMsXG4gICAgICAgIGVsLFxuICAgICAgICB3cmFwcGVyRWwsXG4gICAgICAgIGRldmljZSxcbiAgICAgICAgc3VwcG9ydFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGNvbnN0IGNhcHR1cmUgPSAhIXBhcmFtcy5uZXN0ZWQ7XG4gICAgICBjb25zdCBkb21NZXRob2QgPSBtZXRob2QgPT09ICdvbicgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgICBjb25zdCBzd2lwZXJNZXRob2QgPSBtZXRob2Q7IC8vIFRvdWNoIEV2ZW50c1xuXG4gICAgICBpZiAoIXN1cHBvcnQudG91Y2gpIHtcbiAgICAgICAgZWxbZG9tTWV0aG9kXSh0b3VjaEV2ZW50cy5zdGFydCwgc3dpcGVyLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudFtkb21NZXRob2RdKHRvdWNoRXZlbnRzLm1vdmUsIHN3aXBlci5vblRvdWNoTW92ZSwgY2FwdHVyZSk7XG4gICAgICAgIGRvY3VtZW50W2RvbU1ldGhvZF0odG91Y2hFdmVudHMuZW5kLCBzd2lwZXIub25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGFzc2l2ZUxpc3RlbmVyID0gdG91Y2hFdmVudHMuc3RhcnQgPT09ICd0b3VjaHN0YXJ0JyAmJiBzdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHtcbiAgICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgZWxbZG9tTWV0aG9kXSh0b3VjaEV2ZW50cy5zdGFydCwgc3dpcGVyLm9uVG91Y2hTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgZWxbZG9tTWV0aG9kXSh0b3VjaEV2ZW50cy5tb3ZlLCBzd2lwZXIub25Ub3VjaE1vdmUsIHN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyID8ge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmVcbiAgICAgICAgfSA6IGNhcHR1cmUpO1xuICAgICAgICBlbFtkb21NZXRob2RdKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLm9uVG91Y2hFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKHRvdWNoRXZlbnRzLmNhbmNlbCkge1xuICAgICAgICAgIGVsW2RvbU1ldGhvZF0odG91Y2hFdmVudHMuY2FuY2VsLCBzd2lwZXIub25Ub3VjaEVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBQcmV2ZW50IExpbmtzIENsaWNrc1xuXG5cbiAgICAgIGlmIChwYXJhbXMucHJldmVudENsaWNrcyB8fCBwYXJhbXMucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uKSB7XG4gICAgICAgIGVsW2RvbU1ldGhvZF0oJ2NsaWNrJywgc3dpcGVyLm9uQ2xpY2ssIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgd3JhcHBlckVsW2RvbU1ldGhvZF0oJ3Njcm9sbCcsIHN3aXBlci5vblNjcm9sbCk7XG4gICAgICB9IC8vIFJlc2l6ZSBoYW5kbGVyXG5cblxuICAgICAgaWYgKHBhcmFtcy51cGRhdGVPbldpbmRvd1Jlc2l6ZSkge1xuICAgICAgICBzd2lwZXJbc3dpcGVyTWV0aG9kXShkZXZpY2UuaW9zIHx8IGRldmljZS5hbmRyb2lkID8gJ3Jlc2l6ZSBvcmllbnRhdGlvbmNoYW5nZSBvYnNlcnZlclVwZGF0ZScgOiAncmVzaXplIG9ic2VydmVyVXBkYXRlJywgb25SZXNpemUsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyW3N3aXBlck1ldGhvZF0oJ29ic2VydmVyVXBkYXRlJywgb25SZXNpemUsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHN1cHBvcnRcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBzd2lwZXIub25Ub3VjaFN0YXJ0ID0gb25Ub3VjaFN0YXJ0LmJpbmQoc3dpcGVyKTtcbiAgICAgIHN3aXBlci5vblRvdWNoTW92ZSA9IG9uVG91Y2hNb3ZlLmJpbmQoc3dpcGVyKTtcbiAgICAgIHN3aXBlci5vblRvdWNoRW5kID0gb25Ub3VjaEVuZC5iaW5kKHN3aXBlcik7XG5cbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICBzd2lwZXIub25TY3JvbGwgPSBvblNjcm9sbC5iaW5kKHN3aXBlcik7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5vbkNsaWNrID0gb25DbGljay5iaW5kKHN3aXBlcik7XG5cbiAgICAgIGlmIChzdXBwb3J0LnRvdWNoICYmICFkdW1teUV2ZW50QXR0YWNoZWQpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGR1bW15RXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIGR1bW15RXZlbnRBdHRhY2hlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cyhzd2lwZXIsICdvbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGFjaEV2ZW50cygpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBldmVudHMoc3dpcGVyLCAnb2ZmJyk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cyQxID0ge1xuICAgICAgYXR0YWNoRXZlbnRzLFxuICAgICAgZGV0YWNoRXZlbnRzXG4gICAgfTtcblxuICAgIGNvbnN0IGlzR3JpZEVuYWJsZWQgPSAoc3dpcGVyLCBwYXJhbXMpID0+IHtcbiAgICAgIHJldHVybiBzd2lwZXIuZ3JpZCAmJiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2V0QnJlYWtwb2ludCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICBpbml0aWFsaXplZCxcbiAgICAgICAgbG9vcGVkU2xpZGVzID0gMCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAkZWxcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBjb25zdCBicmVha3BvaW50cyA9IHBhcmFtcy5icmVha3BvaW50cztcbiAgICAgIGlmICghYnJlYWtwb2ludHMgfHwgYnJlYWtwb2ludHMgJiYgT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBHZXQgYnJlYWtwb2ludCBmb3Igd2luZG93IHdpZHRoIGFuZCB1cGRhdGUgcGFyYW1ldGVyc1xuXG4gICAgICBjb25zdCBicmVha3BvaW50ID0gc3dpcGVyLmdldEJyZWFrcG9pbnQoYnJlYWtwb2ludHMsIHN3aXBlci5wYXJhbXMuYnJlYWtwb2ludHNCYXNlLCBzd2lwZXIuZWwpO1xuICAgICAgaWYgKCFicmVha3BvaW50IHx8IHN3aXBlci5jdXJyZW50QnJlYWtwb2ludCA9PT0gYnJlYWtwb2ludCkgcmV0dXJuO1xuICAgICAgY29uc3QgYnJlYWtwb2ludE9ubHlQYXJhbXMgPSBicmVha3BvaW50IGluIGJyZWFrcG9pbnRzID8gYnJlYWtwb2ludHNbYnJlYWtwb2ludF0gOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBicmVha3BvaW50UGFyYW1zID0gYnJlYWtwb2ludE9ubHlQYXJhbXMgfHwgc3dpcGVyLm9yaWdpbmFsUGFyYW1zO1xuICAgICAgY29uc3Qgd2FzTXVsdGlSb3cgPSBpc0dyaWRFbmFibGVkKHN3aXBlciwgcGFyYW1zKTtcbiAgICAgIGNvbnN0IGlzTXVsdGlSb3cgPSBpc0dyaWRFbmFibGVkKHN3aXBlciwgYnJlYWtwb2ludFBhcmFtcyk7XG4gICAgICBjb25zdCB3YXNFbmFibGVkID0gcGFyYW1zLmVuYWJsZWQ7XG5cbiAgICAgIGlmICh3YXNNdWx0aVJvdyAmJiAhaXNNdWx0aVJvdykge1xuICAgICAgICAkZWwucmVtb3ZlQ2xhc3MoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZCAke3BhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWQtY29sdW1uYCk7XG4gICAgICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICAgICAgfSBlbHNlIGlmICghd2FzTXVsdGlSb3cgJiYgaXNNdWx0aVJvdykge1xuICAgICAgICAkZWwuYWRkQ2xhc3MoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZGApO1xuXG4gICAgICAgIGlmIChicmVha3BvaW50UGFyYW1zLmdyaWQuZmlsbCAmJiBicmVha3BvaW50UGFyYW1zLmdyaWQuZmlsbCA9PT0gJ2NvbHVtbicgfHwgIWJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsICYmIHBhcmFtcy5ncmlkLmZpbGwgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKGAke3BhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWQtY29sdW1uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlyZWN0aW9uQ2hhbmdlZCA9IGJyZWFrcG9pbnRQYXJhbXMuZGlyZWN0aW9uICYmIGJyZWFrcG9pbnRQYXJhbXMuZGlyZWN0aW9uICE9PSBwYXJhbXMuZGlyZWN0aW9uO1xuICAgICAgY29uc3QgbmVlZHNSZUxvb3AgPSBwYXJhbXMubG9vcCAmJiAoYnJlYWtwb2ludFBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSBwYXJhbXMuc2xpZGVzUGVyVmlldyB8fCBkaXJlY3Rpb25DaGFuZ2VkKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbkNoYW5nZWQgJiYgaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgc3dpcGVyLmNoYW5nZURpcmVjdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBleHRlbmQoc3dpcGVyLnBhcmFtcywgYnJlYWtwb2ludFBhcmFtcyk7XG4gICAgICBjb25zdCBpc0VuYWJsZWQgPSBzd2lwZXIucGFyYW1zLmVuYWJsZWQ7XG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICAgICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgICAgIGFsbG93U2xpZGVQcmV2OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVQcmV2XG4gICAgICB9KTtcblxuICAgICAgaWYgKHdhc0VuYWJsZWQgJiYgIWlzRW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuZGlzYWJsZSgpO1xuICAgICAgfSBlbHNlIGlmICghd2FzRW5hYmxlZCAmJiBpc0VuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLmVuYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIuY3VycmVudEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xuICAgICAgc3dpcGVyLmVtaXQoJ19iZWZvcmVCcmVha3BvaW50JywgYnJlYWtwb2ludFBhcmFtcyk7XG5cbiAgICAgIGlmIChuZWVkc1JlTG9vcCAmJiBpbml0aWFsaXplZCkge1xuICAgICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCAtIGxvb3BlZFNsaWRlcyArIHN3aXBlci5sb29wZWRTbGlkZXMsIDAsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXQoJ2JyZWFrcG9pbnQnLCBicmVha3BvaW50UGFyYW1zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCcmVha3BvaW50KGJyZWFrcG9pbnRzLCBiYXNlID0gJ3dpbmRvdycsIGNvbnRhaW5lckVsKSB7XG4gICAgICBpZiAoIWJyZWFrcG9pbnRzIHx8IGJhc2UgPT09ICdjb250YWluZXInICYmICFjb250YWluZXJFbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGxldCBicmVha3BvaW50ID0gZmFsc2U7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBiYXNlID09PSAnd2luZG93JyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IGNvbnRhaW5lckVsLmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IHBvaW50cyA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5tYXAocG9pbnQgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBvaW50ID09PSAnc3RyaW5nJyAmJiBwb2ludC5pbmRleE9mKCdAJykgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBtaW5SYXRpbyA9IHBhcnNlRmxvYXQocG9pbnQuc3Vic3RyKDEpKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnRIZWlnaHQgKiBtaW5SYXRpbztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBwb2ludFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBwb2ludCxcbiAgICAgICAgICBwb2ludFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBwb2ludHMuc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYS52YWx1ZSwgMTApIC0gcGFyc2VJbnQoYi52YWx1ZSwgMTApKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBvaW50LFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0gPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGJhc2UgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKGAobWluLXdpZHRoOiAke3ZhbHVlfXB4KWApLm1hdGNoZXMpIHtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQgPSBwb2ludDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPD0gY29udGFpbmVyRWwuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICBicmVha3BvaW50ID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyZWFrcG9pbnQgfHwgJ21heCc7XG4gICAgfVxuXG4gICAgdmFyIGJyZWFrcG9pbnRzID0ge1xuICAgICAgc2V0QnJlYWtwb2ludCxcbiAgICAgIGdldEJyZWFrcG9pbnRcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNsYXNzZXMoZW50cmllcywgcHJlZml4KSB7XG4gICAgICBjb25zdCByZXN1bHRDbGFzc2VzID0gW107XG4gICAgICBlbnRyaWVzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhpdGVtKS5mb3JFYWNoKGNsYXNzTmFtZXMgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW1bY2xhc3NOYW1lc10pIHtcbiAgICAgICAgICAgICAgcmVzdWx0Q2xhc3Nlcy5wdXNoKHByZWZpeCArIGNsYXNzTmFtZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlc3VsdENsYXNzZXMucHVzaChwcmVmaXggKyBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0Q2xhc3NlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NOYW1lcyxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBydGwsXG4gICAgICAgICRlbCxcbiAgICAgICAgZGV2aWNlLFxuICAgICAgICBzdXBwb3J0XG4gICAgICB9ID0gc3dpcGVyOyAvLyBwcmV0dGllci1pZ25vcmVcblxuICAgICAgY29uc3Qgc3VmZml4ZXMgPSBwcmVwYXJlQ2xhc3NlcyhbJ2luaXRpYWxpemVkJywgcGFyYW1zLmRpcmVjdGlvbiwge1xuICAgICAgICAncG9pbnRlci1ldmVudHMnOiAhc3VwcG9ydC50b3VjaFxuICAgICAgfSwge1xuICAgICAgICAnZnJlZS1tb2RlJzogc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZFxuICAgICAgfSwge1xuICAgICAgICAnYXV0b2hlaWdodCc6IHBhcmFtcy5hdXRvSGVpZ2h0XG4gICAgICB9LCB7XG4gICAgICAgICdydGwnOiBydGxcbiAgICAgIH0sIHtcbiAgICAgICAgJ2dyaWQnOiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMVxuICAgICAgfSwge1xuICAgICAgICAnZ3JpZC1jb2x1bW4nOiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMSAmJiBwYXJhbXMuZ3JpZC5maWxsID09PSAnY29sdW1uJ1xuICAgICAgfSwge1xuICAgICAgICAnYW5kcm9pZCc6IGRldmljZS5hbmRyb2lkXG4gICAgICB9LCB7XG4gICAgICAgICdpb3MnOiBkZXZpY2UuaW9zXG4gICAgICB9LCB7XG4gICAgICAgICdjc3MtbW9kZSc6IHBhcmFtcy5jc3NNb2RlXG4gICAgICB9LCB7XG4gICAgICAgICdjZW50ZXJlZCc6IHBhcmFtcy5jc3NNb2RlICYmIHBhcmFtcy5jZW50ZXJlZFNsaWRlc1xuICAgICAgfV0sIHBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzKTtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCguLi5zdWZmaXhlcyk7XG4gICAgICAkZWwuYWRkQ2xhc3MoWy4uLmNsYXNzTmFtZXNdLmpvaW4oJyAnKSk7XG4gICAgICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgJGVsLFxuICAgICAgICBjbGFzc05hbWVzXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgJGVsLnJlbW92ZUNsYXNzKGNsYXNzTmFtZXMuam9pbignICcpKTtcbiAgICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICAgIH1cblxuICAgIHZhciBjbGFzc2VzID0ge1xuICAgICAgYWRkQ2xhc3NlcyxcbiAgICAgIHJlbW92ZUNsYXNzZXNcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9hZEltYWdlKGltYWdlRWwsIHNyYywgc3Jjc2V0LCBzaXplcywgY2hlY2tGb3JDb21wbGV0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgbGV0IGltYWdlO1xuXG4gICAgICBmdW5jdGlvbiBvblJlYWR5KCkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzUGljdHVyZSA9ICQoaW1hZ2VFbCkucGFyZW50KCdwaWN0dXJlJylbMF07XG5cbiAgICAgIGlmICghaXNQaWN0dXJlICYmICghaW1hZ2VFbC5jb21wbGV0ZSB8fCAhY2hlY2tGb3JDb21wbGV0ZSkpIHtcbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZSgpO1xuICAgICAgICAgIGltYWdlLm9ubG9hZCA9IG9uUmVhZHk7XG4gICAgICAgICAgaW1hZ2Uub25lcnJvciA9IG9uUmVhZHk7XG5cbiAgICAgICAgICBpZiAoc2l6ZXMpIHtcbiAgICAgICAgICAgIGltYWdlLnNpemVzID0gc2l6ZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNyY3NldCkge1xuICAgICAgICAgICAgaW1hZ2Uuc3Jjc2V0ID0gc3Jjc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25SZWFkeSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbWFnZSBhbHJlYWR5IGxvYWRlZC4uLlxuICAgICAgICBvblJlYWR5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlbG9hZEltYWdlcygpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIuaW1hZ2VzVG9Mb2FkID0gc3dpcGVyLiRlbC5maW5kKCdpbWcnKTtcblxuICAgICAgZnVuY3Rpb24gb25SZWFkeSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzd2lwZXIgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlciA9PT0gbnVsbCB8fCAhc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHN3aXBlci5pbWFnZXNMb2FkZWQgIT09IHVuZGVmaW5lZCkgc3dpcGVyLmltYWdlc0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmIChzd2lwZXIuaW1hZ2VzTG9hZGVkID09PSBzd2lwZXIuaW1hZ2VzVG9Mb2FkLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnVwZGF0ZU9uSW1hZ2VzUmVhZHkpIHN3aXBlci51cGRhdGUoKTtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnaW1hZ2VzUmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlci5pbWFnZXNUb0xvYWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VFbCA9IHN3aXBlci5pbWFnZXNUb0xvYWRbaV07XG4gICAgICAgIHN3aXBlci5sb2FkSW1hZ2UoaW1hZ2VFbCwgaW1hZ2VFbC5jdXJyZW50U3JjIHx8IGltYWdlRWwuZ2V0QXR0cmlidXRlKCdzcmMnKSwgaW1hZ2VFbC5zcmNzZXQgfHwgaW1hZ2VFbC5nZXRBdHRyaWJ1dGUoJ3NyY3NldCcpLCBpbWFnZUVsLnNpemVzIHx8IGltYWdlRWwuZ2V0QXR0cmlidXRlKCdzaXplcycpLCB0cnVlLCBvblJlYWR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VzID0ge1xuICAgICAgbG9hZEltYWdlLFxuICAgICAgcHJlbG9hZEltYWdlc1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNMb2NrZWQ6IHdhc0xvY2tlZCxcbiAgICAgICAgcGFyYW1zXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbGlkZXNPZmZzZXRCZWZvcmVcbiAgICAgIH0gPSBwYXJhbXM7XG5cbiAgICAgIGlmIChzbGlkZXNPZmZzZXRCZWZvcmUpIHtcbiAgICAgICAgY29uc3QgbGFzdFNsaWRlSW5kZXggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGxhc3RTbGlkZVJpZ2h0RWRnZSA9IHN3aXBlci5zbGlkZXNHcmlkW2xhc3RTbGlkZUluZGV4XSArIHN3aXBlci5zbGlkZXNTaXplc0dyaWRbbGFzdFNsaWRlSW5kZXhdICsgc2xpZGVzT2Zmc2V0QmVmb3JlICogMjtcbiAgICAgICAgc3dpcGVyLmlzTG9ja2VkID0gc3dpcGVyLnNpemUgPiBsYXN0U2xpZGVSaWdodEVkZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIuaXNMb2NrZWQgPSBzd2lwZXIuc25hcEdyaWQubGVuZ3RoID09PSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlKSB7XG4gICAgICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9ICFzd2lwZXIuaXNMb2NrZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuYWxsb3dTbGlkZVByZXYgPT09IHRydWUpIHtcbiAgICAgICAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gIXN3aXBlci5pc0xvY2tlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHdhc0xvY2tlZCAmJiB3YXNMb2NrZWQgIT09IHN3aXBlci5pc0xvY2tlZCkge1xuICAgICAgICBzd2lwZXIuaXNFbmQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSB7XG4gICAgICAgIHN3aXBlci5lbWl0KHN3aXBlci5pc0xvY2tlZCA/ICdsb2NrJyA6ICd1bmxvY2snKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hlY2tPdmVyZmxvdyQxID0ge1xuICAgICAgY2hlY2tPdmVyZmxvd1xuICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBpbml0OiB0cnVlLFxuICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICB0b3VjaEV2ZW50c1RhcmdldDogJ3dyYXBwZXInLFxuICAgICAgaW5pdGlhbFNsaWRlOiAwLFxuICAgICAgc3BlZWQ6IDMwMCxcbiAgICAgIGNzc01vZGU6IGZhbHNlLFxuICAgICAgdXBkYXRlT25XaW5kb3dSZXNpemU6IHRydWUsXG4gICAgICByZXNpemVPYnNlcnZlcjogdHJ1ZSxcbiAgICAgIG5lc3RlZDogZmFsc2UsXG4gICAgICBjcmVhdGVFbGVtZW50czogZmFsc2UsXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9jdXNhYmxlRWxlbWVudHM6ICdpbnB1dCwgc2VsZWN0LCBvcHRpb24sIHRleHRhcmVhLCBidXR0b24sIHZpZGVvLCBsYWJlbCcsXG4gICAgICAvLyBPdmVycmlkZXNcbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgLy9cbiAgICAgIHByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbjogZmFsc2UsXG4gICAgICAvLyBzc3JcbiAgICAgIHVzZXJBZ2VudDogbnVsbCxcbiAgICAgIHVybDogbnVsbCxcbiAgICAgIC8vIFRvIHN1cHBvcnQgaU9TJ3Mgc3dpcGUtdG8tZ28tYmFjayBnZXN0dXJlICh3aGVuIGJlaW5nIHVzZWQgaW4tYXBwKS5cbiAgICAgIGVkZ2VTd2lwZURldGVjdGlvbjogZmFsc2UsXG4gICAgICBlZGdlU3dpcGVUaHJlc2hvbGQ6IDIwLFxuICAgICAgLy8gQXV0b2hlaWdodFxuICAgICAgYXV0b0hlaWdodDogZmFsc2UsXG4gICAgICAvLyBTZXQgd3JhcHBlciB3aWR0aFxuICAgICAgc2V0V3JhcHBlclNpemU6IGZhbHNlLFxuICAgICAgLy8gVmlydHVhbCBUcmFuc2xhdGVcbiAgICAgIHZpcnR1YWxUcmFuc2xhdGU6IGZhbHNlLFxuICAgICAgLy8gRWZmZWN0c1xuICAgICAgZWZmZWN0OiAnc2xpZGUnLFxuICAgICAgLy8gJ3NsaWRlJyBvciAnZmFkZScgb3IgJ2N1YmUnIG9yICdjb3ZlcmZsb3cnIG9yICdmbGlwJ1xuICAgICAgLy8gQnJlYWtwb2ludHNcbiAgICAgIGJyZWFrcG9pbnRzOiB1bmRlZmluZWQsXG4gICAgICBicmVha3BvaW50c0Jhc2U6ICd3aW5kb3cnLFxuICAgICAgLy8gU2xpZGVzIGdyaWRcbiAgICAgIHNwYWNlQmV0d2VlbjogMCxcbiAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICBzbGlkZXNQZXJHcm91cDogMSxcbiAgICAgIHNsaWRlc1Blckdyb3VwU2tpcDogMCxcbiAgICAgIHNsaWRlc1Blckdyb3VwQXV0bzogZmFsc2UsXG4gICAgICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXG4gICAgICBjZW50ZXJlZFNsaWRlc0JvdW5kczogZmFsc2UsXG4gICAgICBzbGlkZXNPZmZzZXRCZWZvcmU6IDAsXG4gICAgICAvLyBpbiBweFxuICAgICAgc2xpZGVzT2Zmc2V0QWZ0ZXI6IDAsXG4gICAgICAvLyBpbiBweFxuICAgICAgbm9ybWFsaXplU2xpZGVJbmRleDogdHJ1ZSxcbiAgICAgIGNlbnRlckluc3VmZmljaWVudFNsaWRlczogZmFsc2UsXG4gICAgICAvLyBEaXNhYmxlIHN3aXBlciBhbmQgaGlkZSBuYXZpZ2F0aW9uIHdoZW4gY29udGFpbmVyIG5vdCBvdmVyZmxvd1xuICAgICAgd2F0Y2hPdmVyZmxvdzogdHJ1ZSxcbiAgICAgIC8vIFJvdW5kIGxlbmd0aFxuICAgICAgcm91bmRMZW5ndGhzOiBmYWxzZSxcbiAgICAgIC8vIFRvdWNoZXNcbiAgICAgIHRvdWNoUmF0aW86IDEsXG4gICAgICB0b3VjaEFuZ2xlOiA0NSxcbiAgICAgIHNpbXVsYXRlVG91Y2g6IHRydWUsXG4gICAgICBzaG9ydFN3aXBlczogdHJ1ZSxcbiAgICAgIGxvbmdTd2lwZXM6IHRydWUsXG4gICAgICBsb25nU3dpcGVzUmF0aW86IDAuNSxcbiAgICAgIGxvbmdTd2lwZXNNczogMzAwLFxuICAgICAgZm9sbG93RmluZ2VyOiB0cnVlLFxuICAgICAgYWxsb3dUb3VjaE1vdmU6IHRydWUsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICB0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgdG91Y2hTdGFydFByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgdG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICAgICAgdG91Y2hSZWxlYXNlT25FZGdlczogZmFsc2UsXG4gICAgICAvLyBVbmlxdWUgTmF2aWdhdGlvbiBFbGVtZW50c1xuICAgICAgdW5pcXVlTmF2RWxlbWVudHM6IHRydWUsXG4gICAgICAvLyBSZXNpc3RhbmNlXG4gICAgICByZXNpc3RhbmNlOiB0cnVlLFxuICAgICAgcmVzaXN0YW5jZVJhdGlvOiAwLjg1LFxuICAgICAgLy8gUHJvZ3Jlc3NcbiAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IGZhbHNlLFxuICAgICAgLy8gQ3Vyc29yXG4gICAgICBncmFiQ3Vyc29yOiBmYWxzZSxcbiAgICAgIC8vIENsaWNrc1xuICAgICAgcHJldmVudENsaWNrczogdHJ1ZSxcbiAgICAgIHByZXZlbnRDbGlja3NQcm9wYWdhdGlvbjogdHJ1ZSxcbiAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZhbHNlLFxuICAgICAgLy8gSW1hZ2VzXG4gICAgICBwcmVsb2FkSW1hZ2VzOiB0cnVlLFxuICAgICAgdXBkYXRlT25JbWFnZXNSZWFkeTogdHJ1ZSxcbiAgICAgIC8vIGxvb3BcbiAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgbG9vcEFkZGl0aW9uYWxTbGlkZXM6IDAsXG4gICAgICBsb29wZWRTbGlkZXM6IG51bGwsXG4gICAgICBsb29wRmlsbEdyb3VwV2l0aEJsYW5rOiBmYWxzZSxcbiAgICAgIGxvb3BQcmV2ZW50c1NsaWRlOiB0cnVlLFxuICAgICAgLy8gU3dpcGluZy9ubyBzd2lwaW5nXG4gICAgICBhbGxvd1NsaWRlUHJldjogdHJ1ZSxcbiAgICAgIGFsbG93U2xpZGVOZXh0OiB0cnVlLFxuICAgICAgc3dpcGVIYW5kbGVyOiBudWxsLFxuICAgICAgLy8gJy5zd2lwZS1oYW5kbGVyJyxcbiAgICAgIG5vU3dpcGluZzogdHJ1ZSxcbiAgICAgIG5vU3dpcGluZ0NsYXNzOiAnc3dpcGVyLW5vLXN3aXBpbmcnLFxuICAgICAgbm9Td2lwaW5nU2VsZWN0b3I6IG51bGwsXG4gICAgICAvLyBQYXNzaXZlIExpc3RlbmVyc1xuICAgICAgcGFzc2l2ZUxpc3RlbmVyczogdHJ1ZSxcbiAgICAgIC8vIE5TXG4gICAgICBjb250YWluZXJNb2RpZmllckNsYXNzOiAnc3dpcGVyLScsXG4gICAgICAvLyBORVdcbiAgICAgIHNsaWRlQ2xhc3M6ICdzd2lwZXItc2xpZGUnLFxuICAgICAgc2xpZGVCbGFua0NsYXNzOiAnc3dpcGVyLXNsaWRlLWludmlzaWJsZS1ibGFuaycsXG4gICAgICBzbGlkZUFjdGl2ZUNsYXNzOiAnc3dpcGVyLXNsaWRlLWFjdGl2ZScsXG4gICAgICBzbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1hY3RpdmUnLFxuICAgICAgc2xpZGVWaXNpYmxlQ2xhc3M6ICdzd2lwZXItc2xpZGUtdmlzaWJsZScsXG4gICAgICBzbGlkZUR1cGxpY2F0ZUNsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZScsXG4gICAgICBzbGlkZU5leHRDbGFzczogJ3N3aXBlci1zbGlkZS1uZXh0JyxcbiAgICAgIHNsaWRlRHVwbGljYXRlTmV4dENsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1uZXh0JyxcbiAgICAgIHNsaWRlUHJldkNsYXNzOiAnc3dpcGVyLXNsaWRlLXByZXYnLFxuICAgICAgc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3M6ICdzd2lwZXItc2xpZGUtZHVwbGljYXRlLXByZXYnLFxuICAgICAgd3JhcHBlckNsYXNzOiAnc3dpcGVyLXdyYXBwZXInLFxuICAgICAgLy8gQ2FsbGJhY2tzXG4gICAgICBydW5DYWxsYmFja3NPbkluaXQ6IHRydWUsXG4gICAgICAvLyBJbnRlcm5hbHNcbiAgICAgIF9lbWl0Q2xhc3NlczogZmFsc2VcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbW9kdWxlRXh0ZW5kUGFyYW1zKHBhcmFtcywgYWxsTW9kdWxlc1BhcmFtcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGV4dGVuZFBhcmFtcyhvYmogPSB7fSkge1xuICAgICAgICBjb25zdCBtb2R1bGVQYXJhbU5hbWUgPSBPYmplY3Qua2V5cyhvYmopWzBdO1xuICAgICAgICBjb25zdCBtb2R1bGVQYXJhbXMgPSBvYmpbbW9kdWxlUGFyYW1OYW1lXTtcblxuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZVBhcmFtcyAhPT0gJ29iamVjdCcgfHwgbW9kdWxlUGFyYW1zID09PSBudWxsKSB7XG4gICAgICAgICAgZXh0ZW5kKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFsnbmF2aWdhdGlvbicsICdwYWdpbmF0aW9uJywgJ3Njcm9sbGJhciddLmluZGV4T2YobW9kdWxlUGFyYW1OYW1lKSA+PSAwICYmIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSB0cnVlKSB7XG4gICAgICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7XG4gICAgICAgICAgICBhdXRvOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKG1vZHVsZVBhcmFtTmFtZSBpbiBwYXJhbXMgJiYgJ2VuYWJsZWQnIGluIG1vZHVsZVBhcmFtcykpIHtcbiAgICAgICAgICBleHRlbmQoYWxsTW9kdWxlc1BhcmFtcywgb2JqKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPT09IHRydWUpIHtcbiAgICAgICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gJ29iamVjdCcgJiYgISgnZW5hYmxlZCcgaW4gcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0pKSB7XG4gICAgICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdKSBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBleHRlbmQoYWxsTW9kdWxlc1BhcmFtcywgb2JqKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiBcIm9mZlwiICovXG4gICAgY29uc3QgcHJvdG90eXBlcyA9IHtcbiAgICAgIGV2ZW50c0VtaXR0ZXIsXG4gICAgICB1cGRhdGUsXG4gICAgICB0cmFuc2xhdGUsXG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgc2xpZGUsXG4gICAgICBsb29wLFxuICAgICAgZ3JhYkN1cnNvcixcbiAgICAgIGV2ZW50czogZXZlbnRzJDEsXG4gICAgICBicmVha3BvaW50cyxcbiAgICAgIGNoZWNrT3ZlcmZsb3c6IGNoZWNrT3ZlcmZsb3ckMSxcbiAgICAgIGNsYXNzZXMsXG4gICAgICBpbWFnZXNcbiAgICB9O1xuICAgIGNvbnN0IGV4dGVuZGVkRGVmYXVsdHMgPSB7fTtcblxuICAgIGNsYXNzIFN3aXBlciB7XG4gICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGxldCBlbDtcbiAgICAgICAgbGV0IHBhcmFtcztcblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXS5jb25zdHJ1Y3RvciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnc1swXSkuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgW2VsLCBwYXJhbXNdID0gYXJncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICAgICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBwYXJhbXMpO1xuICAgICAgICBpZiAoZWwgJiYgIXBhcmFtcy5lbCkgcGFyYW1zLmVsID0gZWw7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5lbCAmJiAkKHBhcmFtcy5lbCkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IHN3aXBlcnMgPSBbXTtcbiAgICAgICAgICAkKHBhcmFtcy5lbCkuZWFjaChjb250YWluZXJFbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBleHRlbmQoe30sIHBhcmFtcywge1xuICAgICAgICAgICAgICBlbDogY29udGFpbmVyRWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3dpcGVycy5wdXNoKG5ldyBTd2lwZXIobmV3UGFyYW1zKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHN3aXBlcnM7XG4gICAgICAgIH0gLy8gU3dpcGVyIEluc3RhbmNlXG5cblxuICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICBzd2lwZXIuX19zd2lwZXJfXyA9IHRydWU7XG4gICAgICAgIHN3aXBlci5zdXBwb3J0ID0gZ2V0U3VwcG9ydCgpO1xuICAgICAgICBzd2lwZXIuZGV2aWNlID0gZ2V0RGV2aWNlKHtcbiAgICAgICAgICB1c2VyQWdlbnQ6IHBhcmFtcy51c2VyQWdlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlci5icm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgICBzd2lwZXIuZXZlbnRzTGlzdGVuZXJzID0ge307XG4gICAgICAgIHN3aXBlci5ldmVudHNBbnlMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgc3dpcGVyLm1vZHVsZXMgPSBbLi4uc3dpcGVyLl9fbW9kdWxlc19fXTtcblxuICAgICAgICBpZiAocGFyYW1zLm1vZHVsZXMgJiYgQXJyYXkuaXNBcnJheShwYXJhbXMubW9kdWxlcykpIHtcbiAgICAgICAgICBzd2lwZXIubW9kdWxlcy5wdXNoKC4uLnBhcmFtcy5tb2R1bGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFsbE1vZHVsZXNQYXJhbXMgPSB7fTtcbiAgICAgICAgc3dpcGVyLm1vZHVsZXMuZm9yRWFjaChtb2QgPT4ge1xuICAgICAgICAgIG1vZCh7XG4gICAgICAgICAgICBzd2lwZXIsXG4gICAgICAgICAgICBleHRlbmRQYXJhbXM6IG1vZHVsZUV4dGVuZFBhcmFtcyhwYXJhbXMsIGFsbE1vZHVsZXNQYXJhbXMpLFxuICAgICAgICAgICAgb246IHN3aXBlci5vbi5iaW5kKHN3aXBlciksXG4gICAgICAgICAgICBvbmNlOiBzd2lwZXIub25jZS5iaW5kKHN3aXBlciksXG4gICAgICAgICAgICBvZmY6IHN3aXBlci5vZmYuYmluZChzd2lwZXIpLFxuICAgICAgICAgICAgZW1pdDogc3dpcGVyLmVtaXQuYmluZChzd2lwZXIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pOyAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuXG4gICAgICAgIGNvbnN0IHN3aXBlclBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIGFsbE1vZHVsZXNQYXJhbXMpOyAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBwYXNzZWQgcGFyYW1zXG5cbiAgICAgICAgc3dpcGVyLnBhcmFtcyA9IGV4dGVuZCh7fSwgc3dpcGVyUGFyYW1zLCBleHRlbmRlZERlZmF1bHRzLCBwYXJhbXMpO1xuICAgICAgICBzd2lwZXIub3JpZ2luYWxQYXJhbXMgPSBleHRlbmQoe30sIHN3aXBlci5wYXJhbXMpO1xuICAgICAgICBzd2lwZXIucGFzc2VkUGFyYW1zID0gZXh0ZW5kKHt9LCBwYXJhbXMpOyAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMgJiYgc3dpcGVyLnBhcmFtcy5vbikge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHN3aXBlci5wYXJhbXMub24pLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgICAgICAgIHN3aXBlci5vbihldmVudE5hbWUsIHN3aXBlci5wYXJhbXMub25bZXZlbnROYW1lXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcyAmJiBzd2lwZXIucGFyYW1zLm9uQW55KSB7XG4gICAgICAgICAgc3dpcGVyLm9uQW55KHN3aXBlci5wYXJhbXMub25BbnkpO1xuICAgICAgICB9IC8vIFNhdmUgRG9tIGxpYlxuXG5cbiAgICAgICAgc3dpcGVyLiQgPSAkOyAvLyBFeHRlbmQgU3dpcGVyXG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgICBlbmFibGVkOiBzd2lwZXIucGFyYW1zLmVuYWJsZWQsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgLy8gQ2xhc3Nlc1xuICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgIC8vIFNsaWRlc1xuICAgICAgICAgIHNsaWRlczogJCgpLFxuICAgICAgICAgIHNsaWRlc0dyaWQ6IFtdLFxuICAgICAgICAgIHNuYXBHcmlkOiBbXSxcbiAgICAgICAgICBzbGlkZXNTaXplc0dyaWQ6IFtdLFxuXG4gICAgICAgICAgLy8gaXNEaXJlY3Rpb25cbiAgICAgICAgICBpc0hvcml6b250YWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaXNWZXJ0aWNhbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gSW5kZXhlc1xuICAgICAgICAgIGFjdGl2ZUluZGV4OiAwLFxuICAgICAgICAgIHJlYWxJbmRleDogMCxcbiAgICAgICAgICAvL1xuICAgICAgICAgIGlzQmVnaW5uaW5nOiB0cnVlLFxuICAgICAgICAgIGlzRW5kOiBmYWxzZSxcbiAgICAgICAgICAvLyBQcm9wc1xuICAgICAgICAgIHRyYW5zbGF0ZTogMCxcbiAgICAgICAgICBwcmV2aW91c1RyYW5zbGF0ZTogMCxcbiAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICB2ZWxvY2l0eTogMCxcbiAgICAgICAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgICAgICAgIC8vIExvY2tzXG4gICAgICAgICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgICAgICAgYWxsb3dTbGlkZVByZXY6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXG4gICAgICAgICAgLy8gVG91Y2ggRXZlbnRzXG4gICAgICAgICAgdG91Y2hFdmVudHM6IGZ1bmN0aW9uIHRvdWNoRXZlbnRzKCkge1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJ107XG4gICAgICAgICAgICBjb25zdCBkZXNrdG9wID0gWydwb2ludGVyZG93bicsICdwb2ludGVybW92ZScsICdwb2ludGVydXAnXTtcbiAgICAgICAgICAgIHN3aXBlci50b3VjaEV2ZW50c1RvdWNoID0ge1xuICAgICAgICAgICAgICBzdGFydDogdG91Y2hbMF0sXG4gICAgICAgICAgICAgIG1vdmU6IHRvdWNoWzFdLFxuICAgICAgICAgICAgICBlbmQ6IHRvdWNoWzJdLFxuICAgICAgICAgICAgICBjYW5jZWw6IHRvdWNoWzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGVza3RvcCA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRlc2t0b3BbMF0sXG4gICAgICAgICAgICAgIG1vdmU6IGRlc2t0b3BbMV0sXG4gICAgICAgICAgICAgIGVuZDogZGVza3RvcFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzd2lwZXIuc3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoID8gc3dpcGVyLnRvdWNoRXZlbnRzVG91Y2ggOiBzd2lwZXIudG91Y2hFdmVudHNEZXNrdG9wO1xuICAgICAgICAgIH0oKSxcbiAgICAgICAgICB0b3VjaEV2ZW50c0RhdGE6IHtcbiAgICAgICAgICAgIGlzVG91Y2hlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNNb3ZlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG91Y2hTdGFydFRpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGFydFRyYW5zbGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3dUaHJlc2hvbGRNb3ZlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBGb3JtIGVsZW1lbnRzIHRvIG1hdGNoXG4gICAgICAgICAgICBmb2N1c2FibGVFbGVtZW50czogc3dpcGVyLnBhcmFtcy5mb2N1c2FibGVFbGVtZW50cyxcbiAgICAgICAgICAgIC8vIExhc3QgY2xpY2sgdGltZVxuICAgICAgICAgICAgbGFzdENsaWNrVGltZTogbm93KCksXG4gICAgICAgICAgICBjbGlja1RpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFZlbG9jaXRpZXNcbiAgICAgICAgICAgIHZlbG9jaXRpZXM6IFtdLFxuICAgICAgICAgICAgYWxsb3dNb21lbnR1bUJvdW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGFydE1vdmluZzogdW5kZWZpbmVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBDbGlja3NcbiAgICAgICAgICBhbGxvd0NsaWNrOiB0cnVlLFxuICAgICAgICAgIC8vIFRvdWNoZXNcbiAgICAgICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICAgICAgICB0b3VjaGVzOiB7XG4gICAgICAgICAgICBzdGFydFg6IDAsXG4gICAgICAgICAgICBzdGFydFk6IDAsXG4gICAgICAgICAgICBjdXJyZW50WDogMCxcbiAgICAgICAgICAgIGN1cnJlbnRZOiAwLFxuICAgICAgICAgICAgZGlmZjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gSW1hZ2VzXG4gICAgICAgICAgaW1hZ2VzVG9Mb2FkOiBbXSxcbiAgICAgICAgICBpbWFnZXNMb2FkZWQ6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlci5lbWl0KCdfc3dpcGVyJyk7IC8vIEluaXRcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5pbml0KSB7XG4gICAgICAgICAgc3dpcGVyLmluaXQoKTtcbiAgICAgICAgfSAvLyBSZXR1cm4gYXBwIGluc3RhbmNlXG5cblxuICAgICAgICByZXR1cm4gc3dpcGVyO1xuICAgICAgfVxuXG4gICAgICBlbmFibGUoKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBzd2lwZXIuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnZW5hYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGRpc2FibGUoKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yKSB7XG4gICAgICAgICAgc3dpcGVyLnVuc2V0R3JhYkN1cnNvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmVtaXQoJ2Rpc2FibGUnKTtcbiAgICAgIH1cblxuICAgICAgc2V0UHJvZ3Jlc3MocHJvZ3Jlc3MsIHNwZWVkKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIHByb2dyZXNzID0gTWF0aC5taW4oTWF0aC5tYXgocHJvZ3Jlc3MsIDApLCAxKTtcbiAgICAgICAgY29uc3QgbWluID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICBjb25zdCBtYXggPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSAobWF4IC0gbWluKSAqIHByb2dyZXNzICsgbWluO1xuICAgICAgICBzd2lwZXIudHJhbnNsYXRlVG8oY3VycmVudCwgdHlwZW9mIHNwZWVkID09PSAndW5kZWZpbmVkJyA/IDAgOiBzcGVlZCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgICAgfVxuXG4gICAgICBlbWl0Q29udGFpbmVyQ2xhc3NlcygpIHtcbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLl9lbWl0Q2xhc3NlcyB8fCAhc3dpcGVyLmVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGNscyA9IHN3aXBlci5lbC5jbGFzc05hbWUuc3BsaXQoJyAnKS5maWx0ZXIoY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3N3aXBlcicpID09PSAwIHx8IGNsYXNzTmFtZS5pbmRleE9mKHN3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcykgPT09IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuZW1pdCgnX2NvbnRhaW5lckNsYXNzZXMnLCBjbHMuam9pbignICcpKTtcbiAgICAgIH1cblxuICAgICAgZ2V0U2xpZGVDbGFzc2VzKHNsaWRlRWwpIHtcbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNsaWRlRWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKCdzd2lwZXItc2xpZGUnKSA9PT0gMCB8fCBjbGFzc05hbWUuaW5kZXhPZihzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3MpID09PSAwO1xuICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICB9XG5cbiAgICAgIGVtaXRTbGlkZXNDbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFzd2lwZXIuZWwpIHJldHVybjtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgICAgICBzd2lwZXIuc2xpZGVzLmVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IHN3aXBlci5nZXRTbGlkZUNsYXNzZXMoc2xpZGVFbCk7XG4gICAgICAgICAgdXBkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNsaWRlRWwsXG4gICAgICAgICAgICBjbGFzc05hbWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ19zbGlkZUNsYXNzJywgc2xpZGVFbCwgY2xhc3NOYW1lcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuZW1pdCgnX3NsaWRlQ2xhc3NlcycsIHVwZGF0ZXMpO1xuICAgICAgfVxuXG4gICAgICBzbGlkZXNQZXJWaWV3RHluYW1pYyh2aWV3ID0gJ2N1cnJlbnQnLCBleGFjdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgIHNsaWRlc0dyaWQsXG4gICAgICAgICAgc2xpZGVzU2l6ZXNHcmlkLFxuICAgICAgICAgIHNpemU6IHN3aXBlclNpemUsXG4gICAgICAgICAgYWN0aXZlSW5kZXhcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgbGV0IHNwdiA9IDE7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIGxldCBzbGlkZVNpemUgPSBzbGlkZXNbYWN0aXZlSW5kZXhdLnN3aXBlclNsaWRlU2l6ZTtcbiAgICAgICAgICBsZXQgYnJlYWtMb29wO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHNsaWRlc1tpXSAmJiAhYnJlYWtMb29wKSB7XG4gICAgICAgICAgICAgIHNsaWRlU2l6ZSArPSBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplO1xuICAgICAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKHNsaWRlU2l6ZSA+IHN3aXBlclNpemUpIGJyZWFrTG9vcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgIGlmIChzbGlkZXNbaV0gJiYgIWJyZWFrTG9vcCkge1xuICAgICAgICAgICAgICBzbGlkZVNpemUgKz0gc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZTtcbiAgICAgICAgICAgICAgc3B2ICs9IDE7XG4gICAgICAgICAgICAgIGlmIChzbGlkZVNpemUgPiBzd2lwZXJTaXplKSBicmVha0xvb3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBpZiAodmlldyA9PT0gJ2N1cnJlbnQnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggKyAxOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlSW5WaWV3ID0gZXhhY3QgPyBzbGlkZXNHcmlkW2ldICsgc2xpZGVzU2l6ZXNHcmlkW2ldIC0gc2xpZGVzR3JpZFthY3RpdmVJbmRleF0gPCBzd2lwZXJTaXplIDogc2xpZGVzR3JpZFtpXSAtIHNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdIDwgc3dpcGVyU2l6ZTtcblxuICAgICAgICAgICAgICBpZiAoc2xpZGVJblZpZXcpIHtcbiAgICAgICAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2xpZGVJblZpZXcgPSBzbGlkZXNHcmlkW2FjdGl2ZUluZGV4XSAtIHNsaWRlc0dyaWRbaV0gPCBzd2lwZXJTaXplO1xuXG4gICAgICAgICAgICAgIGlmIChzbGlkZUluVmlldykge1xuICAgICAgICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNwdjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICBwYXJhbXNcbiAgICAgICAgfSA9IHN3aXBlcjsgLy8gQnJlYWtwb2ludHNcblxuICAgICAgICBpZiAocGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci51cGRhdGVTaXplKCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlKCkge1xuICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgKiAtMSA6IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICAgICAgY29uc3QgbmV3VHJhbnNsYXRlID0gTWF0aC5taW4oTWF0aC5tYXgodHJhbnNsYXRlVmFsdWUsIHN3aXBlci5tYXhUcmFuc2xhdGUoKSksIHN3aXBlci5taW5UcmFuc2xhdGUoKSk7XG4gICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdHJhbnNsYXRlZDtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBzd2lwZXIucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQpIHtcbiAgICAgICAgICBzZXRUcmFuc2xhdGUoKTtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgfHwgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRyYW5zbGF0ZWQpIHtcbiAgICAgICAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XG4gICAgICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5lbWl0KCd1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlRGlyZWN0aW9uKG5ld0RpcmVjdGlvbiwgbmVlZFVwZGF0ZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgY29uc3QgY3VycmVudERpcmVjdGlvbiA9IHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uO1xuXG4gICAgICAgIGlmICghbmV3RGlyZWN0aW9uKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgbmV3RGlyZWN0aW9uID0gY3VycmVudERpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdEaXJlY3Rpb24gPT09IGN1cnJlbnREaXJlY3Rpb24gfHwgbmV3RGlyZWN0aW9uICE9PSAnaG9yaXpvbnRhbCcgJiYgbmV3RGlyZWN0aW9uICE9PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgcmV0dXJuIHN3aXBlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci4kZWwucmVtb3ZlQ2xhc3MoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfSR7Y3VycmVudERpcmVjdGlvbn1gKS5hZGRDbGFzcyhgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtuZXdEaXJlY3Rpb259YCk7XG4gICAgICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICAgICAgICBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9IG5ld0RpcmVjdGlvbjtcbiAgICAgICAgc3dpcGVyLnNsaWRlcy5lYWNoKHNsaWRlRWwgPT4ge1xuICAgICAgICAgIGlmIChuZXdEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHNsaWRlRWwuc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xpZGVFbC5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuZW1pdCgnY2hhbmdlRGlyZWN0aW9uJyk7XG4gICAgICAgIGlmIChuZWVkVXBkYXRlKSBzd2lwZXIudXBkYXRlKCk7XG4gICAgICAgIHJldHVybiBzd2lwZXI7XG4gICAgICB9XG5cbiAgICAgIG1vdW50KGVsKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIubW91bnRlZCkgcmV0dXJuIHRydWU7IC8vIEZpbmQgZWxcblxuICAgICAgICBjb25zdCAkZWwgPSAkKGVsIHx8IHN3aXBlci5wYXJhbXMuZWwpO1xuICAgICAgICBlbCA9ICRlbFswXTtcblxuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuc3dpcGVyID0gc3dpcGVyO1xuXG4gICAgICAgIGNvbnN0IGdldFdyYXBwZXJTZWxlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYC4keyhzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzcyB8fCAnJykudHJpbSgpLnNwbGl0KCcgJykuam9pbignLicpfWA7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZ2V0V3JhcHBlciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoZWwgJiYgZWwuc2hhZG93Um9vdCAmJiBlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9ICQoZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGdldFdyYXBwZXJTZWxlY3RvcigpKSk7IC8vIENoaWxkcmVuIG5lZWRzIHRvIHJldHVybiBzbG90IGl0ZW1zXG5cbiAgICAgICAgICAgIHJlcy5jaGlsZHJlbiA9IG9wdGlvbnMgPT4gJGVsLmNoaWxkcmVuKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAkZWwuY2hpbGRyZW4oZ2V0V3JhcHBlclNlbGVjdG9yKCkpO1xuICAgICAgICB9OyAvLyBGaW5kIFdyYXBwZXJcblxuXG4gICAgICAgIGxldCAkd3JhcHBlckVsID0gZ2V0V3JhcHBlcigpO1xuXG4gICAgICAgIGlmICgkd3JhcHBlckVsLmxlbmd0aCA9PT0gMCAmJiBzd2lwZXIucGFyYW1zLmNyZWF0ZUVsZW1lbnRzKSB7XG4gICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAkd3JhcHBlckVsID0gJCh3cmFwcGVyKTtcbiAgICAgICAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IHN3aXBlci5wYXJhbXMud3JhcHBlckNsYXNzO1xuICAgICAgICAgICRlbC5hcHBlbmQod3JhcHBlcik7XG4gICAgICAgICAgJGVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YCkuZWFjaChzbGlkZUVsID0+IHtcbiAgICAgICAgICAgICR3cmFwcGVyRWwuYXBwZW5kKHNsaWRlRWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgICB3cmFwcGVyRWw6ICR3cmFwcGVyRWxbMF0sXG4gICAgICAgICAgbW91bnRlZDogdHJ1ZSxcbiAgICAgICAgICAvLyBSVExcbiAgICAgICAgICBydGw6IGVsLmRpci50b0xvd2VyQ2FzZSgpID09PSAncnRsJyB8fCAkZWwuY3NzKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcsXG4gICAgICAgICAgcnRsVHJhbnNsYXRlOiBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIChlbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcgfHwgJGVsLmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnKSxcbiAgICAgICAgICB3cm9uZ1JUTDogJHdyYXBwZXJFbC5jc3MoJ2Rpc3BsYXknKSA9PT0gJy13ZWJraXQtYm94J1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGluaXQoZWwpIHtcbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgaWYgKHN3aXBlci5pbml0aWFsaXplZCkgcmV0dXJuIHN3aXBlcjtcbiAgICAgICAgY29uc3QgbW91bnRlZCA9IHN3aXBlci5tb3VudChlbCk7XG4gICAgICAgIGlmIChtb3VudGVkID09PSBmYWxzZSkgcmV0dXJuIHN3aXBlcjtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2JlZm9yZUluaXQnKTsgLy8gU2V0IGJyZWFrcG9pbnRcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5icmVha3BvaW50cykge1xuICAgICAgICAgIHN3aXBlci5zZXRCcmVha3BvaW50KCk7XG4gICAgICAgIH0gLy8gQWRkIENsYXNzZXNcblxuXG4gICAgICAgIHN3aXBlci5hZGRDbGFzc2VzKCk7IC8vIENyZWF0ZSBsb29wXG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XG4gICAgICAgIH0gLy8gVXBkYXRlIHNpemVcblxuXG4gICAgICAgIHN3aXBlci51cGRhdGVTaXplKCk7IC8vIFVwZGF0ZSBzbGlkZXNcblxuICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykge1xuICAgICAgICAgIHN3aXBlci5jaGVja092ZXJmbG93KCk7XG4gICAgICAgIH0gLy8gU2V0IEdyYWIgQ3Vyc29yXG5cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yICYmIHN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnByZWxvYWRJbWFnZXMpIHtcbiAgICAgICAgICBzd2lwZXIucHJlbG9hZEltYWdlcygpO1xuICAgICAgICB9IC8vIFNsaWRlIFRvIEluaXRpYWwgU2xpZGVcblxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIucGFyYW1zLmluaXRpYWxTbGlkZSArIHN3aXBlci5sb29wZWRTbGlkZXMsIDAsIHN3aXBlci5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUsIDAsIHN3aXBlci5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gLy8gQXR0YWNoIGV2ZW50c1xuXG5cbiAgICAgICAgc3dpcGVyLmF0dGFjaEV2ZW50cygpOyAvLyBJbml0IEZsYWdcblxuICAgICAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSB0cnVlOyAvLyBFbWl0XG5cbiAgICAgICAgc3dpcGVyLmVtaXQoJ2luaXQnKTtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2FmdGVySW5pdCcpO1xuICAgICAgICByZXR1cm4gc3dpcGVyO1xuICAgICAgfVxuXG4gICAgICBkZXN0cm95KGRlbGV0ZUluc3RhbmNlID0gdHJ1ZSwgY2xlYW5TdHlsZXMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgJGVsLFxuICAgICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgICAgc2xpZGVzXG4gICAgICAgIH0gPSBzd2lwZXI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zID09PSAndW5kZWZpbmVkJyB8fCBzd2lwZXIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlRGVzdHJveScpOyAvLyBJbml0IEZsYWdcblxuICAgICAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8gRGV0YWNoIGV2ZW50c1xuXG4gICAgICAgIHN3aXBlci5kZXRhY2hFdmVudHMoKTsgLy8gRGVzdHJveSBsb29wXG5cbiAgICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgICAgIH0gLy8gQ2xlYW51cCBzdHlsZXNcblxuXG4gICAgICAgIGlmIChjbGVhblN0eWxlcykge1xuICAgICAgICAgIHN3aXBlci5yZW1vdmVDbGFzc2VzKCk7XG4gICAgICAgICAgJGVsLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICAgICAgJHdyYXBwZXJFbC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXG4gICAgICAgICAgaWYgKHNsaWRlcyAmJiBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzbGlkZXMucmVtb3ZlQ2xhc3MoW3BhcmFtcy5zbGlkZVZpc2libGVDbGFzcywgcGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MsIHBhcmFtcy5zbGlkZU5leHRDbGFzcywgcGFyYW1zLnNsaWRlUHJldkNsYXNzXS5qb2luKCcgJykpLnJlbW92ZUF0dHIoJ3N0eWxlJykucmVtb3ZlQXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnZGVzdHJveScpOyAvLyBEZXRhY2ggZW1pdHRlciBldmVudHNcblxuICAgICAgICBPYmplY3Qua2V5cyhzd2lwZXIuZXZlbnRzTGlzdGVuZXJzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgICAgc3dpcGVyLm9mZihldmVudE5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGVsZXRlSW5zdGFuY2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc3dpcGVyLiRlbFswXS5zd2lwZXIgPSBudWxsO1xuICAgICAgICAgIGRlbGV0ZVByb3BzKHN3aXBlcik7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBleHRlbmREZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgICAgICBleHRlbmQoZXh0ZW5kZWREZWZhdWx0cywgbmV3RGVmYXVsdHMpO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgZ2V0IGV4dGVuZGVkRGVmYXVsdHMoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmRlZERlZmF1bHRzO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBpbnN0YWxsTW9kdWxlKG1vZCkge1xuICAgICAgICBpZiAoIVN3aXBlci5wcm90b3R5cGUuX19tb2R1bGVzX18pIFN3aXBlci5wcm90b3R5cGUuX19tb2R1bGVzX18gPSBbXTtcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IFN3aXBlci5wcm90b3R5cGUuX19tb2R1bGVzX187XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2QgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlcy5pbmRleE9mKG1vZCkgPCAwKSB7XG4gICAgICAgICAgbW9kdWxlcy5wdXNoKG1vZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGljIHVzZShtb2R1bGUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW9kdWxlKSkge1xuICAgICAgICAgIG1vZHVsZS5mb3JFYWNoKG0gPT4gU3dpcGVyLmluc3RhbGxNb2R1bGUobSkpO1xuICAgICAgICAgIHJldHVybiBTd2lwZXI7XG4gICAgICAgIH1cblxuICAgICAgICBTd2lwZXIuaW5zdGFsbE1vZHVsZShtb2R1bGUpO1xuICAgICAgICByZXR1cm4gU3dpcGVyO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMocHJvdG90eXBlcykuZm9yRWFjaChwcm90b3R5cGVHcm91cCA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXSkuZm9yRWFjaChwcm90b01ldGhvZCA9PiB7XG4gICAgICAgIFN3aXBlci5wcm90b3R5cGVbcHJvdG9NZXRob2RdID0gcHJvdG90eXBlc1twcm90b3R5cGVHcm91cF1bcHJvdG9NZXRob2RdO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgU3dpcGVyLnVzZShbUmVzaXplLCBPYnNlcnZlcl0pO1xuXG4gICAgZnVuY3Rpb24gVmlydHVhbCh7XG4gICAgICBzd2lwZXIsXG4gICAgICBleHRlbmRQYXJhbXMsXG4gICAgICBvblxuICAgIH0pIHtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIHZpcnR1YWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzbGlkZXM6IFtdLFxuICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgIHJlbmRlclNsaWRlOiBudWxsLFxuICAgICAgICAgIHJlbmRlckV4dGVybmFsOiBudWxsLFxuICAgICAgICAgIHJlbmRlckV4dGVybmFsVXBkYXRlOiB0cnVlLFxuICAgICAgICAgIGFkZFNsaWRlc0JlZm9yZTogMCxcbiAgICAgICAgICBhZGRTbGlkZXNBZnRlcjogMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxldCBjc3NNb2RlVGltZW91dDtcbiAgICAgIHN3aXBlci52aXJ0dWFsID0ge1xuICAgICAgICBjYWNoZToge30sXG4gICAgICAgIGZyb206IHVuZGVmaW5lZCxcbiAgICAgICAgdG86IHVuZGVmaW5lZCxcbiAgICAgICAgc2xpZGVzOiBbXSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBzbGlkZXNHcmlkOiBbXVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gcmVuZGVyU2xpZGUoc2xpZGUsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMudmlydHVhbDtcblxuICAgICAgICBpZiAocGFyYW1zLmNhY2hlICYmIHN3aXBlci52aXJ0dWFsLmNhY2hlW2luZGV4XSkge1xuICAgICAgICAgIHJldHVybiBzd2lwZXIudmlydHVhbC5jYWNoZVtpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCAkc2xpZGVFbCA9IHBhcmFtcy5yZW5kZXJTbGlkZSA/ICQocGFyYW1zLnJlbmRlclNsaWRlLmNhbGwoc3dpcGVyLCBzbGlkZSwgaW5kZXgpKSA6ICQoYDxkaXYgY2xhc3M9XCIke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31cIiBkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7aW5kZXh9XCI+JHtzbGlkZX08L2Rpdj5gKTtcbiAgICAgICAgaWYgKCEkc2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpKSAkc2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIGluZGV4KTtcbiAgICAgICAgaWYgKHBhcmFtcy5jYWNoZSkgc3dpcGVyLnZpcnR1YWwuY2FjaGVbaW5kZXhdID0gJHNsaWRlRWw7XG4gICAgICAgIHJldHVybiAkc2xpZGVFbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKGZvcmNlKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3LFxuICAgICAgICAgIHNsaWRlc1Blckdyb3VwLFxuICAgICAgICAgIGNlbnRlcmVkU2xpZGVzXG4gICAgICAgIH0gPSBzd2lwZXIucGFyYW1zO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYWRkU2xpZGVzQmVmb3JlLFxuICAgICAgICAgIGFkZFNsaWRlc0FmdGVyXG4gICAgICAgIH0gPSBzd2lwZXIucGFyYW1zLnZpcnR1YWw7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmcm9tOiBwcmV2aW91c0Zyb20sXG4gICAgICAgICAgdG86IHByZXZpb3VzVG8sXG4gICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgIHNsaWRlc0dyaWQ6IHByZXZpb3VzU2xpZGVzR3JpZCxcbiAgICAgICAgICBvZmZzZXQ6IHByZXZpb3VzT2Zmc2V0XG4gICAgICAgIH0gPSBzd2lwZXIudmlydHVhbDtcblxuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggfHwgMDtcbiAgICAgICAgbGV0IG9mZnNldFByb3A7XG4gICAgICAgIGlmIChzd2lwZXIucnRsVHJhbnNsYXRlKSBvZmZzZXRQcm9wID0gJ3JpZ2h0JztlbHNlIG9mZnNldFByb3AgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgICAgbGV0IHNsaWRlc0FmdGVyO1xuICAgICAgICBsZXQgc2xpZGVzQmVmb3JlO1xuXG4gICAgICAgIGlmIChjZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIHNsaWRlc0FmdGVyID0gTWF0aC5mbG9vcihzbGlkZXNQZXJWaWV3IC8gMikgKyBzbGlkZXNQZXJHcm91cCArIGFkZFNsaWRlc0FmdGVyO1xuICAgICAgICAgIHNsaWRlc0JlZm9yZSA9IE1hdGguZmxvb3Ioc2xpZGVzUGVyVmlldyAvIDIpICsgc2xpZGVzUGVyR3JvdXAgKyBhZGRTbGlkZXNCZWZvcmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2xpZGVzQWZ0ZXIgPSBzbGlkZXNQZXJWaWV3ICsgKHNsaWRlc1Blckdyb3VwIC0gMSkgKyBhZGRTbGlkZXNBZnRlcjtcbiAgICAgICAgICBzbGlkZXNCZWZvcmUgPSBzbGlkZXNQZXJHcm91cCArIGFkZFNsaWRlc0JlZm9yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1heCgoYWN0aXZlSW5kZXggfHwgMCkgLSBzbGlkZXNCZWZvcmUsIDApO1xuICAgICAgICBjb25zdCB0byA9IE1hdGgubWluKChhY3RpdmVJbmRleCB8fCAwKSArIHNsaWRlc0FmdGVyLCBzbGlkZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IChzd2lwZXIuc2xpZGVzR3JpZFtmcm9tXSB8fCAwKSAtIChzd2lwZXIuc2xpZGVzR3JpZFswXSB8fCAwKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIudmlydHVhbCwge1xuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIHNsaWRlc0dyaWQ6IHN3aXBlci5zbGlkZXNHcmlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uUmVuZGVyZWQoKSB7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLmxhenkgJiYgc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHN3aXBlci5sYXp5LmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldmlvdXNGcm9tID09PSBmcm9tICYmIHByZXZpb3VzVG8gPT09IHRvICYmICFmb3JjZSkge1xuICAgICAgICAgIGlmIChzd2lwZXIuc2xpZGVzR3JpZCAhPT0gcHJldmlvdXNTbGlkZXNHcmlkICYmIG9mZnNldCAhPT0gcHJldmlvdXNPZmZzZXQpIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZXMuY3NzKG9mZnNldFByb3AsIGAke29mZnNldH1weGApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWwpIHtcbiAgICAgICAgICBzd2lwZXIucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWwuY2FsbChzd2lwZXIsIHtcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHNsaWRlczogZnVuY3Rpb24gZ2V0U2xpZGVzKCkge1xuICAgICAgICAgICAgICBjb25zdCBzbGlkZXNUb1JlbmRlciA9IFtdO1xuXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDw9IHRvOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzbGlkZXNUb1JlbmRlci5wdXNoKHNsaWRlc1tpXSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gc2xpZGVzVG9SZW5kZXI7XG4gICAgICAgICAgICB9KClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWxVcGRhdGUpIHtcbiAgICAgICAgICAgIG9uUmVuZGVyZWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmVwZW5kSW5kZXhlcyA9IFtdO1xuICAgICAgICBjb25zdCBhcHBlbmRJbmRleGVzID0gW107XG5cbiAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwuZmluZChgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWApLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSBwcmV2aW91c0Zyb207IGkgPD0gcHJldmlvdXNUbzsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGZyb20gfHwgaSA+IHRvKSB7XG4gICAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsLmZpbmQoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2l9XCJdYCkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSA+PSBmcm9tICYmIGkgPD0gdG8pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldmlvdXNUbyA9PT0gJ3VuZGVmaW5lZCcgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgYXBwZW5kSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGkgPiBwcmV2aW91c1RvKSBhcHBlbmRJbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgIGlmIChpIDwgcHJldmlvdXNGcm9tKSBwcmVwZW5kSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEluZGV4ZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwuYXBwZW5kKHJlbmRlclNsaWRlKHNsaWRlc1tpbmRleF0sIGluZGV4KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmVwZW5kSW5kZXhlcy5zb3J0KChhLCBiKSA9PiBiIC0gYSkuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwucHJlcGVuZChyZW5kZXJTbGlkZShzbGlkZXNbaW5kZXhdLCBpbmRleCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oJy5zd2lwZXItc2xpZGUnKS5jc3Mob2Zmc2V0UHJvcCwgYCR7b2Zmc2V0fXB4YCk7XG4gICAgICAgIG9uUmVuZGVyZWQoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXBwZW5kU2xpZGUoc2xpZGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2xpZGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHNsaWRlc1tpXSkgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnB1c2goc2xpZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnB1c2goc2xpZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJlcGVuZFNsaWRlKHNsaWRlcykge1xuICAgICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcbiAgICAgICAgbGV0IG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXggKyAxO1xuICAgICAgICBsZXQgbnVtYmVyT2ZOZXdTbGlkZXMgPSAxO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNsaWRlcykpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHNsaWRlc1tpXSkgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnVuc2hpZnQoc2xpZGVzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICsgc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgICBudW1iZXJPZk5ld1NsaWRlcyA9IHNsaWRlcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnVuc2hpZnQoc2xpZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwuY2FjaGUpIHtcbiAgICAgICAgICBjb25zdCBjYWNoZSA9IHN3aXBlci52aXJ0dWFsLmNhY2hlO1xuICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMoY2FjaGUpLmZvckVhY2goY2FjaGVkSW5kZXggPT4ge1xuICAgICAgICAgICAgY29uc3QgJGNhY2hlZEVsID0gY2FjaGVbY2FjaGVkSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkRWxJbmRleCA9ICRjYWNoZWRFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xuXG4gICAgICAgICAgICBpZiAoY2FjaGVkRWxJbmRleCkge1xuICAgICAgICAgICAgICAkY2FjaGVkRWwuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnLCBwYXJzZUludChjYWNoZWRFbEluZGV4LCAxMCkgKyBudW1iZXJPZk5ld1NsaWRlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0NhY2hlW3BhcnNlSW50KGNhY2hlZEluZGV4LCAxMCkgKyBudW1iZXJPZk5ld1NsaWRlc10gPSAkY2FjaGVkRWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3dpcGVyLnZpcnR1YWwuY2FjaGUgPSBuZXdDYWNoZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZSh0cnVlKTtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXgsIDApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1vdmVTbGlkZShzbGlkZXNJbmRleGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2xpZGVzSW5kZXhlcyA9PT0gJ3VuZGVmaW5lZCcgfHwgc2xpZGVzSW5kZXhlcyA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2xpZGVzSW5kZXhlcykpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc2xpZGVzSW5kZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnNwbGljZShzbGlkZXNJbmRleGVzW2ldLCAxKTtcblxuICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5jYWNoZSkge1xuICAgICAgICAgICAgICBkZWxldGUgc3dpcGVyLnZpcnR1YWwuY2FjaGVbc2xpZGVzSW5kZXhlc1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzbGlkZXNJbmRleGVzW2ldIDwgYWN0aXZlSW5kZXgpIGFjdGl2ZUluZGV4IC09IDE7XG4gICAgICAgICAgICBhY3RpdmVJbmRleCA9IE1hdGgubWF4KGFjdGl2ZUluZGV4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnNwbGljZShzbGlkZXNJbmRleGVzLCAxKTtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwuY2FjaGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzd2lwZXIudmlydHVhbC5jYWNoZVtzbGlkZXNJbmRleGVzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2xpZGVzSW5kZXhlcyA8IGFjdGl2ZUluZGV4KSBhY3RpdmVJbmRleCAtPSAxO1xuICAgICAgICAgIGFjdGl2ZUluZGV4ID0gTWF0aC5tYXgoYWN0aXZlSW5kZXgsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlKHRydWUpO1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCwgMCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUFsbFNsaWRlcygpIHtcbiAgICAgICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzID0gW107XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5jYWNoZSkge1xuICAgICAgICAgIHN3aXBlci52aXJ0dWFsLmNhY2hlID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUodHJ1ZSk7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKDAsIDApO1xuICAgICAgfVxuXG4gICAgICBvbignYmVmb3JlSW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBzd2lwZXIudmlydHVhbC5zbGlkZXMgPSBzd2lwZXIucGFyYW1zLnZpcnR1YWwuc2xpZGVzO1xuICAgICAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc312aXJ0dWFsYCk7XG4gICAgICAgIHN3aXBlci5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlKSB7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ3NldFRyYW5zbGF0ZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUgJiYgIXN3aXBlci5faW1tZWRpYXRlVmlydHVhbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChjc3NNb2RlVGltZW91dCk7XG4gICAgICAgICAgY3NzTW9kZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2luaXQgdXBkYXRlIHJlc2l6ZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzZXRDU1NQcm9wZXJ0eShzd2lwZXIud3JhcHBlckVsLCAnLS1zd2lwZXItdmlydHVhbC1zaXplJywgYCR7c3dpcGVyLnZpcnR1YWxTaXplfXB4YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIudmlydHVhbCwge1xuICAgICAgICBhcHBlbmRTbGlkZSxcbiAgICAgICAgcHJlcGVuZFNsaWRlLFxuICAgICAgICByZW1vdmVTbGlkZSxcbiAgICAgICAgcmVtb3ZlQWxsU2xpZGVzLFxuICAgICAgICB1cGRhdGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG4gICAgZnVuY3Rpb24gS2V5Ym9hcmQoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgb24sXG4gICAgICBlbWl0XG4gICAgfSkge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBzd2lwZXIua2V5Ym9hcmQgPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZXh0ZW5kUGFyYW1zKHtcbiAgICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBvbmx5SW5WaWV3cG9ydDogdHJ1ZSxcbiAgICAgICAgICBwYWdlVXBEb3duOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcnRsVHJhbnNsYXRlOiBydGxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgbGV0IGUgPSBldmVudDtcbiAgICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDsgLy8ganF1ZXJ5IGZpeFxuXG4gICAgICAgIGNvbnN0IGtjID0gZS5rZXlDb2RlIHx8IGUuY2hhckNvZGU7XG4gICAgICAgIGNvbnN0IHBhZ2VVcERvd24gPSBzd2lwZXIucGFyYW1zLmtleWJvYXJkLnBhZ2VVcERvd247XG4gICAgICAgIGNvbnN0IGlzUGFnZVVwID0gcGFnZVVwRG93biAmJiBrYyA9PT0gMzM7XG4gICAgICAgIGNvbnN0IGlzUGFnZURvd24gPSBwYWdlVXBEb3duICYmIGtjID09PSAzNDtcbiAgICAgICAgY29uc3QgaXNBcnJvd0xlZnQgPSBrYyA9PT0gMzc7XG4gICAgICAgIGNvbnN0IGlzQXJyb3dSaWdodCA9IGtjID09PSAzOTtcbiAgICAgICAgY29uc3QgaXNBcnJvd1VwID0ga2MgPT09IDM4O1xuICAgICAgICBjb25zdCBpc0Fycm93RG93biA9IGtjID09PSA0MDsgLy8gRGlyZWN0aW9ucyBsb2Nrc1xuXG4gICAgICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgaXNBcnJvd1JpZ2h0IHx8IHN3aXBlci5pc1ZlcnRpY2FsKCkgJiYgaXNBcnJvd0Rvd24gfHwgaXNQYWdlRG93bikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlUHJldiAmJiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpICYmIGlzQXJyb3dMZWZ0IHx8IHN3aXBlci5pc1ZlcnRpY2FsKCkgJiYgaXNBcnJvd1VwIHx8IGlzUGFnZVVwKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnNoaWZ0S2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZSAmJiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJykpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMua2V5Ym9hcmQub25seUluVmlld3BvcnQgJiYgKGlzUGFnZVVwIHx8IGlzUGFnZURvd24gfHwgaXNBcnJvd0xlZnQgfHwgaXNBcnJvd1JpZ2h0IHx8IGlzQXJyb3dVcCB8fCBpc0Fycm93RG93bikpIHtcbiAgICAgICAgICBsZXQgaW5WaWV3ID0gZmFsc2U7IC8vIENoZWNrIHRoYXQgc3dpcGVyIHNob3VsZCBiZSBpbnNpZGUgb2YgdmlzaWJsZSBhcmVhIG9mIHdpbmRvd1xuXG4gICAgICAgICAgaWYgKHN3aXBlci4kZWwucGFyZW50cyhgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWApLmxlbmd0aCA+IDAgJiYgc3dpcGVyLiRlbC5wYXJlbnRzKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9YCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0ICRlbCA9IHN3aXBlci4kZWw7XG4gICAgICAgICAgY29uc3Qgc3dpcGVyV2lkdGggPSAkZWxbMF0uY2xpZW50V2lkdGg7XG4gICAgICAgICAgY29uc3Qgc3dpcGVySGVpZ2h0ID0gJGVsWzBdLmNsaWVudEhlaWdodDtcbiAgICAgICAgICBjb25zdCB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgIGNvbnN0IHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICBjb25zdCBzd2lwZXJPZmZzZXQgPSBzd2lwZXIuJGVsLm9mZnNldCgpO1xuICAgICAgICAgIGlmIChydGwpIHN3aXBlck9mZnNldC5sZWZ0IC09IHN3aXBlci4kZWxbMF0uc2Nyb2xsTGVmdDtcbiAgICAgICAgICBjb25zdCBzd2lwZXJDb29yZCA9IFtbc3dpcGVyT2Zmc2V0LmxlZnQsIHN3aXBlck9mZnNldC50b3BdLCBbc3dpcGVyT2Zmc2V0LmxlZnQgKyBzd2lwZXJXaWR0aCwgc3dpcGVyT2Zmc2V0LnRvcF0sIFtzd2lwZXJPZmZzZXQubGVmdCwgc3dpcGVyT2Zmc2V0LnRvcCArIHN3aXBlckhlaWdodF0sIFtzd2lwZXJPZmZzZXQubGVmdCArIHN3aXBlcldpZHRoLCBzd2lwZXJPZmZzZXQudG9wICsgc3dpcGVySGVpZ2h0XV07XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlckNvb3JkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHN3aXBlckNvb3JkW2ldO1xuXG4gICAgICAgICAgICBpZiAocG9pbnRbMF0gPj0gMCAmJiBwb2ludFswXSA8PSB3aW5kb3dXaWR0aCAmJiBwb2ludFsxXSA+PSAwICYmIHBvaW50WzFdIDw9IHdpbmRvd0hlaWdodCkge1xuICAgICAgICAgICAgICBpZiAocG9pbnRbMF0gPT09IDAgJiYgcG9pbnRbMV0gPT09IDApIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgICAgICAgaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWluVmlldykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICBpZiAoaXNQYWdlVXAgfHwgaXNQYWdlRG93biB8fCBpc0Fycm93TGVmdCB8fCBpc0Fycm93UmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7ZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKChpc1BhZ2VEb3duIHx8IGlzQXJyb3dSaWdodCkgJiYgIXJ0bCB8fCAoaXNQYWdlVXAgfHwgaXNBcnJvd0xlZnQpICYmIHJ0bCkgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgICAgICAgIGlmICgoaXNQYWdlVXAgfHwgaXNBcnJvd0xlZnQpICYmICFydGwgfHwgKGlzUGFnZURvd24gfHwgaXNBcnJvd1JpZ2h0KSAmJiBydGwpIHN3aXBlci5zbGlkZVByZXYoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNQYWdlVXAgfHwgaXNQYWdlRG93biB8fCBpc0Fycm93VXAgfHwgaXNBcnJvd0Rvd24pIHtcbiAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7ZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUGFnZURvd24gfHwgaXNBcnJvd0Rvd24pIHN3aXBlci5zbGlkZU5leHQoKTtcbiAgICAgICAgICBpZiAoaXNQYWdlVXAgfHwgaXNBcnJvd1VwKSBzd2lwZXIuc2xpZGVQcmV2KCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KCdrZXlQcmVzcycsIGtjKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgICBpZiAoc3dpcGVyLmtleWJvYXJkLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgJChkb2N1bWVudCkub24oJ2tleWRvd24nLCBoYW5kbGUpO1xuICAgICAgICBzd2lwZXIua2V5Ym9hcmQuZW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLmtleWJvYXJkLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKCdrZXlkb3duJywgaGFuZGxlKTtcbiAgICAgICAgc3dpcGVyLmtleWJvYXJkLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmtleWJvYXJkLmVuYWJsZWQpIHtcbiAgICAgICAgICBlbmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5rZXlib2FyZC5lbmFibGVkKSB7XG4gICAgICAgICAgZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLmtleWJvYXJkLCB7XG4gICAgICAgIGVuYWJsZSxcbiAgICAgICAgZGlzYWJsZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbiAgICBmdW5jdGlvbiBNb3VzZXdoZWVsKHtcbiAgICAgIHN3aXBlcixcbiAgICAgIGV4dGVuZFBhcmFtcyxcbiAgICAgIG9uLFxuICAgICAgZW1pdFxuICAgIH0pIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgZXh0ZW5kUGFyYW1zKHtcbiAgICAgICAgbW91c2V3aGVlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcbiAgICAgICAgICBpbnZlcnQ6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlVG9BeGlzOiBmYWxzZSxcbiAgICAgICAgICBzZW5zaXRpdml0eTogMSxcbiAgICAgICAgICBldmVudHNUYXJnZXQ6ICdjb250YWluZXInLFxuICAgICAgICAgIHRocmVzaG9sZERlbHRhOiBudWxsLFxuICAgICAgICAgIHRocmVzaG9sZFRpbWU6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzd2lwZXIubW91c2V3aGVlbCA9IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgdGltZW91dDtcbiAgICAgIGxldCBsYXN0U2Nyb2xsVGltZSA9IG5vdygpO1xuICAgICAgbGV0IGxhc3RFdmVudEJlZm9yZVNuYXA7XG4gICAgICBjb25zdCByZWNlbnRXaGVlbEV2ZW50cyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBub3JtYWxpemUoZSkge1xuICAgICAgICAvLyBSZWFzb25hYmxlIGRlZmF1bHRzXG4gICAgICAgIGNvbnN0IFBJWEVMX1NURVAgPSAxMDtcbiAgICAgICAgY29uc3QgTElORV9IRUlHSFQgPSA0MDtcbiAgICAgICAgY29uc3QgUEFHRV9IRUlHSFQgPSA4MDA7XG4gICAgICAgIGxldCBzWCA9IDA7XG4gICAgICAgIGxldCBzWSA9IDA7IC8vIHNwaW5YLCBzcGluWVxuXG4gICAgICAgIGxldCBwWCA9IDA7XG4gICAgICAgIGxldCBwWSA9IDA7IC8vIHBpeGVsWCwgcGl4ZWxZXG4gICAgICAgIC8vIExlZ2FjeVxuXG4gICAgICAgIGlmICgnZGV0YWlsJyBpbiBlKSB7XG4gICAgICAgICAgc1kgPSBlLmRldGFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnd2hlZWxEZWx0YScgaW4gZSkge1xuICAgICAgICAgIHNZID0gLWUud2hlZWxEZWx0YSAvIDEyMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnd2hlZWxEZWx0YVknIGluIGUpIHtcbiAgICAgICAgICBzWSA9IC1lLndoZWVsRGVsdGFZIC8gMTIwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCd3aGVlbERlbHRhWCcgaW4gZSkge1xuICAgICAgICAgIHNYID0gLWUud2hlZWxEZWx0YVggLyAxMjA7XG4gICAgICAgIH0gLy8gc2lkZSBzY3JvbGxpbmcgb24gRkYgd2l0aCBET01Nb3VzZVNjcm9sbFxuXG5cbiAgICAgICAgaWYgKCdheGlzJyBpbiBlICYmIGUuYXhpcyA9PT0gZS5IT1JJWk9OVEFMX0FYSVMpIHtcbiAgICAgICAgICBzWCA9IHNZO1xuICAgICAgICAgIHNZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBYID0gc1ggKiBQSVhFTF9TVEVQO1xuICAgICAgICBwWSA9IHNZICogUElYRUxfU1RFUDtcblxuICAgICAgICBpZiAoJ2RlbHRhWScgaW4gZSkge1xuICAgICAgICAgIHBZID0gZS5kZWx0YVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2RlbHRhWCcgaW4gZSkge1xuICAgICAgICAgIHBYID0gZS5kZWx0YVg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiAhcFgpIHtcbiAgICAgICAgICAvLyBpZiB1c2VyIHNjcm9sbHMgd2l0aCBzaGlmdCBoZSB3YW50cyBob3Jpem9udGFsIHNjcm9sbFxuICAgICAgICAgIHBYID0gcFk7XG4gICAgICAgICAgcFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwWCB8fCBwWSkgJiYgZS5kZWx0YU1vZGUpIHtcbiAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGRlbHRhIGluIExJTkUgdW5pdHNcbiAgICAgICAgICAgIHBYICo9IExJTkVfSEVJR0hUO1xuICAgICAgICAgICAgcFkgKj0gTElORV9IRUlHSFQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlbHRhIGluIFBBR0UgdW5pdHNcbiAgICAgICAgICAgIHBYICo9IFBBR0VfSEVJR0hUO1xuICAgICAgICAgICAgcFkgKj0gUEFHRV9IRUlHSFQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEZhbGwtYmFjayBpZiBzcGluIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG5cblxuICAgICAgICBpZiAocFggJiYgIXNYKSB7XG4gICAgICAgICAgc1ggPSBwWCA8IDEgPyAtMSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocFkgJiYgIXNZKSB7XG4gICAgICAgICAgc1kgPSBwWSA8IDEgPyAtMSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwaW5YOiBzWCxcbiAgICAgICAgICBzcGluWTogc1ksXG4gICAgICAgICAgcGl4ZWxYOiBwWCxcbiAgICAgICAgICBwaXhlbFk6IHBZXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRW50ZXIoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLm1vdXNlRW50ZXJlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLm1vdXNlRW50ZXJlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhbmltYXRlU2xpZGVyKG5ld0V2ZW50KSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGEgJiYgbmV3RXZlbnQuZGVsdGEgPCBzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGEpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGlmIGRlbHRhIG9mIHdoZWVsIHNjcm9sbCBkZWx0YSBpcyBiZWxvdyBjb25maWd1cmVkIHRocmVzaG9sZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkVGltZSAmJiBub3coKSAtIGxhc3RTY3JvbGxUaW1lIDwgc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLnRocmVzaG9sZFRpbWUpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGlmIHRpbWUgYmV0d2VlbiBzY3JvbGxzIGlzIGJlbG93IGNvbmZpZ3VyZWQgdGhyZXNob2xkXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIElmIHRoZSBtb3ZlbWVudCBpcyBOT1QgYmlnIGVub3VnaCBhbmRcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgdGltZSB0aGUgdXNlciBzY3JvbGxlZCB3YXMgdG9vIGNsb3NlIHRvIHRoZSBjdXJyZW50IG9uZSAoYXZvaWQgY29udGludW91c2x5IHRyaWdnZXJpbmcgdGhlIHNsaWRlcik6XG4gICAgICAgIC8vICAgRG9uJ3QgZ28gYW55IGZ1cnRoZXIgKGF2b2lkIGluc2lnbmlmaWNhbnQgc2Nyb2xsIG1vdmVtZW50KS5cblxuXG4gICAgICAgIGlmIChuZXdFdmVudC5kZWx0YSA+PSA2ICYmIG5vdygpIC0gbGFzdFNjcm9sbFRpbWUgPCA2MCkge1xuICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBhcyBhIGRlZmF1bHRcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBJZiB1c2VyIGlzIHNjcm9sbGluZyB0b3dhcmRzIHRoZSBlbmQ6XG4gICAgICAgIC8vICAgSWYgdGhlIHNsaWRlciBoYXNuJ3QgaGl0IHRoZSBsYXRlc3Qgc2xpZGUgb3JcbiAgICAgICAgLy8gICBpZiB0aGUgc2xpZGVyIGlzIGEgbG9vcCBhbmRcbiAgICAgICAgLy8gICBpZiB0aGUgc2xpZGVyIGlzbid0IG1vdmluZyByaWdodCBub3c6XG4gICAgICAgIC8vICAgICBHbyB0byBuZXh0IHNsaWRlIGFuZFxuICAgICAgICAvLyAgICAgZW1pdCBhIHNjcm9sbCBldmVudC5cbiAgICAgICAgLy8gRWxzZSAodGhlIHVzZXIgaXMgc2Nyb2xsaW5nIHRvd2FyZHMgdGhlIGJlZ2lubmluZykgYW5kXG4gICAgICAgIC8vIGlmIHRoZSBzbGlkZXIgaGFzbid0IGhpdCB0aGUgZmlyc3Qgc2xpZGUgb3JcbiAgICAgICAgLy8gaWYgdGhlIHNsaWRlciBpcyBhIGxvb3AgYW5kXG4gICAgICAgIC8vIGlmIHRoZSBzbGlkZXIgaXNuJ3QgbW92aW5nIHJpZ2h0IG5vdzpcbiAgICAgICAgLy8gICBHbyB0byBwcmV2IHNsaWRlIGFuZFxuICAgICAgICAvLyAgIGVtaXQgYSBzY3JvbGwgZXZlbnQuXG5cblxuICAgICAgICBpZiAobmV3RXZlbnQuZGlyZWN0aW9uIDwgMCkge1xuICAgICAgICAgIGlmICgoIXN3aXBlci5pc0VuZCB8fCBzd2lwZXIucGFyYW1zLmxvb3ApICYmICFzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVOZXh0KCk7XG4gICAgICAgICAgICBlbWl0KCdzY3JvbGwnLCBuZXdFdmVudC5yYXcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgoIXN3aXBlci5pc0JlZ2lubmluZyB8fCBzd2lwZXIucGFyYW1zLmxvb3ApICYmICFzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgICAgICAgIGVtaXQoJ3Njcm9sbCcsIG5ld0V2ZW50LnJhdyk7XG4gICAgICAgIH0gLy8gSWYgeW91IGdvdCBoZXJlIGlzIGJlY2F1c2UgYW4gYW5pbWF0aW9uIGhhcyBiZWVuIHRyaWdnZXJlZCBzbyBzdG9yZSB0aGUgY3VycmVudCB0aW1lXG5cblxuICAgICAgICBsYXN0U2Nyb2xsVGltZSA9IG5ldyB3aW5kb3cuRGF0ZSgpLmdldFRpbWUoKTsgLy8gUmV0dXJuIGZhbHNlIGFzIGEgZGVmYXVsdFxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVsZWFzZVNjcm9sbChuZXdFdmVudCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm1vdXNld2hlZWw7XG5cbiAgICAgICAgaWYgKG5ld0V2ZW50LmRpcmVjdGlvbiA8IDApIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgcGFyYW1zLnJlbGVhc2VPbkVkZ2VzKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdHJ1ZSB0byBhbmltYXRlIHNjcm9sbCBvbiBlZGdlc1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0JlZ2lubmluZyAmJiAhc3dpcGVyLnBhcmFtcy5sb29wICYmIHBhcmFtcy5yZWxlYXNlT25FZGdlcykge1xuICAgICAgICAgIC8vIFJldHVybiB0cnVlIHRvIGFuaW1hdGUgc2Nyb2xsIG9uIGVkZ2VzXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShldmVudCkge1xuICAgICAgICBsZXQgZSA9IGV2ZW50O1xuICAgICAgICBsZXQgZGlzYWJsZVBhcmVudFN3aXBlciA9IHRydWU7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGFyZ2V0ID0gc3dpcGVyLiRlbDtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCAhPT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgICB0YXJnZXQgPSAkKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzd2lwZXIubW91c2VFbnRlcmVkICYmICF0YXJnZXRbMF0uY29udGFpbnMoZS50YXJnZXQpICYmICFwYXJhbXMucmVsZWFzZU9uRWRnZXMpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50OyAvLyBqcXVlcnkgZml4XG5cbiAgICAgICAgbGV0IGRlbHRhID0gMDtcbiAgICAgICAgY29uc3QgcnRsRmFjdG9yID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5vcm1hbGl6ZShlKTtcblxuICAgICAgICBpZiAocGFyYW1zLmZvcmNlVG9BeGlzKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRhdGEucGl4ZWxYKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxZKSkgZGVsdGEgPSAtZGF0YS5waXhlbFggKiBydGxGYWN0b3I7ZWxzZSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRhdGEucGl4ZWxZKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxYKSkgZGVsdGEgPSAtZGF0YS5waXhlbFk7ZWxzZSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YSA9IE1hdGguYWJzKGRhdGEucGl4ZWxYKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxZKSA/IC1kYXRhLnBpeGVsWCAqIHJ0bEZhY3RvciA6IC1kYXRhLnBpeGVsWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChwYXJhbXMuaW52ZXJ0KSBkZWx0YSA9IC1kZWx0YTsgLy8gR2V0IHRoZSBzY3JvbGwgcG9zaXRpb25zXG5cbiAgICAgICAgbGV0IHBvc2l0aW9ucyA9IHN3aXBlci5nZXRUcmFuc2xhdGUoKSArIGRlbHRhICogcGFyYW1zLnNlbnNpdGl2aXR5O1xuICAgICAgICBpZiAocG9zaXRpb25zID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkgcG9zaXRpb25zID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICBpZiAocG9zaXRpb25zIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkgcG9zaXRpb25zID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpOyAvLyBXaGVuIGxvb3AgaXMgdHJ1ZTpcbiAgICAgICAgLy8gICAgIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgdHJ1ZS5cbiAgICAgICAgLy8gV2hlbiBsb29wIGlzIGZhbHNlOlxuICAgICAgICAvLyAgICAgaWYgdGhlIHNjcm9sbCBwb3NpdGlvbnMgaXMgbm90IG9uIGVkZ2UsXG4gICAgICAgIC8vICAgICB0aGVuIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgdHJ1ZS5cbiAgICAgICAgLy8gICAgIGlmIHRoZSBzY3JvbGwgb24gZWRnZSBwb3NpdGlvbnMsXG4gICAgICAgIC8vICAgICB0aGVuIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgZmFsc2UuXG5cbiAgICAgICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IHN3aXBlci5wYXJhbXMubG9vcCA/IHRydWUgOiAhKHBvc2l0aW9ucyA9PT0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIHx8IHBvc2l0aW9ucyA9PT0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKTtcbiAgICAgICAgaWYgKGRpc2FibGVQYXJlbnRTd2lwZXIgJiYgc3dpcGVyLnBhcmFtcy5uZXN0ZWQpIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmZyZWVNb2RlIHx8ICFzd2lwZXIucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQpIHtcbiAgICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV3IGV2ZW50IGluIGEgdmFyaWFibGUgd2hpY2ggc3RvcmVzIHRoZSByZWxldmFudCBkYXRhXG4gICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgIGRlbHRhOiBNYXRoLmFicyhkZWx0YSksXG4gICAgICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihkZWx0YSksXG4gICAgICAgICAgICByYXc6IGV2ZW50XG4gICAgICAgICAgfTsgLy8gS2VlcCB0aGUgbW9zdCByZWNlbnQgZXZlbnRzXG5cbiAgICAgICAgICBpZiAocmVjZW50V2hlZWxFdmVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHJlY2VudFdoZWVsRXZlbnRzLnNoaWZ0KCk7IC8vIG9ubHkgc3RvcmUgdGhlIGxhc3QgTiBldmVudHNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcmV2RXZlbnQgPSByZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPyByZWNlbnRXaGVlbEV2ZW50c1tyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5wdXNoKG5ld0V2ZW50KTsgLy8gSWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByZXZpb3VzIHJlY29yZGVkIGV2ZW50OlxuICAgICAgICAgIC8vICAgSWYgZGlyZWN0aW9uIGhhcyBjaGFuZ2VkIG9yXG4gICAgICAgICAgLy8gICBpZiB0aGUgc2Nyb2xsIGlzIHF1aWNrZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lOlxuICAgICAgICAgIC8vICAgICBBbmltYXRlIHRoZSBzbGlkZXIuXG4gICAgICAgICAgLy8gRWxzZSAodGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgd2hlZWwgaXMgbW92ZWQpOlxuICAgICAgICAgIC8vICAgICBBbmltYXRlIHRoZSBzbGlkZXIuXG5cbiAgICAgICAgICBpZiAocHJldkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAobmV3RXZlbnQuZGlyZWN0aW9uICE9PSBwcmV2RXZlbnQuZGlyZWN0aW9uIHx8IG5ld0V2ZW50LmRlbHRhID4gcHJldkV2ZW50LmRlbHRhIHx8IG5ld0V2ZW50LnRpbWUgPiBwcmV2RXZlbnQudGltZSArIDE1MCkge1xuICAgICAgICAgICAgICBhbmltYXRlU2xpZGVyKG5ld0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5pbWF0ZVNsaWRlcihuZXdFdmVudCk7XG4gICAgICAgICAgfSAvLyBJZiBpdCdzIHRpbWUgdG8gcmVsZWFzZSB0aGUgc2Nyb2xsOlxuICAgICAgICAgIC8vICAgUmV0dXJuIG5vdyBzbyB5b3UgZG9uJ3QgaGl0IHRoZSBwcmV2ZW50RGVmYXVsdC5cblxuXG4gICAgICAgICAgaWYgKHJlbGVhc2VTY3JvbGwobmV3RXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRnJlZW1vZGUgb3Igc2Nyb2xsQ29udGFpbmVyOlxuICAgICAgICAgIC8vIElmIHdlIHJlY2VudGx5IHNuYXBwZWQgYWZ0ZXIgYSBtb21lbnR1bSBzY3JvbGwsIHRoZW4gaWdub3JlIHdoZWVsIGV2ZW50c1xuICAgICAgICAgIC8vIHRvIGdpdmUgdGltZSBmb3IgdGhlIGRlY2VsZXJhdGlvbiB0byBmaW5pc2guIFN0b3AgaWdub3JpbmcgYWZ0ZXIgNTAwIG1zZWNzXG4gICAgICAgICAgLy8gb3IgaWYgaXQncyBhIG5ldyBzY3JvbGwgKGxhcmdlciBkZWx0YSBvciBpbnZlcnNlIHNpZ24gYXMgbGFzdCBldmVudCBiZWZvcmVcbiAgICAgICAgICAvLyBhbiBlbmQtb2YtbW9tZW50dW0gc25hcCkuXG4gICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgIGRlbHRhOiBNYXRoLmFicyhkZWx0YSksXG4gICAgICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihkZWx0YSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGlnbm9yZVdoZWVsRXZlbnRzID0gbGFzdEV2ZW50QmVmb3JlU25hcCAmJiBuZXdFdmVudC50aW1lIDwgbGFzdEV2ZW50QmVmb3JlU25hcC50aW1lICsgNTAwICYmIG5ld0V2ZW50LmRlbHRhIDw9IGxhc3RFdmVudEJlZm9yZVNuYXAuZGVsdGEgJiYgbmV3RXZlbnQuZGlyZWN0aW9uID09PSBsYXN0RXZlbnRCZWZvcmVTbmFwLmRpcmVjdGlvbjtcblxuICAgICAgICAgIGlmICghaWdub3JlV2hlZWxFdmVudHMpIHtcbiAgICAgICAgICAgIGxhc3RFdmVudEJlZm9yZVNuYXAgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpICsgZGVsdGEgKiBwYXJhbXMuc2Vuc2l0aXZpdHk7XG4gICAgICAgICAgICBjb25zdCB3YXNCZWdpbm5pbmcgPSBzd2lwZXIuaXNCZWdpbm5pbmc7XG4gICAgICAgICAgICBjb25zdCB3YXNFbmQgPSBzd2lwZXIuaXNFbmQ7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSBwb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHBvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuXG4gICAgICAgICAgICBpZiAoIXdhc0JlZ2lubmluZyAmJiBzd2lwZXIuaXNCZWdpbm5pbmcgfHwgIXdhc0VuZCAmJiBzd2lwZXIuaXNFbmQpIHtcbiAgICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUuc3RpY2t5KSB7XG4gICAgICAgICAgICAgIC8vIFdoZW4gd2hlZWwgc2Nyb2xsaW5nIHN0YXJ0cyB3aXRoIHN0aWNreSAoYWthIHNuYXApIGVuYWJsZWQsIHRoZW4gZGV0ZWN0XG4gICAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgYSBtb21lbnR1bSBzY3JvbGwgYnkgc3RvcmluZyByZWNlbnQgKE49MTU/KSB3aGVlbCBldmVudHMuXG4gICAgICAgICAgICAgIC8vIDEuIGRvIGFsbCBOIGV2ZW50cyBoYXZlIGRlY3JlYXNpbmcgb3Igc2FtZSAoYWJzb2x1dGUgdmFsdWUpIGRlbHRhP1xuICAgICAgICAgICAgICAvLyAyLiBkaWQgYWxsIE4gZXZlbnRzIGFycml2ZSBpbiB0aGUgbGFzdCBNIChNPTUwMD8pIG1zZWNzP1xuICAgICAgICAgICAgICAvLyAzLiBkb2VzIHRoZSBlYXJsaWVzdCBldmVudCBoYXZlIGFuIChhYnNvbHV0ZSB2YWx1ZSkgZGVsdGEgdGhhdCdzXG4gICAgICAgICAgICAgIC8vICAgIGF0IGxlYXN0IFAgKFA9MT8pIGxhcmdlciB0aGFuIHRoZSBtb3N0IHJlY2VudCBldmVudCdzIGRlbHRhP1xuICAgICAgICAgICAgICAvLyA0LiBkb2VzIHRoZSBsYXRlc3QgZXZlbnQgaGF2ZSBhIGRlbHRhIHRoYXQncyBzbWFsbGVyIHRoYW4gUSAoUT02PykgcGl4ZWxzP1xuICAgICAgICAgICAgICAvLyBJZiAxLTQgYXJlIFwieWVzXCIgdGhlbiB3ZSdyZSBuZWFyIHRoZSBlbmQgb2YgYSBtb21lbnR1bSBzY3JvbGwgZGVjZWxlcmF0aW9uLlxuICAgICAgICAgICAgICAvLyBTbmFwIGltbWVkaWF0ZWx5IGFuZCBpZ25vcmUgcmVtYWluaW5nIHdoZWVsIGV2ZW50cyBpbiB0aGlzIHNjcm9sbC5cbiAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgZm9yIFwicmVtYWluaW5nIHdoZWVsIGV2ZW50cyBpbiB0aGlzIHNjcm9sbFwiIGRldGVybWluYXRpb24uXG4gICAgICAgICAgICAgIC8vIElmIDEtNCBhcmVuJ3Qgc2F0aXNmaWVkLCB0aGVuIHdhaXQgdG8gc25hcCB1bnRpbCA1MDBtcyBhZnRlciB0aGUgbGFzdCBldmVudC5cbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIGlmIChyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5zaGlmdCgpOyAvLyBvbmx5IHN0b3JlIHRoZSBsYXN0IE4gZXZlbnRzXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBwcmV2RXZlbnQgPSByZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPyByZWNlbnRXaGVlbEV2ZW50c1tyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RFdmVudCA9IHJlY2VudFdoZWVsRXZlbnRzWzBdO1xuICAgICAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5wdXNoKG5ld0V2ZW50KTtcblxuICAgICAgICAgICAgICBpZiAocHJldkV2ZW50ICYmIChuZXdFdmVudC5kZWx0YSA+IHByZXZFdmVudC5kZWx0YSB8fCBuZXdFdmVudC5kaXJlY3Rpb24gIT09IHByZXZFdmVudC5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5jcmVhc2luZyBvciByZXZlcnNlLXNpZ24gZGVsdGEgbWVhbnMgdGhlIHVzZXIgc3RhcnRlZCBzY3JvbGxpbmcgYWdhaW4uIENsZWFyIHRoZSB3aGVlbCBldmVudCBsb2cuXG4gICAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlY2VudFdoZWVsRXZlbnRzLmxlbmd0aCA+PSAxNSAmJiBuZXdFdmVudC50aW1lIC0gZmlyc3RFdmVudC50aW1lIDwgNTAwICYmIGZpcnN0RXZlbnQuZGVsdGEgLSBuZXdFdmVudC5kZWx0YSA+PSAxICYmIG5ld0V2ZW50LmRlbHRhIDw9IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBkZWNlbGVyYXRpb24gb2YgYSBtb21lbnR1bSBzY3JvbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAgICAgICAgICAgICAgIC8vIHRvIHdhaXQgZm9yIG1vcmUgZXZlbnRzLiBTbmFwIEFTQVAgb24gdGhlIG5leHQgdGljay5cbiAgICAgICAgICAgICAgICAvLyBBbHNvLCBiZWNhdXNlIHRoZXJlJ3Mgc29tZSByZW1haW5pbmcgbW9tZW50dW0gd2UnbGwgYmlhcyB0aGUgc25hcCBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3Rpb24gb2YgdGhlIG9uZ29pbmcgc2Nyb2xsIGJlY2F1c2UgaXQncyBiZXR0ZXIgVVggZm9yIHRoZSBzY3JvbGwgdG8gc25hcFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGUgc2Nyb2xsIGluc3RlYWQgb2YgcmV2ZXJzaW5nIHRvIHNuYXAuICBUaGVyZWZvcmUsXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbHJlYWR5IHNjcm9sbGVkIG1vcmUgdGhhbiAyMCUgaW4gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBrZWVwIGdvaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IHNuYXBUb1RocmVzaG9sZCA9IGRlbHRhID4gMCA/IDAuOCA6IDAuMjtcbiAgICAgICAgICAgICAgICBsYXN0RXZlbnRCZWZvcmVTbmFwID0gbmV3RXZlbnQ7XG4gICAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3Qoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdW5kZWZpbmVkLCBzbmFwVG9UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgIH0sIDApOyAvLyBubyBkZWxheTsgbW92ZSBvbiBuZXh0IHRpY2tcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGdldCBoZXJlLCB0aGVuIHdlIGhhdmVuJ3QgZGV0ZWN0ZWQgdGhlIGVuZCBvZiBhIG1vbWVudHVtIHNjcm9sbCwgc29cbiAgICAgICAgICAgICAgICAvLyB3ZSdsbCBjb25zaWRlciBhIHNjcm9sbCBcImNvbXBsZXRlXCIgd2hlbiB0aGVyZSBoYXZlbid0IGJlZW4gYW55IHdoZWVsIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIGZvciA1MDBtcy5cbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc25hcFRvVGhyZXNob2xkID0gMC41O1xuICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50QmVmb3JlU25hcCA9IG5ld0V2ZW50O1xuICAgICAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHVuZGVmaW5lZCwgc25hcFRvVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIEVtaXQgZXZlbnRcblxuXG4gICAgICAgICAgICBpZiAoIWlnbm9yZVdoZWVsRXZlbnRzKSBlbWl0KCdzY3JvbGwnLCBlKTsgLy8gU3RvcCBhdXRvcGxheVxuXG4gICAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheSAmJiBzd2lwZXIucGFyYW1zLmF1dG9wbGF5RGlzYWJsZU9uSW50ZXJhY3Rpb24pIHN3aXBlci5hdXRvcGxheS5zdG9wKCk7IC8vIFJldHVybiBwYWdlIHNjcm9sbCBvbiBlZGdlIHBvc2l0aW9uc1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IHN3aXBlci5taW5UcmFuc2xhdGUoKSB8fCBwb3NpdGlvbiA9PT0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGV2ZW50cyhtZXRob2QpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHN3aXBlci4kZWw7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQgIT09ICdjb250YWluZXInKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gJChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFttZXRob2RdKCdtb3VzZWVudGVyJywgaGFuZGxlTW91c2VFbnRlcik7XG4gICAgICAgIHRhcmdldFttZXRob2RdKCdtb3VzZWxlYXZlJywgaGFuZGxlTW91c2VMZWF2ZSk7XG4gICAgICAgIHRhcmdldFttZXRob2RdKCd3aGVlbCcsIGhhbmRsZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBoYW5kbGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZXZlbnRzKCdvbicpO1xuICAgICAgICBzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZXZlbnRzKCdvZmYnKTtcbiAgICAgICAgc3dpcGVyLm1vdXNld2hlZWwuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgICAgZGlzYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkKSBlbmFibGUoKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBlbmFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkKSBkaXNhYmxlKCk7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLm1vdXNld2hlZWwsIHtcbiAgICAgICAgZW5hYmxlLFxuICAgICAgICBkaXNhYmxlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkKHN3aXBlciwgb3JpZ2luYWxQYXJhbXMsIHBhcmFtcywgY2hlY2tQcm9wcykge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jcmVhdGVFbGVtZW50cykge1xuICAgICAgICBPYmplY3Qua2V5cyhjaGVja1Byb3BzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWYgKCFwYXJhbXNba2V5XSAmJiBwYXJhbXMuYXV0byA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBzd2lwZXIuJGVsLmNoaWxkcmVuKGAuJHtjaGVja1Byb3BzW2tleV19YClbMF07XG5cbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2hlY2tQcm9wc1trZXldO1xuICAgICAgICAgICAgICBzd2lwZXIuJGVsLmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyYW1zW2tleV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgb3JpZ2luYWxQYXJhbXNba2V5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uKHtcbiAgICAgIHN3aXBlcixcbiAgICAgIGV4dGVuZFBhcmFtcyxcbiAgICAgIG9uLFxuICAgICAgZW1pdFxuICAgIH0pIHtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIG5hdmlnYXRpb246IHtcbiAgICAgICAgICBuZXh0RWw6IG51bGwsXG4gICAgICAgICAgcHJldkVsOiBudWxsLFxuICAgICAgICAgIGhpZGVPbkNsaWNrOiBmYWxzZSxcbiAgICAgICAgICBkaXNhYmxlZENsYXNzOiAnc3dpcGVyLWJ1dHRvbi1kaXNhYmxlZCcsXG4gICAgICAgICAgaGlkZGVuQ2xhc3M6ICdzd2lwZXItYnV0dG9uLWhpZGRlbicsXG4gICAgICAgICAgbG9ja0NsYXNzOiAnc3dpcGVyLWJ1dHRvbi1sb2NrJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci5uYXZpZ2F0aW9uID0ge1xuICAgICAgICBuZXh0RWw6IG51bGwsXG4gICAgICAgICRuZXh0RWw6IG51bGwsXG4gICAgICAgIHByZXZFbDogbnVsbCxcbiAgICAgICAgJHByZXZFbDogbnVsbFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gZ2V0RWwoZWwpIHtcbiAgICAgICAgbGV0ICRlbDtcblxuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAkZWwgPSAkKGVsKTtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmIHR5cGVvZiBlbCA9PT0gJ3N0cmluZycgJiYgJGVsLmxlbmd0aCA+IDEgJiYgc3dpcGVyLiRlbC5maW5kKGVsKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICRlbCA9IHN3aXBlci4kZWwuZmluZChlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRlbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9nZ2xlRWwoJGVsLCBkaXNhYmxlZCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb247XG5cbiAgICAgICAgaWYgKCRlbCAmJiAkZWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICRlbFtkaXNhYmxlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShwYXJhbXMuZGlzYWJsZWRDbGFzcyk7XG4gICAgICAgICAgaWYgKCRlbFswXSAmJiAkZWxbMF0udGFnTmFtZSA9PT0gJ0JVVFRPTicpICRlbFswXS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuXG4gICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgJGVsW3N3aXBlci5pc0xvY2tlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShwYXJhbXMubG9ja0NsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAvLyBVcGRhdGUgTmF2aWdhdGlvbiBCdXR0b25zXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRuZXh0RWwsXG4gICAgICAgICAgJHByZXZFbFxuICAgICAgICB9ID0gc3dpcGVyLm5hdmlnYXRpb247XG4gICAgICAgIHRvZ2dsZUVsKCRwcmV2RWwsIHN3aXBlci5pc0JlZ2lubmluZyk7XG4gICAgICAgIHRvZ2dsZUVsKCRuZXh0RWwsIHN3aXBlci5pc0VuZCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUHJldkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcbiAgICAgICAgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbk5leHRDbGljayhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLnBhcmFtcy5sb29wKSByZXR1cm47XG4gICAgICAgIHN3aXBlci5zbGlkZU5leHQoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uO1xuICAgICAgICBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24gPSBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkKHN3aXBlciwgc3dpcGVyLm9yaWdpbmFsUGFyYW1zLm5hdmlnYXRpb24sIHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbiwge1xuICAgICAgICAgIG5leHRFbDogJ3N3aXBlci1idXR0b24tbmV4dCcsXG4gICAgICAgICAgcHJldkVsOiAnc3dpcGVyLWJ1dHRvbi1wcmV2J1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCEocGFyYW1zLm5leHRFbCB8fCBwYXJhbXMucHJldkVsKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCAkbmV4dEVsID0gZ2V0RWwocGFyYW1zLm5leHRFbCk7XG4gICAgICAgIGNvbnN0ICRwcmV2RWwgPSBnZXRFbChwYXJhbXMucHJldkVsKTtcblxuICAgICAgICBpZiAoJG5leHRFbCAmJiAkbmV4dEVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAkbmV4dEVsLm9uKCdjbGljaycsIG9uTmV4dENsaWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICRwcmV2RWwub24oJ2NsaWNrJywgb25QcmV2Q2xpY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIubmF2aWdhdGlvbiwge1xuICAgICAgICAgICRuZXh0RWwsXG4gICAgICAgICAgbmV4dEVsOiAkbmV4dEVsICYmICRuZXh0RWxbMF0sXG4gICAgICAgICAgJHByZXZFbCxcbiAgICAgICAgICBwcmV2RWw6ICRwcmV2RWwgJiYgJHByZXZFbFswXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgICAgaWYgKCRuZXh0RWwpICRuZXh0RWwuYWRkQ2xhc3MocGFyYW1zLmxvY2tDbGFzcyk7XG4gICAgICAgICAgaWYgKCRwcmV2RWwpICRwcmV2RWwuYWRkQ2xhc3MocGFyYW1zLmxvY2tDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRuZXh0RWwsXG4gICAgICAgICAgJHByZXZFbFxuICAgICAgICB9ID0gc3dpcGVyLm5hdmlnYXRpb247XG5cbiAgICAgICAgaWYgKCRuZXh0RWwgJiYgJG5leHRFbC5sZW5ndGgpIHtcbiAgICAgICAgICAkbmV4dEVsLm9mZignY2xpY2snLCBvbk5leHRDbGljayk7XG4gICAgICAgICAgJG5leHRFbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uZGlzYWJsZWRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJHByZXZFbCAmJiAkcHJldkVsLmxlbmd0aCkge1xuICAgICAgICAgICRwcmV2RWwub2ZmKCdjbGljaycsIG9uUHJldkNsaWNrKTtcbiAgICAgICAgICAkcHJldkVsLnJlbW92ZUNsYXNzKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5kaXNhYmxlZENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ3RvRWRnZSBmcm9tRWRnZSBsb2NrIHVubG9jaycsICgpID0+IHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICBkZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdlbmFibGUgZGlzYWJsZScsICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRuZXh0RWwsXG4gICAgICAgICAgJHByZXZFbFxuICAgICAgICB9ID0gc3dpcGVyLm5hdmlnYXRpb247XG5cbiAgICAgICAgaWYgKCRuZXh0RWwpIHtcbiAgICAgICAgICAkbmV4dEVsW3N3aXBlci5lbmFibGVkID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyddKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5sb2NrQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRwcmV2RWwpIHtcbiAgICAgICAgICAkcHJldkVsW3N3aXBlci5lbmFibGVkID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyddKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5sb2NrQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdjbGljaycsIChfcywgZSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJG5leHRFbCxcbiAgICAgICAgICAkcHJldkVsXG4gICAgICAgIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSBlLnRhcmdldDtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGVPbkNsaWNrICYmICEkKHRhcmdldEVsKS5pcygkcHJldkVsKSAmJiAhJCh0YXJnZXRFbCkuaXMoJG5leHRFbCkpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnBhZ2luYXRpb24gJiYgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiYgKHN3aXBlci5wYWdpbmF0aW9uLmVsID09PSB0YXJnZXRFbCB8fCBzd2lwZXIucGFnaW5hdGlvbi5lbC5jb250YWlucyh0YXJnZXRFbCkpKSByZXR1cm47XG4gICAgICAgICAgbGV0IGlzSGlkZGVuO1xuXG4gICAgICAgICAgaWYgKCRuZXh0RWwpIHtcbiAgICAgICAgICAgIGlzSGlkZGVuID0gJG5leHRFbC5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJHByZXZFbCkge1xuICAgICAgICAgICAgaXNIaWRkZW4gPSAkcHJldkVsLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICBlbWl0KCduYXZpZ2F0aW9uU2hvdycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWl0KCduYXZpZ2F0aW9uSGlkZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkbmV4dEVsKSB7XG4gICAgICAgICAgICAkbmV4dEVsLnRvZ2dsZUNsYXNzKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCRwcmV2RWwpIHtcbiAgICAgICAgICAgICRwcmV2RWwudG9nZ2xlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIubmF2aWdhdGlvbiwge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGluaXQsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsYXNzZXNUb1NlbGVjdG9yKGNsYXNzZXMgPSAnJykge1xuICAgICAgcmV0dXJuIGAuJHtjbGFzc2VzLnRyaW0oKS5yZXBsYWNlKC8oW1xcLjohXFwvXSkvZywgJ1xcXFwkMScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgLnJlcGxhY2UoLyAvZywgJy4nKX1gO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBhZ2luYXRpb24oe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgb24sXG4gICAgICBlbWl0XG4gICAgfSkge1xuICAgICAgY29uc3QgcGZ4ID0gJ3N3aXBlci1wYWdpbmF0aW9uJztcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICBlbDogbnVsbCxcbiAgICAgICAgICBidWxsZXRFbGVtZW50OiAnc3BhbicsXG4gICAgICAgICAgY2xpY2thYmxlOiBmYWxzZSxcbiAgICAgICAgICBoaWRlT25DbGljazogZmFsc2UsXG4gICAgICAgICAgcmVuZGVyQnVsbGV0OiBudWxsLFxuICAgICAgICAgIHJlbmRlclByb2dyZXNzYmFyOiBudWxsLFxuICAgICAgICAgIHJlbmRlckZyYWN0aW9uOiBudWxsLFxuICAgICAgICAgIHJlbmRlckN1c3RvbTogbnVsbCxcbiAgICAgICAgICBwcm9ncmVzc2Jhck9wcG9zaXRlOiBmYWxzZSxcbiAgICAgICAgICB0eXBlOiAnYnVsbGV0cycsXG4gICAgICAgICAgLy8gJ2J1bGxldHMnIG9yICdwcm9ncmVzc2Jhcicgb3IgJ2ZyYWN0aW9uJyBvciAnY3VzdG9tJ1xuICAgICAgICAgIGR5bmFtaWNCdWxsZXRzOiBmYWxzZSxcbiAgICAgICAgICBkeW5hbWljTWFpbkJ1bGxldHM6IDEsXG4gICAgICAgICAgZm9ybWF0RnJhY3Rpb25DdXJyZW50OiBudW1iZXIgPT4gbnVtYmVyLFxuICAgICAgICAgIGZvcm1hdEZyYWN0aW9uVG90YWw6IG51bWJlciA9PiBudW1iZXIsXG4gICAgICAgICAgYnVsbGV0Q2xhc3M6IGAke3BmeH0tYnVsbGV0YCxcbiAgICAgICAgICBidWxsZXRBY3RpdmVDbGFzczogYCR7cGZ4fS1idWxsZXQtYWN0aXZlYCxcbiAgICAgICAgICBtb2RpZmllckNsYXNzOiBgJHtwZnh9LWAsXG4gICAgICAgICAgY3VycmVudENsYXNzOiBgJHtwZnh9LWN1cnJlbnRgLFxuICAgICAgICAgIHRvdGFsQ2xhc3M6IGAke3BmeH0tdG90YWxgLFxuICAgICAgICAgIGhpZGRlbkNsYXNzOiBgJHtwZnh9LWhpZGRlbmAsXG4gICAgICAgICAgcHJvZ3Jlc3NiYXJGaWxsQ2xhc3M6IGAke3BmeH0tcHJvZ3Jlc3NiYXItZmlsbGAsXG4gICAgICAgICAgcHJvZ3Jlc3NiYXJPcHBvc2l0ZUNsYXNzOiBgJHtwZnh9LXByb2dyZXNzYmFyLW9wcG9zaXRlYCxcbiAgICAgICAgICBjbGlja2FibGVDbGFzczogYCR7cGZ4fS1jbGlja2FibGVgLFxuICAgICAgICAgIGxvY2tDbGFzczogYCR7cGZ4fS1sb2NrYCxcbiAgICAgICAgICBob3Jpem9udGFsQ2xhc3M6IGAke3BmeH0taG9yaXpvbnRhbGAsXG4gICAgICAgICAgdmVydGljYWxDbGFzczogYCR7cGZ4fS12ZXJ0aWNhbGBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzd2lwZXIucGFnaW5hdGlvbiA9IHtcbiAgICAgICAgZWw6IG51bGwsXG4gICAgICAgICRlbDogbnVsbCxcbiAgICAgICAgYnVsbGV0czogW11cbiAgICAgIH07XG4gICAgICBsZXQgYnVsbGV0U2l6ZTtcbiAgICAgIGxldCBkeW5hbWljQnVsbGV0SW5kZXggPSAwO1xuXG4gICAgICBmdW5jdGlvbiBpc1BhZ2luYXRpb25EaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICFzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLmVsIHx8ICFzd2lwZXIucGFnaW5hdGlvbi4kZWwgfHwgc3dpcGVyLnBhZ2luYXRpb24uJGVsLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0U2lkZUJ1bGxldHMoJGJ1bGxldEVsLCBwb3NpdGlvbikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYnVsbGV0QWN0aXZlQ2xhc3NcbiAgICAgICAgfSA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICAgICAgJGJ1bGxldEVsW3Bvc2l0aW9uXSgpLmFkZENsYXNzKGAke2J1bGxldEFjdGl2ZUNsYXNzfS0ke3Bvc2l0aW9ufWApW3Bvc2l0aW9uXSgpLmFkZENsYXNzKGAke2J1bGxldEFjdGl2ZUNsYXNzfS0ke3Bvc2l0aW9ufS0ke3Bvc2l0aW9ufWApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIC8vIFJlbmRlciB8fCBVcGRhdGUgUGFnaW5hdGlvbiBidWxsZXRzL2l0ZW1zXG4gICAgICAgIGNvbnN0IHJ0bCA9IHN3aXBlci5ydGw7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICAgICAgaWYgKGlzUGFnaW5hdGlvbkRpc2FibGVkKCkpIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2xpZGVzTGVuZ3RoID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0ICRlbCA9IHN3aXBlci5wYWdpbmF0aW9uLiRlbDsgLy8gQ3VycmVudC9Ub3RhbFxuXG4gICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICBjb25zdCB0b3RhbCA9IHN3aXBlci5wYXJhbXMubG9vcCA/IE1hdGguY2VpbCgoc2xpZGVzTGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDIpIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiBzd2lwZXIuc25hcEdyaWQubGVuZ3RoO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICBjdXJyZW50ID0gTWF0aC5jZWlsKChzd2lwZXIuYWN0aXZlSW5kZXggLSBzd2lwZXIubG9vcGVkU2xpZGVzKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPiBzbGlkZXNMZW5ndGggLSAxIC0gc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDIpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgLT0gc2xpZGVzTGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPiB0b3RhbCAtIDEpIGN1cnJlbnQgLT0gdG90YWw7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPCAwICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvblR5cGUgIT09ICdidWxsZXRzJykgY3VycmVudCA9IHRvdGFsICsgY3VycmVudDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3dpcGVyLnNuYXBJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjdXJyZW50ID0gc3dpcGVyLnNuYXBJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gc3dpcGVyLmFjdGl2ZUluZGV4IHx8IDA7XG4gICAgICAgIH0gLy8gVHlwZXNcblxuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgYnVsbGV0cyA9IHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHM7XG4gICAgICAgICAgbGV0IGZpcnN0SW5kZXg7XG4gICAgICAgICAgbGV0IGxhc3RJbmRleDtcbiAgICAgICAgICBsZXQgbWlkSW5kZXg7XG5cbiAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgICAgICBidWxsZXRTaXplID0gYnVsbGV0cy5lcSgwKVtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnb3V0ZXJXaWR0aCcgOiAnb3V0ZXJIZWlnaHQnXSh0cnVlKTtcbiAgICAgICAgICAgICRlbC5jc3Moc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3dpZHRoJyA6ICdoZWlnaHQnLCBgJHtidWxsZXRTaXplICogKHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgKyA0KX1weGApO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyA+IDEgJiYgc3dpcGVyLnByZXZpb3VzSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBkeW5hbWljQnVsbGV0SW5kZXggKz0gY3VycmVudCAtIHN3aXBlci5wcmV2aW91c0luZGV4O1xuXG4gICAgICAgICAgICAgIGlmIChkeW5hbWljQnVsbGV0SW5kZXggPiBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIC0gMSkge1xuICAgICAgICAgICAgICAgIGR5bmFtaWNCdWxsZXRJbmRleCA9IHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGR5bmFtaWNCdWxsZXRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljQnVsbGV0SW5kZXggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSBjdXJyZW50IC0gZHluYW1pY0J1bGxldEluZGV4O1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gZmlyc3RJbmRleCArIChNYXRoLm1pbihidWxsZXRzLmxlbmd0aCwgcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cykgLSAxKTtcbiAgICAgICAgICAgIG1pZEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBidWxsZXRzLnJlbW92ZUNsYXNzKFsnJywgJy1uZXh0JywgJy1uZXh0LW5leHQnLCAnLXByZXYnLCAnLXByZXYtcHJldicsICctbWFpbiddLm1hcChzdWZmaXggPT4gYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfSR7c3VmZml4fWApLmpvaW4oJyAnKSk7XG5cbiAgICAgICAgICBpZiAoJGVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGJ1bGxldHMuZWFjaChidWxsZXQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCAkYnVsbGV0ID0gJChidWxsZXQpO1xuICAgICAgICAgICAgICBjb25zdCBidWxsZXRJbmRleCA9ICRidWxsZXQuaW5kZXgoKTtcblxuICAgICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAkYnVsbGV0LmFkZENsYXNzKHBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1bGxldEluZGV4ID49IGZpcnN0SW5kZXggJiYgYnVsbGV0SW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAkYnVsbGV0LmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gZmlyc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgc2V0U2lkZUJ1bGxldHMoJGJ1bGxldCwgJ3ByZXYnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgc2V0U2lkZUJ1bGxldHMoJGJ1bGxldCwgJ25leHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCAkYnVsbGV0ID0gYnVsbGV0cy5lcShjdXJyZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGJ1bGxldEluZGV4ID0gJGJ1bGxldC5pbmRleCgpO1xuICAgICAgICAgICAgJGJ1bGxldC5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgICAgICAgIGNvbnN0ICRmaXJzdERpc3BsYXllZEJ1bGxldCA9IGJ1bGxldHMuZXEoZmlyc3RJbmRleCk7XG4gICAgICAgICAgICAgIGNvbnN0ICRsYXN0RGlzcGxheWVkQnVsbGV0ID0gYnVsbGV0cy5lcShsYXN0SW5kZXgpO1xuXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSBmaXJzdEluZGV4OyBpIDw9IGxhc3RJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgYnVsbGV0cy5lcShpKS5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPj0gYnVsbGV0cy5sZW5ndGggLSBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0czsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVsbGV0cy5lcShidWxsZXRzLmxlbmd0aCAtIGkpLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBidWxsZXRzLmVxKGJ1bGxldHMubGVuZ3RoIC0gcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyAtIDEpLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tcHJldmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZXRTaWRlQnVsbGV0cygkZmlyc3REaXNwbGF5ZWRCdWxsZXQsICdwcmV2Jyk7XG4gICAgICAgICAgICAgICAgICBzZXRTaWRlQnVsbGV0cygkbGFzdERpc3BsYXllZEJ1bGxldCwgJ25leHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0U2lkZUJ1bGxldHMoJGZpcnN0RGlzcGxheWVkQnVsbGV0LCAncHJldicpO1xuICAgICAgICAgICAgICAgIHNldFNpZGVCdWxsZXRzKCRsYXN0RGlzcGxheWVkQnVsbGV0LCAnbmV4dCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY0J1bGxldHNMZW5ndGggPSBNYXRoLm1pbihidWxsZXRzLmxlbmd0aCwgcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyArIDQpO1xuICAgICAgICAgICAgY29uc3QgYnVsbGV0c09mZnNldCA9IChidWxsZXRTaXplICogZHluYW1pY0J1bGxldHNMZW5ndGggLSBidWxsZXRTaXplKSAvIDIgLSBtaWRJbmRleCAqIGJ1bGxldFNpemU7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRQcm9wID0gcnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIGJ1bGxldHMuY3NzKHN3aXBlci5pc0hvcml6b250YWwoKSA/IG9mZnNldFByb3AgOiAndG9wJywgYCR7YnVsbGV0c09mZnNldH1weGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICAgICRlbC5maW5kKGNsYXNzZXNUb1NlbGVjdG9yKHBhcmFtcy5jdXJyZW50Q2xhc3MpKS50ZXh0KHBhcmFtcy5mb3JtYXRGcmFjdGlvbkN1cnJlbnQoY3VycmVudCArIDEpKTtcbiAgICAgICAgICAkZWwuZmluZChjbGFzc2VzVG9TZWxlY3RvcihwYXJhbXMudG90YWxDbGFzcykpLnRleHQocGFyYW1zLmZvcm1hdEZyYWN0aW9uVG90YWwodG90YWwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ3Byb2dyZXNzYmFyJykge1xuICAgICAgICAgIGxldCBwcm9ncmVzc2JhckRpcmVjdGlvbjtcblxuICAgICAgICAgIGlmIChwYXJhbXMucHJvZ3Jlc3NiYXJPcHBvc2l0ZSkge1xuICAgICAgICAgICAgcHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9ncmVzc2JhckRpcmVjdGlvbiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSAoY3VycmVudCArIDEpIC8gdG90YWw7XG4gICAgICAgICAgbGV0IHNjYWxlWCA9IDE7XG4gICAgICAgICAgbGV0IHNjYWxlWSA9IDE7XG5cbiAgICAgICAgICBpZiAocHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjYWxlWSA9IHNjYWxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbC5maW5kKGNsYXNzZXNUb1NlbGVjdG9yKHBhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzcykpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlWCgke3NjYWxlWH0pIHNjYWxlWSgke3NjYWxlWX0pYCkudHJhbnNpdGlvbihzd2lwZXIucGFyYW1zLnNwZWVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2N1c3RvbScgJiYgcGFyYW1zLnJlbmRlckN1c3RvbSkge1xuICAgICAgICAgICRlbC5odG1sKHBhcmFtcy5yZW5kZXJDdXN0b20oc3dpcGVyLCBjdXJyZW50ICsgMSwgdG90YWwpKTtcbiAgICAgICAgICBlbWl0KCdwYWdpbmF0aW9uUmVuZGVyJywgJGVsWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbWl0KCdwYWdpbmF0aW9uVXBkYXRlJywgJGVsWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmVuYWJsZWQpIHtcbiAgICAgICAgICAkZWxbc3dpcGVyLmlzTG9ja2VkID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKHBhcmFtcy5sb2NrQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgLy8gUmVuZGVyIENvbnRhaW5lclxuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XG4gICAgICAgIGlmIChpc1BhZ2luYXRpb25EaXNhYmxlZCgpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHNsaWRlc0xlbmd0aCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7XG4gICAgICAgIGxldCBwYWdpbmF0aW9uSFRNTCA9ICcnO1xuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnKSB7XG4gICAgICAgICAgbGV0IG51bWJlck9mQnVsbGV0cyA9IHN3aXBlci5wYXJhbXMubG9vcCA/IE1hdGguY2VpbCgoc2xpZGVzTGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDIpIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiBzd2lwZXIuc25hcEdyaWQubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUgJiYgc3dpcGVyLnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgbnVtYmVyT2ZCdWxsZXRzID4gc2xpZGVzTGVuZ3RoKSB7XG4gICAgICAgICAgICBudW1iZXJPZkJ1bGxldHMgPSBzbGlkZXNMZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkJ1bGxldHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5yZW5kZXJCdWxsZXQpIHtcbiAgICAgICAgICAgICAgcGFnaW5hdGlvbkhUTUwgKz0gcGFyYW1zLnJlbmRlckJ1bGxldC5jYWxsKHN3aXBlciwgaSwgcGFyYW1zLmJ1bGxldENsYXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhZ2luYXRpb25IVE1MICs9IGA8JHtwYXJhbXMuYnVsbGV0RWxlbWVudH0gY2xhc3M9XCIke3BhcmFtcy5idWxsZXRDbGFzc31cIj48LyR7cGFyYW1zLmJ1bGxldEVsZW1lbnR9PmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJGVsLmh0bWwocGFnaW5hdGlvbkhUTUwpO1xuICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMgPSAkZWwuZmluZChjbGFzc2VzVG9TZWxlY3RvcihwYXJhbXMuYnVsbGV0Q2xhc3MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICAgIGlmIChwYXJhbXMucmVuZGVyRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHBhZ2luYXRpb25IVE1MID0gcGFyYW1zLnJlbmRlckZyYWN0aW9uLmNhbGwoc3dpcGVyLCBwYXJhbXMuY3VycmVudENsYXNzLCBwYXJhbXMudG90YWxDbGFzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhZ2luYXRpb25IVE1MID0gYDxzcGFuIGNsYXNzPVwiJHtwYXJhbXMuY3VycmVudENsYXNzfVwiPjwvc3Bhbj5gICsgJyAvICcgKyBgPHNwYW4gY2xhc3M9XCIke3BhcmFtcy50b3RhbENsYXNzfVwiPjwvc3Bhbj5gO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbC5odG1sKHBhZ2luYXRpb25IVE1MKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ3Byb2dyZXNzYmFyJykge1xuICAgICAgICAgIGlmIChwYXJhbXMucmVuZGVyUHJvZ3Jlc3NiYXIpIHtcbiAgICAgICAgICAgIHBhZ2luYXRpb25IVE1MID0gcGFyYW1zLnJlbmRlclByb2dyZXNzYmFyLmNhbGwoc3dpcGVyLCBwYXJhbXMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IGA8c3BhbiBjbGFzcz1cIiR7cGFyYW1zLnByb2dyZXNzYmFyRmlsbENsYXNzfVwiPjwvc3Bhbj5gO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbC5odG1sKHBhZ2luYXRpb25IVE1MKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ2N1c3RvbScpIHtcbiAgICAgICAgICBlbWl0KCdwYWdpbmF0aW9uUmVuZGVyJywgc3dpcGVyLnBhZ2luYXRpb24uJGVsWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24gPSBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkKHN3aXBlciwgc3dpcGVyLm9yaWdpbmFsUGFyYW1zLnBhZ2luYXRpb24sIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbiwge1xuICAgICAgICAgIGVsOiAnc3dpcGVyLXBhZ2luYXRpb24nXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XG4gICAgICAgIGlmICghcGFyYW1zLmVsKSByZXR1cm47XG4gICAgICAgIGxldCAkZWwgPSAkKHBhcmFtcy5lbCk7XG4gICAgICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgdHlwZW9mIHBhcmFtcy5lbCA9PT0gJ3N0cmluZycgJiYgJGVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAkZWwgPSBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLmVsKTsgLy8gY2hlY2sgaWYgaXQgYmVsb25ncyB0byBhbm90aGVyIG5lc3RlZCBTd2lwZXJcblxuICAgICAgICAgIGlmICgkZWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgJGVsID0gJGVsLmZpbHRlcihlbCA9PiB7XG4gICAgICAgICAgICAgIGlmICgkKGVsKS5wYXJlbnRzKCcuc3dpcGVyJylbMF0gIT09IHN3aXBlci5lbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHBhcmFtcy5jbGlja2FibGUpIHtcbiAgICAgICAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLmNsaWNrYWJsZUNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRlbC5hZGRDbGFzcyhwYXJhbXMubW9kaWZpZXJDbGFzcyArIHBhcmFtcy50eXBlKTtcbiAgICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5tb2RpZmllckNsYXNzICsgc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24pO1xuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xuICAgICAgICAgICRlbC5hZGRDbGFzcyhgJHtwYXJhbXMubW9kaWZpZXJDbGFzc30ke3BhcmFtcy50eXBlfS1keW5hbWljYCk7XG4gICAgICAgICAgZHluYW1pY0J1bGxldEluZGV4ID0gMDtcblxuICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIDwgMSkge1xuICAgICAgICAgICAgcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInICYmIHBhcmFtcy5wcm9ncmVzc2Jhck9wcG9zaXRlKSB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5wcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jbGlja2FibGUpIHtcbiAgICAgICAgICAkZWwub24oJ2NsaWNrJywgY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLmJ1bGxldENsYXNzKSwgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkKHRoaXMpLmluZGV4KCkgKiBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkgaW5kZXggKz0gc3dpcGVyLmxvb3BlZFNsaWRlcztcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLnBhZ2luYXRpb24sIHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgZWw6ICRlbFswXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5sb2NrQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICAgICAgaWYgKGlzUGFnaW5hdGlvbkRpc2FibGVkKCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsO1xuICAgICAgICAkZWwucmVtb3ZlQ2xhc3MocGFyYW1zLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKHBhcmFtcy5tb2RpZmllckNsYXNzICsgcGFyYW1zLnR5cGUpO1xuICAgICAgICAkZWwucmVtb3ZlQ2xhc3MocGFyYW1zLm1vZGlmaWVyQ2xhc3MgKyBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbik7XG4gICAgICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMucmVtb3ZlQ2xhc3MpIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMucmVtb3ZlQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzKTtcblxuICAgICAgICBpZiAocGFyYW1zLmNsaWNrYWJsZSkge1xuICAgICAgICAgICRlbC5vZmYoJ2NsaWNrJywgY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLmJ1bGxldENsYXNzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgcmVuZGVyKCk7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignYWN0aXZlSW5kZXhDaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3dpcGVyLnNuYXBJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignc25hcEluZGV4Q2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdzbGlkZXNMZW5ndGhDaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICByZW5kZXIoKTtcbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignc25hcEdyaWRMZW5ndGhDaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgcmVuZGVyKCk7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2VuYWJsZSBkaXNhYmxlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJGVsXG4gICAgICAgIH0gPSBzd2lwZXIucGFnaW5hdGlvbjtcblxuICAgICAgICBpZiAoJGVsKSB7XG4gICAgICAgICAgJGVsW3N3aXBlci5lbmFibGVkID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyddKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5sb2NrQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdsb2NrIHVubG9jaycsICgpID0+IHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdjbGljaycsIChfcywgZSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRFbCA9IGUudGFyZ2V0O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJGVsXG4gICAgICAgIH0gPSBzd2lwZXIucGFnaW5hdGlvbjtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmVsICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5oaWRlT25DbGljayAmJiAkZWwubGVuZ3RoID4gMCAmJiAhJCh0YXJnZXRFbCkuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKSkge1xuICAgICAgICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiAoc3dpcGVyLm5hdmlnYXRpb24ubmV4dEVsICYmIHRhcmdldEVsID09PSBzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwgfHwgc3dpcGVyLm5hdmlnYXRpb24ucHJldkVsICYmIHRhcmdldEVsID09PSBzd2lwZXIubmF2aWdhdGlvbi5wcmV2RWwpKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgaXNIaWRkZW4gPSAkZWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGRlbkNsYXNzKTtcblxuICAgICAgICAgIGlmIChpc0hpZGRlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZW1pdCgncGFnaW5hdGlvblNob3cnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1pdCgncGFnaW5hdGlvbkhpZGUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkZWwudG9nZ2xlQ2xhc3Moc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlci5wYWdpbmF0aW9uLCB7XG4gICAgICAgIHJlbmRlcixcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBpbml0LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTY3JvbGxiYXIoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgb24sXG4gICAgICBlbWl0XG4gICAgfSkge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgbGV0IGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgbGV0IHRpbWVvdXQgPSBudWxsO1xuICAgICAgbGV0IGRyYWdUaW1lb3V0ID0gbnVsbDtcbiAgICAgIGxldCBkcmFnU3RhcnRQb3M7XG4gICAgICBsZXQgZHJhZ1NpemU7XG4gICAgICBsZXQgdHJhY2tTaXplO1xuICAgICAgbGV0IGRpdmlkZXI7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBzY3JvbGxiYXI6IHtcbiAgICAgICAgICBlbDogbnVsbCxcbiAgICAgICAgICBkcmFnU2l6ZTogJ2F1dG8nLFxuICAgICAgICAgIGhpZGU6IGZhbHNlLFxuICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgICAgc25hcE9uUmVsZWFzZTogdHJ1ZSxcbiAgICAgICAgICBsb2NrQ2xhc3M6ICdzd2lwZXItc2Nyb2xsYmFyLWxvY2snLFxuICAgICAgICAgIGRyYWdDbGFzczogJ3N3aXBlci1zY3JvbGxiYXItZHJhZydcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyID0ge1xuICAgICAgICBlbDogbnVsbCxcbiAgICAgICAgZHJhZ0VsOiBudWxsLFxuICAgICAgICAkZWw6IG51bGwsXG4gICAgICAgICRkcmFnRWw6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCB8fCAhc3dpcGVyLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2Nyb2xsYmFyLFxuICAgICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgICAgIHByb2dyZXNzXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZHJhZ0VsLFxuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc2Nyb2xsYmFyO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICAgICAgbGV0IG5ld1NpemUgPSBkcmFnU2l6ZTtcbiAgICAgICAgbGV0IG5ld1BvcyA9ICh0cmFja1NpemUgLSBkcmFnU2l6ZSkgKiBwcm9ncmVzcztcblxuICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgbmV3UG9zID0gLW5ld1BvcztcblxuICAgICAgICAgIGlmIChuZXdQb3MgPiAwKSB7XG4gICAgICAgICAgICBuZXdTaXplID0gZHJhZ1NpemUgLSBuZXdQb3M7XG4gICAgICAgICAgICBuZXdQb3MgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoLW5ld1BvcyArIGRyYWdTaXplID4gdHJhY2tTaXplKSB7XG4gICAgICAgICAgICBuZXdTaXplID0gdHJhY2tTaXplICsgbmV3UG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXdQb3MgPCAwKSB7XG4gICAgICAgICAgbmV3U2l6ZSA9IGRyYWdTaXplICsgbmV3UG9zO1xuICAgICAgICAgIG5ld1BvcyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAobmV3UG9zICsgZHJhZ1NpemUgPiB0cmFja1NpemUpIHtcbiAgICAgICAgICBuZXdTaXplID0gdHJhY2tTaXplIC0gbmV3UG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICRkcmFnRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke25ld1Bvc31weCwgMCwgMClgKTtcbiAgICAgICAgICAkZHJhZ0VsWzBdLnN0eWxlLndpZHRoID0gYCR7bmV3U2l6ZX1weGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGRyYWdFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDBweCwgJHtuZXdQb3N9cHgsIDApYCk7XG4gICAgICAgICAgJGRyYWdFbFswXS5zdHlsZS5oZWlnaHQgPSBgJHtuZXdTaXplfXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuaGlkZSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAkZWxbMF0uc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgJGVsWzBdLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgJGVsLnRyYW5zaXRpb24oNDAwKTtcbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLnNjcm9sbGJhci4kZHJhZ0VsLnRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVTaXplKCkge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICFzd2lwZXIuc2Nyb2xsYmFyLmVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxiYXJcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRkcmFnRWwsXG4gICAgICAgICAgJGVsXG4gICAgICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgJGRyYWdFbFswXS5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgICAgdHJhY2tTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJGVsWzBdLm9mZnNldFdpZHRoIDogJGVsWzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgZGl2aWRlciA9IHN3aXBlci5zaXplIC8gKHN3aXBlci52aXJ0dWFsU2l6ZSArIHN3aXBlci5wYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlIC0gKHN3aXBlci5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBzd2lwZXIuc25hcEdyaWRbMF0gOiAwKSk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplID09PSAnYXV0bycpIHtcbiAgICAgICAgICBkcmFnU2l6ZSA9IHRyYWNrU2l6ZSAqIGRpdmlkZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhZ1NpemUgPSBwYXJzZUludChzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnU2l6ZSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSBgJHtkcmFnU2l6ZX1weGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGRyYWdFbFswXS5zdHlsZS5oZWlnaHQgPSBgJHtkcmFnU2l6ZX1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGl2aWRlciA+PSAxKSB7XG4gICAgICAgICAgJGVsWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGVsWzBdLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5oaWRlKSB7XG4gICAgICAgICAgJGVsWzBdLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuZW5hYmxlZCkge1xuICAgICAgICAgIHNjcm9sbGJhci4kZWxbc3dpcGVyLmlzTG9ja2VkID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmxvY2tDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGUpIHtcbiAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgIHJldHVybiBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFggOiBlLmNsaWVudFg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZIDogZS5jbGllbnRZO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXREcmFnUG9zaXRpb24oZSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2Nyb2xsYmFyLFxuICAgICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZWxcbiAgICAgICAgfSA9IHNjcm9sbGJhcjtcbiAgICAgICAgbGV0IHBvc2l0aW9uUmF0aW87XG4gICAgICAgIHBvc2l0aW9uUmF0aW8gPSAoZ2V0UG9pbnRlclBvc2l0aW9uKGUpIC0gJGVsLm9mZnNldCgpW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdsZWZ0JyA6ICd0b3AnXSAtIChkcmFnU3RhcnRQb3MgIT09IG51bGwgPyBkcmFnU3RhcnRQb3MgOiBkcmFnU2l6ZSAvIDIpKSAvICh0cmFja1NpemUgLSBkcmFnU2l6ZSk7XG4gICAgICAgIHBvc2l0aW9uUmF0aW8gPSBNYXRoLm1heChNYXRoLm1pbihwb3NpdGlvblJhdGlvLCAxKSwgMCk7XG5cbiAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgIHBvc2l0aW9uUmF0aW8gPSAxIC0gcG9zaXRpb25SYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgKHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgKiBwb3NpdGlvblJhdGlvO1xuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MocG9zaXRpb24pO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGUpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxiYXIsXG4gICAgICAgICAgJHdyYXBwZXJFbFxuICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJGVsLFxuICAgICAgICAgICRkcmFnRWxcbiAgICAgICAgfSA9IHNjcm9sbGJhcjtcbiAgICAgICAgaXNUb3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgZHJhZ1N0YXJ0UG9zID0gZS50YXJnZXQgPT09ICRkcmFnRWxbMF0gfHwgZS50YXJnZXQgPT09ICRkcmFnRWwgPyBnZXRQb2ludGVyUG9zaXRpb24oZSkgLSBlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnbGVmdCcgOiAndG9wJ10gOiBudWxsO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbigxMDApO1xuICAgICAgICAkZHJhZ0VsLnRyYW5zaXRpb24oMTAwKTtcbiAgICAgICAgc2V0RHJhZ1Bvc2l0aW9uKGUpO1xuICAgICAgICBjbGVhclRpbWVvdXQoZHJhZ1RpbWVvdXQpO1xuICAgICAgICAkZWwudHJhbnNpdGlvbigwKTtcblxuICAgICAgICBpZiAocGFyYW1zLmhpZGUpIHtcbiAgICAgICAgICAkZWwuY3NzKCdvcGFjaXR5JywgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwuY3NzKCdzY3JvbGwtc25hcC10eXBlJywgJ25vbmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVtaXQoJ3Njcm9sbGJhckRyYWdTdGFydCcsIGUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkRyYWdNb3ZlKGUpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGJhcixcbiAgICAgICAgICAkd3JhcHBlckVsXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgJGRyYWdFbFxuICAgICAgICB9ID0gc2Nyb2xsYmFyO1xuICAgICAgICBpZiAoIWlzVG91Y2hlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICBzZXREcmFnUG9zaXRpb24oZSk7XG4gICAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbigwKTtcbiAgICAgICAgJGVsLnRyYW5zaXRpb24oMCk7XG4gICAgICAgICRkcmFnRWwudHJhbnNpdGlvbigwKTtcbiAgICAgICAgZW1pdCgnc2Nyb2xsYmFyRHJhZ01vdmUnLCBlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25EcmFnRW5kKGUpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxiYXIsXG4gICAgICAgICAgJHdyYXBwZXJFbFxuICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJGVsXG4gICAgICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgICAgIGlmICghaXNUb3VjaGVkKSByZXR1cm47XG4gICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC5jc3MoJ3Njcm9sbC1zbmFwLXR5cGUnLCAnJyk7XG4gICAgICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuaGlkZSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChkcmFnVGltZW91dCk7XG4gICAgICAgICAgZHJhZ1RpbWVvdXQgPSBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAkZWwuY3NzKCdvcGFjaXR5JywgMCk7XG4gICAgICAgICAgICAkZWwudHJhbnNpdGlvbig0MDApO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdCgnc2Nyb2xsYmFyRHJhZ0VuZCcsIGUpO1xuXG4gICAgICAgIGlmIChwYXJhbXMuc25hcE9uUmVsZWFzZSkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvQ2xvc2VzdCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGV2ZW50cyhtZXRob2QpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGJhcixcbiAgICAgICAgICB0b3VjaEV2ZW50c1RvdWNoLFxuICAgICAgICAgIHRvdWNoRXZlbnRzRGVza3RvcCxcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgc3VwcG9ydFxuICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICBjb25zdCAkZWwgPSBzY3JvbGxiYXIuJGVsO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSAkZWxbMF07XG4gICAgICAgIGNvbnN0IGFjdGl2ZUxpc3RlbmVyID0gc3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgJiYgcGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMgPyB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICAgICAgfSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBwYXNzaXZlTGlzdGVuZXIgPSBzdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHtcbiAgICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZXZlbnRNZXRob2QgPSBtZXRob2QgPT09ICdvbicgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG5cbiAgICAgICAgaWYgKCFzdXBwb3J0LnRvdWNoKSB7XG4gICAgICAgICAgdGFyZ2V0W2V2ZW50TWV0aG9kXSh0b3VjaEV2ZW50c0Rlc2t0b3Auc3RhcnQsIG9uRHJhZ1N0YXJ0LCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICAgICAgZG9jdW1lbnRbZXZlbnRNZXRob2RdKHRvdWNoRXZlbnRzRGVza3RvcC5tb3ZlLCBvbkRyYWdNb3ZlLCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICAgICAgZG9jdW1lbnRbZXZlbnRNZXRob2RdKHRvdWNoRXZlbnRzRGVza3RvcC5lbmQsIG9uRHJhZ0VuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRbZXZlbnRNZXRob2RdKHRvdWNoRXZlbnRzVG91Y2guc3RhcnQsIG9uRHJhZ1N0YXJ0LCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICAgICAgdGFyZ2V0W2V2ZW50TWV0aG9kXSh0b3VjaEV2ZW50c1RvdWNoLm1vdmUsIG9uRHJhZ01vdmUsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgICB0YXJnZXRbZXZlbnRNZXRob2RdKHRvdWNoRXZlbnRzVG91Y2guZW5kLCBvbkRyYWdFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5hYmxlRHJhZ2dhYmxlKCkge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsKSByZXR1cm47XG4gICAgICAgIGV2ZW50cygnb24nKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGlzYWJsZURyYWdnYWJsZSgpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgICAgICBldmVudHMoJ29mZicpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2Nyb2xsYmFyLFxuICAgICAgICAgICRlbDogJHN3aXBlckVsXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyID0gY3JlYXRlRWxlbWVudElmTm90RGVmaW5lZChzd2lwZXIsIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5zY3JvbGxiYXIsIHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLCB7XG4gICAgICAgICAgZWw6ICdzd2lwZXItc2Nyb2xsYmFyJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXI7XG4gICAgICAgIGlmICghcGFyYW1zLmVsKSByZXR1cm47XG4gICAgICAgIGxldCAkZWwgPSAkKHBhcmFtcy5lbCk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgdHlwZW9mIHBhcmFtcy5lbCA9PT0gJ3N0cmluZycgJiYgJGVsLmxlbmd0aCA+IDEgJiYgJHN3aXBlckVsLmZpbmQocGFyYW1zLmVsKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAkZWwgPSAkc3dpcGVyRWwuZmluZChwYXJhbXMuZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0ICRkcmFnRWwgPSAkZWwuZmluZChgLiR7c3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ0NsYXNzfWApO1xuXG4gICAgICAgIGlmICgkZHJhZ0VsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICRkcmFnRWwgPSAkKGA8ZGl2IGNsYXNzPVwiJHtzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnQ2xhc3N9XCI+PC9kaXY+YCk7XG4gICAgICAgICAgJGVsLmFwcGVuZCgkZHJhZ0VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2Nyb2xsYmFyLCB7XG4gICAgICAgICAgJGVsLFxuICAgICAgICAgIGVsOiAkZWxbMF0sXG4gICAgICAgICAgJGRyYWdFbCxcbiAgICAgICAgICBkcmFnRWw6ICRkcmFnRWxbMF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICBlbmFibGVEcmFnZ2FibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkZWwpIHtcbiAgICAgICAgICAkZWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBkaXNhYmxlRHJhZ2dhYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIG9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICBpbml0KCk7XG4gICAgICAgIHVwZGF0ZVNpemUoKTtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCd1cGRhdGUgcmVzaXplIG9ic2VydmVyVXBkYXRlIGxvY2sgdW5sb2NrJywgKCkgPT4ge1xuICAgICAgICB1cGRhdGVTaXplKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdzZXRUcmFuc2xhdGUnLCAoKSA9PiB7XG4gICAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignc2V0VHJhbnNpdGlvbicsIChfcywgZHVyYXRpb24pID0+IHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgICB9KTtcbiAgICAgIG9uKCdlbmFibGUgZGlzYWJsZScsICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc3dpcGVyLnNjcm9sbGJhcjtcblxuICAgICAgICBpZiAoJGVsKSB7XG4gICAgICAgICAgJGVsW3N3aXBlci5lbmFibGVkID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyddKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmxvY2tDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIuc2Nyb2xsYmFyLCB7XG4gICAgICAgIHVwZGF0ZVNpemUsXG4gICAgICAgIHNldFRyYW5zbGF0ZSxcbiAgICAgICAgaW5pdCxcbiAgICAgICAgZGVzdHJveVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUGFyYWxsYXgoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgb25cbiAgICB9KSB7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBwYXJhbGxheDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2Zvcm0gPSAoZWwsIHByb2dyZXNzKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBydGxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgICAgIGNvbnN0IHJ0bEZhY3RvciA9IHJ0bCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgcCA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheCcpIHx8ICcwJztcbiAgICAgICAgbGV0IHggPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgteCcpO1xuICAgICAgICBsZXQgeSA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheC15Jyk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gJGVsLmF0dHIoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlJyk7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eScpO1xuXG4gICAgICAgIGlmICh4IHx8IHkpIHtcbiAgICAgICAgICB4ID0geCB8fCAnMCc7XG4gICAgICAgICAgeSA9IHkgfHwgJzAnO1xuICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgIHggPSBwO1xuICAgICAgICAgIHkgPSAnMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeSA9IHA7XG4gICAgICAgICAgeCA9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4LmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgICAgeCA9IGAke3BhcnNlSW50KHgsIDEwKSAqIHByb2dyZXNzICogcnRsRmFjdG9yfSVgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBgJHt4ICogcHJvZ3Jlc3MgKiBydGxGYWN0b3J9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkuaW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICB5ID0gYCR7cGFyc2VJbnQoeSwgMTApICogcHJvZ3Jlc3N9JWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeSA9IGAke3kgKiBwcm9ncmVzc31weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnICYmIG9wYWNpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50T3BhY2l0eSA9IG9wYWNpdHkgLSAob3BhY2l0eSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpO1xuICAgICAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gY3VycmVudE9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNjYWxlID09PSAndW5kZWZpbmVkJyB8fCBzY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICRlbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH0sICR7eX0sIDBweClgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSBzY2FsZSAtIChzY2FsZSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpO1xuICAgICAgICAgICRlbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH0sICR7eX0sIDBweCkgc2NhbGUoJHtjdXJyZW50U2NhbGV9KWApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2xhdGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgIHNuYXBHcmlkXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgICRlbC5jaGlsZHJlbignW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpLmVhY2goZWwgPT4ge1xuICAgICAgICAgIHNldFRyYW5zZm9ybShlbCwgcHJvZ3Jlc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2xpZGVzLmVhY2goKHNsaWRlRWwsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQgc2xpZGVQcm9ncmVzcyA9IHNsaWRlRWwucHJvZ3Jlc3M7XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA+IDEgJiYgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHNsaWRlUHJvZ3Jlc3MgKz0gTWF0aC5jZWlsKHNsaWRlSW5kZXggLyAyKSAtIHByb2dyZXNzICogKHNuYXBHcmlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNsaWRlUHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChzbGlkZVByb2dyZXNzLCAtMSksIDEpO1xuICAgICAgICAgICQoc2xpZGVFbCkuZmluZCgnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpLmVhY2goZWwgPT4ge1xuICAgICAgICAgICAgc2V0VHJhbnNmb3JtKGVsLCBzbGlkZVByb2dyZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2l0aW9uID0gKGR1cmF0aW9uID0gc3dpcGVyLnBhcmFtcy5zcGVlZCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJGVsXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgICRlbC5maW5kKCdbZGF0YS1zd2lwZXItcGFyYWxsYXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC15XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LW9wYWNpdHldLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgtc2NhbGVdJykuZWFjaChwYXJhbGxheEVsID0+IHtcbiAgICAgICAgICBjb25zdCAkcGFyYWxsYXhFbCA9ICQocGFyYWxsYXhFbCk7XG4gICAgICAgICAgbGV0IHBhcmFsbGF4RHVyYXRpb24gPSBwYXJzZUludCgkcGFyYWxsYXhFbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheC1kdXJhdGlvbicpLCAxMCkgfHwgZHVyYXRpb247XG4gICAgICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSBwYXJhbGxheER1cmF0aW9uID0gMDtcbiAgICAgICAgICAkcGFyYWxsYXhFbC50cmFuc2l0aW9uKHBhcmFsbGF4RHVyYXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIG9uKCdiZWZvcmVJbml0JywgKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBzd2lwZXIucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICBzd2lwZXIub3JpZ2luYWxQYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIG9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBzZXRUcmFuc2xhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ3NldFRyYW5zbGF0ZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdzZXRUcmFuc2l0aW9uJywgKF9zd2lwZXIsIGR1cmF0aW9uKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSByZXR1cm47XG4gICAgICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWm9vbSh7XG4gICAgICBzd2lwZXIsXG4gICAgICBleHRlbmRQYXJhbXMsXG4gICAgICBvbixcbiAgICAgIGVtaXRcbiAgICB9KSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIHpvb206IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBtYXhSYXRpbzogMyxcbiAgICAgICAgICBtaW5SYXRpbzogMSxcbiAgICAgICAgICB0b2dnbGU6IHRydWUsXG4gICAgICAgICAgY29udGFpbmVyQ2xhc3M6ICdzd2lwZXItem9vbS1jb250YWluZXInLFxuICAgICAgICAgIHpvb21lZFNsaWRlQ2xhc3M6ICdzd2lwZXItc2xpZGUtem9vbWVkJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci56b29tID0ge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGxldCBjdXJyZW50U2NhbGUgPSAxO1xuICAgICAgbGV0IGlzU2NhbGluZyA9IGZhbHNlO1xuICAgICAgbGV0IGdlc3R1cmVzRW5hYmxlZDtcbiAgICAgIGxldCBmYWtlR2VzdHVyZVRvdWNoZWQ7XG4gICAgICBsZXQgZmFrZUdlc3R1cmVNb3ZlZDtcbiAgICAgIGNvbnN0IGdlc3R1cmUgPSB7XG4gICAgICAgICRzbGlkZUVsOiB1bmRlZmluZWQsXG4gICAgICAgIHNsaWRlV2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgc2xpZGVIZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgJGltYWdlRWw6IHVuZGVmaW5lZCxcbiAgICAgICAgJGltYWdlV3JhcEVsOiB1bmRlZmluZWQsXG4gICAgICAgIG1heFJhdGlvOiAzXG4gICAgICB9O1xuICAgICAgY29uc3QgaW1hZ2UgPSB7XG4gICAgICAgIGlzVG91Y2hlZDogdW5kZWZpbmVkLFxuICAgICAgICBpc01vdmVkOiB1bmRlZmluZWQsXG4gICAgICAgIGN1cnJlbnRYOiB1bmRlZmluZWQsXG4gICAgICAgIGN1cnJlbnRZOiB1bmRlZmluZWQsXG4gICAgICAgIG1pblg6IHVuZGVmaW5lZCxcbiAgICAgICAgbWluWTogdW5kZWZpbmVkLFxuICAgICAgICBtYXhYOiB1bmRlZmluZWQsXG4gICAgICAgIG1heFk6IHVuZGVmaW5lZCxcbiAgICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0WDogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydFk6IHVuZGVmaW5lZCxcbiAgICAgICAgdG91Y2hlc1N0YXJ0OiB7fSxcbiAgICAgICAgdG91Y2hlc0N1cnJlbnQ6IHt9XG4gICAgICB9O1xuICAgICAgY29uc3QgdmVsb2NpdHkgPSB7XG4gICAgICAgIHg6IHVuZGVmaW5lZCxcbiAgICAgICAgeTogdW5kZWZpbmVkLFxuICAgICAgICBwcmV2UG9zaXRpb25YOiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZQb3NpdGlvblk6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJldlRpbWU6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGxldCBzY2FsZSA9IDE7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3dpcGVyLnpvb20sICdzY2FsZScsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpZiAoc2NhbGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUVsID0gZ2VzdHVyZS4kaW1hZ2VFbCA/IGdlc3R1cmUuJGltYWdlRWxbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBzbGlkZUVsID0gZ2VzdHVyZS4kc2xpZGVFbCA/IGdlc3R1cmUuJHNsaWRlRWxbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlbWl0KCd6b29tQ2hhbmdlJywgdmFsdWUsIGltYWdlRWwsIHNsaWRlRWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjYWxlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldERpc3RhbmNlQmV0d2VlblRvdWNoZXMoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpIHJldHVybiAxO1xuICAgICAgICBjb25zdCB4MSA9IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgY29uc3QgeTEgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIGNvbnN0IHgyID0gZS50YXJnZXRUb3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgICBjb25zdCB5MiA9IGUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKHgyIC0geDEpICoqIDIgKyAoeTIgLSB5MSkgKiogMik7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZTtcbiAgICAgIH0gLy8gRXZlbnRzXG5cblxuICAgICAgZnVuY3Rpb24gb25HZXN0dXJlU3RhcnQoZSkge1xuICAgICAgICBjb25zdCBzdXBwb3J0ID0gc3dpcGVyLnN1cHBvcnQ7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcbiAgICAgICAgZmFrZUdlc3R1cmVUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIGZha2VHZXN0dXJlTW92ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXN1cHBvcnQuZ2VzdHVyZXMpIHtcbiAgICAgICAgICBpZiAoZS50eXBlICE9PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmYWtlR2VzdHVyZVRvdWNoZWQgPSB0cnVlO1xuICAgICAgICAgIGdlc3R1cmUuc2NhbGVTdGFydCA9IGdldERpc3RhbmNlQmV0d2VlblRvdWNoZXMoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdlc3R1cmUuJHNsaWRlRWwgfHwgIWdlc3R1cmUuJHNsaWRlRWwubGVuZ3RoKSB7XG4gICAgICAgICAgZ2VzdHVyZS4kc2xpZGVFbCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gKTtcbiAgICAgICAgICBpZiAoZ2VzdHVyZS4kc2xpZGVFbC5sZW5ndGggPT09IDApIGdlc3R1cmUuJHNsaWRlRWwgPSBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgZ2VzdHVyZS4kaW1hZ2VFbCA9IGdlc3R1cmUuJHNsaWRlRWwuZmluZChgLiR7cGFyYW1zLmNvbnRhaW5lckNsYXNzfWApLmVxKDApLmZpbmQoJ2ltZywgc3ZnLCBjYW52YXMsIHBpY3R1cmUsIC5zd2lwZXItem9vbS10YXJnZXQnKTtcbiAgICAgICAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbCA9IGdlc3R1cmUuJGltYWdlRWwucGFyZW50KGAuJHtwYXJhbXMuY29udGFpbmVyQ2xhc3N9YCk7XG4gICAgICAgICAgZ2VzdHVyZS5tYXhSYXRpbyA9IGdlc3R1cmUuJGltYWdlV3JhcEVsLmF0dHIoJ2RhdGEtc3dpcGVyLXpvb20nKSB8fCBwYXJhbXMubWF4UmF0aW87XG5cbiAgICAgICAgICBpZiAoZ2VzdHVyZS4kaW1hZ2VXcmFwRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXN0dXJlLiRpbWFnZUVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZXN0dXJlLiRpbWFnZUVsKSB7XG4gICAgICAgICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2l0aW9uKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNTY2FsaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25HZXN0dXJlQ2hhbmdlKGUpIHtcbiAgICAgICAgY29uc3Qgc3VwcG9ydCA9IHN3aXBlci5zdXBwb3J0O1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnpvb207XG4gICAgICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcblxuICAgICAgICBpZiAoIXN1cHBvcnQuZ2VzdHVyZXMpIHtcbiAgICAgICAgICBpZiAoZS50eXBlICE9PSAndG91Y2htb3ZlJyB8fCBlLnR5cGUgPT09ICd0b3VjaG1vdmUnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmFrZUdlc3R1cmVNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgZ2VzdHVyZS5zY2FsZU1vdmUgPSBnZXREaXN0YW5jZUJldHdlZW5Ub3VjaGVzKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2dlc3R1cmVjaGFuZ2UnKSBvbkdlc3R1cmVTdGFydChlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VwcG9ydC5nZXN0dXJlcykge1xuICAgICAgICAgIHpvb20uc2NhbGUgPSBlLnNjYWxlICogY3VycmVudFNjYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHpvb20uc2NhbGUgPSBnZXN0dXJlLnNjYWxlTW92ZSAvIGdlc3R1cmUuc2NhbGVTdGFydCAqIGN1cnJlbnRTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6b29tLnNjYWxlID4gZ2VzdHVyZS5tYXhSYXRpbykge1xuICAgICAgICAgIHpvb20uc2NhbGUgPSBnZXN0dXJlLm1heFJhdGlvIC0gMSArICh6b29tLnNjYWxlIC0gZ2VzdHVyZS5tYXhSYXRpbyArIDEpICoqIDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6b29tLnNjYWxlIDwgcGFyYW1zLm1pblJhdGlvKSB7XG4gICAgICAgICAgem9vbS5zY2FsZSA9IHBhcmFtcy5taW5SYXRpbyArIDEgLSAocGFyYW1zLm1pblJhdGlvIC0gem9vbS5zY2FsZSArIDEpICoqIDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoJHt6b29tLnNjYWxlfSlgKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25HZXN0dXJlRW5kKGUpIHtcbiAgICAgICAgY29uc3QgZGV2aWNlID0gc3dpcGVyLmRldmljZTtcbiAgICAgICAgY29uc3Qgc3VwcG9ydCA9IHN3aXBlci5zdXBwb3J0O1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnpvb207XG4gICAgICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcblxuICAgICAgICBpZiAoIXN1cHBvcnQuZ2VzdHVyZXMpIHtcbiAgICAgICAgICBpZiAoIWZha2VHZXN0dXJlVG91Y2hlZCB8fCAhZmFrZUdlc3R1cmVNb3ZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlLnR5cGUgIT09ICd0b3VjaGVuZCcgfHwgZS50eXBlID09PSAndG91Y2hlbmQnICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDwgMiAmJiAhZGV2aWNlLmFuZHJvaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmYWtlR2VzdHVyZVRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICBmYWtlR2VzdHVyZU1vdmVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgem9vbS5zY2FsZSA9IE1hdGgubWF4KE1hdGgubWluKHpvb20uc2NhbGUsIGdlc3R1cmUubWF4UmF0aW8pLCBwYXJhbXMubWluUmF0aW8pO1xuICAgICAgICBnZXN0dXJlLiRpbWFnZUVsLnRyYW5zaXRpb24oc3dpcGVyLnBhcmFtcy5zcGVlZCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoJHt6b29tLnNjYWxlfSlgKTtcbiAgICAgICAgY3VycmVudFNjYWxlID0gem9vbS5zY2FsZTtcbiAgICAgICAgaXNTY2FsaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh6b29tLnNjYWxlID09PSAxKSBnZXN0dXJlLiRzbGlkZUVsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgICBjb25zdCBkZXZpY2UgPSBzd2lwZXIuZGV2aWNlO1xuICAgICAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgaWYgKGltYWdlLmlzVG91Y2hlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZGV2aWNlLmFuZHJvaWQgJiYgZS5jYW5jZWxhYmxlKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGltYWdlLmlzVG91Y2hlZCA9IHRydWU7XG4gICAgICAgIGltYWdlLnRvdWNoZXNTdGFydC54ID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgICBpbWFnZS50b3VjaGVzU3RhcnQueSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xuICAgICAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgICAgIGlmICghZ2VzdHVyZS4kaW1hZ2VFbCB8fCBnZXN0dXJlLiRpbWFnZUVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xuICAgICAgICBpZiAoIWltYWdlLmlzVG91Y2hlZCB8fCAhZ2VzdHVyZS4kc2xpZGVFbCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghaW1hZ2UuaXNNb3ZlZCkge1xuICAgICAgICAgIGltYWdlLndpZHRoID0gZ2VzdHVyZS4kaW1hZ2VFbFswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBpbWFnZS5oZWlnaHQgPSBnZXN0dXJlLiRpbWFnZUVsWzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgICBpbWFnZS5zdGFydFggPSBnZXRUcmFuc2xhdGUoZ2VzdHVyZS4kaW1hZ2VXcmFwRWxbMF0sICd4JykgfHwgMDtcbiAgICAgICAgICBpbWFnZS5zdGFydFkgPSBnZXRUcmFuc2xhdGUoZ2VzdHVyZS4kaW1hZ2VXcmFwRWxbMF0sICd5JykgfHwgMDtcbiAgICAgICAgICBnZXN0dXJlLnNsaWRlV2lkdGggPSBnZXN0dXJlLiRzbGlkZUVsWzBdLm9mZnNldFdpZHRoO1xuICAgICAgICAgIGdlc3R1cmUuc2xpZGVIZWlnaHQgPSBnZXN0dXJlLiRzbGlkZUVsWzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDApO1xuICAgICAgICB9IC8vIERlZmluZSBpZiB3ZSBuZWVkIGltYWdlIGRyYWdcblxuXG4gICAgICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gaW1hZ2Uud2lkdGggKiB6b29tLnNjYWxlO1xuICAgICAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBpbWFnZS5oZWlnaHQgKiB6b29tLnNjYWxlO1xuICAgICAgICBpZiAoc2NhbGVkV2lkdGggPCBnZXN0dXJlLnNsaWRlV2lkdGggJiYgc2NhbGVkSGVpZ2h0IDwgZ2VzdHVyZS5zbGlkZUhlaWdodCkgcmV0dXJuO1xuICAgICAgICBpbWFnZS5taW5YID0gTWF0aC5taW4oZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMiAtIHNjYWxlZFdpZHRoIC8gMiwgMCk7XG4gICAgICAgIGltYWdlLm1heFggPSAtaW1hZ2UubWluWDtcbiAgICAgICAgaW1hZ2UubWluWSA9IE1hdGgubWluKGdlc3R1cmUuc2xpZGVIZWlnaHQgLyAyIC0gc2NhbGVkSGVpZ2h0IC8gMiwgMCk7XG4gICAgICAgIGltYWdlLm1heFkgPSAtaW1hZ2UubWluWTtcbiAgICAgICAgaW1hZ2UudG91Y2hlc0N1cnJlbnQueCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgICBpbWFnZS50b3VjaGVzQ3VycmVudC55ID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG5cbiAgICAgICAgaWYgKCFpbWFnZS5pc01vdmVkICYmICFpc1NjYWxpbmcpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpICYmIChNYXRoLmZsb29yKGltYWdlLm1pblgpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WCkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueCA8IGltYWdlLnRvdWNoZXNTdGFydC54IHx8IE1hdGguZmxvb3IoaW1hZ2UubWF4WCkgPT09IE1hdGguZmxvb3IoaW1hZ2Uuc3RhcnRYKSAmJiBpbWFnZS50b3VjaGVzQ3VycmVudC54ID4gaW1hZ2UudG91Y2hlc1N0YXJ0LngpKSB7XG4gICAgICAgICAgICBpbWFnZS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXN3aXBlci5pc0hvcml6b250YWwoKSAmJiAoTWF0aC5mbG9vcihpbWFnZS5taW5ZKSA9PT0gTWF0aC5mbG9vcihpbWFnZS5zdGFydFkpICYmIGltYWdlLnRvdWNoZXNDdXJyZW50LnkgPCBpbWFnZS50b3VjaGVzU3RhcnQueSB8fCBNYXRoLmZsb29yKGltYWdlLm1heFkpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WSkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA+IGltYWdlLnRvdWNoZXNTdGFydC55KSkge1xuICAgICAgICAgICAgaW1hZ2UuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGltYWdlLmlzTW92ZWQgPSB0cnVlO1xuICAgICAgICBpbWFnZS5jdXJyZW50WCA9IGltYWdlLnRvdWNoZXNDdXJyZW50LnggLSBpbWFnZS50b3VjaGVzU3RhcnQueCArIGltYWdlLnN0YXJ0WDtcbiAgICAgICAgaW1hZ2UuY3VycmVudFkgPSBpbWFnZS50b3VjaGVzQ3VycmVudC55IC0gaW1hZ2UudG91Y2hlc1N0YXJ0LnkgKyBpbWFnZS5zdGFydFk7XG5cbiAgICAgICAgaWYgKGltYWdlLmN1cnJlbnRYIDwgaW1hZ2UubWluWCkge1xuICAgICAgICAgIGltYWdlLmN1cnJlbnRYID0gaW1hZ2UubWluWCArIDEgLSAoaW1hZ2UubWluWCAtIGltYWdlLmN1cnJlbnRYICsgMSkgKiogMC44O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltYWdlLmN1cnJlbnRYID4gaW1hZ2UubWF4WCkge1xuICAgICAgICAgIGltYWdlLmN1cnJlbnRYID0gaW1hZ2UubWF4WCAtIDEgKyAoaW1hZ2UuY3VycmVudFggLSBpbWFnZS5tYXhYICsgMSkgKiogMC44O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltYWdlLmN1cnJlbnRZIDwgaW1hZ2UubWluWSkge1xuICAgICAgICAgIGltYWdlLmN1cnJlbnRZID0gaW1hZ2UubWluWSArIDEgLSAoaW1hZ2UubWluWSAtIGltYWdlLmN1cnJlbnRZICsgMSkgKiogMC44O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltYWdlLmN1cnJlbnRZID4gaW1hZ2UubWF4WSkge1xuICAgICAgICAgIGltYWdlLmN1cnJlbnRZID0gaW1hZ2UubWF4WSAtIDEgKyAoaW1hZ2UuY3VycmVudFkgLSBpbWFnZS5tYXhZICsgMSkgKiogMC44O1xuICAgICAgICB9IC8vIFZlbG9jaXR5XG5cblxuICAgICAgICBpZiAoIXZlbG9jaXR5LnByZXZQb3NpdGlvblgpIHZlbG9jaXR5LnByZXZQb3NpdGlvblggPSBpbWFnZS50b3VjaGVzQ3VycmVudC54O1xuICAgICAgICBpZiAoIXZlbG9jaXR5LnByZXZQb3NpdGlvblkpIHZlbG9jaXR5LnByZXZQb3NpdGlvblkgPSBpbWFnZS50b3VjaGVzQ3VycmVudC55O1xuICAgICAgICBpZiAoIXZlbG9jaXR5LnByZXZUaW1lKSB2ZWxvY2l0eS5wcmV2VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZlbG9jaXR5LnggPSAoaW1hZ2UudG91Y2hlc0N1cnJlbnQueCAtIHZlbG9jaXR5LnByZXZQb3NpdGlvblgpIC8gKERhdGUubm93KCkgLSB2ZWxvY2l0eS5wcmV2VGltZSkgLyAyO1xuICAgICAgICB2ZWxvY2l0eS55ID0gKGltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZKSAvIChEYXRlLm5vdygpIC0gdmVsb2NpdHkucHJldlRpbWUpIC8gMjtcbiAgICAgICAgaWYgKE1hdGguYWJzKGltYWdlLnRvdWNoZXNDdXJyZW50LnggLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25YKSA8IDIpIHZlbG9jaXR5LnggPSAwO1xuICAgICAgICBpZiAoTWF0aC5hYnMoaW1hZ2UudG91Y2hlc0N1cnJlbnQueSAtIHZlbG9jaXR5LnByZXZQb3NpdGlvblkpIDwgMikgdmVsb2NpdHkueSA9IDA7XG4gICAgICAgIHZlbG9jaXR5LnByZXZQb3NpdGlvblggPSBpbWFnZS50b3VjaGVzQ3VycmVudC54O1xuICAgICAgICB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZID0gaW1hZ2UudG91Y2hlc0N1cnJlbnQueTtcbiAgICAgICAgdmVsb2NpdHkucHJldlRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7aW1hZ2UuY3VycmVudFh9cHgsICR7aW1hZ2UuY3VycmVudFl9cHgsMClgKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcbiAgICAgICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuICAgICAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBpZiAoIWltYWdlLmlzVG91Y2hlZCB8fCAhaW1hZ2UuaXNNb3ZlZCkge1xuICAgICAgICAgIGltYWdlLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgIGltYWdlLmlzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgaW1hZ2UuaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgbW9tZW50dW1EdXJhdGlvblggPSAzMDA7XG4gICAgICAgIGxldCBtb21lbnR1bUR1cmF0aW9uWSA9IDMwMDtcbiAgICAgICAgY29uc3QgbW9tZW50dW1EaXN0YW5jZVggPSB2ZWxvY2l0eS54ICogbW9tZW50dW1EdXJhdGlvblg7XG4gICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uWCA9IGltYWdlLmN1cnJlbnRYICsgbW9tZW50dW1EaXN0YW5jZVg7XG4gICAgICAgIGNvbnN0IG1vbWVudHVtRGlzdGFuY2VZID0gdmVsb2NpdHkueSAqIG1vbWVudHVtRHVyYXRpb25ZO1xuICAgICAgICBjb25zdCBuZXdQb3NpdGlvblkgPSBpbWFnZS5jdXJyZW50WSArIG1vbWVudHVtRGlzdGFuY2VZOyAvLyBGaXggZHVyYXRpb25cblxuICAgICAgICBpZiAodmVsb2NpdHkueCAhPT0gMCkgbW9tZW50dW1EdXJhdGlvblggPSBNYXRoLmFicygobmV3UG9zaXRpb25YIC0gaW1hZ2UuY3VycmVudFgpIC8gdmVsb2NpdHkueCk7XG4gICAgICAgIGlmICh2ZWxvY2l0eS55ICE9PSAwKSBtb21lbnR1bUR1cmF0aW9uWSA9IE1hdGguYWJzKChuZXdQb3NpdGlvblkgLSBpbWFnZS5jdXJyZW50WSkgLyB2ZWxvY2l0eS55KTtcbiAgICAgICAgY29uc3QgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGgubWF4KG1vbWVudHVtRHVyYXRpb25YLCBtb21lbnR1bUR1cmF0aW9uWSk7XG4gICAgICAgIGltYWdlLmN1cnJlbnRYID0gbmV3UG9zaXRpb25YO1xuICAgICAgICBpbWFnZS5jdXJyZW50WSA9IG5ld1Bvc2l0aW9uWTsgLy8gRGVmaW5lIGlmIHdlIG5lZWQgaW1hZ2UgZHJhZ1xuXG4gICAgICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gaW1hZ2Uud2lkdGggKiB6b29tLnNjYWxlO1xuICAgICAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBpbWFnZS5oZWlnaHQgKiB6b29tLnNjYWxlO1xuICAgICAgICBpbWFnZS5taW5YID0gTWF0aC5taW4oZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMiAtIHNjYWxlZFdpZHRoIC8gMiwgMCk7XG4gICAgICAgIGltYWdlLm1heFggPSAtaW1hZ2UubWluWDtcbiAgICAgICAgaW1hZ2UubWluWSA9IE1hdGgubWluKGdlc3R1cmUuc2xpZGVIZWlnaHQgLyAyIC0gc2NhbGVkSGVpZ2h0IC8gMiwgMCk7XG4gICAgICAgIGltYWdlLm1heFkgPSAtaW1hZ2UubWluWTtcbiAgICAgICAgaW1hZ2UuY3VycmVudFggPSBNYXRoLm1heChNYXRoLm1pbihpbWFnZS5jdXJyZW50WCwgaW1hZ2UubWF4WCksIGltYWdlLm1pblgpO1xuICAgICAgICBpbWFnZS5jdXJyZW50WSA9IE1hdGgubWF4KE1hdGgubWluKGltYWdlLmN1cnJlbnRZLCBpbWFnZS5tYXhZKSwgaW1hZ2UubWluWSk7XG4gICAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsLnRyYW5zaXRpb24obW9tZW50dW1EdXJhdGlvbikudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2ltYWdlLmN1cnJlbnRYfXB4LCAke2ltYWdlLmN1cnJlbnRZfXB4LDApYCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZCgpIHtcbiAgICAgICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuXG4gICAgICAgIGlmIChnZXN0dXJlLiRzbGlkZUVsICYmIHN3aXBlci5wcmV2aW91c0luZGV4ICE9PSBzd2lwZXIuYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgICBpZiAoZ2VzdHVyZS4kaW1hZ2VFbCkge1xuICAgICAgICAgICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChnZXN0dXJlLiRpbWFnZVdyYXBFbCkge1xuICAgICAgICAgICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgwLDAsMCknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB6b29tLnNjYWxlID0gMTtcbiAgICAgICAgICBjdXJyZW50U2NhbGUgPSAxO1xuICAgICAgICAgIGdlc3R1cmUuJHNsaWRlRWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZ2VzdHVyZS4kaW1hZ2VFbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB6b29tSW4oZSkge1xuICAgICAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcblxuICAgICAgICBpZiAoIWdlc3R1cmUuJHNsaWRlRWwpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCkge1xuICAgICAgICAgICAgZ2VzdHVyZS4kc2xpZGVFbCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWdlc3R1cmUuJHNsaWRlRWwpIHtcbiAgICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgc3dpcGVyLnZpcnR1YWwpIHtcbiAgICAgICAgICAgICAgZ2VzdHVyZS4kc2xpZGVFbCA9IHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnZXN0dXJlLiRzbGlkZUVsID0gc3dpcGVyLnNsaWRlcy5lcShzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGdlc3R1cmUuJGltYWdlRWwgPSBnZXN0dXJlLiRzbGlkZUVsLmZpbmQoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKS5lcSgwKS5maW5kKCdpbWcsIHN2ZywgY2FudmFzLCBwaWN0dXJlLCAuc3dpcGVyLXpvb20tdGFyZ2V0Jyk7XG4gICAgICAgICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwgPSBnZXN0dXJlLiRpbWFnZUVsLnBhcmVudChgLiR7cGFyYW1zLmNvbnRhaW5lckNsYXNzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwIHx8ICFnZXN0dXJlLiRpbWFnZVdyYXBFbCB8fCBnZXN0dXJlLiRpbWFnZVdyYXBFbC5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBnZXN0dXJlLiRzbGlkZUVsLmFkZENsYXNzKGAke3BhcmFtcy56b29tZWRTbGlkZUNsYXNzfWApO1xuICAgICAgICBsZXQgdG91Y2hYO1xuICAgICAgICBsZXQgdG91Y2hZO1xuICAgICAgICBsZXQgb2Zmc2V0WDtcbiAgICAgICAgbGV0IG9mZnNldFk7XG4gICAgICAgIGxldCBkaWZmWDtcbiAgICAgICAgbGV0IGRpZmZZO1xuICAgICAgICBsZXQgdHJhbnNsYXRlWDtcbiAgICAgICAgbGV0IHRyYW5zbGF0ZVk7XG4gICAgICAgIGxldCBpbWFnZVdpZHRoO1xuICAgICAgICBsZXQgaW1hZ2VIZWlnaHQ7XG4gICAgICAgIGxldCBzY2FsZWRXaWR0aDtcbiAgICAgICAgbGV0IHNjYWxlZEhlaWdodDtcbiAgICAgICAgbGV0IHRyYW5zbGF0ZU1pblg7XG4gICAgICAgIGxldCB0cmFuc2xhdGVNaW5ZO1xuICAgICAgICBsZXQgdHJhbnNsYXRlTWF4WDtcbiAgICAgICAgbGV0IHRyYW5zbGF0ZU1heFk7XG4gICAgICAgIGxldCBzbGlkZVdpZHRoO1xuICAgICAgICBsZXQgc2xpZGVIZWlnaHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZS50b3VjaGVzU3RhcnQueCA9PT0gJ3VuZGVmaW5lZCcgJiYgZSkge1xuICAgICAgICAgIHRvdWNoWCA9IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgICAgIHRvdWNoWSA9IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdWNoWCA9IGltYWdlLnRvdWNoZXNTdGFydC54O1xuICAgICAgICAgIHRvdWNoWSA9IGltYWdlLnRvdWNoZXNTdGFydC55O1xuICAgICAgICB9XG5cbiAgICAgICAgem9vbS5zY2FsZSA9IGdlc3R1cmUuJGltYWdlV3JhcEVsLmF0dHIoJ2RhdGEtc3dpcGVyLXpvb20nKSB8fCBwYXJhbXMubWF4UmF0aW87XG4gICAgICAgIGN1cnJlbnRTY2FsZSA9IGdlc3R1cmUuJGltYWdlV3JhcEVsLmF0dHIoJ2RhdGEtc3dpcGVyLXpvb20nKSB8fCBwYXJhbXMubWF4UmF0aW87XG5cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBzbGlkZVdpZHRoID0gZ2VzdHVyZS4kc2xpZGVFbFswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBzbGlkZUhlaWdodCA9IGdlc3R1cmUuJHNsaWRlRWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIG9mZnNldFggPSBnZXN0dXJlLiRzbGlkZUVsLm9mZnNldCgpLmxlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICBvZmZzZXRZID0gZ2VzdHVyZS4kc2xpZGVFbC5vZmZzZXQoKS50b3AgKyB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgICBkaWZmWCA9IG9mZnNldFggKyBzbGlkZVdpZHRoIC8gMiAtIHRvdWNoWDtcbiAgICAgICAgICBkaWZmWSA9IG9mZnNldFkgKyBzbGlkZUhlaWdodCAvIDIgLSB0b3VjaFk7XG4gICAgICAgICAgaW1hZ2VXaWR0aCA9IGdlc3R1cmUuJGltYWdlRWxbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgaW1hZ2VIZWlnaHQgPSBnZXN0dXJlLiRpbWFnZUVsWzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgICBzY2FsZWRXaWR0aCA9IGltYWdlV2lkdGggKiB6b29tLnNjYWxlO1xuICAgICAgICAgIHNjYWxlZEhlaWdodCA9IGltYWdlSGVpZ2h0ICogem9vbS5zY2FsZTtcbiAgICAgICAgICB0cmFuc2xhdGVNaW5YID0gTWF0aC5taW4oc2xpZGVXaWR0aCAvIDIgLSBzY2FsZWRXaWR0aCAvIDIsIDApO1xuICAgICAgICAgIHRyYW5zbGF0ZU1pblkgPSBNYXRoLm1pbihzbGlkZUhlaWdodCAvIDIgLSBzY2FsZWRIZWlnaHQgLyAyLCAwKTtcbiAgICAgICAgICB0cmFuc2xhdGVNYXhYID0gLXRyYW5zbGF0ZU1pblg7XG4gICAgICAgICAgdHJhbnNsYXRlTWF4WSA9IC10cmFuc2xhdGVNaW5ZO1xuICAgICAgICAgIHRyYW5zbGF0ZVggPSBkaWZmWCAqIHpvb20uc2NhbGU7XG4gICAgICAgICAgdHJhbnNsYXRlWSA9IGRpZmZZICogem9vbS5zY2FsZTtcblxuICAgICAgICAgIGlmICh0cmFuc2xhdGVYIDwgdHJhbnNsYXRlTWluWCkge1xuICAgICAgICAgICAgdHJhbnNsYXRlWCA9IHRyYW5zbGF0ZU1pblg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRyYW5zbGF0ZVggPiB0cmFuc2xhdGVNYXhYKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVYID0gdHJhbnNsYXRlTWF4WDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhbnNsYXRlWSA8IHRyYW5zbGF0ZU1pblkpIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVNaW5ZO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0cmFuc2xhdGVZID4gdHJhbnNsYXRlTWF4WSkge1xuICAgICAgICAgICAgdHJhbnNsYXRlWSA9IHRyYW5zbGF0ZU1heFk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zbGF0ZVggPSAwO1xuICAgICAgICAgIHRyYW5zbGF0ZVkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVYfXB4LCAke3RyYW5zbGF0ZVl9cHgsMClgKTtcbiAgICAgICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoJHt6b29tLnNjYWxlfSlgKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gem9vbU91dCgpIHtcbiAgICAgICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnpvb207XG5cbiAgICAgICAgaWYgKCFnZXN0dXJlLiRzbGlkZUVsKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBzd2lwZXIudmlydHVhbCkge1xuICAgICAgICAgICAgZ2VzdHVyZS4kc2xpZGVFbCA9IHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlc3R1cmUuJHNsaWRlRWwgPSBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2VzdHVyZS4kaW1hZ2VFbCA9IGdlc3R1cmUuJHNsaWRlRWwuZmluZChgLiR7cGFyYW1zLmNvbnRhaW5lckNsYXNzfWApLmVxKDApLmZpbmQoJ2ltZywgc3ZnLCBjYW52YXMsIHBpY3R1cmUsIC5zd2lwZXItem9vbS10YXJnZXQnKTtcbiAgICAgICAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbCA9IGdlc3R1cmUuJGltYWdlRWwucGFyZW50KGAuJHtwYXJhbXMuY29udGFpbmVyQ2xhc3N9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDAgfHwgIWdlc3R1cmUuJGltYWdlV3JhcEVsIHx8IGdlc3R1cmUuJGltYWdlV3JhcEVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS50b3VjaEFjdGlvbiA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgem9vbS5zY2FsZSA9IDE7XG4gICAgICAgIGN1cnJlbnRTY2FsZSA9IDE7XG4gICAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsLnRyYW5zaXRpb24oMzAwKS50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDAsMCwwKScpO1xuICAgICAgICBnZXN0dXJlLiRpbWFnZUVsLnRyYW5zaXRpb24oMzAwKS50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKScpO1xuICAgICAgICBnZXN0dXJlLiRzbGlkZUVsLnJlbW92ZUNsYXNzKGAke3BhcmFtcy56b29tZWRTbGlkZUNsYXNzfWApO1xuICAgICAgICBnZXN0dXJlLiRzbGlkZUVsID0gdW5kZWZpbmVkO1xuICAgICAgfSAvLyBUb2dnbGUgWm9vbVxuXG5cbiAgICAgIGZ1bmN0aW9uIHpvb21Ub2dnbGUoZSkge1xuICAgICAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG5cbiAgICAgICAgaWYgKHpvb20uc2NhbGUgJiYgem9vbS5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgIC8vIFpvb20gT3V0XG4gICAgICAgICAgem9vbU91dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFpvb20gSW5cbiAgICAgICAgICB6b29tSW4oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKCkge1xuICAgICAgICBjb25zdCBzdXBwb3J0ID0gc3dpcGVyLnN1cHBvcnQ7XG4gICAgICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIHN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHN3aXBlci5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHtcbiAgICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgY29uc3QgYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZSA9IHN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyID8ge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSA6IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzc2l2ZUxpc3RlbmVyLFxuICAgICAgICAgIGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U2xpZGVTZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9nZ2xlR2VzdHVyZXMobWV0aG9kKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXNzaXZlTGlzdGVuZXJcbiAgICAgICAgfSA9IGdldExpc3RlbmVycygpO1xuICAgICAgICBjb25zdCBzbGlkZVNlbGVjdG9yID0gZ2V0U2xpZGVTZWxlY3RvcigpO1xuICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFttZXRob2RdKCdnZXN0dXJlc3RhcnQnLCBzbGlkZVNlbGVjdG9yLCBvbkdlc3R1cmVTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbbWV0aG9kXSgnZ2VzdHVyZWNoYW5nZScsIHNsaWRlU2VsZWN0b3IsIG9uR2VzdHVyZUNoYW5nZSwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbbWV0aG9kXSgnZ2VzdHVyZWVuZCcsIHNsaWRlU2VsZWN0b3IsIG9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5hYmxlR2VzdHVyZXMoKSB7XG4gICAgICAgIGlmIChnZXN0dXJlc0VuYWJsZWQpIHJldHVybjtcbiAgICAgICAgZ2VzdHVyZXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdG9nZ2xlR2VzdHVyZXMoJ29uJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRpc2FibGVHZXN0dXJlcygpIHtcbiAgICAgICAgaWYgKCFnZXN0dXJlc0VuYWJsZWQpIHJldHVybjtcbiAgICAgICAgZ2VzdHVyZXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRvZ2dsZUdlc3R1cmVzKCdvZmYnKTtcbiAgICAgIH0gLy8gQXR0YWNoL0RldGFjaCBFdmVudHNcblxuXG4gICAgICBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICAgICAgaWYgKHpvb20uZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICB6b29tLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBzdXBwb3J0ID0gc3dpcGVyLnN1cHBvcnQ7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXNzaXZlTGlzdGVuZXIsXG4gICAgICAgICAgYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZVxuICAgICAgICB9ID0gZ2V0TGlzdGVuZXJzKCk7XG4gICAgICAgIGNvbnN0IHNsaWRlU2VsZWN0b3IgPSBnZXRTbGlkZVNlbGVjdG9yKCk7IC8vIFNjYWxlIGltYWdlXG5cbiAgICAgICAgaWYgKHN1cHBvcnQuZ2VzdHVyZXMpIHtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vbihzd2lwZXIudG91Y2hFdmVudHMuc3RhcnQsIGVuYWJsZUdlc3R1cmVzLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKHN3aXBlci50b3VjaEV2ZW50cy5lbmQsIGRpc2FibGVHZXN0dXJlcywgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChzd2lwZXIudG91Y2hFdmVudHMuc3RhcnQgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCwgc2xpZGVTZWxlY3Rvciwgb25HZXN0dXJlU3RhcnQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub24oc3dpcGVyLnRvdWNoRXZlbnRzLm1vdmUsIHNsaWRlU2VsZWN0b3IsIG9uR2VzdHVyZUNoYW5nZSwgYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZSk7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub24oc3dpcGVyLnRvdWNoRXZlbnRzLmVuZCwgc2xpZGVTZWxlY3Rvciwgb25HZXN0dXJlRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuXG4gICAgICAgICAgaWYgKHN3aXBlci50b3VjaEV2ZW50cy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKHN3aXBlci50b3VjaEV2ZW50cy5jYW5jZWwsIHNsaWRlU2VsZWN0b3IsIG9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTW92ZSBpbWFnZVxuXG5cbiAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub24oc3dpcGVyLnRvdWNoRXZlbnRzLm1vdmUsIGAuJHtzd2lwZXIucGFyYW1zLnpvb20uY29udGFpbmVyQ2xhc3N9YCwgb25Ub3VjaE1vdmUsIGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgICAgIGlmICghem9vbS5lbmFibGVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHN1cHBvcnQgPSBzd2lwZXIuc3VwcG9ydDtcbiAgICAgICAgem9vbS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXNzaXZlTGlzdGVuZXIsXG4gICAgICAgICAgYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZVxuICAgICAgICB9ID0gZ2V0TGlzdGVuZXJzKCk7XG4gICAgICAgIGNvbnN0IHNsaWRlU2VsZWN0b3IgPSBnZXRTbGlkZVNlbGVjdG9yKCk7IC8vIFNjYWxlIGltYWdlXG5cbiAgICAgICAgaWYgKHN1cHBvcnQuZ2VzdHVyZXMpIHtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLnN0YXJ0LCBlbmFibGVHZXN0dXJlcywgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLmVuZCwgZGlzYWJsZUdlc3R1cmVzLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCwgc2xpZGVTZWxlY3Rvciwgb25HZXN0dXJlU3RhcnQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKHN3aXBlci50b3VjaEV2ZW50cy5tb3ZlLCBzbGlkZVNlbGVjdG9yLCBvbkdlc3R1cmVDaGFuZ2UsIGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmUpO1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9mZihzd2lwZXIudG91Y2hFdmVudHMuZW5kLCBzbGlkZVNlbGVjdG9yLCBvbkdlc3R1cmVFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnRvdWNoRXZlbnRzLmNhbmNlbCkge1xuICAgICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKHN3aXBlci50b3VjaEV2ZW50cy5jYW5jZWwsIHNsaWRlU2VsZWN0b3IsIG9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTW92ZSBpbWFnZVxuXG5cbiAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKHN3aXBlci50b3VjaEV2ZW50cy5tb3ZlLCBgLiR7c3dpcGVyLnBhcmFtcy56b29tLmNvbnRhaW5lckNsYXNzfWAsIG9uVG91Y2hNb3ZlLCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlKTtcbiAgICAgIH1cblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnpvb20uZW5hYmxlZCkge1xuICAgICAgICAgIGVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICBkaXNhYmxlKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCd0b3VjaFN0YXJ0JywgKF9zLCBlKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLnpvb20uZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBvblRvdWNoU3RhcnQoZSk7XG4gICAgICB9KTtcbiAgICAgIG9uKCd0b3VjaEVuZCcsIChfcywgZSkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci56b29tLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgb25Ub3VjaEVuZCgpO1xuICAgICAgfSk7XG4gICAgICBvbignZG91YmxlVGFwJywgKF9zLCBlKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLmFuaW1hdGluZyAmJiBzd2lwZXIucGFyYW1zLnpvb20uZW5hYmxlZCAmJiBzd2lwZXIuem9vbS5lbmFibGVkICYmIHN3aXBlci5wYXJhbXMuem9vbS50b2dnbGUpIHtcbiAgICAgICAgICB6b29tVG9nZ2xlKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCd0cmFuc2l0aW9uRW5kJywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnpvb20uZW5hYmxlZCAmJiBzd2lwZXIucGFyYW1zLnpvb20uZW5hYmxlZCkge1xuICAgICAgICAgIG9uVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdzbGlkZUNoYW5nZScsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgICAgb25UcmFuc2l0aW9uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIuem9vbSwge1xuICAgICAgICBlbmFibGUsXG4gICAgICAgIGRpc2FibGUsXG4gICAgICAgIGluOiB6b29tSW4sXG4gICAgICAgIG91dDogem9vbU91dCxcbiAgICAgICAgdG9nZ2xlOiB6b29tVG9nZ2xlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMYXp5KHtcbiAgICAgIHN3aXBlcixcbiAgICAgIGV4dGVuZFBhcmFtcyxcbiAgICAgIG9uLFxuICAgICAgZW1pdFxuICAgIH0pIHtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIGxhenk6IHtcbiAgICAgICAgICBjaGVja0luVmlldzogZmFsc2UsXG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgbG9hZFByZXZOZXh0OiBmYWxzZSxcbiAgICAgICAgICBsb2FkUHJldk5leHRBbW91bnQ6IDEsXG4gICAgICAgICAgbG9hZE9uVHJhbnNpdGlvblN0YXJ0OiBmYWxzZSxcbiAgICAgICAgICBzY3JvbGxpbmdFbGVtZW50OiAnJyxcbiAgICAgICAgICBlbGVtZW50Q2xhc3M6ICdzd2lwZXItbGF6eScsXG4gICAgICAgICAgbG9hZGluZ0NsYXNzOiAnc3dpcGVyLWxhenktbG9hZGluZycsXG4gICAgICAgICAgbG9hZGVkQ2xhc3M6ICdzd2lwZXItbGF6eS1sb2FkZWQnLFxuICAgICAgICAgIHByZWxvYWRlckNsYXNzOiAnc3dpcGVyLWxhenktcHJlbG9hZGVyJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci5sYXp5ID0ge307XG4gICAgICBsZXQgc2Nyb2xsSGFuZGxlckF0dGFjaGVkID0gZmFsc2U7XG4gICAgICBsZXQgaW5pdGlhbEltYWdlTG9hZGVkID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGxvYWRJblNsaWRlKGluZGV4LCBsb2FkSW5EdXBsaWNhdGUgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMubGF6eTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICAgICAgaWYgKHN3aXBlci5zbGlkZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgICAgICBjb25zdCAkc2xpZGVFbCA9IGlzVmlydHVhbCA/IHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpbmRleH1cIl1gKSA6IHN3aXBlci5zbGlkZXMuZXEoaW5kZXgpO1xuICAgICAgICBjb25zdCAkaW1hZ2VzID0gJHNsaWRlRWwuZmluZChgLiR7cGFyYW1zLmVsZW1lbnRDbGFzc306bm90KC4ke3BhcmFtcy5sb2FkZWRDbGFzc30pOm5vdCguJHtwYXJhbXMubG9hZGluZ0NsYXNzfSlgKTtcblxuICAgICAgICBpZiAoJHNsaWRlRWwuaGFzQ2xhc3MocGFyYW1zLmVsZW1lbnRDbGFzcykgJiYgISRzbGlkZUVsLmhhc0NsYXNzKHBhcmFtcy5sb2FkZWRDbGFzcykgJiYgISRzbGlkZUVsLmhhc0NsYXNzKHBhcmFtcy5sb2FkaW5nQ2xhc3MpKSB7XG4gICAgICAgICAgJGltYWdlcy5wdXNoKCRzbGlkZUVsWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkaW1hZ2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAkaW1hZ2VzLmVhY2goaW1hZ2VFbCA9PiB7XG4gICAgICAgICAgY29uc3QgJGltYWdlRWwgPSAkKGltYWdlRWwpO1xuICAgICAgICAgICRpbWFnZUVsLmFkZENsYXNzKHBhcmFtcy5sb2FkaW5nQ2xhc3MpO1xuICAgICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSAkaW1hZ2VFbC5hdHRyKCdkYXRhLWJhY2tncm91bmQnKTtcbiAgICAgICAgICBjb25zdCBzcmMgPSAkaW1hZ2VFbC5hdHRyKCdkYXRhLXNyYycpO1xuICAgICAgICAgIGNvbnN0IHNyY3NldCA9ICRpbWFnZUVsLmF0dHIoJ2RhdGEtc3Jjc2V0Jyk7XG4gICAgICAgICAgY29uc3Qgc2l6ZXMgPSAkaW1hZ2VFbC5hdHRyKCdkYXRhLXNpemVzJyk7XG4gICAgICAgICAgY29uc3QgJHBpY3R1cmVFbCA9ICRpbWFnZUVsLnBhcmVudCgncGljdHVyZScpO1xuICAgICAgICAgIHN3aXBlci5sb2FkSW1hZ2UoJGltYWdlRWxbMF0sIHNyYyB8fCBiYWNrZ3JvdW5kLCBzcmNzZXQsIHNpemVzLCBmYWxzZSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzd2lwZXIgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlciA9PT0gbnVsbCB8fCAhc3dpcGVyIHx8IHN3aXBlciAmJiAhc3dpcGVyLnBhcmFtcyB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICRpbWFnZUVsLmNzcygnYmFja2dyb3VuZC1pbWFnZScsIGB1cmwoXCIke2JhY2tncm91bmR9XCIpYCk7XG4gICAgICAgICAgICAgICRpbWFnZUVsLnJlbW92ZUF0dHIoJ2RhdGEtYmFja2dyb3VuZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHNyY3NldCkge1xuICAgICAgICAgICAgICAgICRpbWFnZUVsLmF0dHIoJ3NyY3NldCcsIHNyY3NldCk7XG4gICAgICAgICAgICAgICAgJGltYWdlRWwucmVtb3ZlQXR0cignZGF0YS1zcmNzZXQnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChzaXplcykge1xuICAgICAgICAgICAgICAgICRpbWFnZUVsLmF0dHIoJ3NpemVzJywgc2l6ZXMpO1xuICAgICAgICAgICAgICAgICRpbWFnZUVsLnJlbW92ZUF0dHIoJ2RhdGEtc2l6ZXMnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgkcGljdHVyZUVsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICRwaWN0dXJlRWwuY2hpbGRyZW4oJ3NvdXJjZScpLmVhY2goc291cmNlRWwgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgJHNvdXJjZSA9ICQoc291cmNlRWwpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoJHNvdXJjZS5hdHRyKCdkYXRhLXNyY3NldCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICRzb3VyY2UuYXR0cignc3Jjc2V0JywgJHNvdXJjZS5hdHRyKCdkYXRhLXNyY3NldCcpKTtcbiAgICAgICAgICAgICAgICAgICAgJHNvdXJjZS5yZW1vdmVBdHRyKCdkYXRhLXNyY3NldCcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgICRpbWFnZUVsLmF0dHIoJ3NyYycsIHNyYyk7XG4gICAgICAgICAgICAgICAgJGltYWdlRWwucmVtb3ZlQXR0cignZGF0YS1zcmMnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkaW1hZ2VFbC5hZGRDbGFzcyhwYXJhbXMubG9hZGVkQ2xhc3MpLnJlbW92ZUNsYXNzKHBhcmFtcy5sb2FkaW5nQ2xhc3MpO1xuICAgICAgICAgICAgJHNsaWRlRWwuZmluZChgLiR7cGFyYW1zLnByZWxvYWRlckNsYXNzfWApLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wICYmIGxvYWRJbkR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICBjb25zdCBzbGlkZU9yaWdpbmFsSW5kZXggPSAkc2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xuXG4gICAgICAgICAgICAgIGlmICgkc2xpZGVFbC5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTbGlkZSA9IHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3NsaWRlT3JpZ2luYWxJbmRleH1cIl06bm90KC4ke3N3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYCk7XG4gICAgICAgICAgICAgICAgbG9hZEluU2xpZGUob3JpZ2luYWxTbGlkZS5pbmRleCgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlZFNsaWRlID0gc3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3NsaWRlT3JpZ2luYWxJbmRleH1cIl1gKTtcbiAgICAgICAgICAgICAgICBsb2FkSW5TbGlkZShkdXBsaWNhdGVkU2xpZGUuaW5kZXgoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVtaXQoJ2xhenlJbWFnZVJlYWR5JywgJHNsaWRlRWxbMF0sICRpbWFnZUVsWzBdKTtcblxuICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b0hlaWdodCkge1xuICAgICAgICAgICAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVtaXQoJ2xhenlJbWFnZUxvYWQnLCAkc2xpZGVFbFswXSwgJGltYWdlRWxbMF0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgICAgcGFyYW1zOiBzd2lwZXJQYXJhbXMsXG4gICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgIGFjdGl2ZUluZGV4XG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlclBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlclBhcmFtcy5sYXp5O1xuICAgICAgICBsZXQgc2xpZGVzUGVyVmlldyA9IHN3aXBlclBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuXG4gICAgICAgIGlmIChzbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNsaWRlRXhpc3QoaW5kZXgpIHtcbiAgICAgICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgICBpZiAoJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7c3dpcGVyUGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpbmRleH1cIl1gKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzbGlkZXNbaW5kZXhdKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNsaWRlSW5kZXgoc2xpZGVFbCkge1xuICAgICAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHNsaWRlRWwpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICQoc2xpZGVFbCkuaW5kZXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5pdGlhbEltYWdlTG9hZGVkKSBpbml0aWFsSW1hZ2VMb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXJQYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3N9YCkuZWFjaChzbGlkZUVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaXNWaXJ0dWFsID8gJChzbGlkZUVsKS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpIDogJChzbGlkZUVsKS5pbmRleCgpO1xuICAgICAgICAgICAgbG9hZEluU2xpZGUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNsaWRlc1BlclZpZXcgPiAxKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4OyBpIDwgYWN0aXZlSW5kZXggKyBzbGlkZXNQZXJWaWV3OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChzbGlkZUV4aXN0KGkpKSBsb2FkSW5TbGlkZShpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9hZEluU2xpZGUoYWN0aXZlSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5sb2FkUHJldk5leHQpIHtcbiAgICAgICAgICBpZiAoc2xpZGVzUGVyVmlldyA+IDEgfHwgcGFyYW1zLmxvYWRQcmV2TmV4dEFtb3VudCAmJiBwYXJhbXMubG9hZFByZXZOZXh0QW1vdW50ID4gMSkge1xuICAgICAgICAgICAgY29uc3QgYW1vdW50ID0gcGFyYW1zLmxvYWRQcmV2TmV4dEFtb3VudDtcbiAgICAgICAgICAgIGNvbnN0IHNwdiA9IHNsaWRlc1BlclZpZXc7XG4gICAgICAgICAgICBjb25zdCBtYXhJbmRleCA9IE1hdGgubWluKGFjdGl2ZUluZGV4ICsgc3B2ICsgTWF0aC5tYXgoYW1vdW50LCBzcHYpLCBzbGlkZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG1pbkluZGV4ID0gTWF0aC5tYXgoYWN0aXZlSW5kZXggLSBNYXRoLm1heChzcHYsIGFtb3VudCksIDApOyAvLyBOZXh0IFNsaWRlc1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggKyBzbGlkZXNQZXJWaWV3OyBpIDwgbWF4SW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoc2xpZGVFeGlzdChpKSkgbG9hZEluU2xpZGUoaSk7XG4gICAgICAgICAgICB9IC8vIFByZXYgU2xpZGVzXG5cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1pbkluZGV4OyBpIDwgYWN0aXZlSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoc2xpZGVFeGlzdChpKSkgbG9hZEluU2xpZGUoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTbGlkZSA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlclBhcmFtcy5zbGlkZU5leHRDbGFzc31gKTtcbiAgICAgICAgICAgIGlmIChuZXh0U2xpZGUubGVuZ3RoID4gMCkgbG9hZEluU2xpZGUoc2xpZGVJbmRleChuZXh0U2xpZGUpKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZTbGlkZSA9ICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlclBhcmFtcy5zbGlkZVByZXZDbGFzc31gKTtcbiAgICAgICAgICAgIGlmIChwcmV2U2xpZGUubGVuZ3RoID4gMCkgbG9hZEluU2xpZGUoc2xpZGVJbmRleChwcmV2U2xpZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tJblZpZXdPbkxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50ID0gc3dpcGVyLnBhcmFtcy5sYXp5LnNjcm9sbGluZ0VsZW1lbnQgPyAkKHN3aXBlci5wYXJhbXMubGF6eS5zY3JvbGxpbmdFbGVtZW50KSA6ICQod2luZG93KTtcbiAgICAgICAgY29uc3QgaXNXaW5kb3cgPSAkc2Nyb2xsRWxlbWVudFswXSA9PT0gd2luZG93O1xuICAgICAgICBjb25zdCBzY3JvbGxFbGVtZW50V2lkdGggPSBpc1dpbmRvdyA/IHdpbmRvdy5pbm5lcldpZHRoIDogJHNjcm9sbEVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IHNjcm9sbEVsZW1lbnRIZWlnaHQgPSBpc1dpbmRvdyA/IHdpbmRvdy5pbm5lckhlaWdodCA6ICRzY3JvbGxFbGVtZW50WzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3Qgc3dpcGVyT2Zmc2V0ID0gc3dpcGVyLiRlbC5vZmZzZXQoKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGxldCBpblZpZXcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJ0bCkgc3dpcGVyT2Zmc2V0LmxlZnQgLT0gc3dpcGVyLiRlbFswXS5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBzd2lwZXJDb29yZCA9IFtbc3dpcGVyT2Zmc2V0LmxlZnQsIHN3aXBlck9mZnNldC50b3BdLCBbc3dpcGVyT2Zmc2V0LmxlZnQgKyBzd2lwZXIud2lkdGgsIHN3aXBlck9mZnNldC50b3BdLCBbc3dpcGVyT2Zmc2V0LmxlZnQsIHN3aXBlck9mZnNldC50b3AgKyBzd2lwZXIuaGVpZ2h0XSwgW3N3aXBlck9mZnNldC5sZWZ0ICsgc3dpcGVyLndpZHRoLCBzd2lwZXJPZmZzZXQudG9wICsgc3dpcGVyLmhlaWdodF1dO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyQ29vcmQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBwb2ludCA9IHN3aXBlckNvb3JkW2ldO1xuXG4gICAgICAgICAgaWYgKHBvaW50WzBdID49IDAgJiYgcG9pbnRbMF0gPD0gc2Nyb2xsRWxlbWVudFdpZHRoICYmIHBvaW50WzFdID49IDAgJiYgcG9pbnRbMV0gPD0gc2Nyb2xsRWxlbWVudEhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHBvaW50WzBdID09PSAwICYmIHBvaW50WzFdID09PSAwKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICAgICAgICBpblZpZXcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIHN3aXBlci5zdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBzd2lwZXIucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMgPyB7XG4gICAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlOiBmYWxzZVxuICAgICAgICB9IDogZmFsc2U7XG5cbiAgICAgICAgaWYgKGluVmlldykge1xuICAgICAgICAgIGxvYWQoKTtcbiAgICAgICAgICAkc2Nyb2xsRWxlbWVudC5vZmYoJ3Njcm9sbCcsIGNoZWNrSW5WaWV3T25Mb2FkLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzY3JvbGxIYW5kbGVyQXR0YWNoZWQpIHtcbiAgICAgICAgICBzY3JvbGxIYW5kbGVyQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICRzY3JvbGxFbGVtZW50Lm9uKCdzY3JvbGwnLCBjaGVja0luVmlld09uTG9hZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbignYmVmb3JlSW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkICYmIHN3aXBlci5wYXJhbXMucHJlbG9hZEltYWdlcykge1xuICAgICAgICAgIHN3aXBlci5wYXJhbXMucHJlbG9hZEltYWdlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmNoZWNrSW5WaWV3KSB7XG4gICAgICAgICAgICBjaGVja0luVmlld09uTG9hZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdzY3JvbGwnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZyZWVNb2RlICYmIHN3aXBlci5wYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiAhc3dpcGVyLnBhcmFtcy5mcmVlTW9kZS5zdGlja3kpIHtcbiAgICAgICAgICBsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ3Njcm9sbGJhckRyYWdNb3ZlIHJlc2l6ZSBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZScsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5jaGVja0luVmlldykge1xuICAgICAgICAgICAgY2hlY2tJblZpZXdPbkxvYWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbigndHJhbnNpdGlvblN0YXJ0JywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmxvYWRPblRyYW5zaXRpb25TdGFydCB8fCAhc3dpcGVyLnBhcmFtcy5sYXp5LmxvYWRPblRyYW5zaXRpb25TdGFydCAmJiAhaW5pdGlhbEltYWdlTG9hZGVkKSB7XG4gICAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmNoZWNrSW5WaWV3KSB7XG4gICAgICAgICAgICAgIGNoZWNrSW5WaWV3T25Mb2FkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCd0cmFuc2l0aW9uRW5kJywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQgJiYgIXN3aXBlci5wYXJhbXMubGF6eS5sb2FkT25UcmFuc2l0aW9uU3RhcnQpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmNoZWNrSW5WaWV3KSB7XG4gICAgICAgICAgICBjaGVja0luVmlld09uTG9hZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdzbGlkZUNoYW5nZScsICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxhenksXG4gICAgICAgICAgY3NzTW9kZSxcbiAgICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzLFxuICAgICAgICAgIHRvdWNoUmVsZWFzZU9uRWRnZXMsXG4gICAgICAgICAgcmVzaXN0YW5jZVJhdGlvXG4gICAgICAgIH0gPSBzd2lwZXIucGFyYW1zO1xuXG4gICAgICAgIGlmIChsYXp5LmVuYWJsZWQgJiYgKGNzc01vZGUgfHwgd2F0Y2hTbGlkZXNQcm9ncmVzcyAmJiAodG91Y2hSZWxlYXNlT25FZGdlcyB8fCByZXNpc3RhbmNlUmF0aW8gPT09IDApKSkge1xuICAgICAgICAgIGxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlci5sYXp5LCB7XG4gICAgICAgIGxvYWQsXG4gICAgICAgIGxvYWRJblNsaWRlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQgbm8tYml0d2lzZTogW1wiZXJyb3JcIiwgeyBcImFsbG93XCI6IFtcIj4+XCJdIH1dICovXG4gICAgZnVuY3Rpb24gQ29udHJvbGxlcih7XG4gICAgICBzd2lwZXIsXG4gICAgICBleHRlbmRQYXJhbXMsXG4gICAgICBvblxuICAgIH0pIHtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIGNvbnRyb2xsZXI6IHtcbiAgICAgICAgICBjb250cm9sOiB1bmRlZmluZWQsXG4gICAgICAgICAgaW52ZXJzZTogZmFsc2UsXG4gICAgICAgICAgYnk6ICdzbGlkZScgLy8gb3IgJ2NvbnRhaW5lcidcblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci5jb250cm9sbGVyID0ge1xuICAgICAgICBjb250cm9sOiB1bmRlZmluZWRcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIExpbmVhclNwbGluZSh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaCgpIHtcbiAgICAgICAgICBsZXQgbWF4SW5kZXg7XG4gICAgICAgICAgbGV0IG1pbkluZGV4O1xuICAgICAgICAgIGxldCBndWVzcztcbiAgICAgICAgICByZXR1cm4gKGFycmF5LCB2YWwpID0+IHtcbiAgICAgICAgICAgIG1pbkluZGV4ID0gLTE7XG4gICAgICAgICAgICBtYXhJbmRleCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKG1heEluZGV4IC0gbWluSW5kZXggPiAxKSB7XG4gICAgICAgICAgICAgIGd1ZXNzID0gbWF4SW5kZXggKyBtaW5JbmRleCA+PiAxO1xuXG4gICAgICAgICAgICAgIGlmIChhcnJheVtndWVzc10gPD0gdmFsKSB7XG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBndWVzcztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGd1ZXNzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXhJbmRleDtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5sYXN0SW5kZXggPSB4Lmxlbmd0aCAtIDE7IC8vIEdpdmVuIGFuIHggdmFsdWUgKHgyKSwgcmV0dXJuIHRoZSBleHBlY3RlZCB5MiB2YWx1ZTpcbiAgICAgICAgLy8gKHgxLHkxKSBpcyB0aGUga25vd24gcG9pbnQgYmVmb3JlIGdpdmVuIHZhbHVlLFxuICAgICAgICAvLyAoeDMseTMpIGlzIHRoZSBrbm93biBwb2ludCBhZnRlciBnaXZlbiB2YWx1ZS5cblxuICAgICAgICBsZXQgaTE7XG4gICAgICAgIGxldCBpMztcblxuICAgICAgICB0aGlzLmludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoeDIpIHtcbiAgICAgICAgICBpZiAoIXgyKSByZXR1cm4gMDsgLy8gR2V0IHRoZSBpbmRleGVzIG9mIHgxIGFuZCB4MyAodGhlIGFycmF5IGluZGV4ZXMgYmVmb3JlIGFuZCBhZnRlciBnaXZlbiB4Mik6XG5cbiAgICAgICAgICBpMyA9IGJpbmFyeVNlYXJjaCh0aGlzLngsIHgyKTtcbiAgICAgICAgICBpMSA9IGkzIC0gMTsgLy8gV2UgaGF2ZSBvdXIgaW5kZXhlcyBpMSAmIGkzLCBzbyB3ZSBjYW4gY2FsY3VsYXRlIGFscmVhZHk6XG4gICAgICAgICAgLy8geTIgOj0gKCh4MuKIkngxKSDDlyAoeTPiiJJ5MSkpIMO3ICh4M+KIkngxKSArIHkxXG5cbiAgICAgICAgICByZXR1cm4gKHgyIC0gdGhpcy54W2kxXSkgKiAodGhpcy55W2kzXSAtIHRoaXMueVtpMV0pIC8gKHRoaXMueFtpM10gLSB0aGlzLnhbaTFdKSArIHRoaXMueVtpMV07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IC8vIHh4eDogZm9yIG5vdyBpIHdpbGwganVzdCBzYXZlIG9uZSBzcGxpbmUgZnVuY3Rpb24gdG8gdG9cblxuXG4gICAgICBmdW5jdGlvbiBnZXRJbnRlcnBvbGF0ZUZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIuY29udHJvbGxlci5zcGxpbmUpIHtcbiAgICAgICAgICBzd2lwZXIuY29udHJvbGxlci5zcGxpbmUgPSBzd2lwZXIucGFyYW1zLmxvb3AgPyBuZXcgTGluZWFyU3BsaW5lKHN3aXBlci5zbGlkZXNHcmlkLCBjLnNsaWRlc0dyaWQpIDogbmV3IExpbmVhclNwbGluZShzd2lwZXIuc25hcEdyaWQsIGMuc25hcEdyaWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZShfdCwgYnlDb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBzd2lwZXIuY29udHJvbGxlci5jb250cm9sO1xuICAgICAgICBsZXQgbXVsdGlwbGllcjtcbiAgICAgICAgbGV0IGNvbnRyb2xsZWRUcmFuc2xhdGU7XG4gICAgICAgIGNvbnN0IFN3aXBlciA9IHN3aXBlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICBmdW5jdGlvbiBzZXRDb250cm9sbGVkVHJhbnNsYXRlKGMpIHtcbiAgICAgICAgICAvLyB0aGlzIHdpbGwgY3JlYXRlIGFuIEludGVycG9sYXRlIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBzbmFwR3JpZHNcbiAgICAgICAgICAvLyB4IGlzIHRoZSBHcmlkIG9mIHRoZSBzY3JvbGxlZCBzY3JvbGxlciBhbmQgeSB3aWxsIGJlIHRoZSBjb250cm9sbGVkIHNjcm9sbGVyXG4gICAgICAgICAgLy8gaXQgbWFrZXMgc2Vuc2UgdG8gY3JlYXRlIHRoaXMgb25seSBvbmNlIGFuZCByZWNhbGwgaXQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGRvZXMgYSBsb3Qgb2YgdmFsdWUgY2FjaGluZyBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgICBjb25zdCB0cmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gLXN3aXBlci50cmFuc2xhdGUgOiBzd2lwZXIudHJhbnNsYXRlO1xuXG4gICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5ieSA9PT0gJ3NsaWRlJykge1xuICAgICAgICAgICAgZ2V0SW50ZXJwb2xhdGVGdW5jdGlvbihjKTsgLy8gaSBhbSBub3Qgc3VyZSB3aHkgdGhlIHZhbHVlcyBoYXZlIHRvIGJlIG11bHRpcGxpY2F0ZWQgdGhpcyB3YXksIHRyaWVkIHRvIGludmVydCB0aGUgc25hcEdyaWRcbiAgICAgICAgICAgIC8vIGJ1dCBpdCBkaWQgbm90IHdvcmsgb3V0XG5cbiAgICAgICAgICAgIGNvbnRyb2xsZWRUcmFuc2xhdGUgPSAtc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lLmludGVycG9sYXRlKC10cmFuc2xhdGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29udHJvbGxlZFRyYW5zbGF0ZSB8fCBzd2lwZXIucGFyYW1zLmNvbnRyb2xsZXIuYnkgPT09ICdjb250YWluZXInKSB7XG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gKGMubWF4VHJhbnNsYXRlKCkgLSBjLm1pblRyYW5zbGF0ZSgpKSAvIChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpO1xuICAgICAgICAgICAgY29udHJvbGxlZFRyYW5zbGF0ZSA9ICh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpICogbXVsdGlwbGllciArIGMubWluVHJhbnNsYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5pbnZlcnNlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVkVHJhbnNsYXRlID0gYy5tYXhUcmFuc2xhdGUoKSAtIGNvbnRyb2xsZWRUcmFuc2xhdGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYy51cGRhdGVQcm9ncmVzcyhjb250cm9sbGVkVHJhbnNsYXRlKTtcbiAgICAgICAgICBjLnNldFRyYW5zbGF0ZShjb250cm9sbGVkVHJhbnNsYXRlLCBzd2lwZXIpO1xuICAgICAgICAgIGMudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgICAgICBjLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRyb2xsZWQpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250cm9sbGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlZFtpXSAhPT0gYnlDb250cm9sbGVyICYmIGNvbnRyb2xsZWRbaV0gaW5zdGFuY2VvZiBTd2lwZXIpIHtcbiAgICAgICAgICAgICAgc2V0Q29udHJvbGxlZFRyYW5zbGF0ZShjb250cm9sbGVkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY29udHJvbGxlZCBpbnN0YW5jZW9mIFN3aXBlciAmJiBieUNvbnRyb2xsZXIgIT09IGNvbnRyb2xsZWQpIHtcbiAgICAgICAgICBzZXRDb250cm9sbGVkVHJhbnNsYXRlKGNvbnRyb2xsZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBTd2lwZXIgPSBzd2lwZXIuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBzd2lwZXIuY29udHJvbGxlci5jb250cm9sO1xuICAgICAgICBsZXQgaTtcblxuICAgICAgICBmdW5jdGlvbiBzZXRDb250cm9sbGVkVHJhbnNpdGlvbihjKSB7XG4gICAgICAgICAgYy5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBzd2lwZXIpO1xuXG4gICAgICAgICAgaWYgKGR1cmF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICBjLnRyYW5zaXRpb25TdGFydCgpO1xuXG4gICAgICAgICAgICBpZiAoYy5wYXJhbXMuYXV0b0hlaWdodCkge1xuICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgYy51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjLiR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghY29udHJvbGxlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgIGlmIChjLnBhcmFtcy5sb29wICYmIHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5ieSA9PT0gJ3NsaWRlJykge1xuICAgICAgICAgICAgICAgIGMubG9vcEZpeCgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYy50cmFuc2l0aW9uRW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250cm9sbGVkKSkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250cm9sbGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlZFtpXSAhPT0gYnlDb250cm9sbGVyICYmIGNvbnRyb2xsZWRbaV0gaW5zdGFuY2VvZiBTd2lwZXIpIHtcbiAgICAgICAgICAgICAgc2V0Q29udHJvbGxlZFRyYW5zaXRpb24oY29udHJvbGxlZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZWQgaW5zdGFuY2VvZiBTd2lwZXIgJiYgYnlDb250cm9sbGVyICE9PSBjb250cm9sbGVkKSB7XG4gICAgICAgICAgc2V0Q29udHJvbGxlZFRyYW5zaXRpb24oY29udHJvbGxlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlU3BsaW5lKCkge1xuICAgICAgICBpZiAoIXN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wpIHJldHVybjtcblxuICAgICAgICBpZiAoc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lKSB7XG4gICAgICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBzd2lwZXIuY29udHJvbGxlci5zcGxpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb24oJ2JlZm9yZUluaXQnLCAoKSA9PiB7XG4gICAgICAgIHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wgPSBzd2lwZXIucGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbDtcbiAgICAgIH0pO1xuICAgICAgb24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgcmVtb3ZlU3BsaW5lKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgIHJlbW92ZVNwbGluZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignb2JzZXJ2ZXJVcGRhdGUnLCAoKSA9PiB7XG4gICAgICAgIHJlbW92ZVNwbGluZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignc2V0VHJhbnNsYXRlJywgKF9zLCB0cmFuc2xhdGUsIGJ5Q29udHJvbGxlcikgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSwgYnlDb250cm9sbGVyKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ3NldFRyYW5zaXRpb24nLCAoX3MsIGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIuY29udHJvbGxlci5jb250cm9sKSByZXR1cm47XG4gICAgICAgIHN3aXBlci5jb250cm9sbGVyLnNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcik7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLmNvbnRyb2xsZXIsIHtcbiAgICAgICAgc2V0VHJhbnNsYXRlLFxuICAgICAgICBzZXRUcmFuc2l0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBMTF5KHtcbiAgICAgIHN3aXBlcixcbiAgICAgIGV4dGVuZFBhcmFtcyxcbiAgICAgIG9uXG4gICAgfSkge1xuICAgICAgZXh0ZW5kUGFyYW1zKHtcbiAgICAgICAgYTExeToge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbm90aWZpY2F0aW9uQ2xhc3M6ICdzd2lwZXItbm90aWZpY2F0aW9uJyxcbiAgICAgICAgICBwcmV2U2xpZGVNZXNzYWdlOiAnUHJldmlvdXMgc2xpZGUnLFxuICAgICAgICAgIG5leHRTbGlkZU1lc3NhZ2U6ICdOZXh0IHNsaWRlJyxcbiAgICAgICAgICBmaXJzdFNsaWRlTWVzc2FnZTogJ1RoaXMgaXMgdGhlIGZpcnN0IHNsaWRlJyxcbiAgICAgICAgICBsYXN0U2xpZGVNZXNzYWdlOiAnVGhpcyBpcyB0aGUgbGFzdCBzbGlkZScsXG4gICAgICAgICAgcGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2U6ICdHbyB0byBzbGlkZSB7e2luZGV4fX0nLFxuICAgICAgICAgIHNsaWRlTGFiZWxNZXNzYWdlOiAne3tpbmRleH19IC8ge3tzbGlkZXNMZW5ndGh9fScsXG4gICAgICAgICAgY29udGFpbmVyTWVzc2FnZTogbnVsbCxcbiAgICAgICAgICBjb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlOiBudWxsLFxuICAgICAgICAgIGl0ZW1Sb2xlRGVzY3JpcHRpb25NZXNzYWdlOiBudWxsLFxuICAgICAgICAgIHNsaWRlUm9sZTogJ2dyb3VwJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxldCBsaXZlUmVnaW9uID0gbnVsbDtcblxuICAgICAgZnVuY3Rpb24gbm90aWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gbGl2ZVJlZ2lvbjtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgbm90aWZpY2F0aW9uLmh0bWwoJycpO1xuICAgICAgICBub3RpZmljYXRpb24uaHRtbChtZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UmFuZG9tTnVtYmVyKHNpemUgPSAxNikge1xuICAgICAgICBjb25zdCByYW5kb21DaGFyID0gKCkgPT4gTWF0aC5yb3VuZCgxNiAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgICAgICByZXR1cm4gJ3gnLnJlcGVhdChzaXplKS5yZXBsYWNlKC94L2csIHJhbmRvbUNoYXIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYWtlRWxGb2N1c2FibGUoJGVsKSB7XG4gICAgICAgICRlbC5hdHRyKCd0YWJJbmRleCcsICcwJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1ha2VFbE5vdEZvY3VzYWJsZSgkZWwpIHtcbiAgICAgICAgJGVsLmF0dHIoJ3RhYkluZGV4JywgJy0xJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEVsUm9sZSgkZWwsIHJvbGUpIHtcbiAgICAgICAgJGVsLmF0dHIoJ3JvbGUnLCByb2xlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkRWxSb2xlRGVzY3JpcHRpb24oJGVsLCBkZXNjcmlwdGlvbikge1xuICAgICAgICAkZWwuYXR0cignYXJpYS1yb2xlZGVzY3JpcHRpb24nLCBkZXNjcmlwdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEVsQ29udHJvbHMoJGVsLCBjb250cm9scykge1xuICAgICAgICAkZWwuYXR0cignYXJpYS1jb250cm9scycsIGNvbnRyb2xzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkRWxMYWJlbCgkZWwsIGxhYmVsKSB7XG4gICAgICAgICRlbC5hdHRyKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRFbElkKCRlbCwgaWQpIHtcbiAgICAgICAgJGVsLmF0dHIoJ2lkJywgaWQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRFbExpdmUoJGVsLCBsaXZlKSB7XG4gICAgICAgICRlbC5hdHRyKCdhcmlhLWxpdmUnLCBsaXZlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGlzYWJsZUVsKCRlbCkge1xuICAgICAgICAkZWwuYXR0cignYXJpYS1kaXNhYmxlZCcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbmFibGVFbCgkZWwpIHtcbiAgICAgICAgJGVsLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRW50ZXJPclNwYWNlS2V5KGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSAhPT0gMTMgJiYgZS5rZXlDb2RlICE9PSAzMikgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmExMXk7XG4gICAgICAgIGNvbnN0ICR0YXJnZXRFbCA9ICQoZS50YXJnZXQpO1xuXG4gICAgICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiBzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsICYmICR0YXJnZXRFbC5pcyhzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsKSkge1xuICAgICAgICAgIGlmICghKHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLnBhcmFtcy5sb29wKSkge1xuICAgICAgICAgICAgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzd2lwZXIuaXNFbmQpIHtcbiAgICAgICAgICAgIG5vdGlmeShwYXJhbXMubGFzdFNsaWRlTWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vdGlmeShwYXJhbXMubmV4dFNsaWRlTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWwgJiYgJHRhcmdldEVsLmlzKHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWwpKSB7XG4gICAgICAgICAgaWYgKCEoc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmxvb3ApKSB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVQcmV2KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN3aXBlci5pc0JlZ2lubmluZykge1xuICAgICAgICAgICAgbm90aWZ5KHBhcmFtcy5maXJzdFNsaWRlTWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vdGlmeShwYXJhbXMucHJldlNsaWRlTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uICYmICR0YXJnZXRFbC5pcyhjbGFzc2VzVG9TZWxlY3Rvcihzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpKSkge1xuICAgICAgICAgICR0YXJnZXRFbFswXS5jbGljaygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU5hdmlnYXRpb24oKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3AgfHwgIXN3aXBlci5uYXZpZ2F0aW9uKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkbmV4dEVsLFxuICAgICAgICAgICRwcmV2RWxcbiAgICAgICAgfSA9IHN3aXBlci5uYXZpZ2F0aW9uO1xuXG4gICAgICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICAgICAgICAgIGRpc2FibGVFbCgkcHJldkVsKTtcbiAgICAgICAgICAgIG1ha2VFbE5vdEZvY3VzYWJsZSgkcHJldkVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5hYmxlRWwoJHByZXZFbCk7XG4gICAgICAgICAgICBtYWtlRWxGb2N1c2FibGUoJHByZXZFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRuZXh0RWwgJiYgJG5leHRFbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5pc0VuZCkge1xuICAgICAgICAgICAgZGlzYWJsZUVsKCRuZXh0RWwpO1xuICAgICAgICAgICAgbWFrZUVsTm90Rm9jdXNhYmxlKCRuZXh0RWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmFibGVFbCgkbmV4dEVsKTtcbiAgICAgICAgICAgIG1ha2VFbEZvY3VzYWJsZSgkbmV4dEVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFzUGFnaW5hdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN3aXBlci5wYWdpbmF0aW9uICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlUGFnaW5hdGlvbigpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5hMTF5O1xuXG4gICAgICAgIGlmIChoYXNQYWdpbmF0aW9uKCkpIHtcbiAgICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmVhY2goYnVsbGV0RWwgPT4ge1xuICAgICAgICAgICAgY29uc3QgJGJ1bGxldEVsID0gJChidWxsZXRFbCk7XG4gICAgICAgICAgICBtYWtlRWxGb2N1c2FibGUoJGJ1bGxldEVsKTtcblxuICAgICAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24ucmVuZGVyQnVsbGV0KSB7XG4gICAgICAgICAgICAgIGFkZEVsUm9sZSgkYnVsbGV0RWwsICdidXR0b24nKTtcbiAgICAgICAgICAgICAgYWRkRWxMYWJlbCgkYnVsbGV0RWwsIHBhcmFtcy5wYWdpbmF0aW9uQnVsbGV0TWVzc2FnZS5yZXBsYWNlKC9cXHtcXHtpbmRleFxcfVxcfS8sICRidWxsZXRFbC5pbmRleCgpICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluaXROYXZFbCA9ICgkZWwsIHdyYXBwZXJJZCwgbWVzc2FnZSkgPT4ge1xuICAgICAgICBtYWtlRWxGb2N1c2FibGUoJGVsKTtcblxuICAgICAgICBpZiAoJGVsWzBdLnRhZ05hbWUgIT09ICdCVVRUT04nKSB7XG4gICAgICAgICAgYWRkRWxSb2xlKCRlbCwgJ2J1dHRvbicpO1xuICAgICAgICAgICRlbC5vbigna2V5ZG93bicsIG9uRW50ZXJPclNwYWNlS2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZEVsTGFiZWwoJGVsLCBtZXNzYWdlKTtcbiAgICAgICAgYWRkRWxDb250cm9scygkZWwsIHdyYXBwZXJJZCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmExMXk7XG4gICAgICAgIHN3aXBlci4kZWwuYXBwZW5kKGxpdmVSZWdpb24pOyAvLyBDb250YWluZXJcblxuICAgICAgICBjb25zdCAkY29udGFpbmVyRWwgPSBzd2lwZXIuJGVsO1xuXG4gICAgICAgIGlmIChwYXJhbXMuY29udGFpbmVyUm9sZURlc2NyaXB0aW9uTWVzc2FnZSkge1xuICAgICAgICAgIGFkZEVsUm9sZURlc2NyaXB0aW9uKCRjb250YWluZXJFbCwgcGFyYW1zLmNvbnRhaW5lclJvbGVEZXNjcmlwdGlvbk1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jb250YWluZXJNZXNzYWdlKSB7XG4gICAgICAgICAgYWRkRWxMYWJlbCgkY29udGFpbmVyRWwsIHBhcmFtcy5jb250YWluZXJNZXNzYWdlKTtcbiAgICAgICAgfSAvLyBXcmFwcGVyXG5cblxuICAgICAgICBjb25zdCAkd3JhcHBlckVsID0gc3dpcGVyLiR3cmFwcGVyRWw7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJJZCA9ICR3cmFwcGVyRWwuYXR0cignaWQnKSB8fCBgc3dpcGVyLXdyYXBwZXItJHtnZXRSYW5kb21OdW1iZXIoMTYpfWA7XG4gICAgICAgIGNvbnN0IGxpdmUgPSBzd2lwZXIucGFyYW1zLmF1dG9wbGF5ICYmIHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCA/ICdvZmYnIDogJ3BvbGl0ZSc7XG4gICAgICAgIGFkZEVsSWQoJHdyYXBwZXJFbCwgd3JhcHBlcklkKTtcbiAgICAgICAgYWRkRWxMaXZlKCR3cmFwcGVyRWwsIGxpdmUpOyAvLyBTbGlkZVxuXG4gICAgICAgIGlmIChwYXJhbXMuaXRlbVJvbGVEZXNjcmlwdGlvbk1lc3NhZ2UpIHtcbiAgICAgICAgICBhZGRFbFJvbGVEZXNjcmlwdGlvbigkKHN3aXBlci5zbGlkZXMpLCBwYXJhbXMuaXRlbVJvbGVEZXNjcmlwdGlvbk1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkRWxSb2xlKCQoc3dpcGVyLnNsaWRlcyksIHBhcmFtcy5zbGlkZVJvbGUpO1xuICAgICAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIucGFyYW1zLmxvb3AgPyBzd2lwZXIuc2xpZGVzLmZpbHRlcihlbCA9PiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKHN3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICAgICAgICBzd2lwZXIuc2xpZGVzLmVhY2goKHNsaWRlRWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgJHNsaWRlRWwgPSAkKHNsaWRlRWwpO1xuICAgICAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzd2lwZXIucGFyYW1zLmxvb3AgPyBwYXJzZUludCgkc2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCkgOiBpbmRleDtcbiAgICAgICAgICBjb25zdCBhcmlhTGFiZWxNZXNzYWdlID0gcGFyYW1zLnNsaWRlTGFiZWxNZXNzYWdlLnJlcGxhY2UoL1xce1xce2luZGV4XFx9XFx9Lywgc2xpZGVJbmRleCArIDEpLnJlcGxhY2UoL1xce1xce3NsaWRlc0xlbmd0aFxcfVxcfS8sIHNsaWRlc0xlbmd0aCk7XG4gICAgICAgICAgYWRkRWxMYWJlbCgkc2xpZGVFbCwgYXJpYUxhYmVsTWVzc2FnZSk7XG4gICAgICAgIH0pOyAvLyBOYXZpZ2F0aW9uXG5cbiAgICAgICAgbGV0ICRuZXh0RWw7XG4gICAgICAgIGxldCAkcHJldkVsO1xuXG4gICAgICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiBzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsKSB7XG4gICAgICAgICAgJG5leHRFbCA9IHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLm5hdmlnYXRpb24gJiYgc3dpcGVyLm5hdmlnYXRpb24uJHByZXZFbCkge1xuICAgICAgICAgICRwcmV2RWwgPSBzd2lwZXIubmF2aWdhdGlvbi4kcHJldkVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRuZXh0RWwgJiYgJG5leHRFbC5sZW5ndGgpIHtcbiAgICAgICAgICBpbml0TmF2RWwoJG5leHRFbCwgd3JhcHBlcklkLCBwYXJhbXMubmV4dFNsaWRlTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJHByZXZFbCAmJiAkcHJldkVsLmxlbmd0aCkge1xuICAgICAgICAgIGluaXROYXZFbCgkcHJldkVsLCB3cmFwcGVySWQsIHBhcmFtcy5wcmV2U2xpZGVNZXNzYWdlKTtcbiAgICAgICAgfSAvLyBQYWdpbmF0aW9uXG5cblxuICAgICAgICBpZiAoaGFzUGFnaW5hdGlvbigpKSB7XG4gICAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24uJGVsLm9uKCdrZXlkb3duJywgY2xhc3Nlc1RvU2VsZWN0b3Ioc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKSwgb25FbnRlck9yU3BhY2VLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmIChsaXZlUmVnaW9uICYmIGxpdmVSZWdpb24ubGVuZ3RoID4gMCkgbGl2ZVJlZ2lvbi5yZW1vdmUoKTtcbiAgICAgICAgbGV0ICRuZXh0RWw7XG4gICAgICAgIGxldCAkcHJldkVsO1xuXG4gICAgICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiBzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsKSB7XG4gICAgICAgICAgJG5leHRFbCA9IHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLm5hdmlnYXRpb24gJiYgc3dpcGVyLm5hdmlnYXRpb24uJHByZXZFbCkge1xuICAgICAgICAgICRwcmV2RWwgPSBzd2lwZXIubmF2aWdhdGlvbi4kcHJldkVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRuZXh0RWwpIHtcbiAgICAgICAgICAkbmV4dEVsLm9mZigna2V5ZG93bicsIG9uRW50ZXJPclNwYWNlS2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcHJldkVsKSB7XG4gICAgICAgICAgJHByZXZFbC5vZmYoJ2tleWRvd24nLCBvbkVudGVyT3JTcGFjZUtleSk7XG4gICAgICAgIH0gLy8gUGFnaW5hdGlvblxuXG5cbiAgICAgICAgaWYgKGhhc1BhZ2luYXRpb24oKSkge1xuICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5vZmYoJ2tleWRvd24nLCBjbGFzc2VzVG9TZWxlY3Rvcihzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpLCBvbkVudGVyT3JTcGFjZUtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb24oJ2JlZm9yZUluaXQnLCAoKSA9PiB7XG4gICAgICAgIGxpdmVSZWdpb24gPSAkKGA8c3BhbiBjbGFzcz1cIiR7c3dpcGVyLnBhcmFtcy5hMTF5Lm5vdGlmaWNhdGlvbkNsYXNzfVwiIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiIGFyaWEtYXRvbWljPVwidHJ1ZVwiPjwvc3Bhbj5gKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2FmdGVySW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmExMXkuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBpbml0KCk7XG4gICAgICAgIHVwZGF0ZU5hdmlnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ3RvRWRnZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmExMXkuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdmcm9tRWRnZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmExMXkuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdwYWdpbmF0aW9uVXBkYXRlJywgKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuYTExeS5lbmFibGVkKSByZXR1cm47XG4gICAgICAgIHVwZGF0ZVBhZ2luYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5hMTF5LmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSGlzdG9yeSh7XG4gICAgICBzd2lwZXIsXG4gICAgICBleHRlbmRQYXJhbXMsXG4gICAgICBvblxuICAgIH0pIHtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICByb290OiAnJyxcbiAgICAgICAgICByZXBsYWNlU3RhdGU6IGZhbHNlLFxuICAgICAgICAgIGtleTogJ3NsaWRlcydcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBwYXRocyA9IHt9O1xuXG4gICAgICBjb25zdCBzbHVnaWZ5ID0gdGV4dCA9PiB7XG4gICAgICAgIHJldHVybiB0ZXh0LnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnLScpLnJlcGxhY2UoL1teXFx3LV0rL2csICcnKS5yZXBsYWNlKC8tLSsvZywgJy0nKS5yZXBsYWNlKC9eLSsvLCAnJykucmVwbGFjZSgvLSskLywgJycpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZ2V0UGF0aFZhbHVlcyA9IHVybE92ZXJyaWRlID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICAgIGxldCBsb2NhdGlvbjtcblxuICAgICAgICBpZiAodXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IG5ldyBVUkwodXJsT3ZlcnJpZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF0aEFycmF5ID0gbG9jYXRpb24ucGF0aG5hbWUuc2xpY2UoMSkuc3BsaXQoJy8nKS5maWx0ZXIocGFydCA9PiBwYXJ0ICE9PSAnJyk7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gcGF0aEFycmF5Lmxlbmd0aDtcbiAgICAgICAgY29uc3Qga2V5ID0gcGF0aEFycmF5W3RvdGFsIC0gMl07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGF0aEFycmF5W3RvdGFsIC0gMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRIaXN0b3J5ID0gKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZWQgfHwgIXN3aXBlci5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKSByZXR1cm47XG4gICAgICAgIGxldCBsb2NhdGlvbjtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy51cmwpIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IG5ldyBVUkwoc3dpcGVyLnBhcmFtcy51cmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2xpZGUgPSBzd2lwZXIuc2xpZGVzLmVxKGluZGV4KTtcbiAgICAgICAgbGV0IHZhbHVlID0gc2x1Z2lmeShzbGlkZS5hdHRyKCdkYXRhLWhpc3RvcnknKSk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuaGlzdG9yeS5yb290Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgcm9vdCA9IHN3aXBlci5wYXJhbXMuaGlzdG9yeS5yb290O1xuICAgICAgICAgIGlmIChyb290W3Jvb3QubGVuZ3RoIC0gMV0gPT09ICcvJykgcm9vdCA9IHJvb3Quc2xpY2UoMCwgcm9vdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB2YWx1ZSA9IGAke3Jvb3R9LyR7a2V5fS8ke3ZhbHVlfWA7XG4gICAgICAgIH0gZWxzZSBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGAke2tleX0vJHt2YWx1ZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gd2luZG93Lmhpc3Rvcnkuc3RhdGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9LCBudWxsLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSwgbnVsbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzY3JvbGxUb1NsaWRlID0gKHNwZWVkLCB2YWx1ZSwgcnVuQ2FsbGJhY2tzKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBzbGlkZSA9IHN3aXBlci5zbGlkZXMuZXEoaSk7XG4gICAgICAgICAgICBjb25zdCBzbGlkZUhpc3RvcnkgPSBzbHVnaWZ5KHNsaWRlLmF0dHIoJ2RhdGEtaGlzdG9yeScpKTtcblxuICAgICAgICAgICAgaWYgKHNsaWRlSGlzdG9yeSA9PT0gdmFsdWUgJiYgIXNsaWRlLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzbGlkZS5pbmRleCgpO1xuICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKDAsIHNwZWVkLCBydW5DYWxsYmFja3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRIaXN0b3J5UG9wU3RhdGUgPSAoKSA9PiB7XG4gICAgICAgIHBhdGhzID0gZ2V0UGF0aFZhbHVlcyhzd2lwZXIucGFyYW1zLnVybCk7XG4gICAgICAgIHNjcm9sbFRvU2xpZGUoc3dpcGVyLnBhcmFtcy5zcGVlZCwgc3dpcGVyLnBhdGhzLnZhbHVlLCBmYWxzZSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmhpc3RvcnkpIHJldHVybjtcblxuICAgICAgICBpZiAoIXdpbmRvdy5oaXN0b3J5IHx8ICF3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcbiAgICAgICAgICBzd2lwZXIucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBwYXRocyA9IGdldFBhdGhWYWx1ZXMoc3dpcGVyLnBhcmFtcy51cmwpO1xuICAgICAgICBpZiAoIXBhdGhzLmtleSAmJiAhcGF0aHMudmFsdWUpIHJldHVybjtcbiAgICAgICAgc2Nyb2xsVG9TbGlkZSgwLCBwYXRocy52YWx1ZSwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpO1xuXG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHNldEhpc3RvcnlQb3BTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuXG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHNldEhpc3RvcnlQb3BTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIG9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQpIHtcbiAgICAgICAgICBpbml0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCkge1xuICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbigndHJhbnNpdGlvbkVuZCBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZScsICgpID0+IHtcbiAgICAgICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgICAgc2V0SGlzdG9yeShzd2lwZXIucGFyYW1zLmhpc3Rvcnkua2V5LCBzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdzbGlkZUNoYW5nZScsICgpID0+IHtcbiAgICAgICAgaWYgKGluaXRpYWxpemVkICYmIHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICAgIHNldEhpc3Rvcnkoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LmtleSwgc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSGFzaE5hdmlnYXRpb24oe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgZW1pdCxcbiAgICAgIG9uXG4gICAgfSkge1xuICAgICAgbGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIGhhc2hOYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgcmVwbGFjZVN0YXRlOiBmYWxzZSxcbiAgICAgICAgICB3YXRjaFN0YXRlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgb25IYXNoQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICBlbWl0KCdoYXNoQ2hhbmdlJyk7XG4gICAgICAgIGNvbnN0IG5ld0hhc2ggPSBkb2N1bWVudC5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMnLCAnJyk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVNsaWRlSGFzaCA9IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KS5hdHRyKCdkYXRhLWhhc2gnKTtcblxuICAgICAgICBpZiAobmV3SGFzaCAhPT0gYWN0aXZlU2xpZGVIYXNoKSB7XG4gICAgICAgICAgY29uc3QgbmV3SW5kZXggPSBzd2lwZXIuJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLWhhc2g9XCIke25ld0hhc2h9XCJdYCkuaW5kZXgoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld0luZGV4ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKG5ld0luZGV4KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2V0SGFzaCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFpbml0aWFsaXplZCB8fCAhc3dpcGVyLnBhcmFtcy5oYXNoTmF2aWdhdGlvbi5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24ucmVwbGFjZVN0YXRlICYmIHdpbmRvdy5oaXN0b3J5ICYmIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCBgIyR7c3dpcGVyLnNsaWRlcy5lcShzd2lwZXIuYWN0aXZlSW5kZXgpLmF0dHIoJ2RhdGEtaGFzaCcpfWAgfHwgJycpO1xuICAgICAgICAgIGVtaXQoJ2hhc2hTZXQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzbGlkZSA9IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgICBjb25zdCBoYXNoID0gc2xpZGUuYXR0cignZGF0YS1oYXNoJykgfHwgc2xpZGUuYXR0cignZGF0YS1oaXN0b3J5Jyk7XG4gICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IGhhc2ggfHwgJyc7XG4gICAgICAgICAgZW1pdCgnaGFzaFNldCcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCB8fCBzd2lwZXIucGFyYW1zLmhpc3RvcnkgJiYgc3dpcGVyLnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBoYXNoID0gZG9jdW1lbnQubG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjJywgJycpO1xuXG4gICAgICAgIGlmIChoYXNoKSB7XG4gICAgICAgICAgY29uc3Qgc3BlZWQgPSAwO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gc3dpcGVyLnNsaWRlcy5lcShpKTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlSGFzaCA9IHNsaWRlLmF0dHIoJ2RhdGEtaGFzaCcpIHx8IHNsaWRlLmF0dHIoJ2RhdGEtaGlzdG9yeScpO1xuXG4gICAgICAgICAgICBpZiAoc2xpZGVIYXNoID09PSBoYXNoICYmICFzbGlkZS5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc2xpZGUuaW5kZXgoKTtcbiAgICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG8oaW5kZXgsIHNwZWVkLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24ud2F0Y2hTdGF0ZSkge1xuICAgICAgICAgICQod2luZG93KS5vbignaGFzaGNoYW5nZScsIG9uSGFzaENoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLndhdGNoU3RhdGUpIHtcbiAgICAgICAgICAkKHdpbmRvdykub2ZmKCdoYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgICBpbml0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ3RyYW5zaXRpb25FbmQgX2ZyZWVNb2RlTm9Nb21lbnR1bVJlbGVhc2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAgIHNldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignc2xpZGVDaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChpbml0aWFsaXplZCAmJiBzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzZXRIYXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby11bmRlcnNjb3JlLWRhbmdsZTogXCJvZmZcIiAqL1xuICAgIGZ1bmN0aW9uIEF1dG9wbGF5KHtcbiAgICAgIHN3aXBlcixcbiAgICAgIGV4dGVuZFBhcmFtcyxcbiAgICAgIG9uLFxuICAgICAgZW1pdFxuICAgIH0pIHtcbiAgICAgIGxldCB0aW1lb3V0O1xuICAgICAgc3dpcGVyLmF1dG9wbGF5ID0ge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgcGF1c2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIGF1dG9wbGF5OiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgZGVsYXk6IDMwMDAsXG4gICAgICAgICAgd2FpdEZvclRyYW5zaXRpb246IHRydWUsXG4gICAgICAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IHRydWUsXG4gICAgICAgICAgc3RvcE9uTGFzdFNsaWRlOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnNlRGlyZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICBwYXVzZU9uTW91c2VFbnRlcjogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgICAgY29uc3QgJGFjdGl2ZVNsaWRlRWwgPSBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICAgIGxldCBkZWxheSA9IHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGVsYXk7XG5cbiAgICAgICAgaWYgKCRhY3RpdmVTbGlkZUVsLmF0dHIoJ2RhdGEtc3dpcGVyLWF1dG9wbGF5JykpIHtcbiAgICAgICAgICBkZWxheSA9ICRhY3RpdmVTbGlkZUVsLmF0dHIoJ2RhdGEtc3dpcGVyLWF1dG9wbGF5JykgfHwgc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICBsZXQgYXV0b3BsYXlSZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5yZXZlcnNlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlUHJldihzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5pc0JlZ2lubmluZykge1xuICAgICAgICAgICAgICBhdXRvcGxheVJlc3VsdCA9IHN3aXBlci5zbGlkZVByZXYoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZSkge1xuICAgICAgICAgICAgICBhdXRvcGxheVJlc3VsdCA9IHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgICAgICBhdXRvcGxheVJlc3VsdCA9IHN3aXBlci5zbGlkZU5leHQoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBlbWl0KCdhdXRvcGxheScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5pc0VuZCkge1xuICAgICAgICAgICAgYXV0b3BsYXlSZXN1bHQgPSBzd2lwZXIuc2xpZGVOZXh0KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZSkge1xuICAgICAgICAgICAgYXV0b3BsYXlSZXN1bHQgPSBzd2lwZXIuc2xpZGVUbygwLCBzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlICYmIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSBydW4oKTtlbHNlIGlmIChhdXRvcGxheVJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJ1bigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0ICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBlbWl0KCdhdXRvcGxheVN0YXJ0Jyk7XG4gICAgICAgIHJ1bigpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGVtaXQoJ2F1dG9wbGF5U3RvcCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGF1c2Uoc3BlZWQpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuO1xuICAgICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkgcmV0dXJuO1xuICAgICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc3BlZWQgPT09IDAgfHwgIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkud2FpdEZvclRyYW5zaXRpb24pIHtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgcnVuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgWyd0cmFuc2l0aW9uZW5kJywgJ3dlYmtpdFRyYW5zaXRpb25FbmQnXS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgICBwYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnICYmIHN3aXBlci5hdXRvcGxheS5wYXVzZWQpIHtcbiAgICAgICAgICBydW4oKTtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLiR3cmFwcGVyRWwpIHJldHVybjtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBzd2lwZXIuJHdyYXBwZXJFbFswXSkgcmV0dXJuO1xuICAgICAgICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uKSB7XG4gICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBydW4oKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXR0YWNoTW91c2VFdmVudHMoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnBhdXNlT25Nb3VzZUVudGVyKSB7XG4gICAgICAgICAgc3dpcGVyLiRlbC5vbignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgICAgICAgc3dpcGVyLiRlbC5vbignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0YWNoTW91c2VFdmVudHMoKSB7XG4gICAgICAgIHN3aXBlci4kZWwub2ZmKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgc3dpcGVyLiRlbC5vZmYoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgfVxuXG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCkge1xuICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICAgIGF0dGFjaE1vdXNlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIChfcywgc3BlZWQsIGludGVybmFsKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbCB8fCAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlKHNwZWVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignc2xpZGVyRmlyc3RNb3ZlJywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbigndG91Y2hFbmQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCAmJiAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICBkZXRhY2hNb3VzZUV2ZW50cygpO1xuXG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLmF1dG9wbGF5LCB7XG4gICAgICAgIHBhdXNlLFxuICAgICAgICBydW4sXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBzdG9wXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUaHVtYih7XG4gICAgICBzd2lwZXIsXG4gICAgICBleHRlbmRQYXJhbXMsXG4gICAgICBvblxuICAgIH0pIHtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIHRodW1iczoge1xuICAgICAgICAgIHN3aXBlcjogbnVsbCxcbiAgICAgICAgICBtdWx0aXBsZUFjdGl2ZVRodW1iczogdHJ1ZSxcbiAgICAgICAgICBhdXRvU2Nyb2xsT2Zmc2V0OiAwLFxuICAgICAgICAgIHNsaWRlVGh1bWJBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS10aHVtYi1hY3RpdmUnLFxuICAgICAgICAgIHRodW1ic0NvbnRhaW5lckNsYXNzOiAnc3dpcGVyLXRodW1icydcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBzd2lwZXJDcmVhdGVkID0gZmFsc2U7XG4gICAgICBzd2lwZXIudGh1bWJzID0ge1xuICAgICAgICBzd2lwZXI6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIG9uVGh1bWJDbGljaygpIHtcbiAgICAgICAgY29uc3QgdGh1bWJzU3dpcGVyID0gc3dpcGVyLnRodW1icy5zd2lwZXI7XG4gICAgICAgIGlmICghdGh1bWJzU3dpcGVyKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGNsaWNrZWRJbmRleCA9IHRodW1ic1N3aXBlci5jbGlja2VkSW5kZXg7XG4gICAgICAgIGNvbnN0IGNsaWNrZWRTbGlkZSA9IHRodW1ic1N3aXBlci5jbGlja2VkU2xpZGU7XG4gICAgICAgIGlmIChjbGlja2VkU2xpZGUgJiYgJChjbGlja2VkU2xpZGUpLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcykpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGlja2VkSW5kZXggPT09ICd1bmRlZmluZWQnIHx8IGNsaWNrZWRJbmRleCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgc2xpZGVUb0luZGV4O1xuXG4gICAgICAgIGlmICh0aHVtYnNTd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICBzbGlkZVRvSW5kZXggPSBwYXJzZUludCgkKHRodW1ic1N3aXBlci5jbGlja2VkU2xpZGUpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbGlkZVRvSW5kZXggPSBjbGlja2VkSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcblxuICAgICAgICAgIGlmIChzd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRJbmRleCkuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgICAgIHN3aXBlci5fY2xpZW50TGVmdCA9IHN3aXBlci4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQ7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJldkluZGV4ID0gc3dpcGVyLnNsaWRlcy5lcShjdXJyZW50SW5kZXgpLnByZXZBbGwoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7c2xpZGVUb0luZGV4fVwiXWApLmVxKDApLmluZGV4KCk7XG4gICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gc3dpcGVyLnNsaWRlcy5lcShjdXJyZW50SW5kZXgpLm5leHRBbGwoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7c2xpZGVUb0luZGV4fVwiXWApLmVxKDApLmluZGV4KCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwcmV2SW5kZXggPT09ICd1bmRlZmluZWQnKSBzbGlkZVRvSW5kZXggPSBuZXh0SW5kZXg7ZWxzZSBpZiAodHlwZW9mIG5leHRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHNsaWRlVG9JbmRleCA9IHByZXZJbmRleDtlbHNlIGlmIChuZXh0SW5kZXggLSBjdXJyZW50SW5kZXggPCBjdXJyZW50SW5kZXggLSBwcmV2SW5kZXgpIHNsaWRlVG9JbmRleCA9IG5leHRJbmRleDtlbHNlIHNsaWRlVG9JbmRleCA9IHByZXZJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0aHVtYnM6IHRodW1ic1BhcmFtc1xuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcztcbiAgICAgICAgaWYgKGluaXRpYWxpemVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgU3dpcGVyQ2xhc3MgPSBzd2lwZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgaWYgKHRodW1ic1BhcmFtcy5zd2lwZXIgaW5zdGFuY2VvZiBTd2lwZXJDbGFzcykge1xuICAgICAgICAgIHN3aXBlci50aHVtYnMuc3dpcGVyID0gdGh1bWJzUGFyYW1zLnN3aXBlcjtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHN3aXBlci50aHVtYnMuc3dpcGVyLm9yaWdpbmFsUGFyYW1zLCB7XG4gICAgICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHN3aXBlci50aHVtYnMuc3dpcGVyLnBhcmFtcywge1xuICAgICAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodGh1bWJzUGFyYW1zLnN3aXBlcikpIHtcbiAgICAgICAgICBjb25zdCB0aHVtYnNTd2lwZXJQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aHVtYnNQYXJhbXMuc3dpcGVyKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRodW1ic1N3aXBlclBhcmFtcywge1xuICAgICAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3dpcGVyLnRodW1icy5zd2lwZXIgPSBuZXcgU3dpcGVyQ2xhc3ModGh1bWJzU3dpcGVyUGFyYW1zKTtcbiAgICAgICAgICBzd2lwZXJDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci50aHVtYnMuc3dpcGVyLiRlbC5hZGRDbGFzcyhzd2lwZXIucGFyYW1zLnRodW1icy50aHVtYnNDb250YWluZXJDbGFzcyk7XG4gICAgICAgIHN3aXBlci50aHVtYnMuc3dpcGVyLm9uKCd0YXAnLCBvblRodW1iQ2xpY2spO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKGluaXRpYWwpIHtcbiAgICAgICAgY29uc3QgdGh1bWJzU3dpcGVyID0gc3dpcGVyLnRodW1icy5zd2lwZXI7XG4gICAgICAgIGlmICghdGh1bWJzU3dpcGVyKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHNsaWRlc1BlclZpZXcgPSB0aHVtYnNTd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHRodW1ic1N3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogdGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgICBjb25zdCBhdXRvU2Nyb2xsT2Zmc2V0ID0gc3dpcGVyLnBhcmFtcy50aHVtYnMuYXV0b1Njcm9sbE9mZnNldDtcbiAgICAgICAgY29uc3QgdXNlT2Zmc2V0ID0gYXV0b1Njcm9sbE9mZnNldCAmJiAhdGh1bWJzU3dpcGVyLnBhcmFtcy5sb29wO1xuXG4gICAgICAgIGlmIChzd2lwZXIucmVhbEluZGV4ICE9PSB0aHVtYnNTd2lwZXIucmVhbEluZGV4IHx8IHVzZU9mZnNldCkge1xuICAgICAgICAgIGxldCBjdXJyZW50VGh1bWJzSW5kZXggPSB0aHVtYnNTd2lwZXIuYWN0aXZlSW5kZXg7XG4gICAgICAgICAgbGV0IG5ld1RodW1ic0luZGV4O1xuICAgICAgICAgIGxldCBkaXJlY3Rpb247XG5cbiAgICAgICAgICBpZiAodGh1bWJzU3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgICBpZiAodGh1bWJzU3dpcGVyLnNsaWRlcy5lcShjdXJyZW50VGh1bWJzSW5kZXgpLmhhc0NsYXNzKHRodW1ic1N3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICAgICAgICAgdGh1bWJzU3dpcGVyLmxvb3BGaXgoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgICAgICAgdGh1bWJzU3dpcGVyLl9jbGllbnRMZWZ0ID0gdGh1bWJzU3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcbiAgICAgICAgICAgICAgY3VycmVudFRodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLmFjdGl2ZUluZGV4O1xuICAgICAgICAgICAgfSAvLyBGaW5kIGFjdHVhbCB0aHVtYnMgaW5kZXggdG8gc2xpZGUgdG9cblxuXG4gICAgICAgICAgICBjb25zdCBwcmV2VGh1bWJzSW5kZXggPSB0aHVtYnNTd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRUaHVtYnNJbmRleCkucHJldkFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzd2lwZXIucmVhbEluZGV4fVwiXWApLmVxKDApLmluZGV4KCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0VGh1bWJzSW5kZXggPSB0aHVtYnNTd2lwZXIuc2xpZGVzLmVxKGN1cnJlbnRUaHVtYnNJbmRleCkubmV4dEFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzd2lwZXIucmVhbEluZGV4fVwiXWApLmVxKDApLmluZGV4KCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldlRodW1ic0luZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBuZXdUaHVtYnNJbmRleCA9IG5leHRUaHVtYnNJbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRUaHVtYnNJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgbmV3VGh1bWJzSW5kZXggPSBwcmV2VGh1bWJzSW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRUaHVtYnNJbmRleCAtIGN1cnJlbnRUaHVtYnNJbmRleCA9PT0gY3VycmVudFRodW1ic0luZGV4IC0gcHJldlRodW1ic0luZGV4KSB7XG4gICAgICAgICAgICAgIG5ld1RodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA+IDEgPyBuZXh0VGh1bWJzSW5kZXggOiBjdXJyZW50VGh1bWJzSW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRUaHVtYnNJbmRleCAtIGN1cnJlbnRUaHVtYnNJbmRleCA8IGN1cnJlbnRUaHVtYnNJbmRleCAtIHByZXZUaHVtYnNJbmRleCkge1xuICAgICAgICAgICAgICBuZXdUaHVtYnNJbmRleCA9IG5leHRUaHVtYnNJbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1RodW1ic0luZGV4ID0gcHJldlRodW1ic0luZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBzd2lwZXIuYWN0aXZlSW5kZXggPiBzd2lwZXIucHJldmlvdXNJbmRleCA/ICduZXh0JyA6ICdwcmV2JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VGh1bWJzSW5kZXggPSBzd2lwZXIucmVhbEluZGV4O1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3VGh1bWJzSW5kZXggPiBzd2lwZXIucHJldmlvdXNJbmRleCA/ICduZXh0JyA6ICdwcmV2JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXNlT2Zmc2V0KSB7XG4gICAgICAgICAgICBuZXdUaHVtYnNJbmRleCArPSBkaXJlY3Rpb24gPT09ICduZXh0JyA/IGF1dG9TY3JvbGxPZmZzZXQgOiAtMSAqIGF1dG9TY3JvbGxPZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRodW1ic1N3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcyAmJiB0aHVtYnNTd2lwZXIudmlzaWJsZVNsaWRlc0luZGV4ZXMuaW5kZXhPZihuZXdUaHVtYnNJbmRleCkgPCAwKSB7XG4gICAgICAgICAgICBpZiAodGh1bWJzU3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgICAgICBpZiAobmV3VGh1bWJzSW5kZXggPiBjdXJyZW50VGh1bWJzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBuZXdUaHVtYnNJbmRleCA9IG5ld1RodW1ic0luZGV4IC0gTWF0aC5mbG9vcihzbGlkZXNQZXJWaWV3IC8gMikgKyAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1RodW1ic0luZGV4ID0gbmV3VGh1bWJzSW5kZXggKyBNYXRoLmZsb29yKHNsaWRlc1BlclZpZXcgLyAyKSAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3VGh1bWJzSW5kZXggPiBjdXJyZW50VGh1bWJzSW5kZXggJiYgdGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSkgO1xuXG4gICAgICAgICAgICB0aHVtYnNTd2lwZXIuc2xpZGVUbyhuZXdUaHVtYnNJbmRleCwgaW5pdGlhbCA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBBY3RpdmF0ZSB0aHVtYnNcblxuXG4gICAgICAgIGxldCB0aHVtYnNUb0FjdGl2YXRlID0gMTtcbiAgICAgICAgY29uc3QgdGh1bWJBY3RpdmVDbGFzcyA9IHN3aXBlci5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcztcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSAmJiAhc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIHRodW1ic1RvQWN0aXZhdGUgPSBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMudGh1bWJzLm11bHRpcGxlQWN0aXZlVGh1bWJzKSB7XG4gICAgICAgICAgdGh1bWJzVG9BY3RpdmF0ZSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aHVtYnNUb0FjdGl2YXRlID0gTWF0aC5mbG9vcih0aHVtYnNUb0FjdGl2YXRlKTtcbiAgICAgICAgdGh1bWJzU3dpcGVyLnNsaWRlcy5yZW1vdmVDbGFzcyh0aHVtYkFjdGl2ZUNsYXNzKTtcblxuICAgICAgICBpZiAodGh1bWJzU3dpcGVyLnBhcmFtcy5sb29wIHx8IHRodW1ic1N3aXBlci5wYXJhbXMudmlydHVhbCAmJiB0aHVtYnNTd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGh1bWJzVG9BY3RpdmF0ZTsgaSArPSAxKSB7XG4gICAgICAgICAgICB0aHVtYnNTd2lwZXIuJHdyYXBwZXJFbC5jaGlsZHJlbihgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzd2lwZXIucmVhbEluZGV4ICsgaX1cIl1gKS5hZGRDbGFzcyh0aHVtYkFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aHVtYnNUb0FjdGl2YXRlOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRodW1ic1N3aXBlci5zbGlkZXMuZXEoc3dpcGVyLnJlYWxJbmRleCArIGkpLmFkZENsYXNzKHRodW1iQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbignYmVmb3JlSW5pdCcsICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRodW1ic1xuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcztcbiAgICAgICAgaWYgKCF0aHVtYnMgfHwgIXRodW1icy5zd2lwZXIpIHJldHVybjtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgICB1cGRhdGUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdzbGlkZUNoYW5nZSB1cGRhdGUgcmVzaXplIG9ic2VydmVyVXBkYXRlJywgKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci50aHVtYnMuc3dpcGVyKSByZXR1cm47XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignc2V0VHJhbnNpdGlvbicsIChfcywgZHVyYXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgdGh1bWJzU3dpcGVyID0gc3dpcGVyLnRodW1icy5zd2lwZXI7XG4gICAgICAgIGlmICghdGh1bWJzU3dpcGVyKSByZXR1cm47XG4gICAgICAgIHRodW1ic1N3aXBlci5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2JlZm9yZURlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRodW1ic1N3aXBlciA9IHN3aXBlci50aHVtYnMuc3dpcGVyO1xuICAgICAgICBpZiAoIXRodW1ic1N3aXBlcikgcmV0dXJuO1xuXG4gICAgICAgIGlmIChzd2lwZXJDcmVhdGVkICYmIHRodW1ic1N3aXBlcikge1xuICAgICAgICAgIHRodW1ic1N3aXBlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIudGh1bWJzLCB7XG4gICAgICAgIGluaXQsXG4gICAgICAgIHVwZGF0ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJlZU1vZGUoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgZW1pdCxcbiAgICAgIG9uY2VcbiAgICB9KSB7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBmcmVlTW9kZToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIG1vbWVudHVtOiB0cnVlLFxuICAgICAgICAgIG1vbWVudHVtUmF0aW86IDEsXG4gICAgICAgICAgbW9tZW50dW1Cb3VuY2U6IHRydWUsXG4gICAgICAgICAgbW9tZW50dW1Cb3VuY2VSYXRpbzogMSxcbiAgICAgICAgICBtb21lbnR1bVZlbG9jaXR5UmF0aW86IDEsXG4gICAgICAgICAgc3RpY2t5OiBmYWxzZSxcbiAgICAgICAgICBtaW5pbXVtVmVsb2NpdHk6IDAuMDJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdG91Y2hFdmVudHNEYXRhOiBkYXRhLFxuICAgICAgICAgIHRvdWNoZXNcbiAgICAgICAgfSA9IHN3aXBlcjsgLy8gVmVsb2NpdHlcblxuICAgICAgICBpZiAoZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRhdGEudmVsb2NpdGllcy5wdXNoKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzdGFydFgnIDogJ3N0YXJ0WSddLFxuICAgICAgICAgICAgdGltZTogZGF0YS50b3VjaFN0YXJ0VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS52ZWxvY2l0aWVzLnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdjdXJyZW50WCcgOiAnY3VycmVudFknXSxcbiAgICAgICAgICB0aW1lOiBub3coKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Ub3VjaEVuZCh7XG4gICAgICAgIGN1cnJlbnRQb3NcbiAgICAgIH0pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAkd3JhcHBlckVsLFxuICAgICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgIHRvdWNoRXZlbnRzRGF0YTogZGF0YVxuICAgICAgICB9ID0gc3dpcGVyOyAvLyBUaW1lIGRpZmZcblxuICAgICAgICBjb25zdCB0b3VjaEVuZFRpbWUgPSBub3coKTtcbiAgICAgICAgY29uc3QgdGltZURpZmYgPSB0b3VjaEVuZFRpbWUgLSBkYXRhLnRvdWNoU3RhcnRUaW1lO1xuXG4gICAgICAgIGlmIChjdXJyZW50UG9zIDwgLXN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQb3MgPiAtc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5zbGlkZXMubGVuZ3RoIDwgc25hcEdyaWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbmFwR3JpZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlLm1vbWVudHVtKSB7XG4gICAgICAgICAgaWYgKGRhdGEudmVsb2NpdGllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0TW92ZUV2ZW50ID0gZGF0YS52ZWxvY2l0aWVzLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgdmVsb2NpdHlFdmVudCA9IGRhdGEudmVsb2NpdGllcy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gbGFzdE1vdmVFdmVudC5wb3NpdGlvbiAtIHZlbG9jaXR5RXZlbnQucG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gbGFzdE1vdmVFdmVudC50aW1lIC0gdmVsb2NpdHlFdmVudC50aW1lO1xuICAgICAgICAgICAgc3dpcGVyLnZlbG9jaXR5ID0gZGlzdGFuY2UgLyB0aW1lO1xuICAgICAgICAgICAgc3dpcGVyLnZlbG9jaXR5IC89IDI7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpIDwgcGFyYW1zLmZyZWVNb2RlLm1pbmltdW1WZWxvY2l0eSkge1xuICAgICAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgfSAvLyB0aGlzIGltcGxpZXMgdGhhdCB0aGUgdXNlciBzdG9wcGVkIG1vdmluZyBhIGZpbmdlciB0aGVuIHJlbGVhc2VkLlxuICAgICAgICAgICAgLy8gVGhlcmUgd291bGQgYmUgbm8gZXZlbnRzIHdpdGggZGlzdGFuY2UgemVybywgc28gdGhlIGxhc3QgZXZlbnQgaXMgc3RhbGUuXG5cblxuICAgICAgICAgICAgaWYgKHRpbWUgPiAxNTAgfHwgbm93KCkgLSBsYXN0TW92ZUV2ZW50LnRpbWUgPiAzMDApIHtcbiAgICAgICAgICAgICAgc3dpcGVyLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpcGVyLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgKj0gcGFyYW1zLmZyZWVNb2RlLm1vbWVudHVtVmVsb2NpdHlSYXRpbztcbiAgICAgICAgICBkYXRhLnZlbG9jaXRpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICBsZXQgbW9tZW50dW1EdXJhdGlvbiA9IDEwMDAgKiBwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1SYXRpbztcbiAgICAgICAgICBjb25zdCBtb21lbnR1bURpc3RhbmNlID0gc3dpcGVyLnZlbG9jaXR5ICogbW9tZW50dW1EdXJhdGlvbjtcbiAgICAgICAgICBsZXQgbmV3UG9zaXRpb24gPSBzd2lwZXIudHJhbnNsYXRlICsgbW9tZW50dW1EaXN0YW5jZTtcbiAgICAgICAgICBpZiAocnRsKSBuZXdQb3NpdGlvbiA9IC1uZXdQb3NpdGlvbjtcbiAgICAgICAgICBsZXQgZG9Cb3VuY2UgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgYWZ0ZXJCb3VuY2VQb3NpdGlvbjtcbiAgICAgICAgICBjb25zdCBib3VuY2VBbW91bnQgPSBNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpICogMjAgKiBwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2VSYXRpbztcbiAgICAgICAgICBsZXQgbmVlZHNMb29wRml4O1xuXG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uIDwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlLm1vbWVudHVtQm91bmNlKSB7XG4gICAgICAgICAgICAgIGlmIChuZXdQb3NpdGlvbiArIHN3aXBlci5tYXhUcmFuc2xhdGUoKSA8IC1ib3VuY2VBbW91bnQpIHtcbiAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIGJvdW5jZUFtb3VudDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFmdGVyQm91bmNlUG9zaXRpb24gPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG4gICAgICAgICAgICAgIGRvQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZGF0YS5hbGxvd01vbWVudHVtQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSBuZWVkc0xvb3BGaXggPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV3UG9zaXRpb24gPiBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpID4gYm91bmNlQW1vdW50KSB7XG4gICAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCkgKyBib3VuY2VBbW91bnQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhZnRlckJvdW5jZVBvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgICBkb0JvdW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgIGRhdGEuYWxsb3dNb21lbnR1bUJvdW5jZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdQb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5sb29wICYmIHBhcmFtcy5jZW50ZXJlZFNsaWRlcykgbmVlZHNMb29wRml4ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcmVlTW9kZS5zdGlja3kpIHtcbiAgICAgICAgICAgIGxldCBuZXh0U2xpZGU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc25hcEdyaWQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHNuYXBHcmlkW2pdID4gLW5ld1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgbmV4dFNsaWRlID0gajtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc25hcEdyaWRbbmV4dFNsaWRlXSAtIG5ld1Bvc2l0aW9uKSA8IE1hdGguYWJzKHNuYXBHcmlkW25leHRTbGlkZSAtIDFdIC0gbmV3UG9zaXRpb24pIHx8IHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc25hcEdyaWRbbmV4dFNsaWRlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc25hcEdyaWRbbmV4dFNsaWRlIC0gMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gLW5ld1Bvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWVkc0xvb3BGaXgpIHtcbiAgICAgICAgICAgIG9uY2UoJ3RyYW5zaXRpb25FbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIEZpeCBkdXJhdGlvblxuXG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnZlbG9jaXR5ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBNYXRoLmFicygoLW5ld1Bvc2l0aW9uIC0gc3dpcGVyLnRyYW5zbGF0ZSkgLyBzd2lwZXIudmVsb2NpdHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGguYWJzKChuZXdQb3NpdGlvbiAtIHN3aXBlci50cmFuc2xhdGUpIC8gc3dpcGVyLnZlbG9jaXR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZS5zdGlja3kpIHtcbiAgICAgICAgICAgICAgLy8gSWYgZnJlZU1vZGUuc3RpY2t5IGlzIGFjdGl2ZSBhbmQgdGhlIHVzZXIgZW5kcyBhIHN3aXBlIHdpdGggYSBzbG93LXZlbG9jaXR5XG4gICAgICAgICAgICAgIC8vIGV2ZW50LCB0aGVuIGR1cmF0aW9ucyBjYW4gYmUgMjArIHNlY29uZHMgdG8gc2xpZGUgb25lIChvciB6ZXJvISkgc2xpZGVzLlxuICAgICAgICAgICAgICAvLyBJdCdzIGVhc3kgdG8gc2VlIHRoaXMgd2hlbiBzaW11bGF0aW5nIHRvdWNoIHdpdGggbW91c2UgZXZlbnRzLiBUbyBmaXggdGhpcyxcbiAgICAgICAgICAgICAgLy8gbGltaXQgc2luZ2xlLXNsaWRlIHN3aXBlcyB0byB0aGUgZGVmYXVsdCBzbGlkZSBkdXJhdGlvbi4gVGhpcyBhbHNvIGhhcyB0aGVcbiAgICAgICAgICAgICAgLy8gbmljZSBzaWRlIGVmZmVjdCBvZiBtYXRjaGluZyBzbGlkZSBzcGVlZCBpZiB0aGUgdXNlciBzdG9wcGVkIG1vdmluZyBiZWZvcmVcbiAgICAgICAgICAgICAgLy8gbGlmdGluZyBmaW5nZXIgb3IgbW91c2UgdnMuIG1vdmluZyBzbG93bHkgYmVmb3JlIGxpZnRpbmcgdGhlIGZpbmdlci9tb3VzZS5cbiAgICAgICAgICAgICAgLy8gRm9yIGZhc3RlciBzd2lwZXMsIGFsc28gYXBwbHkgbGltaXRzIChhbGJlaXQgaGlnaGVyIG9uZXMpLlxuICAgICAgICAgICAgICBjb25zdCBtb3ZlRGlzdGFuY2UgPSBNYXRoLmFicygocnRsID8gLW5ld1Bvc2l0aW9uIDogbmV3UG9zaXRpb24pIC0gc3dpcGVyLnRyYW5zbGF0ZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbGlkZVNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW3N3aXBlci5hY3RpdmVJbmRleF07XG5cbiAgICAgICAgICAgICAgaWYgKG1vdmVEaXN0YW5jZSA8IGN1cnJlbnRTbGlkZVNpemUpIHtcbiAgICAgICAgICAgICAgICBtb21lbnR1bUR1cmF0aW9uID0gcGFyYW1zLnNwZWVkO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vdmVEaXN0YW5jZSA8IDIgKiBjdXJyZW50U2xpZGVTaXplKSB7XG4gICAgICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IHBhcmFtcy5zcGVlZCAqIDEuNTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb21lbnR1bUR1cmF0aW9uID0gcGFyYW1zLnNwZWVkICogMi41O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZnJlZU1vZGUuc3RpY2t5KSB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlLm1vbWVudHVtQm91bmNlICYmIGRvQm91bmNlKSB7XG4gICAgICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoYWZ0ZXJCb3VuY2VQb3NpdGlvbik7XG4gICAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihtb21lbnR1bUR1cmF0aW9uKTtcbiAgICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydCh0cnVlLCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UpIHJldHVybjtcbiAgICAgICAgICAgICAgZW1pdCgnbW9tZW50dW1Cb3VuY2UnKTtcbiAgICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24ocGFyYW1zLnNwZWVkKTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShhZnRlckJvdW5jZVBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci52ZWxvY2l0eSkge1xuICAgICAgICAgICAgZW1pdCgnX2ZyZWVNb2RlTm9Nb21lbnR1bVJlbGVhc2UnKTtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihtb21lbnR1bUR1cmF0aW9uKTtcbiAgICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydCh0cnVlLCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MobmV3UG9zaXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlLnN0aWNreSkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvQ2xvc2VzdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcbiAgICAgICAgICBlbWl0KCdfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJhbXMuZnJlZU1vZGUubW9tZW50dW0gfHwgdGltZURpZmYgPj0gcGFyYW1zLmxvbmdTd2lwZXNNcykge1xuICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgZnJlZU1vZGU6IHtcbiAgICAgICAgICBvblRvdWNoTW92ZSxcbiAgICAgICAgICBvblRvdWNoRW5kXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEdyaWQoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zXG4gICAgfSkge1xuICAgICAgZXh0ZW5kUGFyYW1zKHtcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHJvd3M6IDEsXG4gICAgICAgICAgZmlsbDogJ2NvbHVtbidcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsZXQgc2xpZGVzTnVtYmVyRXZlblRvUm93cztcbiAgICAgIGxldCBzbGlkZXNQZXJSb3c7XG4gICAgICBsZXQgbnVtRnVsbENvbHVtbnM7XG5cbiAgICAgIGNvbnN0IGluaXRTbGlkZXMgPSBzbGlkZXNMZW5ndGggPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlld1xuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJvd3MsXG4gICAgICAgICAgZmlsbFxuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcy5ncmlkO1xuICAgICAgICBzbGlkZXNQZXJSb3cgPSBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzIC8gcm93cztcbiAgICAgICAgbnVtRnVsbENvbHVtbnMgPSBNYXRoLmZsb29yKHNsaWRlc0xlbmd0aCAvIHJvd3MpO1xuXG4gICAgICAgIGlmIChNYXRoLmZsb29yKHNsaWRlc0xlbmd0aCAvIHJvd3MpID09PSBzbGlkZXNMZW5ndGggLyByb3dzKSB7XG4gICAgICAgICAgc2xpZGVzTnVtYmVyRXZlblRvUm93cyA9IHNsaWRlc0xlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gTWF0aC5jZWlsKHNsaWRlc0xlbmd0aCAvIHJvd3MpICogcm93cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycgJiYgZmlsbCA9PT0gJ3JvdycpIHtcbiAgICAgICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gTWF0aC5tYXgoc2xpZGVzTnVtYmVyRXZlblRvUm93cywgc2xpZGVzUGVyVmlldyAqIHJvd3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVTbGlkZSA9IChpLCBzbGlkZSwgc2xpZGVzTGVuZ3RoLCBnZXREaXJlY3Rpb25MYWJlbCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2xpZGVzUGVyR3JvdXAsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuXG4gICAgICAgIH0gPSBzd2lwZXIucGFyYW1zO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcm93cyxcbiAgICAgICAgICBmaWxsXG4gICAgICAgIH0gPSBzd2lwZXIucGFyYW1zLmdyaWQ7IC8vIFNldCBzbGlkZXMgb3JkZXJcblxuICAgICAgICBsZXQgbmV3U2xpZGVPcmRlckluZGV4O1xuICAgICAgICBsZXQgY29sdW1uO1xuICAgICAgICBsZXQgcm93O1xuXG4gICAgICAgIGlmIChmaWxsID09PSAncm93JyAmJiBzbGlkZXNQZXJHcm91cCA+IDEpIHtcbiAgICAgICAgICBjb25zdCBncm91cEluZGV4ID0gTWF0aC5mbG9vcihpIC8gKHNsaWRlc1Blckdyb3VwICogcm93cykpO1xuICAgICAgICAgIGNvbnN0IHNsaWRlSW5kZXhJbkdyb3VwID0gaSAtIHJvd3MgKiBzbGlkZXNQZXJHcm91cCAqIGdyb3VwSW5kZXg7XG4gICAgICAgICAgY29uc3QgY29sdW1uc0luR3JvdXAgPSBncm91cEluZGV4ID09PSAwID8gc2xpZGVzUGVyR3JvdXAgOiBNYXRoLm1pbihNYXRoLmNlaWwoKHNsaWRlc0xlbmd0aCAtIGdyb3VwSW5kZXggKiByb3dzICogc2xpZGVzUGVyR3JvdXApIC8gcm93cyksIHNsaWRlc1Blckdyb3VwKTtcbiAgICAgICAgICByb3cgPSBNYXRoLmZsb29yKHNsaWRlSW5kZXhJbkdyb3VwIC8gY29sdW1uc0luR3JvdXApO1xuICAgICAgICAgIGNvbHVtbiA9IHNsaWRlSW5kZXhJbkdyb3VwIC0gcm93ICogY29sdW1uc0luR3JvdXAgKyBncm91cEluZGV4ICogc2xpZGVzUGVyR3JvdXA7XG4gICAgICAgICAgbmV3U2xpZGVPcmRlckluZGV4ID0gY29sdW1uICsgcm93ICogc2xpZGVzTnVtYmVyRXZlblRvUm93cyAvIHJvd3M7XG4gICAgICAgICAgc2xpZGUuY3NzKHtcbiAgICAgICAgICAgICctd2Via2l0LW9yZGVyJzogbmV3U2xpZGVPcmRlckluZGV4LFxuICAgICAgICAgICAgb3JkZXI6IG5ld1NsaWRlT3JkZXJJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGwgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgY29sdW1uID0gTWF0aC5mbG9vcihpIC8gcm93cyk7XG4gICAgICAgICAgcm93ID0gaSAtIGNvbHVtbiAqIHJvd3M7XG5cbiAgICAgICAgICBpZiAoY29sdW1uID4gbnVtRnVsbENvbHVtbnMgfHwgY29sdW1uID09PSBudW1GdWxsQ29sdW1ucyAmJiByb3cgPT09IHJvd3MgLSAxKSB7XG4gICAgICAgICAgICByb3cgKz0gMTtcblxuICAgICAgICAgICAgaWYgKHJvdyA+PSByb3dzKSB7XG4gICAgICAgICAgICAgIHJvdyA9IDA7XG4gICAgICAgICAgICAgIGNvbHVtbiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3cgPSBNYXRoLmZsb29yKGkgLyBzbGlkZXNQZXJSb3cpO1xuICAgICAgICAgIGNvbHVtbiA9IGkgLSByb3cgKiBzbGlkZXNQZXJSb3c7XG4gICAgICAgIH1cblxuICAgICAgICBzbGlkZS5jc3MoZ2V0RGlyZWN0aW9uTGFiZWwoJ21hcmdpbi10b3AnKSwgcm93ICE9PSAwID8gc3BhY2VCZXR3ZWVuICYmIGAke3NwYWNlQmV0d2Vlbn1weGAgOiAnJyk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVXcmFwcGVyU2l6ZSA9IChzbGlkZVNpemUsIHNuYXBHcmlkLCBnZXREaXJlY3Rpb25MYWJlbCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3BhY2VCZXR3ZWVuLFxuICAgICAgICAgIGNlbnRlcmVkU2xpZGVzLFxuICAgICAgICAgIHJvdW5kTGVuZ3Roc1xuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJvd3NcbiAgICAgICAgfSA9IHN3aXBlci5wYXJhbXMuZ3JpZDtcbiAgICAgICAgc3dpcGVyLnZpcnR1YWxTaXplID0gKHNsaWRlU2l6ZSArIHNwYWNlQmV0d2VlbikgKiBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzO1xuICAgICAgICBzd2lwZXIudmlydHVhbFNpemUgPSBNYXRoLmNlaWwoc3dpcGVyLnZpcnR1YWxTaXplIC8gcm93cykgLSBzcGFjZUJldHdlZW47XG4gICAgICAgIHN3aXBlci4kd3JhcHBlckVsLmNzcyh7XG4gICAgICAgICAgW2dldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXTogYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgc3BhY2VCZXR3ZWVufXB4YFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgICBzbmFwR3JpZC5zcGxpY2UoMCwgc25hcEdyaWQubGVuZ3RoKTtcbiAgICAgICAgICBjb25zdCBuZXdTbGlkZXNHcmlkID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYXBHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2xpZGVzR3JpZEl0ZW0gPSBzbmFwR3JpZFtpXTtcbiAgICAgICAgICAgIGlmIChyb3VuZExlbmd0aHMpIHNsaWRlc0dyaWRJdGVtID0gTWF0aC5mbG9vcihzbGlkZXNHcmlkSXRlbSk7XG4gICAgICAgICAgICBpZiAoc25hcEdyaWRbaV0gPCBzd2lwZXIudmlydHVhbFNpemUgKyBzbmFwR3JpZFswXSkgbmV3U2xpZGVzR3JpZC5wdXNoKHNsaWRlc0dyaWRJdGVtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzbmFwR3JpZC5wdXNoKC4uLm5ld1NsaWRlc0dyaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzd2lwZXIuZ3JpZCA9IHtcbiAgICAgICAgaW5pdFNsaWRlcyxcbiAgICAgICAgdXBkYXRlU2xpZGUsXG4gICAgICAgIHVwZGF0ZVdyYXBwZXJTaXplXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGVuZFNsaWRlKHNsaWRlcykge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgcGFyYW1zXG4gICAgICB9ID0gc3dpcGVyO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoc2xpZGVzW2ldKSAkd3JhcHBlckVsLmFwcGVuZChzbGlkZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkd3JhcHBlckVsLmFwcGVuZChzbGlkZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBlbmRTbGlkZShzbGlkZXMpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgYWN0aXZlSW5kZXhcbiAgICAgIH0gPSBzd2lwZXI7XG5cbiAgICAgIGlmIChwYXJhbXMubG9vcCkge1xuICAgICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXggKyAxO1xuXG4gICAgICBpZiAodHlwZW9mIHNsaWRlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHNsaWRlc1tpXSkgJHdyYXBwZXJFbC5wcmVwZW5kKHNsaWRlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICsgc2xpZGVzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR3cmFwcGVyRWwucHJlcGVuZChzbGlkZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFNsaWRlKGluZGV4LCBzbGlkZXMpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgYWN0aXZlSW5kZXhcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBsZXQgYWN0aXZlSW5kZXhCdWZmZXIgPSBhY3RpdmVJbmRleDtcblxuICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgIGFjdGl2ZUluZGV4QnVmZmVyIC09IHN3aXBlci5sb29wZWRTbGlkZXM7XG4gICAgICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICAgICAgICBzd2lwZXIuc2xpZGVzID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhc2VMZW5ndGggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcblxuICAgICAgaWYgKGluZGV4IDw9IDApIHtcbiAgICAgICAgc3dpcGVyLnByZXBlbmRTbGlkZShzbGlkZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+PSBiYXNlTGVuZ3RoKSB7XG4gICAgICAgIHN3aXBlci5hcHBlbmRTbGlkZShzbGlkZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4QnVmZmVyID4gaW5kZXggPyBhY3RpdmVJbmRleEJ1ZmZlciArIDEgOiBhY3RpdmVJbmRleEJ1ZmZlcjtcbiAgICAgIGNvbnN0IHNsaWRlc0J1ZmZlciA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gYmFzZUxlbmd0aCAtIDE7IGkgPj0gaW5kZXg7IGkgLT0gMSkge1xuICAgICAgICBjb25zdCBjdXJyZW50U2xpZGUgPSBzd2lwZXIuc2xpZGVzLmVxKGkpO1xuICAgICAgICBjdXJyZW50U2xpZGUucmVtb3ZlKCk7XG4gICAgICAgIHNsaWRlc0J1ZmZlci51bnNoaWZ0KGN1cnJlbnRTbGlkZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoc2xpZGVzW2ldKSAkd3JhcHBlckVsLmFwcGVuZChzbGlkZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleEJ1ZmZlciA+IGluZGV4ID8gYWN0aXZlSW5kZXhCdWZmZXIgKyBzbGlkZXMubGVuZ3RoIDogYWN0aXZlSW5kZXhCdWZmZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkd3JhcHBlckVsLmFwcGVuZChzbGlkZXMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0J1ZmZlci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAkd3JhcHBlckVsLmFwcGVuZChzbGlkZXNCdWZmZXJbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXggKyBzd2lwZXIubG9vcGVkU2xpZGVzLCAwLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVNsaWRlKHNsaWRlc0luZGV4ZXMpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgYWN0aXZlSW5kZXhcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBsZXQgYWN0aXZlSW5kZXhCdWZmZXIgPSBhY3RpdmVJbmRleDtcblxuICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgIGFjdGl2ZUluZGV4QnVmZmVyIC09IHN3aXBlci5sb29wZWRTbGlkZXM7XG4gICAgICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICAgICAgICBzd2lwZXIuc2xpZGVzID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4QnVmZmVyO1xuICAgICAgbGV0IGluZGV4VG9SZW1vdmU7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVzSW5kZXhlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzSW5kZXhlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0luZGV4ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gc2xpZGVzSW5kZXhlc1tpXTtcbiAgICAgICAgICBpZiAoc3dpcGVyLnNsaWRlc1tpbmRleFRvUmVtb3ZlXSkgc3dpcGVyLnNsaWRlcy5lcShpbmRleFRvUmVtb3ZlKS5yZW1vdmUoKTtcbiAgICAgICAgICBpZiAoaW5kZXhUb1JlbW92ZSA8IG5ld0FjdGl2ZUluZGV4KSBuZXdBY3RpdmVJbmRleCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3QWN0aXZlSW5kZXggPSBNYXRoLm1heChuZXdBY3RpdmVJbmRleCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleFRvUmVtb3ZlID0gc2xpZGVzSW5kZXhlcztcbiAgICAgICAgaWYgKHN3aXBlci5zbGlkZXNbaW5kZXhUb1JlbW92ZV0pIHN3aXBlci5zbGlkZXMuZXEoaW5kZXhUb1JlbW92ZSkucmVtb3ZlKCk7XG4gICAgICAgIGlmIChpbmRleFRvUmVtb3ZlIDwgbmV3QWN0aXZlSW5kZXgpIG5ld0FjdGl2ZUluZGV4IC09IDE7XG4gICAgICAgIG5ld0FjdGl2ZUluZGV4ID0gTWF0aC5tYXgobmV3QWN0aXZlSW5kZXgsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXggKyBzd2lwZXIubG9vcGVkU2xpZGVzLCAwLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbFNsaWRlcygpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBzbGlkZXNJbmRleGVzID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzbGlkZXNJbmRleGVzLnB1c2goaSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5yZW1vdmVTbGlkZShzbGlkZXNJbmRleGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNYW5pcHVsYXRpb24oe1xuICAgICAgc3dpcGVyXG4gICAgfSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgYXBwZW5kU2xpZGU6IGFwcGVuZFNsaWRlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgcHJlcGVuZFNsaWRlOiBwcmVwZW5kU2xpZGUuYmluZChzd2lwZXIpLFxuICAgICAgICBhZGRTbGlkZTogYWRkU2xpZGUuYmluZChzd2lwZXIpLFxuICAgICAgICByZW1vdmVTbGlkZTogcmVtb3ZlU2xpZGUuYmluZChzd2lwZXIpLFxuICAgICAgICByZW1vdmVBbGxTbGlkZXM6IHJlbW92ZUFsbFNsaWRlcy5iaW5kKHN3aXBlcilcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVmZmVjdEluaXQocGFyYW1zKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgc3dpcGVyLFxuICAgICAgICBvbixcbiAgICAgICAgc2V0VHJhbnNsYXRlLFxuICAgICAgICBzZXRUcmFuc2l0aW9uLFxuICAgICAgICBvdmVyd3JpdGVQYXJhbXMsXG4gICAgICAgIHBlcnNwZWN0aXZlXG4gICAgICB9ID0gcGFyYW1zO1xuICAgICAgb24oJ2JlZm9yZUluaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gZWZmZWN0KSByZXR1cm47XG4gICAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfSR7ZWZmZWN0fWApO1xuXG4gICAgICAgIGlmIChwZXJzcGVjdGl2ZSAmJiBwZXJzcGVjdGl2ZSgpKSB7XG4gICAgICAgICAgc3dpcGVyLmNsYXNzTmFtZXMucHVzaChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9M2RgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG92ZXJ3cml0ZVBhcmFtc1Jlc3VsdCA9IG92ZXJ3cml0ZVBhcmFtcyA/IG92ZXJ3cml0ZVBhcmFtcygpIDoge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLnBhcmFtcywgb3ZlcndyaXRlUGFyYW1zUmVzdWx0KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIub3JpZ2luYWxQYXJhbXMsIG92ZXJ3cml0ZVBhcmFtc1Jlc3VsdCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdzZXRUcmFuc2xhdGUnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gZWZmZWN0KSByZXR1cm47XG4gICAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignc2V0VHJhbnNpdGlvbicsIChfcywgZHVyYXRpb24pID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSBlZmZlY3QpIHJldHVybjtcbiAgICAgICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlZmZlY3RUYXJnZXQoZWZmZWN0UGFyYW1zLCAkc2xpZGVFbCkge1xuICAgICAgaWYgKGVmZmVjdFBhcmFtcy50cmFuc2Zvcm1FbCkge1xuICAgICAgICByZXR1cm4gJHNsaWRlRWwuZmluZChlZmZlY3RQYXJhbXMudHJhbnNmb3JtRWwpLmNzcyh7XG4gICAgICAgICAgJ2JhY2tmYWNlLXZpc2liaWxpdHknOiAnaGlkZGVuJyxcbiAgICAgICAgICAnLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkc2xpZGVFbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlZmZlY3RWaXJ0dWFsVHJhbnNpdGlvbkVuZCh7XG4gICAgICBzd2lwZXIsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHRyYW5zZm9ybUVsLFxuICAgICAgYWxsU2xpZGVzXG4gICAgfSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbGlkZXMsXG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICAkd3JhcHBlckVsXG4gICAgICB9ID0gc3dpcGVyO1xuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlICYmIGR1cmF0aW9uICE9PSAwKSB7XG4gICAgICAgIGxldCBldmVudFRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgJHRyYW5zaXRpb25FbmRUYXJnZXQ7XG5cbiAgICAgICAgaWYgKGFsbFNsaWRlcykge1xuICAgICAgICAgICR0cmFuc2l0aW9uRW5kVGFyZ2V0ID0gdHJhbnNmb3JtRWwgPyBzbGlkZXMuZmluZCh0cmFuc2Zvcm1FbCkgOiBzbGlkZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHRyYW5zaXRpb25FbmRUYXJnZXQgPSB0cmFuc2Zvcm1FbCA/IHNsaWRlcy5lcShhY3RpdmVJbmRleCkuZmluZCh0cmFuc2Zvcm1FbCkgOiBzbGlkZXMuZXEoYWN0aXZlSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRyYW5zaXRpb25FbmRUYXJnZXQudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50VHJpZ2dlcmVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgIGV2ZW50VHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgdHJpZ2dlckV2ZW50cyA9IFsnd2Via2l0VHJhbnNpdGlvbkVuZCcsICd0cmFuc2l0aW9uZW5kJ107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWdnZXJFdmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICR3cmFwcGVyRWwudHJpZ2dlcih0cmlnZ2VyRXZlbnRzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEVmZmVjdEZhZGUoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgb25cbiAgICB9KSB7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBmYWRlRWZmZWN0OiB7XG4gICAgICAgICAgY3Jvc3NGYWRlOiBmYWxzZSxcbiAgICAgICAgICB0cmFuc2Zvcm1FbDogbnVsbFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2V0VHJhbnNsYXRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2xpZGVzXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuZmFkZUVmZmVjdDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGNvbnN0ICRzbGlkZUVsID0gc3dpcGVyLnNsaWRlcy5lcShpKTtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSAkc2xpZGVFbFswXS5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICAgICAgICBsZXQgdHggPSAtb2Zmc2V0O1xuICAgICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlKSB0eCAtPSBzd2lwZXIudHJhbnNsYXRlO1xuICAgICAgICAgIGxldCB0eSA9IDA7XG5cbiAgICAgICAgICBpZiAoIXN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgdHkgPSB0eDtcbiAgICAgICAgICAgIHR4ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzbGlkZU9wYWNpdHkgPSBzd2lwZXIucGFyYW1zLmZhZGVFZmZlY3QuY3Jvc3NGYWRlID8gTWF0aC5tYXgoMSAtIE1hdGguYWJzKCRzbGlkZUVsWzBdLnByb2dyZXNzKSwgMCkgOiAxICsgTWF0aC5taW4oTWF0aC5tYXgoJHNsaWRlRWxbMF0ucHJvZ3Jlc3MsIC0xKSwgMCk7XG4gICAgICAgICAgY29uc3QgJHRhcmdldEVsID0gZWZmZWN0VGFyZ2V0KHBhcmFtcywgJHNsaWRlRWwpO1xuICAgICAgICAgICR0YXJnZXRFbC5jc3Moe1xuICAgICAgICAgICAgb3BhY2l0eTogc2xpZGVPcGFjaXR5XG4gICAgICAgICAgfSkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3R4fXB4LCAke3R5fXB4LCAwcHgpYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNldFRyYW5zaXRpb24gPSBkdXJhdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0cmFuc2Zvcm1FbFxuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcy5mYWRlRWZmZWN0O1xuICAgICAgICBjb25zdCAkdHJhbnNpdGlvbkVsZW1lbnRzID0gdHJhbnNmb3JtRWwgPyBzd2lwZXIuc2xpZGVzLmZpbmQodHJhbnNmb3JtRWwpIDogc3dpcGVyLnNsaWRlcztcbiAgICAgICAgJHRyYW5zaXRpb25FbGVtZW50cy50cmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgZWZmZWN0VmlydHVhbFRyYW5zaXRpb25FbmQoe1xuICAgICAgICAgIHN3aXBlcixcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICB0cmFuc2Zvcm1FbCxcbiAgICAgICAgICBhbGxTbGlkZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBlZmZlY3RJbml0KHtcbiAgICAgICAgZWZmZWN0OiAnZmFkZScsXG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgb24sXG4gICAgICAgIHNldFRyYW5zbGF0ZSxcbiAgICAgICAgc2V0VHJhbnNpdGlvbixcbiAgICAgICAgb3ZlcndyaXRlUGFyYW1zOiAoKSA9PiAoe1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICAgICAgc2xpZGVzUGVyR3JvdXA6IDEsXG4gICAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgICBzcGFjZUJldHdlZW46IDAsXG4gICAgICAgICAgdmlydHVhbFRyYW5zbGF0ZTogIXN3aXBlci5wYXJhbXMuY3NzTW9kZVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRWZmZWN0Q3ViZSh7XG4gICAgICBzd2lwZXIsXG4gICAgICBleHRlbmRQYXJhbXMsXG4gICAgICBvblxuICAgIH0pIHtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIGN1YmVFZmZlY3Q6IHtcbiAgICAgICAgICBzbGlkZVNoYWRvd3M6IHRydWUsXG4gICAgICAgICAgc2hhZG93OiB0cnVlLFxuICAgICAgICAgIHNoYWRvd09mZnNldDogMjAsXG4gICAgICAgICAgc2hhZG93U2NhbGU6IDAuOTRcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNldFRyYW5zbGF0ZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbCxcbiAgICAgICAgICAkd3JhcHBlckVsLFxuICAgICAgICAgIHNsaWRlcyxcbiAgICAgICAgICB3aWR0aDogc3dpcGVyV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzd2lwZXJIZWlnaHQsXG4gICAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgICAgc2l6ZTogc3dpcGVyU2l6ZSxcbiAgICAgICAgICBicm93c2VyXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuY3ViZUVmZmVjdDtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgICAgICAgbGV0IHdyYXBwZXJSb3RhdGUgPSAwO1xuICAgICAgICBsZXQgJGN1YmVTaGFkb3dFbDtcblxuICAgICAgICBpZiAocGFyYW1zLnNoYWRvdykge1xuICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICRjdWJlU2hhZG93RWwgPSAkd3JhcHBlckVsLmZpbmQoJy5zd2lwZXItY3ViZS1zaGFkb3cnKTtcblxuICAgICAgICAgICAgaWYgKCRjdWJlU2hhZG93RWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICRjdWJlU2hhZG93RWwgPSAkKCc8ZGl2IGNsYXNzPVwic3dpcGVyLWN1YmUtc2hhZG93XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICR3cmFwcGVyRWwuYXBwZW5kKCRjdWJlU2hhZG93RWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkY3ViZVNoYWRvd0VsLmNzcyh7XG4gICAgICAgICAgICAgIGhlaWdodDogYCR7c3dpcGVyV2lkdGh9cHhgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGN1YmVTaGFkb3dFbCA9ICRlbC5maW5kKCcuc3dpcGVyLWN1YmUtc2hhZG93Jyk7XG5cbiAgICAgICAgICAgIGlmICgkY3ViZVNoYWRvd0VsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAkY3ViZVNoYWRvd0VsID0gJCgnPGRpdiBjbGFzcz1cInN3aXBlci1jdWJlLXNoYWRvd1wiPjwvZGl2PicpO1xuICAgICAgICAgICAgICAkZWwuYXBwZW5kKCRjdWJlU2hhZG93RWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY29uc3QgJHNsaWRlRWwgPSBzbGlkZXMuZXEoaSk7XG4gICAgICAgICAgbGV0IHNsaWRlSW5kZXggPSBpO1xuXG4gICAgICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICAgICAgc2xpZGVJbmRleCA9IHBhcnNlSW50KCRzbGlkZUVsLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgc2xpZGVBbmdsZSA9IHNsaWRlSW5kZXggKiA5MDtcbiAgICAgICAgICBsZXQgcm91bmQgPSBNYXRoLmZsb29yKHNsaWRlQW5nbGUgLyAzNjApO1xuXG4gICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgc2xpZGVBbmdsZSA9IC1zbGlkZUFuZ2xlO1xuICAgICAgICAgICAgcm91bmQgPSBNYXRoLmZsb29yKC1zbGlkZUFuZ2xlIC8gMzYwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKCRzbGlkZUVsWzBdLnByb2dyZXNzLCAxKSwgLTEpO1xuICAgICAgICAgIGxldCB0eCA9IDA7XG4gICAgICAgICAgbGV0IHR5ID0gMDtcbiAgICAgICAgICBsZXQgdHogPSAwO1xuXG4gICAgICAgICAgaWYgKHNsaWRlSW5kZXggJSA0ID09PSAwKSB7XG4gICAgICAgICAgICB0eCA9IC1yb3VuZCAqIDQgKiBzd2lwZXJTaXplO1xuICAgICAgICAgICAgdHogPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHNsaWRlSW5kZXggLSAxKSAlIDQgPT09IDApIHtcbiAgICAgICAgICAgIHR4ID0gMDtcbiAgICAgICAgICAgIHR6ID0gLXJvdW5kICogNCAqIHN3aXBlclNpemU7XG4gICAgICAgICAgfSBlbHNlIGlmICgoc2xpZGVJbmRleCAtIDIpICUgNCA9PT0gMCkge1xuICAgICAgICAgICAgdHggPSBzd2lwZXJTaXplICsgcm91bmQgKiA0ICogc3dpcGVyU2l6ZTtcbiAgICAgICAgICAgIHR6ID0gc3dpcGVyU2l6ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChzbGlkZUluZGV4IC0gMykgJSA0ID09PSAwKSB7XG4gICAgICAgICAgICB0eCA9IC1zd2lwZXJTaXplO1xuICAgICAgICAgICAgdHogPSAzICogc3dpcGVyU2l6ZSArIHN3aXBlclNpemUgKiA0ICogcm91bmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgdHggPSAtdHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHR5ID0gdHg7XG4gICAgICAgICAgICB0eCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gYHJvdGF0ZVgoJHtpc0hvcml6b250YWwgPyAwIDogLXNsaWRlQW5nbGV9ZGVnKSByb3RhdGVZKCR7aXNIb3Jpem9udGFsID8gc2xpZGVBbmdsZSA6IDB9ZGVnKSB0cmFuc2xhdGUzZCgke3R4fXB4LCAke3R5fXB4LCAke3R6fXB4KWA7XG5cbiAgICAgICAgICBpZiAocHJvZ3Jlc3MgPD0gMSAmJiBwcm9ncmVzcyA+IC0xKSB7XG4gICAgICAgICAgICB3cmFwcGVyUm90YXRlID0gc2xpZGVJbmRleCAqIDkwICsgcHJvZ3Jlc3MgKiA5MDtcbiAgICAgICAgICAgIGlmIChydGwpIHdyYXBwZXJSb3RhdGUgPSAtc2xpZGVJbmRleCAqIDkwIC0gcHJvZ3Jlc3MgKiA5MDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkc2xpZGVFbC50cmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICAgICAgICAgIGlmIChwYXJhbXMuc2xpZGVTaGFkb3dzKSB7XG4gICAgICAgICAgICAvLyBTZXQgc2hhZG93c1xuICAgICAgICAgICAgbGV0IHNoYWRvd0JlZm9yZSA9IGlzSG9yaXpvbnRhbCA/ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKSA6ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCcpO1xuICAgICAgICAgICAgbGV0IHNoYWRvd0FmdGVyID0gaXNIb3Jpem9udGFsID8gJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQnKSA6ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbScpO1xuXG4gICAgICAgICAgICBpZiAoc2hhZG93QmVmb3JlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBzaGFkb3dCZWZvcmUgPSAkKGA8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0ke2lzSG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnfVwiPjwvZGl2PmApO1xuICAgICAgICAgICAgICAkc2xpZGVFbC5hcHBlbmQoc2hhZG93QmVmb3JlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNoYWRvd0FmdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBzaGFkb3dBZnRlciA9ICQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LSR7aXNIb3Jpem9udGFsID8gJ3JpZ2h0JyA6ICdib3R0b20nfVwiPjwvZGl2PmApO1xuICAgICAgICAgICAgICAkc2xpZGVFbC5hcHBlbmQoc2hhZG93QWZ0ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hhZG93QmVmb3JlLmxlbmd0aCkgc2hhZG93QmVmb3JlWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heCgtcHJvZ3Jlc3MsIDApO1xuICAgICAgICAgICAgaWYgKHNoYWRvd0FmdGVyLmxlbmd0aCkgc2hhZG93QWZ0ZXJbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KHByb2dyZXNzLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkd3JhcHBlckVsLmNzcyh7XG4gICAgICAgICAgJy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbic6IGA1MCUgNTAlIC0ke3N3aXBlclNpemUgLyAyfXB4YCxcbiAgICAgICAgICAndHJhbnNmb3JtLW9yaWdpbic6IGA1MCUgNTAlIC0ke3N3aXBlclNpemUgLyAyfXB4YFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocGFyYW1zLnNoYWRvdykge1xuICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICRjdWJlU2hhZG93RWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsICR7c3dpcGVyV2lkdGggLyAyICsgcGFyYW1zLnNoYWRvd09mZnNldH1weCwgJHstc3dpcGVyV2lkdGggLyAyfXB4KSByb3RhdGVYKDkwZGVnKSByb3RhdGVaKDBkZWcpIHNjYWxlKCR7cGFyYW1zLnNoYWRvd1NjYWxlfSlgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93QW5nbGUgPSBNYXRoLmFicyh3cmFwcGVyUm90YXRlKSAtIE1hdGguZmxvb3IoTWF0aC5hYnMod3JhcHBlclJvdGF0ZSkgLyA5MCkgKiA5MDtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSAxLjUgLSAoTWF0aC5zaW4oc2hhZG93QW5nbGUgKiAyICogTWF0aC5QSSAvIDM2MCkgLyAyICsgTWF0aC5jb3Moc2hhZG93QW5nbGUgKiAyICogTWF0aC5QSSAvIDM2MCkgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlMSA9IHBhcmFtcy5zaGFkb3dTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlMiA9IHBhcmFtcy5zaGFkb3dTY2FsZSAvIG11bHRpcGxpZXI7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwYXJhbXMuc2hhZG93T2Zmc2V0O1xuICAgICAgICAgICAgJGN1YmVTaGFkb3dFbC50cmFuc2Zvcm0oYHNjYWxlM2QoJHtzY2FsZTF9LCAxLCAke3NjYWxlMn0pIHRyYW5zbGF0ZTNkKDBweCwgJHtzd2lwZXJIZWlnaHQgLyAyICsgb2Zmc2V0fXB4LCAkey1zd2lwZXJIZWlnaHQgLyAyIC8gc2NhbGUyfXB4KSByb3RhdGVYKC05MGRlZylgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB6RmFjdG9yID0gYnJvd3Nlci5pc1NhZmFyaSB8fCBicm93c2VyLmlzV2ViVmlldyA/IC1zd2lwZXJTaXplIC8gMiA6IDA7XG4gICAgICAgICR3cmFwcGVyRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsMCwke3pGYWN0b3J9cHgpIHJvdGF0ZVgoJHtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAwIDogd3JhcHBlclJvdGF0ZX1kZWcpIHJvdGF0ZVkoJHtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAtd3JhcHBlclJvdGF0ZSA6IDB9ZGVnKWApO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2V0VHJhbnNpdGlvbiA9IGR1cmF0aW9uID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbCxcbiAgICAgICAgICBzbGlkZXNcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgc2xpZGVzLnRyYW5zaXRpb24oZHVyYXRpb24pLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpLnRyYW5zaXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmN1YmVFZmZlY3Quc2hhZG93ICYmICFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAkZWwuZmluZCgnLnN3aXBlci1jdWJlLXNoYWRvdycpLnRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBlZmZlY3RJbml0KHtcbiAgICAgICAgZWZmZWN0OiAnY3ViZScsXG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgb24sXG4gICAgICAgIHNldFRyYW5zbGF0ZSxcbiAgICAgICAgc2V0VHJhbnNpdGlvbixcbiAgICAgICAgcGVyc3BlY3RpdmU6ICgpID0+IHRydWUsXG4gICAgICAgIG92ZXJ3cml0ZVBhcmFtczogKCkgPT4gKHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXG4gICAgICAgICAgcmVzaXN0YW5jZVJhdGlvOiAwLFxuICAgICAgICAgIHNwYWNlQmV0d2VlbjogMCxcbiAgICAgICAgICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXG4gICAgICAgICAgdmlydHVhbFRyYW5zbGF0ZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2hhZG93KHBhcmFtcywgJHNsaWRlRWwsIHNpZGUpIHtcbiAgICAgIGNvbnN0IHNoYWRvd0NsYXNzID0gYHN3aXBlci1zbGlkZS1zaGFkb3cke3NpZGUgPyBgLSR7c2lkZX1gIDogJyd9YDtcbiAgICAgIGNvbnN0ICRzaGFkb3dDb250YWluZXIgPSBwYXJhbXMudHJhbnNmb3JtRWwgPyAkc2xpZGVFbC5maW5kKHBhcmFtcy50cmFuc2Zvcm1FbCkgOiAkc2xpZGVFbDtcbiAgICAgIGxldCAkc2hhZG93RWwgPSAkc2hhZG93Q29udGFpbmVyLmNoaWxkcmVuKGAuJHtzaGFkb3dDbGFzc31gKTtcblxuICAgICAgaWYgKCEkc2hhZG93RWwubGVuZ3RoKSB7XG4gICAgICAgICRzaGFkb3dFbCA9ICQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93JHtzaWRlID8gYC0ke3NpZGV9YCA6ICcnfVwiPjwvZGl2PmApO1xuICAgICAgICAkc2hhZG93Q29udGFpbmVyLmFwcGVuZCgkc2hhZG93RWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJHNoYWRvd0VsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEVmZmVjdEZsaXAoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgb25cbiAgICB9KSB7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBmbGlwRWZmZWN0OiB7XG4gICAgICAgICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxuICAgICAgICAgIGxpbWl0Um90YXRpb246IHRydWUsXG4gICAgICAgICAgdHJhbnNmb3JtRWw6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNldFRyYW5zbGF0ZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNsaWRlcyxcbiAgICAgICAgICBydGxUcmFuc2xhdGU6IHJ0bFxuICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmZsaXBFZmZlY3Q7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zdCAkc2xpZGVFbCA9IHNsaWRlcy5lcShpKTtcbiAgICAgICAgICBsZXQgcHJvZ3Jlc3MgPSAkc2xpZGVFbFswXS5wcm9ncmVzcztcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZsaXBFZmZlY3QubGltaXRSb3RhdGlvbikge1xuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1heChNYXRoLm1pbigkc2xpZGVFbFswXS5wcm9ncmVzcywgMSksIC0xKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSAkc2xpZGVFbFswXS5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICAgICAgICBjb25zdCByb3RhdGUgPSAtMTgwICogcHJvZ3Jlc3M7XG4gICAgICAgICAgbGV0IHJvdGF0ZVkgPSByb3RhdGU7XG4gICAgICAgICAgbGV0IHJvdGF0ZVggPSAwO1xuICAgICAgICAgIGxldCB0eCA9IHN3aXBlci5wYXJhbXMuY3NzTW9kZSA/IC1vZmZzZXQgLSBzd2lwZXIudHJhbnNsYXRlIDogLW9mZnNldDtcbiAgICAgICAgICBsZXQgdHkgPSAwO1xuXG4gICAgICAgICAgaWYgKCFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgIHR5ID0gdHg7XG4gICAgICAgICAgICB0eCA9IDA7XG4gICAgICAgICAgICByb3RhdGVYID0gLXJvdGF0ZVk7XG4gICAgICAgICAgICByb3RhdGVZID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJ0bCkge1xuICAgICAgICAgICAgcm90YXRlWSA9IC1yb3RhdGVZO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRzbGlkZUVsWzBdLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKHByb2dyZXNzKSkgKyBzbGlkZXMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHBhcmFtcy5zbGlkZVNoYWRvd3MpIHtcbiAgICAgICAgICAgIC8vIFNldCBzaGFkb3dzXG4gICAgICAgICAgICBsZXQgc2hhZG93QmVmb3JlID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wJyk7XG4gICAgICAgICAgICBsZXQgc2hhZG93QWZ0ZXIgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tJyk7XG5cbiAgICAgICAgICAgIGlmIChzaGFkb3dCZWZvcmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHNoYWRvd0JlZm9yZSA9IGNyZWF0ZVNoYWRvdyhwYXJhbXMsICRzbGlkZUVsLCBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnbGVmdCcgOiAndG9wJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaGFkb3dBZnRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgc2hhZG93QWZ0ZXIgPSBjcmVhdGVTaGFkb3cocGFyYW1zLCAkc2xpZGVFbCwgc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3JpZ2h0JyA6ICdib3R0b20nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNoYWRvd0JlZm9yZS5sZW5ndGgpIHNoYWRvd0JlZm9yZVswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgoLXByb2dyZXNzLCAwKTtcbiAgICAgICAgICAgIGlmIChzaGFkb3dBZnRlci5sZW5ndGgpIHNoYWRvd0FmdGVyWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heChwcm9ncmVzcywgMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dHh9cHgsICR7dHl9cHgsIDBweCkgcm90YXRlWCgke3JvdGF0ZVh9ZGVnKSByb3RhdGVZKCR7cm90YXRlWX1kZWcpYDtcbiAgICAgICAgICBjb25zdCAkdGFyZ2V0RWwgPSBlZmZlY3RUYXJnZXQocGFyYW1zLCAkc2xpZGVFbCk7XG4gICAgICAgICAgJHRhcmdldEVsLnRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2l0aW9uID0gZHVyYXRpb24gPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHJhbnNmb3JtRWxcbiAgICAgICAgfSA9IHN3aXBlci5wYXJhbXMuZmxpcEVmZmVjdDtcbiAgICAgICAgY29uc3QgJHRyYW5zaXRpb25FbGVtZW50cyA9IHRyYW5zZm9ybUVsID8gc3dpcGVyLnNsaWRlcy5maW5kKHRyYW5zZm9ybUVsKSA6IHN3aXBlci5zbGlkZXM7XG4gICAgICAgICR0cmFuc2l0aW9uRWxlbWVudHMudHJhbnNpdGlvbihkdXJhdGlvbikuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0JykudHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgICAgIGVmZmVjdFZpcnR1YWxUcmFuc2l0aW9uRW5kKHtcbiAgICAgICAgICBzd2lwZXIsXG4gICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgdHJhbnNmb3JtRWxcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBlZmZlY3RJbml0KHtcbiAgICAgICAgZWZmZWN0OiAnZmxpcCcsXG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgb24sXG4gICAgICAgIHNldFRyYW5zbGF0ZSxcbiAgICAgICAgc2V0VHJhbnNpdGlvbixcbiAgICAgICAgcGVyc3BlY3RpdmU6ICgpID0+IHRydWUsXG4gICAgICAgIG92ZXJ3cml0ZVBhcmFtczogKCkgPT4gKHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAwLFxuICAgICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6ICFzd2lwZXIucGFyYW1zLmNzc01vZGVcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEVmZmVjdENvdmVyZmxvdyh7XG4gICAgICBzd2lwZXIsXG4gICAgICBleHRlbmRQYXJhbXMsXG4gICAgICBvblxuICAgIH0pIHtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIGNvdmVyZmxvd0VmZmVjdDoge1xuICAgICAgICAgIHJvdGF0ZTogNTAsXG4gICAgICAgICAgc3RyZXRjaDogMCxcbiAgICAgICAgICBkZXB0aDogMTAwLFxuICAgICAgICAgIHNjYWxlOiAxLFxuICAgICAgICAgIG1vZGlmaWVyOiAxLFxuICAgICAgICAgIHNsaWRlU2hhZG93czogdHJ1ZSxcbiAgICAgICAgICB0cmFuc2Zvcm1FbDogbnVsbFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2V0VHJhbnNsYXRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2lkdGg6IHN3aXBlcldpZHRoLFxuICAgICAgICAgIGhlaWdodDogc3dpcGVySGVpZ2h0LFxuICAgICAgICAgIHNsaWRlcyxcbiAgICAgICAgICBzbGlkZXNTaXplc0dyaWRcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5jb3ZlcmZsb3dFZmZlY3Q7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHN3aXBlci5pc0hvcml6b250YWwoKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gaXNIb3Jpem9udGFsID8gLXRyYW5zZm9ybSArIHN3aXBlcldpZHRoIC8gMiA6IC10cmFuc2Zvcm0gKyBzd2lwZXJIZWlnaHQgLyAyO1xuICAgICAgICBjb25zdCByb3RhdGUgPSBpc0hvcml6b250YWwgPyBwYXJhbXMucm90YXRlIDogLXBhcmFtcy5yb3RhdGU7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHBhcmFtcy5kZXB0aDsgLy8gRWFjaCBzbGlkZSBvZmZzZXQgZnJvbSBjZW50ZXJcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc2xpZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY29uc3QgJHNsaWRlRWwgPSBzbGlkZXMuZXEoaSk7XG4gICAgICAgICAgY29uc3Qgc2xpZGVTaXplID0gc2xpZGVzU2l6ZXNHcmlkW2ldO1xuICAgICAgICAgIGNvbnN0IHNsaWRlT2Zmc2V0ID0gJHNsaWRlRWxbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0TXVsdGlwbGllciA9IChjZW50ZXIgLSBzbGlkZU9mZnNldCAtIHNsaWRlU2l6ZSAvIDIpIC8gc2xpZGVTaXplICogcGFyYW1zLm1vZGlmaWVyO1xuICAgICAgICAgIGxldCByb3RhdGVZID0gaXNIb3Jpem9udGFsID8gcm90YXRlICogb2Zmc2V0TXVsdGlwbGllciA6IDA7XG4gICAgICAgICAgbGV0IHJvdGF0ZVggPSBpc0hvcml6b250YWwgPyAwIDogcm90YXRlICogb2Zmc2V0TXVsdGlwbGllcjsgLy8gdmFyIHJvdGF0ZVogPSAwXG5cbiAgICAgICAgICBsZXQgdHJhbnNsYXRlWiA9IC10cmFuc2xhdGUgKiBNYXRoLmFicyhvZmZzZXRNdWx0aXBsaWVyKTtcbiAgICAgICAgICBsZXQgc3RyZXRjaCA9IHBhcmFtcy5zdHJldGNoOyAvLyBBbGxvdyBwZXJjZW50YWdlIHRvIG1ha2UgYSByZWxhdGl2ZSBzdHJldGNoIGZvciByZXNwb25zaXZlIHNsaWRlcnNcblxuICAgICAgICAgIGlmICh0eXBlb2Ygc3RyZXRjaCA9PT0gJ3N0cmluZycgJiYgc3RyZXRjaC5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAgICAgICBzdHJldGNoID0gcGFyc2VGbG9hdChwYXJhbXMuc3RyZXRjaCkgLyAxMDAgKiBzbGlkZVNpemU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHRyYW5zbGF0ZVkgPSBpc0hvcml6b250YWwgPyAwIDogc3RyZXRjaCAqIG9mZnNldE11bHRpcGxpZXI7XG4gICAgICAgICAgbGV0IHRyYW5zbGF0ZVggPSBpc0hvcml6b250YWwgPyBzdHJldGNoICogb2Zmc2V0TXVsdGlwbGllciA6IDA7XG4gICAgICAgICAgbGV0IHNjYWxlID0gMSAtICgxIC0gcGFyYW1zLnNjYWxlKSAqIE1hdGguYWJzKG9mZnNldE11bHRpcGxpZXIpOyAvLyBGaXggZm9yIHVsdHJhIHNtYWxsIHZhbHVlc1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHRyYW5zbGF0ZVgpIDwgMC4wMDEpIHRyYW5zbGF0ZVggPSAwO1xuICAgICAgICAgIGlmIChNYXRoLmFicyh0cmFuc2xhdGVZKSA8IDAuMDAxKSB0cmFuc2xhdGVZID0gMDtcbiAgICAgICAgICBpZiAoTWF0aC5hYnModHJhbnNsYXRlWikgPCAwLjAwMSkgdHJhbnNsYXRlWiA9IDA7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKHJvdGF0ZVkpIDwgMC4wMDEpIHJvdGF0ZVkgPSAwO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGVYKSA8IDAuMDAxKSByb3RhdGVYID0gMDtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoc2NhbGUpIDwgMC4wMDEpIHNjYWxlID0gMDtcbiAgICAgICAgICBjb25zdCBzbGlkZVRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVh9cHgsJHt0cmFuc2xhdGVZfXB4LCR7dHJhbnNsYXRlWn1weCkgIHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgcm90YXRlWSgke3JvdGF0ZVl9ZGVnKSBzY2FsZSgke3NjYWxlfSlgO1xuICAgICAgICAgIGNvbnN0ICR0YXJnZXRFbCA9IGVmZmVjdFRhcmdldChwYXJhbXMsICRzbGlkZUVsKTtcbiAgICAgICAgICAkdGFyZ2V0RWwudHJhbnNmb3JtKHNsaWRlVHJhbnNmb3JtKTtcbiAgICAgICAgICAkc2xpZGVFbFswXS5zdHlsZS56SW5kZXggPSAtTWF0aC5hYnMoTWF0aC5yb3VuZChvZmZzZXRNdWx0aXBsaWVyKSkgKyAxO1xuXG4gICAgICAgICAgaWYgKHBhcmFtcy5zbGlkZVNoYWRvd3MpIHtcbiAgICAgICAgICAgIC8vIFNldCBzaGFkb3dzXG4gICAgICAgICAgICBsZXQgJHNoYWRvd0JlZm9yZUVsID0gaXNIb3Jpem9udGFsID8gJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wJyk7XG4gICAgICAgICAgICBsZXQgJHNoYWRvd0FmdGVyRWwgPSBpc0hvcml6b250YWwgPyAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tJyk7XG5cbiAgICAgICAgICAgIGlmICgkc2hhZG93QmVmb3JlRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICRzaGFkb3dCZWZvcmVFbCA9IGNyZWF0ZVNoYWRvdyhwYXJhbXMsICRzbGlkZUVsLCBpc0hvcml6b250YWwgPyAnbGVmdCcgOiAndG9wJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkc2hhZG93QWZ0ZXJFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgJHNoYWRvd0FmdGVyRWwgPSBjcmVhdGVTaGFkb3cocGFyYW1zLCAkc2xpZGVFbCwgaXNIb3Jpem9udGFsID8gJ3JpZ2h0JyA6ICdib3R0b20nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCRzaGFkb3dCZWZvcmVFbC5sZW5ndGgpICRzaGFkb3dCZWZvcmVFbFswXS5zdHlsZS5vcGFjaXR5ID0gb2Zmc2V0TXVsdGlwbGllciA+IDAgPyBvZmZzZXRNdWx0aXBsaWVyIDogMDtcbiAgICAgICAgICAgIGlmICgkc2hhZG93QWZ0ZXJFbC5sZW5ndGgpICRzaGFkb3dBZnRlckVsWzBdLnN0eWxlLm9wYWNpdHkgPSAtb2Zmc2V0TXVsdGlwbGllciA+IDAgPyAtb2Zmc2V0TXVsdGlwbGllciA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2l0aW9uID0gZHVyYXRpb24gPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHJhbnNmb3JtRWxcbiAgICAgICAgfSA9IHN3aXBlci5wYXJhbXMuY292ZXJmbG93RWZmZWN0O1xuICAgICAgICBjb25zdCAkdHJhbnNpdGlvbkVsZW1lbnRzID0gdHJhbnNmb3JtRWwgPyBzd2lwZXIuc2xpZGVzLmZpbmQodHJhbnNmb3JtRWwpIDogc3dpcGVyLnNsaWRlcztcbiAgICAgICAgJHRyYW5zaXRpb25FbGVtZW50cy50cmFuc2l0aW9uKGR1cmF0aW9uKS5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKS50cmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIGVmZmVjdEluaXQoe1xuICAgICAgICBlZmZlY3Q6ICdjb3ZlcmZsb3cnLFxuICAgICAgICBzd2lwZXIsXG4gICAgICAgIG9uLFxuICAgICAgICBzZXRUcmFuc2xhdGUsXG4gICAgICAgIHNldFRyYW5zaXRpb24sXG4gICAgICAgIHBlcnNwZWN0aXZlOiAoKSA9PiB0cnVlLFxuICAgICAgICBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7XG4gICAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRWZmZWN0Q3JlYXRpdmUoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgb25cbiAgICB9KSB7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBjcmVhdGl2ZUVmZmVjdDoge1xuICAgICAgICAgIHRyYW5zZm9ybUVsOiBudWxsLFxuICAgICAgICAgIGxpbWl0UHJvZ3Jlc3M6IDEsXG4gICAgICAgICAgc2hhZG93UGVyUHJvZ3Jlc3M6IGZhbHNlLFxuICAgICAgICAgIHByb2dyZXNzTXVsdGlwbGllcjogMSxcbiAgICAgICAgICBwZXJzcGVjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBwcmV2OiB7XG4gICAgICAgICAgICB0cmFuc2xhdGU6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIHJvdGF0ZTogWzAsIDAsIDBdLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHNjYWxlOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuZXh0OiB7XG4gICAgICAgICAgICB0cmFuc2xhdGU6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIHJvdGF0ZTogWzAsIDAsIDBdLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHNjYWxlOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZ2V0VHJhbnNsYXRlVmFsdWUgPSB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1weGA7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2xhdGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzbGlkZXMsXG4gICAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgICBzbGlkZXNTaXplc0dyaWRcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5jcmVhdGl2ZUVmZmVjdDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHByb2dyZXNzTXVsdGlwbGllcjogbXVsdGlwbGllclxuICAgICAgICB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBpc0NlbnRlcmVkU2xpZGVzID0gc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcztcblxuICAgICAgICBpZiAoaXNDZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IHNsaWRlc1NpemVzR3JpZFswXSAvIDIgLSBzd2lwZXIucGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZSB8fCAwO1xuICAgICAgICAgICR3cmFwcGVyRWwudHJhbnNmb3JtKGB0cmFuc2xhdGVYKGNhbGMoNTAlIC0gJHttYXJnaW59cHgpKWApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zdCAkc2xpZGVFbCA9IHNsaWRlcy5lcShpKTtcbiAgICAgICAgICBjb25zdCBzbGlkZVByb2dyZXNzID0gJHNsaWRlRWxbMF0ucHJvZ3Jlc3M7XG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heCgkc2xpZGVFbFswXS5wcm9ncmVzcywgLXBhcmFtcy5saW1pdFByb2dyZXNzKSwgcGFyYW1zLmxpbWl0UHJvZ3Jlc3MpO1xuICAgICAgICAgIGxldCBvcmlnaW5hbFByb2dyZXNzID0gcHJvZ3Jlc3M7XG5cbiAgICAgICAgICBpZiAoIWlzQ2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsUHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heCgkc2xpZGVFbFswXS5vcmlnaW5hbFByb2dyZXNzLCAtcGFyYW1zLmxpbWl0UHJvZ3Jlc3MpLCBwYXJhbXMubGltaXRQcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gJHNsaWRlRWxbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICAgICAgY29uc3QgdCA9IFtzd2lwZXIucGFyYW1zLmNzc01vZGUgPyAtb2Zmc2V0IC0gc3dpcGVyLnRyYW5zbGF0ZSA6IC1vZmZzZXQsIDAsIDBdO1xuICAgICAgICAgIGNvbnN0IHIgPSBbMCwgMCwgMF07XG4gICAgICAgICAgbGV0IGN1c3RvbSA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKCFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgIHRbMV0gPSB0WzBdO1xuICAgICAgICAgICAgdFswXSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICB0cmFuc2xhdGU6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIHJvdGF0ZTogWzAsIDAsIDBdLFxuICAgICAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDApIHtcbiAgICAgICAgICAgIGRhdGEgPSBwYXJhbXMubmV4dDtcbiAgICAgICAgICAgIGN1c3RvbSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcyA+IDApIHtcbiAgICAgICAgICAgIGRhdGEgPSBwYXJhbXMucHJldjtcbiAgICAgICAgICAgIGN1c3RvbSA9IHRydWU7XG4gICAgICAgICAgfSAvLyBzZXQgdHJhbnNsYXRlXG5cblxuICAgICAgICAgIHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB0W2luZGV4XSA9IGBjYWxjKCR7dmFsdWV9cHggKyAoJHtnZXRUcmFuc2xhdGVWYWx1ZShkYXRhLnRyYW5zbGF0ZVtpbmRleF0pfSAqICR7TWF0aC5hYnMocHJvZ3Jlc3MgKiBtdWx0aXBsaWVyKX0pKWA7XG4gICAgICAgICAgfSk7IC8vIHNldCByb3RhdGVzXG5cbiAgICAgICAgICByLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcltpbmRleF0gPSBkYXRhLnJvdGF0ZVtpbmRleF0gKiBNYXRoLmFicyhwcm9ncmVzcyAqIG11bHRpcGxpZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgICRzbGlkZUVsWzBdLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKHNsaWRlUHJvZ3Jlc3MpKSArIHNsaWRlcy5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgdHJhbnNsYXRlU3RyaW5nID0gdC5qb2luKCcsICcpO1xuICAgICAgICAgIGNvbnN0IHJvdGF0ZVN0cmluZyA9IGByb3RhdGVYKCR7clswXX1kZWcpIHJvdGF0ZVkoJHtyWzFdfWRlZykgcm90YXRlWigke3JbMl19ZGVnKWA7XG4gICAgICAgICAgY29uc3Qgc2NhbGVTdHJpbmcgPSBvcmlnaW5hbFByb2dyZXNzIDwgMCA/IGBzY2FsZSgkezEgKyAoMSAtIGRhdGEuc2NhbGUpICogb3JpZ2luYWxQcm9ncmVzcyAqIG11bHRpcGxpZXJ9KWAgOiBgc2NhbGUoJHsxIC0gKDEgLSBkYXRhLnNjYWxlKSAqIG9yaWdpbmFsUHJvZ3Jlc3MgKiBtdWx0aXBsaWVyfSlgO1xuICAgICAgICAgIGNvbnN0IG9wYWNpdHlTdHJpbmcgPSBvcmlnaW5hbFByb2dyZXNzIDwgMCA/IDEgKyAoMSAtIGRhdGEub3BhY2l0eSkgKiBvcmlnaW5hbFByb2dyZXNzICogbXVsdGlwbGllciA6IDEgLSAoMSAtIGRhdGEub3BhY2l0eSkgKiBvcmlnaW5hbFByb2dyZXNzICogbXVsdGlwbGllcjtcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVTdHJpbmd9KSAke3JvdGF0ZVN0cmluZ30gJHtzY2FsZVN0cmluZ31gOyAvLyBTZXQgc2hhZG93c1xuXG4gICAgICAgICAgaWYgKGN1c3RvbSAmJiBkYXRhLnNoYWRvdyB8fCAhY3VzdG9tKSB7XG4gICAgICAgICAgICBsZXQgJHNoYWRvd0VsID0gJHNsaWRlRWwuY2hpbGRyZW4oJy5zd2lwZXItc2xpZGUtc2hhZG93Jyk7XG5cbiAgICAgICAgICAgIGlmICgkc2hhZG93RWwubGVuZ3RoID09PSAwICYmIGRhdGEuc2hhZG93KSB7XG4gICAgICAgICAgICAgICRzaGFkb3dFbCA9IGNyZWF0ZVNoYWRvdyhwYXJhbXMsICRzbGlkZUVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCRzaGFkb3dFbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2hhZG93T3BhY2l0eSA9IHBhcmFtcy5zaGFkb3dQZXJQcm9ncmVzcyA/IHByb2dyZXNzICogKDEgLyBwYXJhbXMubGltaXRQcm9ncmVzcykgOiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgJHNoYWRvd0VsWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyhzaGFkb3dPcGFjaXR5KSwgMCksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0ICR0YXJnZXRFbCA9IGVmZmVjdFRhcmdldChwYXJhbXMsICRzbGlkZUVsKTtcbiAgICAgICAgICAkdGFyZ2V0RWwudHJhbnNmb3JtKHRyYW5zZm9ybSkuY3NzKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlTdHJpbmdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChkYXRhLm9yaWdpbikge1xuICAgICAgICAgICAgJHRhcmdldEVsLmNzcygndHJhbnNmb3JtLW9yaWdpbicsIGRhdGEub3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNldFRyYW5zaXRpb24gPSBkdXJhdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0cmFuc2Zvcm1FbFxuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcy5jcmVhdGl2ZUVmZmVjdDtcbiAgICAgICAgY29uc3QgJHRyYW5zaXRpb25FbGVtZW50cyA9IHRyYW5zZm9ybUVsID8gc3dpcGVyLnNsaWRlcy5maW5kKHRyYW5zZm9ybUVsKSA6IHN3aXBlci5zbGlkZXM7XG4gICAgICAgICR0cmFuc2l0aW9uRWxlbWVudHMudHJhbnNpdGlvbihkdXJhdGlvbikuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3cnKS50cmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgZWZmZWN0VmlydHVhbFRyYW5zaXRpb25FbmQoe1xuICAgICAgICAgIHN3aXBlcixcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICB0cmFuc2Zvcm1FbCxcbiAgICAgICAgICBhbGxTbGlkZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBlZmZlY3RJbml0KHtcbiAgICAgICAgZWZmZWN0OiAnY3JlYXRpdmUnLFxuICAgICAgICBzd2lwZXIsXG4gICAgICAgIG9uLFxuICAgICAgICBzZXRUcmFuc2xhdGUsXG4gICAgICAgIHNldFRyYW5zaXRpb24sXG4gICAgICAgIHBlcnNwZWN0aXZlOiAoKSA9PiBzd2lwZXIucGFyYW1zLmNyZWF0aXZlRWZmZWN0LnBlcnNwZWN0aXZlLFxuICAgICAgICBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7XG4gICAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiAhc3dpcGVyLnBhcmFtcy5jc3NNb2RlXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBFZmZlY3RDYXJkcyh7XG4gICAgICBzd2lwZXIsXG4gICAgICBleHRlbmRQYXJhbXMsXG4gICAgICBvblxuICAgIH0pIHtcbiAgICAgIGV4dGVuZFBhcmFtcyh7XG4gICAgICAgIGNhcmRzRWZmZWN0OiB7XG4gICAgICAgICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxuICAgICAgICAgIHRyYW5zZm9ybUVsOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2xhdGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzbGlkZXMsXG4gICAgICAgICAgYWN0aXZlSW5kZXhcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5jYXJkc0VmZmVjdDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHN0YXJ0VHJhbnNsYXRlLFxuICAgICAgICAgIGlzVG91Y2hlZFxuICAgICAgICB9ID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcbiAgICAgICAgY29uc3QgY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci50cmFuc2xhdGU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zdCAkc2xpZGVFbCA9IHNsaWRlcy5lcShpKTtcbiAgICAgICAgICBjb25zdCBzbGlkZVByb2dyZXNzID0gJHNsaWRlRWxbMF0ucHJvZ3Jlc3M7XG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChzbGlkZVByb2dyZXNzLCAtNCksIDQpO1xuICAgICAgICAgIGxldCBvZmZzZXQgPSAkc2xpZGVFbFswXS5zd2lwZXJTbGlkZU9mZnNldDtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmICFzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsLnRyYW5zZm9ybShgdHJhbnNsYXRlWCgke3N3aXBlci5taW5UcmFuc2xhdGUoKX1weClgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBzbGlkZXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHRYID0gc3dpcGVyLnBhcmFtcy5jc3NNb2RlID8gLW9mZnNldCAtIHN3aXBlci50cmFuc2xhdGUgOiAtb2Zmc2V0O1xuICAgICAgICAgIGxldCB0WSA9IDA7XG4gICAgICAgICAgY29uc3QgdFogPSAtMTAwICogTWF0aC5hYnMocHJvZ3Jlc3MpO1xuICAgICAgICAgIGxldCBzY2FsZSA9IDE7XG4gICAgICAgICAgbGV0IHJvdGF0ZSA9IC0yICogcHJvZ3Jlc3M7XG4gICAgICAgICAgbGV0IHRYQWRkID0gOCAtIE1hdGguYWJzKHByb2dyZXNzKSAqIDAuNzU7XG4gICAgICAgICAgY29uc3QgaXNTd2lwZVRvTmV4dCA9IChpID09PSBhY3RpdmVJbmRleCB8fCBpID09PSBhY3RpdmVJbmRleCAtIDEpICYmIHByb2dyZXNzID4gMCAmJiBwcm9ncmVzcyA8IDEgJiYgKGlzVG91Y2hlZCB8fCBzd2lwZXIucGFyYW1zLmNzc01vZGUpICYmIGN1cnJlbnRUcmFuc2xhdGUgPCBzdGFydFRyYW5zbGF0ZTtcbiAgICAgICAgICBjb25zdCBpc1N3aXBlVG9QcmV2ID0gKGkgPT09IGFjdGl2ZUluZGV4IHx8IGkgPT09IGFjdGl2ZUluZGV4ICsgMSkgJiYgcHJvZ3Jlc3MgPCAwICYmIHByb2dyZXNzID4gLTEgJiYgKGlzVG91Y2hlZCB8fCBzd2lwZXIucGFyYW1zLmNzc01vZGUpICYmIGN1cnJlbnRUcmFuc2xhdGUgPiBzdGFydFRyYW5zbGF0ZTtcblxuICAgICAgICAgIGlmIChpc1N3aXBlVG9OZXh0IHx8IGlzU3dpcGVUb1ByZXYpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YlByb2dyZXNzID0gKDEgLSBNYXRoLmFicygoTWF0aC5hYnMocHJvZ3Jlc3MpIC0gMC41KSAvIDAuNSkpICoqIDAuNTtcbiAgICAgICAgICAgIHJvdGF0ZSArPSAtMjggKiBwcm9ncmVzcyAqIHN1YlByb2dyZXNzO1xuICAgICAgICAgICAgc2NhbGUgKz0gLTAuNSAqIHN1YlByb2dyZXNzO1xuICAgICAgICAgICAgdFhBZGQgKz0gOTYgKiBzdWJQcm9ncmVzcztcbiAgICAgICAgICAgIHRZID0gYCR7LTI1ICogc3ViUHJvZ3Jlc3MgKiBNYXRoLmFicyhwcm9ncmVzcyl9JWA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByb2dyZXNzIDwgMCkge1xuICAgICAgICAgICAgLy8gbmV4dFxuICAgICAgICAgICAgdFggPSBgY2FsYygke3RYfXB4ICsgKCR7dFhBZGQgKiBNYXRoLmFicyhwcm9ncmVzcyl9JSkpYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyZXNzID4gMCkge1xuICAgICAgICAgICAgLy8gcHJldlxuICAgICAgICAgICAgdFggPSBgY2FsYygke3RYfXB4ICsgKC0ke3RYQWRkICogTWF0aC5hYnMocHJvZ3Jlc3MpfSUpKWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRYID0gYCR7dFh9cHhgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2WSA9IHRZO1xuICAgICAgICAgICAgdFkgPSB0WDtcbiAgICAgICAgICAgIHRYID0gcHJldlk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc2NhbGVTdHJpbmcgPSBwcm9ncmVzcyA8IDAgPyBgJHsxICsgKDEgLSBzY2FsZSkgKiBwcm9ncmVzc31gIDogYCR7MSAtICgxIC0gc2NhbGUpICogcHJvZ3Jlc3N9YDtcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgXG4gICAgICAgIHRyYW5zbGF0ZTNkKCR7dFh9LCAke3RZfSwgJHt0Wn1weClcbiAgICAgICAgcm90YXRlWigke3JvdGF0ZX1kZWcpXG4gICAgICAgIHNjYWxlKCR7c2NhbGVTdHJpbmd9KVxuICAgICAgYDtcblxuICAgICAgICAgIGlmIChwYXJhbXMuc2xpZGVTaGFkb3dzKSB7XG4gICAgICAgICAgICAvLyBTZXQgc2hhZG93c1xuICAgICAgICAgICAgbGV0ICRzaGFkb3dFbCA9ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93Jyk7XG5cbiAgICAgICAgICAgIGlmICgkc2hhZG93RWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICRzaGFkb3dFbCA9IGNyZWF0ZVNoYWRvdyhwYXJhbXMsICRzbGlkZUVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCRzaGFkb3dFbC5sZW5ndGgpICRzaGFkb3dFbFswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5taW4oTWF0aC5tYXgoKE1hdGguYWJzKHByb2dyZXNzKSAtIDAuNSkgLyAwLjUsIDApLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkc2xpZGVFbFswXS5zdHlsZS56SW5kZXggPSAtTWF0aC5hYnMoTWF0aC5yb3VuZChzbGlkZVByb2dyZXNzKSkgKyBzbGlkZXMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0ICR0YXJnZXRFbCA9IGVmZmVjdFRhcmdldChwYXJhbXMsICRzbGlkZUVsKTtcbiAgICAgICAgICAkdGFyZ2V0RWwudHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNldFRyYW5zaXRpb24gPSBkdXJhdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0cmFuc2Zvcm1FbFxuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcy5jYXJkc0VmZmVjdDtcbiAgICAgICAgY29uc3QgJHRyYW5zaXRpb25FbGVtZW50cyA9IHRyYW5zZm9ybUVsID8gc3dpcGVyLnNsaWRlcy5maW5kKHRyYW5zZm9ybUVsKSA6IHN3aXBlci5zbGlkZXM7XG4gICAgICAgICR0cmFuc2l0aW9uRWxlbWVudHMudHJhbnNpdGlvbihkdXJhdGlvbikuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3cnKS50cmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgZWZmZWN0VmlydHVhbFRyYW5zaXRpb25FbmQoe1xuICAgICAgICAgIHN3aXBlcixcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICB0cmFuc2Zvcm1FbFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGVmZmVjdEluaXQoe1xuICAgICAgICBlZmZlY3Q6ICdjYXJkcycsXG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgb24sXG4gICAgICAgIHNldFRyYW5zbGF0ZSxcbiAgICAgICAgc2V0VHJhbnNpdGlvbixcbiAgICAgICAgcGVyc3BlY3RpdmU6ICgpID0+IHRydWUsXG4gICAgICAgIG92ZXJ3cml0ZVBhcmFtczogKCkgPT4gKHtcbiAgICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6ICFzd2lwZXIucGFyYW1zLmNzc01vZGVcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN3aXBlciBDbGFzc1xuICAgIGNvbnN0IG1vZHVsZXMgPSBbVmlydHVhbCwgS2V5Ym9hcmQsIE1vdXNld2hlZWwsIE5hdmlnYXRpb24sIFBhZ2luYXRpb24sIFNjcm9sbGJhciwgUGFyYWxsYXgsIFpvb20sIExhenksIENvbnRyb2xsZXIsIEExMXksIEhpc3RvcnksIEhhc2hOYXZpZ2F0aW9uLCBBdXRvcGxheSwgVGh1bWIsIGZyZWVNb2RlLCBHcmlkLCBNYW5pcHVsYXRpb24sIEVmZmVjdEZhZGUsIEVmZmVjdEN1YmUsIEVmZmVjdEZsaXAsIEVmZmVjdENvdmVyZmxvdywgRWZmZWN0Q3JlYXRpdmUsIEVmZmVjdENhcmRzXTtcbiAgICBTd2lwZXIudXNlKG1vZHVsZXMpO1xuXG4gICAgcmV0dXJuIFN3aXBlcjtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXBlci1idW5kbGUuanMubWFwXG4iLCIodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIikgJiYgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnkocm9vdCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb3R0aWUgPSBmYWN0b3J5KHJvb3QpO1xuICAgICAgICByb290LmJvZHltb3ZpbiA9IHJvb3QubG90dGllO1xuICAgIH1cbn0oKHdpbmRvdyB8fCB7fSksIGZ1bmN0aW9uKHdpbmRvdykge1xuXHQvKiBnbG9iYWwgbG9jYXRpb25IcmVmOndyaXRhYmxlLCBhbmltYXRpb25NYW5hZ2VyLCBzdWJmcmFtZUVuYWJsZWQ6d3JpdGFibGUsIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzOndyaXRhYmxlLCByb3VuZFZhbHVlcyxcclxuZXhwcmVzc2lvbnNQbHVnaW46d3JpdGFibGUsIFByb3BlcnR5RmFjdG9yeSwgU2hhcGVQcm9wZXJ0eUZhY3RvcnksIE1hdHJpeCwgaWRQcmVmaXg6d3JpdGFibGUgKi9cclxuLyogZXhwb3J0ZWQgbG9jYXRpb25IcmVmLCBzdWJmcmFtZUVuYWJsZWQsIGV4cHJlc3Npb25zUGx1Z2luLCBpZFByZWZpeCAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogZXhwb3J0ZWQgc3ZnTlMsIGxvY2F0aW9uSHJlZiwgaW5pdGlhbERlZmF1bHRGcmFtZSAqL1xyXG5cclxudmFyIHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuXHJcbnZhciBsb2NhdGlvbkhyZWYgPSAnJztcclxuXHJcbnZhciBpbml0aWFsRGVmYXVsdEZyYW1lID0gLTk5OTk5OTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5ICovXHJcbi8qIGV4cG9ydGVkIHN1YmZyYW1lRW5hYmxlZCwgZXhwcmVzc2lvbnNQbHVnaW4sIGlzU2FmYXJpLCBjYWNoZWRDb2xvcnMsIGJtUG93LCBibVNxcnQsIGJtRmxvb3IsIGJtTWF4LCBibU1pbiwgUHJvamVjdEludGVyZmFjZSxcclxuZGVmYXVsdEN1cnZlU2VnbWVudHMsIGRlZ1RvUmFkcywgcm91bmRDb3JuZXIsIGJtUm5kLCBzdHlsZURpdiwgQk1FbnRlckZyYW1lRXZlbnQsIEJNQ29tcGxldGVFdmVudCwgQk1Db21wbGV0ZUxvb3BFdmVudCxcclxuQk1TZWdtZW50U3RhcnRFdmVudCwgQk1EZXN0cm95RXZlbnQsIEJNUmVuZGVyRnJhbWVFcnJvckV2ZW50LCBCTUNvbmZpZ0Vycm9yRXZlbnQsIEJNQW5pbWF0aW9uQ29uZmlnRXJyb3JFdmVudCwgY3JlYXRlRWxlbWVudElELFxyXG5hZGRTYXR1cmF0aW9uVG9SR0IsIGFkZEJyaWdodG5lc3NUb1JHQiwgYWRkSHVlVG9SR0IsIHJnYlRvSGV4ICovXHJcblxyXG52YXIgc3ViZnJhbWVFbmFibGVkID0gdHJ1ZTtcclxudmFyIGlkUHJlZml4ID0gJyc7XHJcbnZhciBleHByZXNzaW9uc1BsdWdpbjtcclxudmFyIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxudmFyIGNhY2hlZENvbG9ycyA9IHt9O1xyXG52YXIgYm1SbmQ7XHJcbnZhciBibVBvdyA9IE1hdGgucG93O1xyXG52YXIgYm1TcXJ0ID0gTWF0aC5zcXJ0O1xyXG52YXIgYm1GbG9vciA9IE1hdGguZmxvb3I7XHJcbnZhciBibU1heCA9IE1hdGgubWF4O1xyXG52YXIgYm1NaW4gPSBNYXRoLm1pbjtcclxuXHJcbnZhciBCTU1hdGggPSB7fTtcclxuKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHJvcGVydHlOYW1lcyA9IFsnYWJzJywgJ2Fjb3MnLCAnYWNvc2gnLCAnYXNpbicsICdhc2luaCcsICdhdGFuJywgJ2F0YW5oJywgJ2F0YW4yJywgJ2NlaWwnLCAnY2JydCcsICdleHBtMScsICdjbHozMicsICdjb3MnLCAnY29zaCcsICdleHAnLCAnZmxvb3InLCAnZnJvdW5kJywgJ2h5cG90JywgJ2ltdWwnLCAnbG9nJywgJ2xvZzFwJywgJ2xvZzInLCAnbG9nMTAnLCAnbWF4JywgJ21pbicsICdwb3cnLCAncmFuZG9tJywgJ3JvdW5kJywgJ3NpZ24nLCAnc2luJywgJ3NpbmgnLCAnc3FydCcsICd0YW4nLCAndGFuaCcsICd0cnVuYycsICdFJywgJ0xOMTAnLCAnTE4yJywgJ0xPRzEwRScsICdMT0cyRScsICdQSScsICdTUVJUMV8yJywgJ1NRUlQyJ107XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgQk1NYXRoW3Byb3BlcnR5TmFtZXNbaV1dID0gTWF0aFtwcm9wZXJ0eU5hbWVzW2ldXTtcclxuICB9XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiBQcm9qZWN0SW50ZXJmYWNlKCkgeyByZXR1cm4ge307IH1cclxuXHJcbkJNTWF0aC5yYW5kb20gPSBNYXRoLnJhbmRvbTtcclxuQk1NYXRoLmFicyA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICB2YXIgdE9mVmFsID0gdHlwZW9mIHZhbDtcclxuICBpZiAodE9mVmFsID09PSAnb2JqZWN0JyAmJiB2YWwubGVuZ3RoKSB7XHJcbiAgICB2YXIgYWJzQXJyID0gY3JlYXRlU2l6ZWRBcnJheSh2YWwubGVuZ3RoKTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgYWJzQXJyW2ldID0gTWF0aC5hYnModmFsW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhYnNBcnI7XHJcbiAgfVxyXG4gIHJldHVybiBNYXRoLmFicyh2YWwpO1xyXG59O1xyXG52YXIgZGVmYXVsdEN1cnZlU2VnbWVudHMgPSAxNTA7XHJcbnZhciBkZWdUb1JhZHMgPSBNYXRoLlBJIC8gMTgwO1xyXG52YXIgcm91bmRDb3JuZXIgPSAwLjU1MTk7XHJcblxyXG5mdW5jdGlvbiByb3VuZFZhbHVlcyhmbGFnKSB7XHJcbiAgaWYgKGZsYWcpIHtcclxuICAgIGJtUm5kID0gTWF0aC5yb3VuZDtcclxuICB9IGVsc2Uge1xyXG4gICAgYm1SbmQgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5yb3VuZFZhbHVlcyhmYWxzZSk7XHJcblxyXG5mdW5jdGlvbiBzdHlsZURpdihlbGVtZW50KSB7XHJcbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgZWxlbWVudC5zdHlsZS50b3AgPSAwO1xyXG4gIGVsZW1lbnQuc3R5bGUubGVmdCA9IDA7XHJcbiAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xyXG4gIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gJzAgMCc7XHJcbiAgZWxlbWVudC5zdHlsZS5iYWNrZmFjZVZpc2liaWxpdHkgPSAndmlzaWJsZSc7XHJcbiAgZWxlbWVudC5zdHlsZS53ZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAndmlzaWJsZSc7XHJcbiAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XHJcbiAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XHJcbiAgZWxlbWVudC5zdHlsZS5tb3pUcmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJNRW50ZXJGcmFtZUV2ZW50KHR5cGUsIGN1cnJlbnRUaW1lLCB0b3RhbFRpbWUsIGZyYW1lTXVsdGlwbGllcikge1xyXG4gIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgdGhpcy5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gIHRoaXMudG90YWxUaW1lID0gdG90YWxUaW1lO1xyXG4gIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcclxufVxyXG5cclxuZnVuY3Rpb24gQk1Db21wbGV0ZUV2ZW50KHR5cGUsIGZyYW1lTXVsdGlwbGllcikge1xyXG4gIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgdGhpcy5kaXJlY3Rpb24gPSBmcmFtZU11bHRpcGxpZXIgPCAwID8gLTEgOiAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCTUNvbXBsZXRlTG9vcEV2ZW50KHR5cGUsIHRvdGFsTG9vcHMsIGN1cnJlbnRMb29wLCBmcmFtZU11bHRpcGxpZXIpIHtcclxuICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gIHRoaXMuY3VycmVudExvb3AgPSBjdXJyZW50TG9vcDtcclxuICB0aGlzLnRvdGFsTG9vcHMgPSB0b3RhbExvb3BzO1xyXG4gIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcclxufVxyXG5cclxuZnVuY3Rpb24gQk1TZWdtZW50U3RhcnRFdmVudCh0eXBlLCBmaXJzdEZyYW1lLCB0b3RhbEZyYW1lcykge1xyXG4gIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgdGhpcy5maXJzdEZyYW1lID0gZmlyc3RGcmFtZTtcclxuICB0aGlzLnRvdGFsRnJhbWVzID0gdG90YWxGcmFtZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJNRGVzdHJveUV2ZW50KHR5cGUsIHRhcmdldCkge1xyXG4gIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJNUmVuZGVyRnJhbWVFcnJvckV2ZW50KG5hdGl2ZUVycm9yLCBjdXJyZW50VGltZSkge1xyXG4gIHRoaXMudHlwZSA9ICdyZW5kZXJGcmFtZUVycm9yJztcclxuICB0aGlzLm5hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XHJcbiAgdGhpcy5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCTUNvbmZpZ0Vycm9yRXZlbnQobmF0aXZlRXJyb3IpIHtcclxuICB0aGlzLnR5cGUgPSAnY29uZmlnRXJyb3InO1xyXG4gIHRoaXMubmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcclxufVxyXG5cclxuZnVuY3Rpb24gQk1BbmltYXRpb25Db25maWdFcnJvckV2ZW50KHR5cGUsIG5hdGl2ZUVycm9yKSB7XHJcbiAgdGhpcy50eXBlID0gdHlwZTtcclxuICB0aGlzLm5hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XHJcbn1cclxuXHJcbnZhciBjcmVhdGVFbGVtZW50SUQgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBfY291bnQgPSAwO1xyXG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVJRCgpIHtcclxuICAgIF9jb3VudCArPSAxO1xyXG4gICAgcmV0dXJuIGlkUHJlZml4ICsgJ19fbG90dGllX2VsZW1lbnRfJyArIF9jb3VudDtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuZnVuY3Rpb24gSFNWdG9SR0IoaCwgcywgdikge1xyXG4gIHZhciByO1xyXG4gIHZhciBnO1xyXG4gIHZhciBiO1xyXG4gIHZhciBpO1xyXG4gIHZhciBmO1xyXG4gIHZhciBwO1xyXG4gIHZhciBxO1xyXG4gIHZhciB0O1xyXG4gIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcclxuICBmID0gaCAqIDYgLSBpO1xyXG4gIHAgPSB2ICogKDEgLSBzKTtcclxuICBxID0gdiAqICgxIC0gZiAqIHMpO1xyXG4gIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XHJcbiAgc3dpdGNoIChpICUgNikge1xyXG4gICAgY2FzZSAwOiByID0gdjsgZyA9IHQ7IGIgPSBwOyBicmVhaztcclxuICAgIGNhc2UgMTogciA9IHE7IGcgPSB2OyBiID0gcDsgYnJlYWs7XHJcbiAgICBjYXNlIDI6IHIgPSBwOyBnID0gdjsgYiA9IHQ7IGJyZWFrO1xyXG4gICAgY2FzZSAzOiByID0gcDsgZyA9IHE7IGIgPSB2OyBicmVhaztcclxuICAgIGNhc2UgNDogciA9IHQ7IGcgPSBwOyBiID0gdjsgYnJlYWs7XHJcbiAgICBjYXNlIDU6IHIgPSB2OyBnID0gcDsgYiA9IHE7IGJyZWFrO1xyXG4gICAgZGVmYXVsdDogYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiBbcixcclxuICAgIGcsXHJcbiAgICBiXTtcclxufVxyXG5cclxuZnVuY3Rpb24gUkdCdG9IU1YociwgZywgYikge1xyXG4gIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcclxuICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XHJcbiAgdmFyIGQgPSBtYXggLSBtaW47XHJcbiAgdmFyIGg7XHJcbiAgdmFyIHMgPSAobWF4ID09PSAwID8gMCA6IGQgLyBtYXgpO1xyXG4gIHZhciB2ID0gbWF4IC8gMjU1O1xyXG5cclxuICBzd2l0Y2ggKG1heCkge1xyXG4gICAgY2FzZSBtaW46IGggPSAwOyBicmVhaztcclxuICAgIGNhc2UgcjogaCA9IChnIC0gYikgKyBkICogKGcgPCBiID8gNiA6IDApOyBoIC89IDYgKiBkOyBicmVhaztcclxuICAgIGNhc2UgZzogaCA9IChiIC0gcikgKyBkICogMjsgaCAvPSA2ICogZDsgYnJlYWs7XHJcbiAgICBjYXNlIGI6IGggPSAociAtIGcpICsgZCAqIDQ7IGggLz0gNiAqIGQ7IGJyZWFrO1xyXG4gICAgZGVmYXVsdDogYnJlYWs7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gW1xyXG4gICAgaCxcclxuICAgIHMsXHJcbiAgICB2LFxyXG4gIF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFNhdHVyYXRpb25Ub1JHQihjb2xvciwgb2Zmc2V0KSB7XHJcbiAgdmFyIGhzdiA9IFJHQnRvSFNWKGNvbG9yWzBdICogMjU1LCBjb2xvclsxXSAqIDI1NSwgY29sb3JbMl0gKiAyNTUpO1xyXG4gIGhzdlsxXSArPSBvZmZzZXQ7XHJcbiAgaWYgKGhzdlsxXSA+IDEpIHtcclxuICAgIGhzdlsxXSA9IDE7XHJcbiAgfSBlbHNlIGlmIChoc3ZbMV0gPD0gMCkge1xyXG4gICAgaHN2WzFdID0gMDtcclxuICB9XHJcbiAgcmV0dXJuIEhTVnRvUkdCKGhzdlswXSwgaHN2WzFdLCBoc3ZbMl0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRCcmlnaHRuZXNzVG9SR0IoY29sb3IsIG9mZnNldCkge1xyXG4gIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcclxuICBoc3ZbMl0gKz0gb2Zmc2V0O1xyXG4gIGlmIChoc3ZbMl0gPiAxKSB7XHJcbiAgICBoc3ZbMl0gPSAxO1xyXG4gIH0gZWxzZSBpZiAoaHN2WzJdIDwgMCkge1xyXG4gICAgaHN2WzJdID0gMDtcclxuICB9XHJcbiAgcmV0dXJuIEhTVnRvUkdCKGhzdlswXSwgaHN2WzFdLCBoc3ZbMl0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRIdWVUb1JHQihjb2xvciwgb2Zmc2V0KSB7XHJcbiAgdmFyIGhzdiA9IFJHQnRvSFNWKGNvbG9yWzBdICogMjU1LCBjb2xvclsxXSAqIDI1NSwgY29sb3JbMl0gKiAyNTUpO1xyXG4gIGhzdlswXSArPSBvZmZzZXQgLyAzNjA7XHJcbiAgaWYgKGhzdlswXSA+IDEpIHtcclxuICAgIGhzdlswXSAtPSAxO1xyXG4gIH0gZWxzZSBpZiAoaHN2WzBdIDwgMCkge1xyXG4gICAgaHN2WzBdICs9IDE7XHJcbiAgfVxyXG4gIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcclxufVxyXG5cclxudmFyIHJnYlRvSGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY29sb3JNYXAgPSBbXTtcclxuICB2YXIgaTtcclxuICB2YXIgaGV4O1xyXG4gIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkgKz0gMSkge1xyXG4gICAgaGV4ID0gaS50b1N0cmluZygxNik7XHJcbiAgICBjb2xvck1hcFtpXSA9IGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKHIsIGcsIGIpIHtcclxuICAgIGlmIChyIDwgMCkge1xyXG4gICAgICByID0gMDtcclxuICAgIH1cclxuICAgIGlmIChnIDwgMCkge1xyXG4gICAgICBnID0gMDtcclxuICAgIH1cclxuICAgIGlmIChiIDwgMCkge1xyXG4gICAgICBiID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiAnIycgKyBjb2xvck1hcFtyXSArIGNvbG9yTWFwW2ddICsgY29sb3JNYXBbYl07XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIEJhc2VFdmVudCgpIHt9XHJcbkJhc2VFdmVudC5wcm90b3R5cGUgPSB7XHJcbiAgdHJpZ2dlckV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lLCBhcmdzKSB7XHJcbiAgICBpZiAodGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2Nic1tldmVudE5hbWVdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIGNhbGxiYWNrc1tpXShhcmdzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcclxuICAgIGlmICghdGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0gPSBbXTtcclxuICAgIH1cclxuICAgIHRoaXMuX2Nic1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICB9LFxyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdID0gbnVsbDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy5fY2JzW2V2ZW50TmFtZV0ubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYnNbZXZlbnROYW1lXVtpXSA9PT0gY2FsbGJhY2spIHtcclxuICAgICAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIGkgLT0gMTtcclxuICAgICAgICAgIGxlbiAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLl9jYnNbZXZlbnROYW1lXS5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG59O1xyXG5cclxuLyogZXhwb3J0ZWQgY3JlYXRlVHlwZWRBcnJheSwgY3JlYXRlU2l6ZWRBcnJheSAqL1xyXG5cclxudmFyIGNyZWF0ZVR5cGVkQXJyYXkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZ3VsYXJBcnJheSh0eXBlLCBsZW4pIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBhcnIgPSBbXTtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlICdpbnQxNic6XHJcbiAgICAgIGNhc2UgJ3VpbnQ4Yyc6XHJcbiAgICAgICAgdmFsdWUgPSAxO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHZhbHVlID0gMS4xO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGFyci5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNyZWF0ZVR5cGVkQXJyYXlGYWN0b3J5KHR5cGUsIGxlbikge1xyXG4gICAgaWYgKHR5cGUgPT09ICdmbG9hdDMyJykge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xyXG4gICAgfSBpZiAodHlwZSA9PT0gJ2ludDE2Jykge1xyXG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkobGVuKTtcclxuICAgIH0gaWYgKHR5cGUgPT09ICd1aW50OGMnKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkobGVuKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWd1bGFyQXJyYXkodHlwZSwgbGVuKTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlVHlwZWRBcnJheUZhY3Rvcnk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVSZWd1bGFyQXJyYXk7XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTaXplZEFycmF5KGxlbikge1xyXG4gIHJldHVybiBBcnJheS5hcHBseShudWxsLCB7IGxlbmd0aDogbGVuIH0pO1xyXG59XHJcblxyXG4vKiBnbG9iYWwgc3ZnTlMgKi9cclxuLyogZXhwb3J0ZWQgY3JlYXRlTlMgKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU5TKHR5cGUpIHtcclxuICAvLyByZXR1cm4ge2FwcGVuZENoaWxkOmZ1bmN0aW9uKCl7fSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oKXt9LHN0eWxlOnt9fVxyXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHR5cGUpO1xyXG59XHJcblxyXG4vKiBleHBvcnRlZCBjcmVhdGVUYWcgKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRhZyh0eXBlKSB7XHJcbiAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cclxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKCkge31cclxuRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyLnByb3RvdHlwZSA9IHtcclxuICBhZGREeW5hbWljUHJvcGVydHk6IGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xyXG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxuICAgICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfSxcclxuICBpdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5nZXRWYWx1ZSgpO1xyXG4gICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5fbWRmKSB7XHJcbiAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xyXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XHJcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSBmYWxzZTtcclxuICB9LFxyXG59O1xyXG5cclxuLyogZXhwb3J0ZWQgZ2V0QmxlbmRNb2RlICovXHJcblxyXG52YXIgZ2V0QmxlbmRNb2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgYmxlbmRNb2RlRW51bXMgPSB7XHJcbiAgICAwOiAnc291cmNlLW92ZXInLFxyXG4gICAgMTogJ211bHRpcGx5JyxcclxuICAgIDI6ICdzY3JlZW4nLFxyXG4gICAgMzogJ292ZXJsYXknLFxyXG4gICAgNDogJ2RhcmtlbicsXHJcbiAgICA1OiAnbGlnaHRlbicsXHJcbiAgICA2OiAnY29sb3ItZG9kZ2UnLFxyXG4gICAgNzogJ2NvbG9yLWJ1cm4nLFxyXG4gICAgODogJ2hhcmQtbGlnaHQnLFxyXG4gICAgOTogJ3NvZnQtbGlnaHQnLFxyXG4gICAgMTA6ICdkaWZmZXJlbmNlJyxcclxuICAgIDExOiAnZXhjbHVzaW9uJyxcclxuICAgIDEyOiAnaHVlJyxcclxuICAgIDEzOiAnc2F0dXJhdGlvbicsXHJcbiAgICAxNDogJ2NvbG9yJyxcclxuICAgIDE1OiAnbHVtaW5vc2l0eScsXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChtb2RlKSB7XHJcbiAgICByZXR1cm4gYmxlbmRNb2RlRW51bXNbbW9kZV0gfHwgJyc7XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGV4cG9ydGVkIGxpbmVDYXBFbnVtLCBsaW5lSm9pbkVudW0gKi9cclxuXHJcbnZhciBsaW5lQ2FwRW51bSA9IHtcclxuICAxOiAnYnV0dCcsXHJcbiAgMjogJ3JvdW5kJyxcclxuICAzOiAnc3F1YXJlJyxcclxufTtcclxuXHJcbnZhciBsaW5lSm9pbkVudW0gPSB7XHJcbiAgMTogJ21pdGVyJyxcclxuICAyOiAncm91bmQnLFxyXG4gIDM6ICdiZXZlbCcsXHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlVHlwZWRBcnJheSAqL1xyXG5cclxuLyohXHJcbiBUcmFuc2Zvcm1hdGlvbiBNYXRyaXggdjIuMFxyXG4gKGMpIEVwaXN0ZW1leCAyMDE0LTIwMTVcclxuIHd3dy5lcGlzdGVtZXguY29tXHJcbiBCeSBLZW4gRnlyc3RlbmJlcmdcclxuIENvbnRyaWJ1dGlvbnMgYnkgbGVlb25peWEuXHJcbiBMaWNlbnNlOiBNSVQsIGhlYWRlciByZXF1aXJlZC5cclxuICovXHJcblxyXG4vKipcclxuICogMkQgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9iamVjdCBpbml0aWFsaXplZCB3aXRoIGlkZW50aXR5IG1hdHJpeC5cclxuICpcclxuICogVGhlIG1hdHJpeCBjYW4gc3luY2hyb25pemUgYSBjYW52YXMgY29udGV4dCBieSBzdXBwbHlpbmcgdGhlIGNvbnRleHRcclxuICogYXMgYW4gYXJndW1lbnQsIG9yIGxhdGVyIGFwcGx5IGN1cnJlbnQgYWJzb2x1dGUgdHJhbnNmb3JtIHRvIGFuXHJcbiAqIGV4aXN0aW5nIGNvbnRleHQuXHJcbiAqXHJcbiAqIEFsbCB2YWx1ZXMgYXJlIGhhbmRsZWQgYXMgZmxvYXRpbmcgcG9pbnQgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW2NvbnRleHRdIC0gT3B0aW9uYWwgY29udGV4dCB0byBzeW5jIHdpdGggTWF0cml4XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGEgLSBzY2FsZSB4XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGIgLSBzaGVhciB5XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGMgLSBzaGVhciB4XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGQgLSBzY2FsZSB5XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGUgLSB0cmFuc2xhdGUgeFxyXG4gKiBAcHJvcCB7bnVtYmVyfSBmIC0gdHJhbnNsYXRlIHlcclxuICogQHByb3Age0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBbY29udGV4dD1udWxsXSAtIHNldCBvciBnZXQgY3VycmVudCBjYW52YXMgY29udGV4dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcblxyXG52YXIgTWF0cml4ID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX2NvcyA9IE1hdGguY29zO1xyXG4gIHZhciBfc2luID0gTWF0aC5zaW47XHJcbiAgdmFyIF90YW4gPSBNYXRoLnRhbjtcclxuICB2YXIgX3JuZCA9IE1hdGgucm91bmQ7XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gICAgdGhpcy5wcm9wc1swXSA9IDE7XHJcbiAgICB0aGlzLnByb3BzWzFdID0gMDtcclxuICAgIHRoaXMucHJvcHNbMl0gPSAwO1xyXG4gICAgdGhpcy5wcm9wc1szXSA9IDA7XHJcbiAgICB0aGlzLnByb3BzWzRdID0gMDtcclxuICAgIHRoaXMucHJvcHNbNV0gPSAxO1xyXG4gICAgdGhpcy5wcm9wc1s2XSA9IDA7XHJcbiAgICB0aGlzLnByb3BzWzddID0gMDtcclxuICAgIHRoaXMucHJvcHNbOF0gPSAwO1xyXG4gICAgdGhpcy5wcm9wc1s5XSA9IDA7XHJcbiAgICB0aGlzLnByb3BzWzEwXSA9IDE7XHJcbiAgICB0aGlzLnByb3BzWzExXSA9IDA7XHJcbiAgICB0aGlzLnByb3BzWzEyXSA9IDA7XHJcbiAgICB0aGlzLnByb3BzWzEzXSA9IDA7XHJcbiAgICB0aGlzLnByb3BzWzE0XSA9IDA7XHJcbiAgICB0aGlzLnByb3BzWzE1XSA9IDE7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJvdGF0ZShhbmdsZSkge1xyXG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcclxuICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XHJcbiAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByb3RhdGVYKGFuZ2xlKSB7XHJcbiAgICBpZiAoYW5nbGUgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xyXG4gICAgdmFyIG1TaW4gPSBfc2luKGFuZ2xlKTtcclxuICAgIHJldHVybiB0aGlzLl90KDEsIDAsIDAsIDAsIDAsIG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJvdGF0ZVkoYW5nbGUpIHtcclxuICAgIGlmIChhbmdsZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XHJcbiAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3QobUNvcywgMCwgbVNpbiwgMCwgMCwgMSwgMCwgMCwgLW1TaW4sIDAsIG1Db3MsIDAsIDAsIDAsIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcm90YXRlWihhbmdsZSkge1xyXG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcclxuICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XHJcbiAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzaGVhcihzeCwgc3kpIHtcclxuICAgIHJldHVybiB0aGlzLl90KDEsIHN5LCBzeCwgMSwgMCwgMCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBza2V3KGF4LCBheSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2hlYXIoX3RhbihheCksIF90YW4oYXkpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNrZXdGcm9tQXhpcyhheCwgYW5nbGUpIHtcclxuICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XHJcbiAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3QobUNvcywgbVNpbiwgMCwgMCwgLW1TaW4sIG1Db3MsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXHJcbiAgICAgIC5fdCgxLCAwLCAwLCAwLCBfdGFuKGF4KSwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcclxuICAgICAgLl90KG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKTtcclxuICAgIC8vIHJldHVybiB0aGlzLl90KG1Db3MsIG1TaW4sIC1tU2luLCBtQ29zLCAwLCAwKS5fdCgxLCAwLCBfdGFuKGF4KSwgMSwgMCwgMCkuX3QobUNvcywgLW1TaW4sIG1TaW4sIG1Db3MsIDAsIDApO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NhbGUoc3gsIHN5LCBzeikge1xyXG4gICAgaWYgKCFzeiAmJiBzeiAhPT0gMCkge1xyXG4gICAgICBzeiA9IDE7XHJcbiAgICB9XHJcbiAgICBpZiAoc3ggPT09IDEgJiYgc3kgPT09IDEgJiYgc3ogPT09IDEpIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fdChzeCwgMCwgMCwgMCwgMCwgc3ksIDAsIDAsIDAsIDAsIHN6LCAwLCAwLCAwLCAwLCAxKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvLCBwKSB7XHJcbiAgICB0aGlzLnByb3BzWzBdID0gYTtcclxuICAgIHRoaXMucHJvcHNbMV0gPSBiO1xyXG4gICAgdGhpcy5wcm9wc1syXSA9IGM7XHJcbiAgICB0aGlzLnByb3BzWzNdID0gZDtcclxuICAgIHRoaXMucHJvcHNbNF0gPSBlO1xyXG4gICAgdGhpcy5wcm9wc1s1XSA9IGY7XHJcbiAgICB0aGlzLnByb3BzWzZdID0gZztcclxuICAgIHRoaXMucHJvcHNbN10gPSBoO1xyXG4gICAgdGhpcy5wcm9wc1s4XSA9IGk7XHJcbiAgICB0aGlzLnByb3BzWzldID0gajtcclxuICAgIHRoaXMucHJvcHNbMTBdID0gaztcclxuICAgIHRoaXMucHJvcHNbMTFdID0gbDtcclxuICAgIHRoaXMucHJvcHNbMTJdID0gbTtcclxuICAgIHRoaXMucHJvcHNbMTNdID0gbjtcclxuICAgIHRoaXMucHJvcHNbMTRdID0gbztcclxuICAgIHRoaXMucHJvcHNbMTVdID0gcDtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHR4LCB0eSwgdHopIHtcclxuICAgIHR6ID0gdHogfHwgMDtcclxuICAgIGlmICh0eCAhPT0gMCB8fCB0eSAhPT0gMCB8fCB0eiAhPT0gMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCB0eCwgdHksIHR6LCAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdHJhbnNmb3JtKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsIGcyLCBoMiwgaTIsIGoyLCBrMiwgbDIsIG0yLCBuMiwgbzIsIHAyKSB7XHJcbiAgICB2YXIgX3AgPSB0aGlzLnByb3BzO1xyXG5cclxuICAgIGlmIChhMiA9PT0gMSAmJiBiMiA9PT0gMCAmJiBjMiA9PT0gMCAmJiBkMiA9PT0gMCAmJiBlMiA9PT0gMCAmJiBmMiA9PT0gMSAmJiBnMiA9PT0gMCAmJiBoMiA9PT0gMCAmJiBpMiA9PT0gMCAmJiBqMiA9PT0gMCAmJiBrMiA9PT0gMSAmJiBsMiA9PT0gMCkge1xyXG4gICAgICAvLyBOT1RFOiBjb21tZW50aW5nIHRoaXMgY29uZGl0aW9uIGJlY2F1c2UgVHVyYm9GYW4gZGVvcHRpbWl6ZXMgY29kZSB3aGVuIHByZXNlbnRcclxuICAgICAgLy8gaWYobTIgIT09IDAgfHwgbjIgIT09IDAgfHwgbzIgIT09IDApe1xyXG4gICAgICBfcFsxMl0gPSBfcFsxMl0gKiBhMiArIF9wWzE1XSAqIG0yO1xyXG4gICAgICBfcFsxM10gPSBfcFsxM10gKiBmMiArIF9wWzE1XSAqIG4yO1xyXG4gICAgICBfcFsxNF0gPSBfcFsxNF0gKiBrMiArIF9wWzE1XSAqIG8yO1xyXG4gICAgICBfcFsxNV0gKj0gcDI7XHJcbiAgICAgIC8vIH1cclxuICAgICAgdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhMSA9IF9wWzBdO1xyXG4gICAgdmFyIGIxID0gX3BbMV07XHJcbiAgICB2YXIgYzEgPSBfcFsyXTtcclxuICAgIHZhciBkMSA9IF9wWzNdO1xyXG4gICAgdmFyIGUxID0gX3BbNF07XHJcbiAgICB2YXIgZjEgPSBfcFs1XTtcclxuICAgIHZhciBnMSA9IF9wWzZdO1xyXG4gICAgdmFyIGgxID0gX3BbN107XHJcbiAgICB2YXIgaTEgPSBfcFs4XTtcclxuICAgIHZhciBqMSA9IF9wWzldO1xyXG4gICAgdmFyIGsxID0gX3BbMTBdO1xyXG4gICAgdmFyIGwxID0gX3BbMTFdO1xyXG4gICAgdmFyIG0xID0gX3BbMTJdO1xyXG4gICAgdmFyIG4xID0gX3BbMTNdO1xyXG4gICAgdmFyIG8xID0gX3BbMTRdO1xyXG4gICAgdmFyIHAxID0gX3BbMTVdO1xyXG5cclxuICAgIC8qIG1hdHJpeCBvcmRlciAoY2FudmFzIGNvbXBhdGlibGUpOlxyXG4gICAgICAgICAqIGFjZVxyXG4gICAgICAgICAqIGJkZlxyXG4gICAgICAgICAqIDAwMVxyXG4gICAgICAgICAqL1xyXG4gICAgX3BbMF0gPSBhMSAqIGEyICsgYjEgKiBlMiArIGMxICogaTIgKyBkMSAqIG0yO1xyXG4gICAgX3BbMV0gPSBhMSAqIGIyICsgYjEgKiBmMiArIGMxICogajIgKyBkMSAqIG4yO1xyXG4gICAgX3BbMl0gPSBhMSAqIGMyICsgYjEgKiBnMiArIGMxICogazIgKyBkMSAqIG8yO1xyXG4gICAgX3BbM10gPSBhMSAqIGQyICsgYjEgKiBoMiArIGMxICogbDIgKyBkMSAqIHAyO1xyXG5cclxuICAgIF9wWzRdID0gZTEgKiBhMiArIGYxICogZTIgKyBnMSAqIGkyICsgaDEgKiBtMjtcclxuICAgIF9wWzVdID0gZTEgKiBiMiArIGYxICogZjIgKyBnMSAqIGoyICsgaDEgKiBuMjtcclxuICAgIF9wWzZdID0gZTEgKiBjMiArIGYxICogZzIgKyBnMSAqIGsyICsgaDEgKiBvMjtcclxuICAgIF9wWzddID0gZTEgKiBkMiArIGYxICogaDIgKyBnMSAqIGwyICsgaDEgKiBwMjtcclxuXHJcbiAgICBfcFs4XSA9IGkxICogYTIgKyBqMSAqIGUyICsgazEgKiBpMiArIGwxICogbTI7XHJcbiAgICBfcFs5XSA9IGkxICogYjIgKyBqMSAqIGYyICsgazEgKiBqMiArIGwxICogbjI7XHJcbiAgICBfcFsxMF0gPSBpMSAqIGMyICsgajEgKiBnMiArIGsxICogazIgKyBsMSAqIG8yO1xyXG4gICAgX3BbMTFdID0gaTEgKiBkMiArIGoxICogaDIgKyBrMSAqIGwyICsgbDEgKiBwMjtcclxuXHJcbiAgICBfcFsxMl0gPSBtMSAqIGEyICsgbjEgKiBlMiArIG8xICogaTIgKyBwMSAqIG0yO1xyXG4gICAgX3BbMTNdID0gbTEgKiBiMiArIG4xICogZjIgKyBvMSAqIGoyICsgcDEgKiBuMjtcclxuICAgIF9wWzE0XSA9IG0xICogYzIgKyBuMSAqIGcyICsgbzEgKiBrMiArIHAxICogbzI7XHJcbiAgICBfcFsxNV0gPSBtMSAqIGQyICsgbjEgKiBoMiArIG8xICogbDIgKyBwMSAqIHAyO1xyXG5cclxuICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0lkZW50aXR5KCkge1xyXG4gICAgaWYgKCF0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQpIHtcclxuICAgICAgdGhpcy5faWRlbnRpdHkgPSAhKHRoaXMucHJvcHNbMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxXSAhPT0gMCB8fCB0aGlzLnByb3BzWzJdICE9PSAwIHx8IHRoaXMucHJvcHNbM10gIT09IDAgfHwgdGhpcy5wcm9wc1s0XSAhPT0gMCB8fCB0aGlzLnByb3BzWzVdICE9PSAxIHx8IHRoaXMucHJvcHNbNl0gIT09IDAgfHwgdGhpcy5wcm9wc1s3XSAhPT0gMCB8fCB0aGlzLnByb3BzWzhdICE9PSAwIHx8IHRoaXMucHJvcHNbOV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxMV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMl0gIT09IDAgfHwgdGhpcy5wcm9wc1sxM10gIT09IDAgfHwgdGhpcy5wcm9wc1sxNF0gIT09IDAgfHwgdGhpcy5wcm9wc1sxNV0gIT09IDEpO1xyXG4gICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2lkZW50aXR5O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXF1YWxzKG1hdHIpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgMTYpIHtcclxuICAgICAgaWYgKG1hdHIucHJvcHNbaV0gIT09IHRoaXMucHJvcHNbaV0pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbG9uZShtYXRyKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XHJcbiAgICAgIG1hdHIucHJvcHNbaV0gPSB0aGlzLnByb3BzW2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdHI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbG9uZUZyb21Qcm9wcyhwcm9wcykge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xyXG4gICAgICB0aGlzLnByb3BzW2ldID0gcHJvcHNbaV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhcHBseVRvUG9pbnQoeCwgeSwgeikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogeCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl0sXHJcbiAgICAgIHk6IHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdLFxyXG4gICAgICB6OiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF0sXHJcbiAgICB9O1xyXG4gICAgLyogcmV0dXJuIHtcclxuICAgICAgICAgeDogeCAqIG1lLmEgKyB5ICogbWUuYyArIG1lLmUsXHJcbiAgICAgICAgIHk6IHggKiBtZS5iICsgeSAqIG1lLmQgKyBtZS5mXHJcbiAgICAgICAgIH07ICovXHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGFwcGx5VG9YKHgsIHksIHopIHtcclxuICAgIHJldHVybiB4ICogdGhpcy5wcm9wc1swXSArIHkgKiB0aGlzLnByb3BzWzRdICsgeiAqIHRoaXMucHJvcHNbOF0gKyB0aGlzLnByb3BzWzEyXTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYXBwbHlUb1koeCwgeSwgeikge1xyXG4gICAgcmV0dXJuIHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBhcHBseVRvWih4LCB5LCB6KSB7XHJcbiAgICByZXR1cm4geCAqIHRoaXMucHJvcHNbMl0gKyB5ICogdGhpcy5wcm9wc1s2XSArIHogKiB0aGlzLnByb3BzWzEwXSArIHRoaXMucHJvcHNbMTRdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0SW52ZXJzZU1hdHJpeCgpIHtcclxuICAgIHZhciBkZXRlcm1pbmFudCA9IHRoaXMucHJvcHNbMF0gKiB0aGlzLnByb3BzWzVdIC0gdGhpcy5wcm9wc1sxXSAqIHRoaXMucHJvcHNbNF07XHJcbiAgICB2YXIgYSA9IHRoaXMucHJvcHNbNV0gLyBkZXRlcm1pbmFudDtcclxuICAgIHZhciBiID0gLXRoaXMucHJvcHNbMV0gLyBkZXRlcm1pbmFudDtcclxuICAgIHZhciBjID0gLXRoaXMucHJvcHNbNF0gLyBkZXRlcm1pbmFudDtcclxuICAgIHZhciBkID0gdGhpcy5wcm9wc1swXSAvIGRldGVybWluYW50O1xyXG4gICAgdmFyIGUgPSAodGhpcy5wcm9wc1s0XSAqIHRoaXMucHJvcHNbMTNdIC0gdGhpcy5wcm9wc1s1XSAqIHRoaXMucHJvcHNbMTJdKSAvIGRldGVybWluYW50O1xyXG4gICAgdmFyIGYgPSAtKHRoaXMucHJvcHNbMF0gKiB0aGlzLnByb3BzWzEzXSAtIHRoaXMucHJvcHNbMV0gKiB0aGlzLnByb3BzWzEyXSkgLyBkZXRlcm1pbmFudDtcclxuICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgaW52ZXJzZU1hdHJpeC5wcm9wc1swXSA9IGE7XHJcbiAgICBpbnZlcnNlTWF0cml4LnByb3BzWzFdID0gYjtcclxuICAgIGludmVyc2VNYXRyaXgucHJvcHNbNF0gPSBjO1xyXG4gICAgaW52ZXJzZU1hdHJpeC5wcm9wc1s1XSA9IGQ7XHJcbiAgICBpbnZlcnNlTWF0cml4LnByb3BzWzEyXSA9IGU7XHJcbiAgICBpbnZlcnNlTWF0cml4LnByb3BzWzEzXSA9IGY7XHJcbiAgICByZXR1cm4gaW52ZXJzZU1hdHJpeDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludmVyc2VQb2ludChwdCkge1xyXG4gICAgdmFyIGludmVyc2VNYXRyaXggPSB0aGlzLmdldEludmVyc2VNYXRyaXgoKTtcclxuICAgIHJldHVybiBpbnZlcnNlTWF0cml4LmFwcGx5VG9Qb2ludEFycmF5KHB0WzBdLCBwdFsxXSwgcHRbMl0gfHwgMCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnZlcnNlUG9pbnRzKHB0cykge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gcHRzLmxlbmd0aDtcclxuICAgIHZhciByZXRQdHMgPSBbXTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZXRQdHNbaV0gPSBpbnZlcnNlUG9pbnQocHRzW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXRQdHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhcHBseVRvVHJpcGxlUG9pbnRzKHB0MSwgcHQyLCBwdDMpIHtcclxuICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgNik7XHJcbiAgICBpZiAodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgYXJyWzBdID0gcHQxWzBdO1xyXG4gICAgICBhcnJbMV0gPSBwdDFbMV07XHJcbiAgICAgIGFyclsyXSA9IHB0MlswXTtcclxuICAgICAgYXJyWzNdID0gcHQyWzFdO1xyXG4gICAgICBhcnJbNF0gPSBwdDNbMF07XHJcbiAgICAgIGFycls1XSA9IHB0M1sxXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBwMCA9IHRoaXMucHJvcHNbMF07XHJcbiAgICAgIHZhciBwMSA9IHRoaXMucHJvcHNbMV07XHJcbiAgICAgIHZhciBwNCA9IHRoaXMucHJvcHNbNF07XHJcbiAgICAgIHZhciBwNSA9IHRoaXMucHJvcHNbNV07XHJcbiAgICAgIHZhciBwMTIgPSB0aGlzLnByb3BzWzEyXTtcclxuICAgICAgdmFyIHAxMyA9IHRoaXMucHJvcHNbMTNdO1xyXG4gICAgICBhcnJbMF0gPSBwdDFbMF0gKiBwMCArIHB0MVsxXSAqIHA0ICsgcDEyO1xyXG4gICAgICBhcnJbMV0gPSBwdDFbMF0gKiBwMSArIHB0MVsxXSAqIHA1ICsgcDEzO1xyXG4gICAgICBhcnJbMl0gPSBwdDJbMF0gKiBwMCArIHB0MlsxXSAqIHA0ICsgcDEyO1xyXG4gICAgICBhcnJbM10gPSBwdDJbMF0gKiBwMSArIHB0MlsxXSAqIHA1ICsgcDEzO1xyXG4gICAgICBhcnJbNF0gPSBwdDNbMF0gKiBwMCArIHB0M1sxXSAqIHA0ICsgcDEyO1xyXG4gICAgICBhcnJbNV0gPSBwdDNbMF0gKiBwMSArIHB0M1sxXSAqIHA1ICsgcDEzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludEFycmF5KHgsIHksIHopIHtcclxuICAgIHZhciBhcnI7XHJcbiAgICBpZiAodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgYXJyID0gW3gsIHksIHpdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXJyID0gW1xyXG4gICAgICAgIHggKiB0aGlzLnByb3BzWzBdICsgeSAqIHRoaXMucHJvcHNbNF0gKyB6ICogdGhpcy5wcm9wc1s4XSArIHRoaXMucHJvcHNbMTJdLFxyXG4gICAgICAgIHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdLFxyXG4gICAgICAgIHggKiB0aGlzLnByb3BzWzJdICsgeSAqIHRoaXMucHJvcHNbNl0gKyB6ICogdGhpcy5wcm9wc1sxMF0gKyB0aGlzLnByb3BzWzE0XSxcclxuICAgICAgXTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhcHBseVRvUG9pbnRTdHJpbmdpZmllZCh4LCB5KSB7XHJcbiAgICBpZiAodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgcmV0dXJuIHggKyAnLCcgKyB5O1xyXG4gICAgfVxyXG4gICAgdmFyIF9wID0gdGhpcy5wcm9wcztcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKCh4ICogX3BbMF0gKyB5ICogX3BbNF0gKyBfcFsxMl0pICogMTAwKSAvIDEwMCArICcsJyArIE1hdGgucm91bmQoKHggKiBfcFsxXSArIHkgKiBfcFs1XSArIF9wWzEzXSkgKiAxMDApIC8gMTAwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9DU1MoKSB7XHJcbiAgICAvLyBEb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSB0byBhZGQgdGhpcyBvcHRpbWl6YXRpb24uIElmIGl0IGlzIGFuIGlkZW50aXR5IG1hdHJpeCwgaXQncyB2ZXJ5IGxpa2VseSB0aGlzIHdpbGwgZ2V0IGNhbGxlZCBvbmx5IG9uY2Ugc2luY2UgaXQgd29uJ3QgYmUga2V5ZnJhbWVkLlxyXG4gICAgLyogaWYodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH0gKi9cclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICB2YXIgY3NzVmFsdWUgPSAnbWF0cml4M2QoJztcclxuICAgIHZhciB2ID0gMTAwMDA7XHJcbiAgICB3aGlsZSAoaSA8IDE2KSB7XHJcbiAgICAgIGNzc1ZhbHVlICs9IF9ybmQocHJvcHNbaV0gKiB2KSAvIHY7XHJcbiAgICAgIGNzc1ZhbHVlICs9IGkgPT09IDE1ID8gJyknIDogJywnO1xyXG4gICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3NzVmFsdWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByb3VuZE1hdHJpeFByb3BlcnR5KHZhbCkge1xyXG4gICAgdmFyIHYgPSAxMDAwMDtcclxuICAgIGlmICgodmFsIDwgMC4wMDAwMDEgJiYgdmFsID4gMCkgfHwgKHZhbCA+IC0wLjAwMDAwMSAmJiB2YWwgPCAwKSkge1xyXG4gICAgICByZXR1cm4gX3JuZCh2YWwgKiB2KSAvIHY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG8yZENTUygpIHtcclxuICAgIC8vIERvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIGFkZCB0aGlzIG9wdGltaXphdGlvbi4gSWYgaXQgaXMgYW4gaWRlbnRpdHkgbWF0cml4LCBpdCdzIHZlcnkgbGlrZWx5IHRoaXMgd2lsbCBnZXQgY2FsbGVkIG9ubHkgb25jZSBzaW5jZSBpdCB3b24ndCBiZSBrZXlmcmFtZWQuXHJcbiAgICAvKiBpZih0aGlzLmlzSWRlbnRpdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfSAqL1xyXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgIHZhciBfYSA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbMF0pO1xyXG4gICAgdmFyIF9iID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxXSk7XHJcbiAgICB2YXIgX2MgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzRdKTtcclxuICAgIHZhciBfZCA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbNV0pO1xyXG4gICAgdmFyIF9lID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxMl0pO1xyXG4gICAgdmFyIF9mID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxM10pO1xyXG4gICAgcmV0dXJuICdtYXRyaXgoJyArIF9hICsgJywnICsgX2IgKyAnLCcgKyBfYyArICcsJyArIF9kICsgJywnICsgX2UgKyAnLCcgKyBfZiArICcpJztcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlc2V0ID0gcmVzZXQ7XHJcbiAgICB0aGlzLnJvdGF0ZSA9IHJvdGF0ZTtcclxuICAgIHRoaXMucm90YXRlWCA9IHJvdGF0ZVg7XHJcbiAgICB0aGlzLnJvdGF0ZVkgPSByb3RhdGVZO1xyXG4gICAgdGhpcy5yb3RhdGVaID0gcm90YXRlWjtcclxuICAgIHRoaXMuc2tldyA9IHNrZXc7XHJcbiAgICB0aGlzLnNrZXdGcm9tQXhpcyA9IHNrZXdGcm9tQXhpcztcclxuICAgIHRoaXMuc2hlYXIgPSBzaGVhcjtcclxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtID0gc2V0VHJhbnNmb3JtO1xyXG4gICAgdGhpcy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgIHRoaXMuYXBwbHlUb1BvaW50ID0gYXBwbHlUb1BvaW50O1xyXG4gICAgdGhpcy5hcHBseVRvWCA9IGFwcGx5VG9YO1xyXG4gICAgdGhpcy5hcHBseVRvWSA9IGFwcGx5VG9ZO1xyXG4gICAgdGhpcy5hcHBseVRvWiA9IGFwcGx5VG9aO1xyXG4gICAgdGhpcy5hcHBseVRvUG9pbnRBcnJheSA9IGFwcGx5VG9Qb2ludEFycmF5O1xyXG4gICAgdGhpcy5hcHBseVRvVHJpcGxlUG9pbnRzID0gYXBwbHlUb1RyaXBsZVBvaW50cztcclxuICAgIHRoaXMuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQgPSBhcHBseVRvUG9pbnRTdHJpbmdpZmllZDtcclxuICAgIHRoaXMudG9DU1MgPSB0b0NTUztcclxuICAgIHRoaXMudG8yZENTUyA9IHRvMmRDU1M7XHJcbiAgICB0aGlzLmNsb25lID0gY2xvbmU7XHJcbiAgICB0aGlzLmNsb25lRnJvbVByb3BzID0gY2xvbmVGcm9tUHJvcHM7XHJcbiAgICB0aGlzLmVxdWFscyA9IGVxdWFscztcclxuICAgIHRoaXMuaW52ZXJzZVBvaW50cyA9IGludmVyc2VQb2ludHM7XHJcbiAgICB0aGlzLmludmVyc2VQb2ludCA9IGludmVyc2VQb2ludDtcclxuICAgIHRoaXMuZ2V0SW52ZXJzZU1hdHJpeCA9IGdldEludmVyc2VNYXRyaXg7XHJcbiAgICB0aGlzLl90ID0gdGhpcy50cmFuc2Zvcm07XHJcbiAgICB0aGlzLmlzSWRlbnRpdHkgPSBpc0lkZW50aXR5O1xyXG4gICAgdGhpcy5faWRlbnRpdHkgPSB0cnVlO1xyXG4gICAgdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5wcm9wcyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxNik7XHJcbiAgICB0aGlzLnJlc2V0KCk7XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlICovXHJcbi8qXHJcbiBDb3B5cmlnaHQgMjAxNCBEYXZpZCBCYXUuXHJcblxyXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cclxuIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXHJcbiBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxyXG4gU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAocG9vbCwgbWF0aCkge1xyXG4vL1xyXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXHJcbi8vXHJcbiAgICB2YXIgZ2xvYmFsID0gdGhpcyxcclxuICAgICAgICB3aWR0aCA9IDI1NiwgICAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcclxuICAgICAgICBjaHVua3MgPSA2LCAgICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcclxuICAgICAgICBkaWdpdHMgPSA1MiwgICAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcclxuICAgICAgICBybmduYW1lID0gJ3JhbmRvbScsIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cclxuICAgICAgICBzdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyksXHJcbiAgICAgICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcclxuICAgICAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXHJcbiAgICAgICAgbWFzayA9IHdpZHRoIC0gMSxcclxuICAgICAgICBub2RlY3J5cHRvOyAgICAgICAgIC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cclxuXHJcbi8vXHJcbi8vIHNlZWRyYW5kb20oKVxyXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cclxuLy9cclxuICAgIGZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIga2V5ID0gW107XHJcbiAgICAgICAgb3B0aW9ucyA9IChvcHRpb25zID09PSB0cnVlKSA/IHsgZW50cm9weTogdHJ1ZSB9IDogKG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgICAgICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cclxuICAgICAgICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxyXG4gICAgICAgICAgICAgICAgKHNlZWQgPT09IG51bGwpID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpO1xyXG5cclxuICAgICAgICAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cclxuICAgICAgICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcclxuICAgICAgICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxyXG4gICAgICAgIHZhciBwcm5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxyXG4gICAgICAgICAgICAgICAgZCA9IHN0YXJ0ZGVub20sICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxyXG4gICAgICAgICAgICAgICAgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cclxuICAgICAgICAgICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XHJcbiAgICAgICAgICAgICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXHJcbiAgICAgICAgICAgICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXHJcbiAgICAgICAgICAgICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcclxuICAgICAgICAgICAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSB8IDA7IH07XHJcbiAgICAgICAgcHJuZy5xdWljayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIC8gMHgxMDAwMDAwMDA7IH07XHJcbiAgICAgICAgcHJuZy5kb3VibGUgPSBwcm5nO1xyXG5cclxuICAgICAgICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxyXG4gICAgICAgIG1peGtleSh0b3N0cmluZyhhcmM0LlMpLCBwb29sKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXHJcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLnBhc3MgfHwgY2FsbGJhY2sgfHxcclxuICAgICAgICBmdW5jdGlvbihwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9hZCB0aGUgYXJjNCBzdGF0ZSBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBpZiBpdCBoYXMgYW4gUyBhcnJheS5cclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5TKSB7IGNvcHkoc3RhdGUsIGFyYzQpOyB9XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHByb3ZpZGUgdGhlIC5zdGF0ZSBtZXRob2QgaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zLnN0YXRlLlxyXG4gICAgICAgICAgICAgICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weShhcmM0LCB7fSk7IH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGNhbGxlZCBhcyBhIG1ldGhvZCBvZiBNYXRoIChNYXRoLnNlZWRyYW5kb20oKSksIG11dGF0ZVxyXG4gICAgICAgICAgICAvLyBNYXRoLnJhbmRvbSBiZWNhdXNlIHRoYXQgaXMgaG93IHNlZWRyYW5kb20uanMgaGFzIHdvcmtlZCBzaW5jZSB2MS4wLlxyXG4gICAgICAgICAgICBpZiAoaXNfbWF0aF9jYWxsKSB7IG1hdGhbcm5nbmFtZV0gPSBwcm5nOyByZXR1cm4gc2VlZDsgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBhIG5ld2VyIGNhbGxpbmcgY29udmVudGlvbiwgc28gcmV0dXJuIHRoZVxyXG4gICAgICAgICAgICAvLyBwcm5nIGRpcmVjdGx5LlxyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBwcm5nO1xyXG4gICAgICAgIH0pKFxyXG4gICAgICAgICAgICBwcm5nLFxyXG4gICAgICAgICAgICBzaG9ydHNlZWQsXHJcbiAgICAgICAgICAgICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6ICh0aGlzID09IG1hdGgpLFxyXG4gICAgICAgICAgICBvcHRpb25zLnN0YXRlKTtcclxuICAgIH1cclxuICAgIG1hdGhbJ3NlZWQnICsgcm5nbmFtZV0gPSBzZWVkcmFuZG9tO1xyXG5cclxuLy9cclxuLy8gQVJDNFxyXG4vL1xyXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXHJcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxyXG4vL1xyXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xyXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XHJcbi8vIHRoYXQgaXMgaW4gdGhlIHJhbmdlIDAgPD0geCA8ICh3aWR0aCBeIGNvdW50KS5cclxuLy9cclxuICAgIGZ1bmN0aW9uIEFSQzQoa2V5KSB7XHJcbiAgICAgICAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXHJcbiAgICAgICAgICAgIG1lID0gdGhpcywgaSA9IDAsIGogPSBtZS5pID0gbWUuaiA9IDAsIHMgPSBtZS5TID0gW107XHJcblxyXG4gICAgICAgIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXHJcbiAgICAgICAgaWYgKCFrZXlsZW4pIHsga2V5ID0gW2tleWxlbisrXTsgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxyXG4gICAgICAgIHdoaWxlIChpIDwgd2lkdGgpIHtcclxuICAgICAgICAgICAgc1tpXSA9IGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIGtleVtpICUga2V5bGVuXSArICh0ID0gc1tpXSkpXTtcclxuICAgICAgICAgICAgc1tqXSA9IHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXHJcbiAgICAgICAgbWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XHJcbiAgICAgICAgICAgIC8vIFVzaW5nIGluc3RhbmNlIG1lbWJlcnMgaW5zdGVhZCBvZiBjbG9zdXJlIHN0YXRlIG5lYXJseSBkb3VibGVzIHNwZWVkLlxyXG4gICAgICAgICAgICB2YXIgdCwgciA9IDAsXHJcbiAgICAgICAgICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xyXG4gICAgICAgICAgICB3aGlsZSAoY291bnQtLSkge1xyXG4gICAgICAgICAgICAgICAgdCA9IHNbaSA9IG1hc2sgJiAoaSArIDEpXTtcclxuICAgICAgICAgICAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoKHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyB0KV0pICsgKHNbal0gPSB0KSldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1lLmkgPSBpOyBtZS5qID0gajtcclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxyXG4gICAgICAgICAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXHJcbiAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vZ29vZ2xlLmNvbS9zZWFyY2g/cT1yc2ErZmx1aHJlcityZXNwb25zZSZidG5JXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbi8vXHJcbi8vIGNvcHkoKVxyXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxyXG4vL1xyXG4gICAgZnVuY3Rpb24gY29weShmLCB0KSB7XHJcbiAgICAgICAgdC5pID0gZi5pO1xyXG4gICAgICAgIHQuaiA9IGYuajtcclxuICAgICAgICB0LlMgPSBmLlMuc2xpY2UoKTtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuXHJcbi8vXHJcbi8vIGZsYXR0ZW4oKVxyXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXHJcbi8vXHJcbiAgICBmdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcclxuICAgICAgICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJyk7XHJcbiAgICB9XHJcblxyXG4vL1xyXG4vLyBtaXhrZXkoKVxyXG4vLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXHJcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxyXG4vL1xyXG4gICAgZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xyXG4gICAgICAgIHZhciBzdHJpbmdzZWVkID0gc2VlZCArICcnLCBzbWVhciwgaiA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBrZXlbbWFzayAmIGpdID1cclxuICAgICAgICAgICAgICAgIG1hc2sgJiAoKHNtZWFyIF49IGtleVttYXNrICYgal0gKiAxOSkgKyBzdHJpbmdzZWVkLmNoYXJDb2RlQXQoaisrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b3N0cmluZyhrZXkpO1xyXG4gICAgfVxyXG5cclxuLy9cclxuLy8gYXV0b3NlZWQoKVxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCBmb3IgYXV0b3NlZWRpbmcsIHVzaW5nIHdpbmRvdy5jcnlwdG8gYW5kIE5vZGUgY3J5cHRvXHJcbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXHJcbi8vXHJcbiAgICBmdW5jdGlvbiBhdXRvc2VlZCgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAobm9kZWNyeXB0bykgeyByZXR1cm4gdG9zdHJpbmcobm9kZWNyeXB0by5yYW5kb21CeXRlcyh3aWR0aCkpOyB9XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh3aWR0aCk7XHJcbiAgICAgICAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxyXG4gICAgICAgICAgICAgICAgcGx1Z2lucyA9IGJyb3dzZXIgJiYgYnJvd3Nlci5wbHVnaW5zO1xyXG4gICAgICAgICAgICByZXR1cm4gWytuZXcgRGF0ZSgpLCBnbG9iYWwsIHBsdWdpbnMsIGdsb2JhbC5zY3JlZW4sIHRvc3RyaW5nKHBvb2wpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4vL1xyXG4vLyB0b3N0cmluZygpXHJcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xyXG4vL1xyXG4gICAgZnVuY3Rpb24gdG9zdHJpbmcoYSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xyXG4gICAgfVxyXG5cclxuLy9cclxuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcclxuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cclxuLy8gbm90IHdhbnQgdG8gaW50ZXJmZXJlIHdpdGggZGV0ZXJtaW5pc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxyXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxyXG4vLyBpbml0aWFsaXphdGlvbi5cclxuLy9cclxuICAgIG1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTtcclxuXHJcbi8vXHJcbi8vIE5vZGVqcyBhbmQgQU1EIHN1cHBvcnQ6IGV4cG9ydCB0aGUgaW1wbGVtZW50YXRpb24gYXMgYSBtb2R1bGUgdXNpbmdcclxuLy8gZWl0aGVyIGNvbnZlbnRpb24uXHJcbi8vXHJcblxyXG4vLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cclxufSkoXHJcbiAgICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcclxuICAgIEJNTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXHJcbik7XHJcbi8qIGVzbGludC1kaXNhYmxlICovXHJcbnZhciBCZXppZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAvKipcclxuICAgICAqIEJlemllckVhc2luZyAtIHVzZSBiZXppZXIgY3VydmUgZm9yIHRyYW5zaXRpb24gZWFzaW5nIGZ1bmN0aW9uXHJcbiAgICAgKiBieSBHYcOrdGFuIFJlbmF1ZGVhdSAyMDE0IC0gMjAxNSDigJMgTUlUIExpY2Vuc2VcclxuICAgICAqXHJcbiAgICAgKiBDcmVkaXRzOiBpcyBiYXNlZCBvbiBGaXJlZm94J3MgbnNTTUlMS2V5U3BsaW5lLmNwcFxyXG4gICAgICogVXNhZ2U6XHJcbiAgICAgKiB2YXIgc3BsaW5lID0gQmV6aWVyRWFzaW5nKFsgMC4yNSwgMC4xLCAwLjI1LCAxLjAgXSlcclxuICAgICAqIHNwbGluZS5nZXQoeCkgPT4gcmV0dXJucyB0aGUgZWFzaW5nIHZhbHVlIHwgeCBtdXN0IGJlIGluIFswLCAxXSByYW5nZVxyXG4gICAgICpcclxuICAgICAqL1xyXG5cclxuICB2YXIgb2IgPSB7fTtcclxuICBvYi5nZXRCZXppZXJFYXNpbmcgPSBnZXRCZXppZXJFYXNpbmc7XHJcbiAgdmFyIGJlemllcnMgPSB7fTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0QmV6aWVyRWFzaW5nKGEsIGIsIGMsIGQsIG5tKSB7XHJcbiAgICB2YXIgc3RyID0gbm0gfHwgKCdiZXpfJyArIGEgKyAnXycgKyBiICsgJ18nICsgYyArICdfJyArIGQpLnJlcGxhY2UoL1xcLi9nLCAncCcpO1xyXG4gICAgaWYgKGJlemllcnNbc3RyXSkge1xyXG4gICAgICByZXR1cm4gYmV6aWVyc1tzdHJdO1xyXG4gICAgfVxyXG4gICAgdmFyIGJlekVhc2luZyA9IG5ldyBCZXppZXJFYXNpbmcoW2EsIGIsIGMsIGRdKTtcclxuICAgIGJlemllcnNbc3RyXSA9IGJlekVhc2luZztcclxuICAgIHJldHVybiBiZXpFYXNpbmc7XHJcbiAgfVxyXG5cclxuICAvLyBUaGVzZSB2YWx1ZXMgYXJlIGVzdGFibGlzaGVkIGJ5IGVtcGlyaWNpc20gd2l0aCB0ZXN0cyAodHJhZGVvZmY6IHBlcmZvcm1hbmNlIFZTIHByZWNpc2lvbilcclxuICB2YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0O1xyXG4gIHZhciBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XHJcbiAgdmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcclxuICB2YXIgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcclxuXHJcbiAgdmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcclxuICB2YXIga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xyXG5cclxuICB2YXIgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ2Z1bmN0aW9uJztcclxuXHJcbiAgZnVuY3Rpb24gQShhQTEsIGFBMikgeyByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExOyB9XHJcbiAgZnVuY3Rpb24gQihhQTEsIGFBMikgeyByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExOyB9XHJcbiAgZnVuY3Rpb24gQyhhQTEpIHsgcmV0dXJuIDMuMCAqIGFBMTsgfVxyXG5cclxuICAvLyBSZXR1cm5zIHgodCkgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgeSh0KSBnaXZlbiB0LCB5MSwgYW5kIHkyLlxyXG4gIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XHJcbiAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm5zIGR4L2R0IGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIGR5L2R0IGdpdmVuIHQsIHkxLCBhbmQgeTIuXHJcbiAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7XHJcbiAgICByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xyXG4gICAgdmFyIGN1cnJlbnRYLFxyXG4gICAgICBjdXJyZW50VCxcclxuICAgICAgaSA9IDA7XHJcbiAgICBkbyB7XHJcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XHJcbiAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XHJcbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xyXG4gICAgICAgIGFCID0gY3VycmVudFQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYUEgPSBjdXJyZW50VDtcclxuICAgICAgfVxyXG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcclxuICAgIHJldHVybiBjdXJyZW50VDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XHJcbiAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XHJcbiAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkgcmV0dXJuIGFHdWVzc1Q7XHJcbiAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XHJcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYUd1ZXNzVDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgICogcG9pbnRzIGlzIGFuIGFycmF5IG9mIFsgbVgxLCBtWTEsIG1YMiwgbVkyIF1cclxuICAgICAqL1xyXG4gIGZ1bmN0aW9uIEJlemllckVhc2luZyhwb2ludHMpIHtcclxuICAgIHRoaXMuX3AgPSBwb2ludHM7XHJcbiAgICB0aGlzLl9tU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcclxuICAgIHRoaXMuX3ByZWNvbXB1dGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5nZXQgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgQmV6aWVyRWFzaW5nLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxyXG4gICAgICAgIG1ZMSA9IHRoaXMuX3BbMV0sXHJcbiAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcclxuICAgICAgICBtWTIgPSB0aGlzLl9wWzNdO1xyXG4gICAgICBpZiAoIXRoaXMuX3ByZWNvbXB1dGVkKSB0aGlzLl9wcmVjb21wdXRlKCk7XHJcbiAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgcmV0dXJuIHg7IC8vIGxpbmVhclxyXG4gICAgICAvLyBCZWNhdXNlIEphdmFTY3JpcHQgbnVtYmVyIGFyZSBpbXByZWNpc2UsIHdlIHNob3VsZCBndWFyYW50ZWUgdGhlIGV4dHJlbWVzIGFyZSByaWdodC5cclxuICAgICAgaWYgKHggPT09IDApIHJldHVybiAwO1xyXG4gICAgICBpZiAoeCA9PT0gMSkgcmV0dXJuIDE7XHJcbiAgICAgIHJldHVybiBjYWxjQmV6aWVyKHRoaXMuX2dldFRGb3JYKHgpLCBtWTEsIG1ZMik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFByaXZhdGUgcGFydFxyXG5cclxuICAgIF9wcmVjb21wdXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxyXG4gICAgICAgIG1ZMSA9IHRoaXMuX3BbMV0sXHJcbiAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcclxuICAgICAgICBtWTIgPSB0aGlzLl9wWzNdO1xyXG4gICAgICB0aGlzLl9wcmVjb21wdXRlZCA9IHRydWU7XHJcbiAgICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikgeyB0aGlzLl9jYWxjU2FtcGxlVmFsdWVzKCk7IH1cclxuICAgIH0sXHJcblxyXG4gICAgX2NhbGNTYW1wbGVWYWx1ZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXHJcbiAgICAgICAgbVgyID0gdGhpcy5fcFsyXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcclxuICAgICAgICB0aGlzLl9tU2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgICogZ2V0VEZvclggY2hvc2UgdGhlIGZhc3Rlc3QgaGV1cmlzdGljIHRvIGRldGVybWluZSB0aGUgcGVyY2VudGFnZSB2YWx1ZSBwcmVjaXNlbHkgZnJvbSBhIGdpdmVuIFggcHJvamVjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgIF9nZXRURm9yWDogZnVuY3Rpb24gKGFYKSB7XHJcbiAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxyXG4gICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXHJcbiAgICAgICAgbVNhbXBsZVZhbHVlcyA9IHRoaXMuX21TYW1wbGVWYWx1ZXM7XHJcblxyXG4gICAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMDtcclxuICAgICAgdmFyIGN1cnJlbnRTYW1wbGUgPSAxO1xyXG4gICAgICB2YXIgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xyXG5cclxuICAgICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XHJcbiAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XHJcbiAgICAgIH1cclxuICAgICAgLS1jdXJyZW50U2FtcGxlO1xyXG5cclxuICAgICAgLy8gSW50ZXJwb2xhdGUgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGd1ZXNzIGZvciB0XHJcbiAgICAgIHZhciBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAobVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcclxuICAgICAgdmFyIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xyXG5cclxuICAgICAgdmFyIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xyXG4gICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcclxuICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xyXG4gICAgICB9IGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xyXG4gICAgICAgIHJldHVybiBndWVzc0ZvclQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gb2I7XHJcbn0oKSk7XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gIHZhciBsYXN0VGltZSA9IDA7XHJcbiAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBsdXNwbHVzXHJcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gIH1cclxuICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xyXG4gICAgICB2YXIgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xyXG4gICAgICB9LFxyXG4gICAgICB0aW1lVG9DYWxsKTtcclxuICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XHJcbiAgICAgIHJldHVybiBpZDtcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuICAgIH07XHJcbiAgfVxyXG59KCkpO1xyXG5cclxuLyogZXhwb3J0ZWQgZXh0ZW5kUHJvdG90eXBlLCBnZXREZXNjcmlwdG9yLCBjcmVhdGVQcm94eUZ1bmN0aW9uICovXHJcblxyXG5mdW5jdGlvbiBleHRlbmRQcm90b3R5cGUoc291cmNlcywgZGVzdGluYXRpb24pIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gc291cmNlcy5sZW5ndGg7XHJcbiAgdmFyIHNvdXJjZVByb3RvdHlwZTtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIHNvdXJjZVByb3RvdHlwZSA9IHNvdXJjZXNbaV0ucHJvdG90eXBlO1xyXG4gICAgZm9yICh2YXIgYXR0ciBpbiBzb3VyY2VQcm90b3R5cGUpIHtcclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2VQcm90b3R5cGUsIGF0dHIpKSBkZXN0aW5hdGlvbi5wcm90b3R5cGVbYXR0cl0gPSBzb3VyY2VQcm90b3R5cGVbYXR0cl07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREZXNjcmlwdG9yKG9iamVjdCwgcHJvcCkge1xyXG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5RnVuY3Rpb24ocHJvdG90eXBlKSB7XHJcbiAgZnVuY3Rpb24gUHJveHlGdW5jdGlvbigpIHt9XHJcbiAgUHJveHlGdW5jdGlvbi5wcm90b3R5cGUgPSBwcm90b3R5cGU7XHJcbiAgcmV0dXJuIFByb3h5RnVuY3Rpb247XHJcbn1cclxuXHJcbi8qIGdsb2JhbCBzZWdtZW50c0xlbmd0aFBvb2wsIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzLCBjcmVhdGVTaXplZEFycmF5LCBibVBvdywgYm1TcXJ0LCBibUZsb29yLCBjcmVhdGVUeXBlZEFycmF5LCBiZXppZXJMZW5ndGhQb29sICovXHJcbi8qIGV4cG9ydGVkIGJleiAqL1xyXG5cclxuZnVuY3Rpb24gYmV6RnVuY3Rpb24oKSB7XHJcbiAgdmFyIG1hdGggPSBNYXRoO1xyXG5cclxuICBmdW5jdGlvbiBwb2ludE9uTGluZTJEKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcclxuICAgIHZhciBkZXQxID0gKHgxICogeTIpICsgKHkxICogeDMpICsgKHgyICogeTMpIC0gKHgzICogeTIpIC0gKHkzICogeDEpIC0gKHgyICogeTEpO1xyXG4gICAgcmV0dXJuIGRldDEgPiAtMC4wMDEgJiYgZGV0MSA8IDAuMDAxO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcG9pbnRPbkxpbmUzRCh4MSwgeTEsIHoxLCB4MiwgeTIsIHoyLCB4MywgeTMsIHozKSB7XHJcbiAgICBpZiAoejEgPT09IDAgJiYgejIgPT09IDAgJiYgejMgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHBvaW50T25MaW5lMkQoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGlzdDEgPSBtYXRoLnNxcnQobWF0aC5wb3coeDIgLSB4MSwgMikgKyBtYXRoLnBvdyh5MiAtIHkxLCAyKSArIG1hdGgucG93KHoyIC0gejEsIDIpKTtcclxuICAgIHZhciBkaXN0MiA9IG1hdGguc3FydChtYXRoLnBvdyh4MyAtIHgxLCAyKSArIG1hdGgucG93KHkzIC0geTEsIDIpICsgbWF0aC5wb3coejMgLSB6MSwgMikpO1xyXG4gICAgdmFyIGRpc3QzID0gbWF0aC5zcXJ0KG1hdGgucG93KHgzIC0geDIsIDIpICsgbWF0aC5wb3coeTMgLSB5MiwgMikgKyBtYXRoLnBvdyh6MyAtIHoyLCAyKSk7XHJcbiAgICB2YXIgZGlmZkRpc3Q7XHJcbiAgICBpZiAoZGlzdDEgPiBkaXN0Mikge1xyXG4gICAgICBpZiAoZGlzdDEgPiBkaXN0Mykge1xyXG4gICAgICAgIGRpZmZEaXN0ID0gZGlzdDEgLSBkaXN0MiAtIGRpc3QzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpZmZEaXN0ID0gZGlzdDMgLSBkaXN0MiAtIGRpc3QxO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGRpc3QzID4gZGlzdDIpIHtcclxuICAgICAgZGlmZkRpc3QgPSBkaXN0MyAtIGRpc3QyIC0gZGlzdDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkaWZmRGlzdCA9IGRpc3QyIC0gZGlzdDEgLSBkaXN0MztcclxuICAgIH1cclxuICAgIHJldHVybiBkaWZmRGlzdCA+IC0wLjAwMDEgJiYgZGlmZkRpc3QgPCAwLjAwMDE7XHJcbiAgfVxyXG5cclxuICB2YXIgZ2V0QmV6aWVyTGVuZ3RoID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHQxLCBwdDIsIHB0MywgcHQ0KSB7XHJcbiAgICAgIHZhciBjdXJ2ZVNlZ21lbnRzID0gZGVmYXVsdEN1cnZlU2VnbWVudHM7XHJcbiAgICAgIHZhciBrO1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbjtcclxuICAgICAgdmFyIHB0Q29vcmQ7XHJcbiAgICAgIHZhciBwZXJjO1xyXG4gICAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xyXG4gICAgICB2YXIgcHREaXN0YW5jZTtcclxuICAgICAgdmFyIHBvaW50ID0gW107XHJcbiAgICAgIHZhciBsYXN0UG9pbnQgPSBbXTtcclxuICAgICAgdmFyIGxlbmd0aERhdGEgPSBiZXppZXJMZW5ndGhQb29sLm5ld0VsZW1lbnQoKTtcclxuICAgICAgbGVuID0gcHQzLmxlbmd0aDtcclxuICAgICAgZm9yIChrID0gMDsgayA8IGN1cnZlU2VnbWVudHM7IGsgKz0gMSkge1xyXG4gICAgICAgIHBlcmMgPSBrIC8gKGN1cnZlU2VnbWVudHMgLSAxKTtcclxuICAgICAgICBwdERpc3RhbmNlID0gMDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgIHB0Q29vcmQgPSBibVBvdygxIC0gcGVyYywgMykgKiBwdDFbaV0gKyAzICogYm1Qb3coMSAtIHBlcmMsIDIpICogcGVyYyAqIHB0M1tpXSArIDMgKiAoMSAtIHBlcmMpICogYm1Qb3cocGVyYywgMikgKiBwdDRbaV0gKyBibVBvdyhwZXJjLCAzKSAqIHB0MltpXTtcclxuICAgICAgICAgIHBvaW50W2ldID0gcHRDb29yZDtcclxuICAgICAgICAgIGlmIChsYXN0UG9pbnRbaV0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHREaXN0YW5jZSArPSBibVBvdyhwb2ludFtpXSAtIGxhc3RQb2ludFtpXSwgMik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsYXN0UG9pbnRbaV0gPSBwb2ludFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHB0RGlzdGFuY2UpIHtcclxuICAgICAgICAgIHB0RGlzdGFuY2UgPSBibVNxcnQocHREaXN0YW5jZSk7XHJcbiAgICAgICAgICBhZGRlZExlbmd0aCArPSBwdERpc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZW5ndGhEYXRhLnBlcmNlbnRzW2tdID0gcGVyYztcclxuICAgICAgICBsZW5ndGhEYXRhLmxlbmd0aHNba10gPSBhZGRlZExlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICBsZW5ndGhEYXRhLmFkZGVkTGVuZ3RoID0gYWRkZWRMZW5ndGg7XHJcbiAgICAgIHJldHVybiBsZW5ndGhEYXRhO1xyXG4gICAgfTtcclxuICB9KCkpO1xyXG5cclxuICBmdW5jdGlvbiBnZXRTZWdtZW50c0xlbmd0aChzaGFwZURhdGEpIHtcclxuICAgIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzTGVuZ3RoUG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICB2YXIgY2xvc2VkID0gc2hhcGVEYXRhLmM7XHJcbiAgICB2YXIgcGF0aFYgPSBzaGFwZURhdGEudjtcclxuICAgIHZhciBwYXRoTyA9IHNoYXBlRGF0YS5vO1xyXG4gICAgdmFyIHBhdGhJID0gc2hhcGVEYXRhLmk7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBzaGFwZURhdGEuX2xlbmd0aDtcclxuICAgIHZhciBsZW5ndGhzID0gc2VnbWVudHNMZW5ndGgubGVuZ3RocztcclxuICAgIHZhciB0b3RhbExlbmd0aCA9IDA7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAxKSB7XHJcbiAgICAgIGxlbmd0aHNbaV0gPSBnZXRCZXppZXJMZW5ndGgocGF0aFZbaV0sIHBhdGhWW2kgKyAxXSwgcGF0aE9baV0sIHBhdGhJW2kgKyAxXSk7XHJcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBpZiAoY2xvc2VkICYmIGxlbikge1xyXG4gICAgICBsZW5ndGhzW2ldID0gZ2V0QmV6aWVyTGVuZ3RoKHBhdGhWW2ldLCBwYXRoVlswXSwgcGF0aE9baV0sIHBhdGhJWzBdKTtcclxuICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcclxuICAgIH1cclxuICAgIHNlZ21lbnRzTGVuZ3RoLnRvdGFsTGVuZ3RoID0gdG90YWxMZW5ndGg7XHJcbiAgICByZXR1cm4gc2VnbWVudHNMZW5ndGg7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBCZXppZXJEYXRhKGxlbmd0aCkge1xyXG4gICAgdGhpcy5zZWdtZW50TGVuZ3RoID0gMDtcclxuICAgIHRoaXMucG9pbnRzID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBQb2ludERhdGEocGFydGlhbCwgcG9pbnQpIHtcclxuICAgIHRoaXMucGFydGlhbExlbmd0aCA9IHBhcnRpYWw7XHJcbiAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XHJcbiAgfVxyXG5cclxuICB2YXIgYnVpbGRCZXppZXJEYXRhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzdG9yZWREYXRhID0ge307XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQpIHtcclxuICAgICAgdmFyIGJlemllck5hbWUgPSAocHQxWzBdICsgJ18nICsgcHQxWzFdICsgJ18nICsgcHQyWzBdICsgJ18nICsgcHQyWzFdICsgJ18nICsgcHQzWzBdICsgJ18nICsgcHQzWzFdICsgJ18nICsgcHQ0WzBdICsgJ18nICsgcHQ0WzFdKS5yZXBsYWNlKC9cXC4vZywgJ3AnKTtcclxuICAgICAgaWYgKCFzdG9yZWREYXRhW2Jlemllck5hbWVdKSB7XHJcbiAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBkZWZhdWx0Q3VydmVTZWdtZW50cztcclxuICAgICAgICB2YXIgaztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbGVuO1xyXG4gICAgICAgIHZhciBwdENvb3JkO1xyXG4gICAgICAgIHZhciBwZXJjO1xyXG4gICAgICAgIHZhciBhZGRlZExlbmd0aCA9IDA7XHJcbiAgICAgICAgdmFyIHB0RGlzdGFuY2U7XHJcbiAgICAgICAgdmFyIHBvaW50O1xyXG4gICAgICAgIHZhciBsYXN0UG9pbnQgPSBudWxsO1xyXG4gICAgICAgIGlmIChwdDEubGVuZ3RoID09PSAyICYmIChwdDFbMF0gIT09IHB0MlswXSB8fCBwdDFbMV0gIT09IHB0MlsxXSkgJiYgcG9pbnRPbkxpbmUyRChwdDFbMF0sIHB0MVsxXSwgcHQyWzBdLCBwdDJbMV0sIHB0MVswXSArIHB0M1swXSwgcHQxWzFdICsgcHQzWzFdKSAmJiBwb2ludE9uTGluZTJEKHB0MVswXSwgcHQxWzFdLCBwdDJbMF0sIHB0MlsxXSwgcHQyWzBdICsgcHQ0WzBdLCBwdDJbMV0gKyBwdDRbMV0pKSB7XHJcbiAgICAgICAgICBjdXJ2ZVNlZ21lbnRzID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJlemllckRhdGEgPSBuZXcgQmV6aWVyRGF0YShjdXJ2ZVNlZ21lbnRzKTtcclxuICAgICAgICBsZW4gPSBwdDMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBjdXJ2ZVNlZ21lbnRzOyBrICs9IDEpIHtcclxuICAgICAgICAgIHBvaW50ID0gY3JlYXRlU2l6ZWRBcnJheShsZW4pO1xyXG4gICAgICAgICAgcGVyYyA9IGsgLyAoY3VydmVTZWdtZW50cyAtIDEpO1xyXG4gICAgICAgICAgcHREaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgcHRDb29yZCA9IGJtUG93KDEgLSBwZXJjLCAzKSAqIHB0MVtpXSArIDMgKiBibVBvdygxIC0gcGVyYywgMikgKiBwZXJjICogKHB0MVtpXSArIHB0M1tpXSkgKyAzICogKDEgLSBwZXJjKSAqIGJtUG93KHBlcmMsIDIpICogKHB0MltpXSArIHB0NFtpXSkgKyBibVBvdyhwZXJjLCAzKSAqIHB0MltpXTtcclxuICAgICAgICAgICAgcG9pbnRbaV0gPSBwdENvb3JkO1xyXG4gICAgICAgICAgICBpZiAobGFzdFBvaW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgcHREaXN0YW5jZSArPSBibVBvdyhwb2ludFtpXSAtIGxhc3RQb2ludFtpXSwgMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHB0RGlzdGFuY2UgPSBibVNxcnQocHREaXN0YW5jZSk7XHJcbiAgICAgICAgICBhZGRlZExlbmd0aCArPSBwdERpc3RhbmNlO1xyXG4gICAgICAgICAgYmV6aWVyRGF0YS5wb2ludHNba10gPSBuZXcgUG9pbnREYXRhKHB0RGlzdGFuY2UsIHBvaW50KTtcclxuICAgICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGggPSBhZGRlZExlbmd0aDtcclxuICAgICAgICBzdG9yZWREYXRhW2Jlemllck5hbWVdID0gYmV6aWVyRGF0YTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc3RvcmVkRGF0YVtiZXppZXJOYW1lXTtcclxuICAgIH07XHJcbiAgfSgpKTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0RGlzdGFuY2VQZXJjKHBlcmMsIGJlemllckRhdGEpIHtcclxuICAgIHZhciBwZXJjZW50cyA9IGJlemllckRhdGEucGVyY2VudHM7XHJcbiAgICB2YXIgbGVuZ3RocyA9IGJlemllckRhdGEubGVuZ3RocztcclxuICAgIHZhciBsZW4gPSBwZXJjZW50cy5sZW5ndGg7XHJcbiAgICB2YXIgaW5pdFBvcyA9IGJtRmxvb3IoKGxlbiAtIDEpICogcGVyYyk7XHJcbiAgICB2YXIgbGVuZ3RoUG9zID0gcGVyYyAqIGJlemllckRhdGEuYWRkZWRMZW5ndGg7XHJcbiAgICB2YXIgbFBlcmMgPSAwO1xyXG4gICAgaWYgKGluaXRQb3MgPT09IGxlbiAtIDEgfHwgaW5pdFBvcyA9PT0gMCB8fCBsZW5ndGhQb3MgPT09IGxlbmd0aHNbaW5pdFBvc10pIHtcclxuICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdO1xyXG4gICAgfVxyXG4gICAgdmFyIGRpciA9IGxlbmd0aHNbaW5pdFBvc10gPiBsZW5ndGhQb3MgPyAtMSA6IDE7XHJcbiAgICB2YXIgZmxhZyA9IHRydWU7XHJcbiAgICB3aGlsZSAoZmxhZykge1xyXG4gICAgICBpZiAobGVuZ3Roc1tpbml0UG9zXSA8PSBsZW5ndGhQb3MgJiYgbGVuZ3Roc1tpbml0UG9zICsgMV0gPiBsZW5ndGhQb3MpIHtcclxuICAgICAgICBsUGVyYyA9IChsZW5ndGhQb3MgLSBsZW5ndGhzW2luaXRQb3NdKSAvIChsZW5ndGhzW2luaXRQb3MgKyAxXSAtIGxlbmd0aHNbaW5pdFBvc10pO1xyXG4gICAgICAgIGZsYWcgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbml0UG9zICs9IGRpcjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5pdFBvcyA8IDAgfHwgaW5pdFBvcyA+PSBsZW4gLSAxKSB7XHJcbiAgICAgICAgLy8gRklYIGZvciBUeXBlZEFycmF5cyB0aGF0IGRvbid0IHN0b3JlIGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIGVub3VnaCBhY2N1cmFjeVxyXG4gICAgICAgIGlmIChpbml0UG9zID09PSBsZW4gLSAxKSB7XHJcbiAgICAgICAgICByZXR1cm4gcGVyY2VudHNbaW5pdFBvc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsYWcgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdICsgKHBlcmNlbnRzW2luaXRQb3MgKyAxXSAtIHBlcmNlbnRzW2luaXRQb3NdKSAqIGxQZXJjO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UG9pbnRJblNlZ21lbnQocHQxLCBwdDIsIHB0MywgcHQ0LCBwZXJjZW50LCBiZXppZXJEYXRhKSB7XHJcbiAgICB2YXIgdDEgPSBnZXREaXN0YW5jZVBlcmMocGVyY2VudCwgYmV6aWVyRGF0YSk7XHJcbiAgICB2YXIgdTEgPSAxIC0gdDE7XHJcbiAgICB2YXIgcHRYID0gbWF0aC5yb3VuZCgodTEgKiB1MSAqIHUxICogcHQxWzBdICsgKHQxICogdTEgKiB1MSArIHUxICogdDEgKiB1MSArIHUxICogdTEgKiB0MSkgKiBwdDNbMF0gKyAodDEgKiB0MSAqIHUxICsgdTEgKiB0MSAqIHQxICsgdDEgKiB1MSAqIHQxKSAqIHB0NFswXSArIHQxICogdDEgKiB0MSAqIHB0MlswXSkgKiAxMDAwKSAvIDEwMDA7XHJcbiAgICB2YXIgcHRZID0gbWF0aC5yb3VuZCgodTEgKiB1MSAqIHUxICogcHQxWzFdICsgKHQxICogdTEgKiB1MSArIHUxICogdDEgKiB1MSArIHUxICogdTEgKiB0MSkgKiBwdDNbMV0gKyAodDEgKiB0MSAqIHUxICsgdTEgKiB0MSAqIHQxICsgdDEgKiB1MSAqIHQxKSAqIHB0NFsxXSArIHQxICogdDEgKiB0MSAqIHB0MlsxXSkgKiAxMDAwKSAvIDEwMDA7XHJcbiAgICByZXR1cm4gW3B0WCwgcHRZXTtcclxuICB9XHJcblxyXG4gIHZhciBiZXppZXJTZWdtZW50UG9pbnRzID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDgpO1xyXG5cclxuICBmdW5jdGlvbiBnZXROZXdTZWdtZW50KHB0MSwgcHQyLCBwdDMsIHB0NCwgc3RhcnRQZXJjLCBlbmRQZXJjLCBiZXppZXJEYXRhKSB7XHJcbiAgICBpZiAoc3RhcnRQZXJjIDwgMCkge1xyXG4gICAgICBzdGFydFBlcmMgPSAwO1xyXG4gICAgfSBlbHNlIGlmIChzdGFydFBlcmMgPiAxKSB7XHJcbiAgICAgIHN0YXJ0UGVyYyA9IDE7XHJcbiAgICB9XHJcbiAgICB2YXIgdDAgPSBnZXREaXN0YW5jZVBlcmMoc3RhcnRQZXJjLCBiZXppZXJEYXRhKTtcclxuICAgIGVuZFBlcmMgPSBlbmRQZXJjID4gMSA/IDEgOiBlbmRQZXJjO1xyXG4gICAgdmFyIHQxID0gZ2V0RGlzdGFuY2VQZXJjKGVuZFBlcmMsIGJlemllckRhdGEpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gcHQxLmxlbmd0aDtcclxuICAgIHZhciB1MCA9IDEgLSB0MDtcclxuICAgIHZhciB1MSA9IDEgLSB0MTtcclxuICAgIHZhciB1MHUwdTAgPSB1MCAqIHUwICogdTA7XHJcbiAgICB2YXIgdDB1MHUwXzMgPSB0MCAqIHUwICogdTAgKiAzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgdmFyIHQwdDB1MF8zID0gdDAgKiB0MCAqIHUwICogMzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgIHZhciB0MHQwdDAgPSB0MCAqIHQwICogdDA7XHJcbiAgICAvL1xyXG4gICAgdmFyIHUwdTB1MSA9IHUwICogdTAgKiB1MTtcclxuICAgIHZhciB0MHUwdTFfMyA9IHQwICogdTAgKiB1MSArIHUwICogdDAgKiB1MSArIHUwICogdTAgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgIHZhciB0MHQwdTFfMyA9IHQwICogdDAgKiB1MSArIHUwICogdDAgKiB0MSArIHQwICogdTAgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgIHZhciB0MHQwdDEgPSB0MCAqIHQwICogdDE7XHJcbiAgICAvL1xyXG4gICAgdmFyIHUwdTF1MSA9IHUwICogdTEgKiB1MTtcclxuICAgIHZhciB0MHUxdTFfMyA9IHQwICogdTEgKiB1MSArIHUwICogdDEgKiB1MSArIHUwICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgIHZhciB0MHQxdTFfMyA9IHQwICogdDEgKiB1MSArIHUwICogdDEgKiB0MSArIHQwICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgIHZhciB0MHQxdDEgPSB0MCAqIHQxICogdDE7XHJcbiAgICAvL1xyXG4gICAgdmFyIHUxdTF1MSA9IHUxICogdTEgKiB1MTtcclxuICAgIHZhciB0MXUxdTFfMyA9IHQxICogdTEgKiB1MSArIHUxICogdDEgKiB1MSArIHUxICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgIHZhciB0MXQxdTFfMyA9IHQxICogdDEgKiB1MSArIHUxICogdDEgKiB0MSArIHQxICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgIHZhciB0MXQxdDEgPSB0MSAqIHQxICogdDE7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgYmV6aWVyU2VnbWVudFBvaW50c1tpICogNF0gPSBtYXRoLnJvdW5kKCh1MHUwdTAgKiBwdDFbaV0gKyB0MHUwdTBfMyAqIHB0M1tpXSArIHQwdDB1MF8zICogcHQ0W2ldICsgdDB0MHQwICogcHQyW2ldKSAqIDEwMDApIC8gMTAwMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgICAgYmV6aWVyU2VnbWVudFBvaW50c1tpICogNCArIDFdID0gbWF0aC5yb3VuZCgodTB1MHUxICogcHQxW2ldICsgdDB1MHUxXzMgKiBwdDNbaV0gKyB0MHQwdTFfMyAqIHB0NFtpXSArIHQwdDB0MSAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXHJcbiAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAyXSA9IG1hdGgucm91bmQoKHUwdTF1MSAqIHB0MVtpXSArIHQwdTF1MV8zICogcHQzW2ldICsgdDB0MXUxXzMgKiBwdDRbaV0gKyB0MHQxdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG4gICAgICBiZXppZXJTZWdtZW50UG9pbnRzW2kgKiA0ICsgM10gPSBtYXRoLnJvdW5kKCh1MXUxdTEgKiBwdDFbaV0gKyB0MXUxdTFfMyAqIHB0M1tpXSArIHQxdDF1MV8zICogcHQ0W2ldICsgdDF0MXQxICogcHQyW2ldKSAqIDEwMDApIC8gMTAwMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYmV6aWVyU2VnbWVudFBvaW50cztcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBnZXRTZWdtZW50c0xlbmd0aDogZ2V0U2VnbWVudHNMZW5ndGgsXHJcbiAgICBnZXROZXdTZWdtZW50OiBnZXROZXdTZWdtZW50LFxyXG4gICAgZ2V0UG9pbnRJblNlZ21lbnQ6IGdldFBvaW50SW5TZWdtZW50LFxyXG4gICAgYnVpbGRCZXppZXJEYXRhOiBidWlsZEJlemllckRhdGEsXHJcbiAgICBwb2ludE9uTGluZTJEOiBwb2ludE9uTGluZTJELFxyXG4gICAgcG9pbnRPbkxpbmUzRDogcG9pbnRPbkxpbmUzRCxcclxuICB9O1xyXG59XHJcblxyXG52YXIgYmV6ID0gYmV6RnVuY3Rpb24oKTtcclxuXHJcbi8qIGV4cG9ydGVkIGRhdGFNYW5hZ2VyICovXHJcblxyXG5mdW5jdGlvbiBkYXRhRnVuY3Rpb25NYW5hZ2VyKCkge1xyXG4gIC8vIHZhciB0Q2FudmFzSGVscGVyID0gY3JlYXRlVGFnKCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICBmdW5jdGlvbiBjb21wbGV0ZUxheWVycyhsYXllcnMsIGNvbXBzLCBmb250TWFuYWdlcikge1xyXG4gICAgdmFyIGxheWVyRGF0YTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XHJcbiAgICB2YXIgajtcclxuICAgIHZhciBqTGVuO1xyXG4gICAgdmFyIGs7XHJcbiAgICB2YXIga0xlbjtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBsYXllckRhdGEgPSBsYXllcnNbaV07XHJcbiAgICAgIGlmICgoJ2tzJyBpbiBsYXllckRhdGEpICYmICFsYXllckRhdGEuY29tcGxldGVkKSB7XHJcbiAgICAgICAgbGF5ZXJEYXRhLmNvbXBsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGxheWVyRGF0YS50dCkge1xyXG4gICAgICAgICAgbGF5ZXJzW2kgLSAxXS50ZCA9IGxheWVyRGF0YS50dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxheWVyRGF0YS5oYXNNYXNrKSB7XHJcbiAgICAgICAgICB2YXIgbWFza1Byb3BzID0gbGF5ZXJEYXRhLm1hc2tzUHJvcGVydGllcztcclxuICAgICAgICAgIGpMZW4gPSBtYXNrUHJvcHMubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0LmsuaSkge1xyXG4gICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMobWFza1Byb3BzW2pdLnB0LmspO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGtMZW4gPSBtYXNrUHJvcHNbal0ucHQuay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpIHtcclxuICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhtYXNrUHJvcHNbal0ucHQua1trXS5zWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXNrUHJvcHNbal0ucHQua1trXS5lKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMobWFza1Byb3BzW2pdLnB0Lmtba10uZVswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXllckRhdGEudHkgPT09IDApIHtcclxuICAgICAgICAgIGxheWVyRGF0YS5sYXllcnMgPSBmaW5kQ29tcExheWVycyhsYXllckRhdGEucmVmSWQsIGNvbXBzKTtcclxuICAgICAgICAgIGNvbXBsZXRlTGF5ZXJzKGxheWVyRGF0YS5sYXllcnMsIGNvbXBzLCBmb250TWFuYWdlcik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXllckRhdGEudHkgPT09IDQpIHtcclxuICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGxheWVyRGF0YS5zaGFwZXMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXJEYXRhLnR5ID09PSA1KSB7XHJcbiAgICAgICAgICBjb21wbGV0ZVRleHQobGF5ZXJEYXRhLCBmb250TWFuYWdlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaW5kQ29tcExheWVycyhpZCwgY29tcHMpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBsZW4gPSBjb21wcy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICBpZiAoY29tcHNbaV0uaWQgPT09IGlkKSB7XHJcbiAgICAgICAgaWYgKCFjb21wc1tpXS5sYXllcnMuX191c2VkKSB7XHJcbiAgICAgICAgICBjb21wc1tpXS5sYXllcnMuX191c2VkID0gdHJ1ZTtcclxuICAgICAgICAgIHJldHVybiBjb21wc1tpXS5sYXllcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbXBzW2ldLmxheWVycykpO1xyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcGxldGVTaGFwZXMoYXJyKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgakxlbjtcclxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgIGlmIChhcnJbaV0udHkgPT09ICdzaCcpIHtcclxuICAgICAgICBpZiAoYXJyW2ldLmtzLmsuaSkge1xyXG4gICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhhcnJbaV0ua3Muayk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGpMZW4gPSBhcnJbaV0ua3Muay5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5zKSB7XHJcbiAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhhcnJbaV0ua3Mua1tqXS5zWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJyW2ldLmtzLmtbal0uZSkge1xyXG4gICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmtbal0uZVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XHJcbiAgICAgICAgY29tcGxldGVTaGFwZXMoYXJyW2ldLml0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhwYXRoKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBwYXRoLmkubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHBhdGguaVtpXVswXSArPSBwYXRoLnZbaV1bMF07XHJcbiAgICAgIHBhdGguaVtpXVsxXSArPSBwYXRoLnZbaV1bMV07XHJcbiAgICAgIHBhdGgub1tpXVswXSArPSBwYXRoLnZbaV1bMF07XHJcbiAgICAgIHBhdGgub1tpXVsxXSArPSBwYXRoLnZbaV1bMV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjaGVja1ZlcnNpb24obWluaW11bSwgYW5pbVZlcnNpb25TdHJpbmcpIHtcclxuICAgIHZhciBhbmltVmVyc2lvbiA9IGFuaW1WZXJzaW9uU3RyaW5nID8gYW5pbVZlcnNpb25TdHJpbmcuc3BsaXQoJy4nKSA6IFsxMDAsIDEwMCwgMTAwXTtcclxuICAgIGlmIChtaW5pbXVtWzBdID4gYW5pbVZlcnNpb25bMF0pIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGlmIChhbmltVmVyc2lvblswXSA+IG1pbmltdW1bMF0pIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG1pbmltdW1bMV0gPiBhbmltVmVyc2lvblsxXSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gaWYgKGFuaW1WZXJzaW9uWzFdID4gbWluaW11bVsxXSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobWluaW11bVsyXSA+IGFuaW1WZXJzaW9uWzJdKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBpZiAoYW5pbVZlcnNpb25bMl0gPiBtaW5pbXVtWzJdKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNoZWNrVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNCwgMTRdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHRMYXllcih0ZXh0TGF5ZXIpIHtcclxuICAgICAgdmFyIGRvY3VtZW50RGF0YSA9IHRleHRMYXllci50LmQ7XHJcbiAgICAgIHRleHRMYXllci50LmQgPSB7XHJcbiAgICAgICAgazogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBzOiBkb2N1bWVudERhdGEsXHJcbiAgICAgICAgICAgIHQ6IDAsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXRlcmF0ZUxheWVycyhsYXllcnMpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA1KSB7XHJcbiAgICAgICAgICB1cGRhdGVUZXh0TGF5ZXIobGF5ZXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRhdGEpIHtcclxuICAgICAgaWYgKGNoZWNrVmVyc2lvbihtaW5pbXVtVmVyc2lvbiwgYW5pbWF0aW9uRGF0YS52KSkge1xyXG4gICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xyXG4gICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0cykge1xyXG4gICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0aW9uRGF0YS5hc3NldHMubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpIHtcclxuICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSgpKTtcclxuXHJcbiAgdmFyIGNoZWNrQ2hhcnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG1pbmltdW1WZXJzaW9uID0gWzQsIDcsIDk5XTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xyXG4gICAgICBpZiAoYW5pbWF0aW9uRGF0YS5jaGFycyAmJiAhY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuY2hhcnMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBqO1xyXG4gICAgICAgIHZhciBqTGVuO1xyXG4gICAgICAgIHZhciBwYXRoRGF0YTtcclxuICAgICAgICB2YXIgcGF0aHM7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5jaGFyc1tpXS5kYXRhICYmIGFuaW1hdGlvbkRhdGEuY2hhcnNbaV0uZGF0YS5zaGFwZXMpIHtcclxuICAgICAgICAgICAgcGF0aHMgPSBhbmltYXRpb25EYXRhLmNoYXJzW2ldLmRhdGEuc2hhcGVzWzBdLml0O1xyXG4gICAgICAgICAgICBqTGVuID0gcGF0aHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgICAgIHBhdGhEYXRhID0gcGF0aHNbal0ua3MuaztcclxuICAgICAgICAgICAgICBpZiAoIXBhdGhEYXRhLl9fY29udmVydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKHBhdGhzW2pdLmtzLmspO1xyXG4gICAgICAgICAgICAgICAgcGF0aERhdGEuX19jb252ZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KCkpO1xyXG5cclxuICB2YXIgY2hlY2tQYXRoUHJvcGVydGllcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNSwgNywgMTVdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHRMYXllcih0ZXh0TGF5ZXIpIHtcclxuICAgICAgdmFyIHBhdGhEYXRhID0gdGV4dExheWVyLnQucDtcclxuICAgICAgaWYgKHR5cGVvZiBwYXRoRGF0YS5hID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHBhdGhEYXRhLmEgPSB7XHJcbiAgICAgICAgICBhOiAwLFxyXG4gICAgICAgICAgazogcGF0aERhdGEuYSxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgcGF0aERhdGEucCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBwYXRoRGF0YS5wID0ge1xyXG4gICAgICAgICAgYTogMCxcclxuICAgICAgICAgIGs6IHBhdGhEYXRhLnAsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIHBhdGhEYXRhLnIgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcGF0aERhdGEuciA9IHtcclxuICAgICAgICAgIGE6IDAsXHJcbiAgICAgICAgICBrOiBwYXRoRGF0YS5yLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIGlmIChsYXllcnNbaV0udHkgPT09IDUpIHtcclxuICAgICAgICAgIHVwZGF0ZVRleHRMYXllcihsYXllcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xyXG4gICAgICBpZiAoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XHJcbiAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzKSB7XHJcbiAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xyXG4gICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KCkpO1xyXG5cclxuICB2YXIgY2hlY2tDb2xvcnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG1pbmltdW1WZXJzaW9uID0gWzQsIDEsIDldO1xyXG5cclxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVTaGFwZXMoc2hhcGVzKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gc2hhcGVzLmxlbmd0aDtcclxuICAgICAgdmFyIGo7XHJcbiAgICAgIHZhciBqTGVuO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZ3InKSB7XHJcbiAgICAgICAgICBpdGVyYXRlU2hhcGVzKHNoYXBlc1tpXS5pdCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdmbCcgfHwgc2hhcGVzW2ldLnR5ID09PSAnc3QnKSB7XHJcbiAgICAgICAgICBpZiAoc2hhcGVzW2ldLmMuayAmJiBzaGFwZXNbaV0uYy5rWzBdLmkpIHtcclxuICAgICAgICAgICAgakxlbiA9IHNoYXBlc1tpXS5jLmsubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmtbal0ucykge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5zWzBdIC89IDI1NTtcclxuICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uc1sxXSAvPSAyNTU7XHJcbiAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMl0gLz0gMjU1O1xyXG4gICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5zWzNdIC89IDI1NTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmtbal0uZSkge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5lWzBdIC89IDI1NTtcclxuICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVsxXSAvPSAyNTU7XHJcbiAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLmVbMl0gLz0gMjU1O1xyXG4gICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5lWzNdIC89IDI1NTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMF0gLz0gMjU1O1xyXG4gICAgICAgICAgICBzaGFwZXNbaV0uYy5rWzFdIC89IDI1NTtcclxuICAgICAgICAgICAgc2hhcGVzW2ldLmMua1syXSAvPSAyNTU7XHJcbiAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbM10gLz0gMjU1O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVMYXllcnMobGF5ZXJzKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgaWYgKGxheWVyc1tpXS50eSA9PT0gNCkge1xyXG4gICAgICAgICAgaXRlcmF0ZVNoYXBlcyhsYXllcnNbaV0uc2hhcGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRhdGEpIHtcclxuICAgICAgaWYgKGNoZWNrVmVyc2lvbihtaW5pbXVtVmVyc2lvbiwgYW5pbWF0aW9uRGF0YS52KSkge1xyXG4gICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xyXG4gICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0cykge1xyXG4gICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0aW9uRGF0YS5hc3NldHMubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpIHtcclxuICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSgpKTtcclxuXHJcbiAgdmFyIGNoZWNrU2hhcGVzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs0LCA0LCAxOF07XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGxldGVDbG9zaW5nU2hhcGVzKGFycikge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICAgIHZhciBqO1xyXG4gICAgICB2YXIgakxlbjtcclxuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICBpZiAoYXJyW2ldLnR5ID09PSAnc2gnKSB7XHJcbiAgICAgICAgICBpZiAoYXJyW2ldLmtzLmsuaSkge1xyXG4gICAgICAgICAgICBhcnJbaV0ua3Muay5jID0gYXJyW2ldLmNsb3NlZDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGpMZW4gPSBhcnJbaV0ua3Muay5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ldLmtzLmtbal0ucykge1xyXG4gICAgICAgICAgICAgICAgYXJyW2ldLmtzLmtbal0uc1swXS5jID0gYXJyW2ldLmNsb3NlZDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLmUpIHtcclxuICAgICAgICAgICAgICAgIGFycltpXS5rcy5rW2pdLmVbMF0uYyA9IGFycltpXS5jbG9zZWQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgICAgIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhhcnJbaV0uaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVMYXllcnMobGF5ZXJzKSB7XHJcbiAgICAgIHZhciBsYXllckRhdGE7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcclxuICAgICAgdmFyIGo7XHJcbiAgICAgIHZhciBqTGVuO1xyXG4gICAgICB2YXIgaztcclxuICAgICAgdmFyIGtMZW47XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIGxheWVyRGF0YSA9IGxheWVyc1tpXTtcclxuICAgICAgICBpZiAobGF5ZXJEYXRhLmhhc01hc2spIHtcclxuICAgICAgICAgIHZhciBtYXNrUHJvcHMgPSBsYXllckRhdGEubWFza3NQcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgakxlbiA9IG1hc2tQcm9wcy5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXNrUHJvcHNbal0ucHQuay5pKSB7XHJcbiAgICAgICAgICAgICAgbWFza1Byb3BzW2pdLnB0LmsuYyA9IG1hc2tQcm9wc1tqXS5jbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBrTGVuID0gbWFza1Byb3BzW2pdLnB0LmsubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXNrUHJvcHNbal0ucHQua1trXS5zKSB7XHJcbiAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rW2tdLnNbMF0uYyA9IG1hc2tQcm9wc1tqXS5jbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXNrUHJvcHNbal0ucHQua1trXS5lKSB7XHJcbiAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rW2tdLmVbMF0uYyA9IG1hc2tQcm9wc1tqXS5jbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxheWVyRGF0YS50eSA9PT0gNCkge1xyXG4gICAgICAgICAgY29tcGxldGVDbG9zaW5nU2hhcGVzKGxheWVyRGF0YS5zaGFwZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xyXG4gICAgICBpZiAoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XHJcbiAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzKSB7XHJcbiAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xyXG4gICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KCkpO1xyXG5cclxuICBmdW5jdGlvbiBjb21wbGV0ZURhdGEoYW5pbWF0aW9uRGF0YSwgZm9udE1hbmFnZXIpIHtcclxuICAgIGlmIChhbmltYXRpb25EYXRhLl9fY29tcGxldGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDb2xvcnMoYW5pbWF0aW9uRGF0YSk7XHJcbiAgICBjaGVja1RleHQoYW5pbWF0aW9uRGF0YSk7XHJcbiAgICBjaGVja0NoYXJzKGFuaW1hdGlvbkRhdGEpO1xyXG4gICAgY2hlY2tQYXRoUHJvcGVydGllcyhhbmltYXRpb25EYXRhKTtcclxuICAgIGNoZWNrU2hhcGVzKGFuaW1hdGlvbkRhdGEpO1xyXG4gICAgY29tcGxldGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMsIGFuaW1hdGlvbkRhdGEuYXNzZXRzLCBmb250TWFuYWdlcik7XHJcbiAgICBhbmltYXRpb25EYXRhLl9fY29tcGxldGUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcGxldGVUZXh0KGRhdGEpIHtcclxuICAgIGlmIChkYXRhLnQuYS5sZW5ndGggPT09IDAgJiYgISgnbScgaW4gZGF0YS50LnApKSB7XHJcbiAgICAgIGRhdGEuc2luZ2xlU2hhcGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIG1vZHVsZU9iID0ge307XHJcbiAgbW9kdWxlT2IuY29tcGxldGVEYXRhID0gY29tcGxldGVEYXRhO1xyXG4gIG1vZHVsZU9iLmNoZWNrQ29sb3JzID0gY2hlY2tDb2xvcnM7XHJcbiAgbW9kdWxlT2IuY2hlY2tDaGFycyA9IGNoZWNrQ2hhcnM7XHJcbiAgbW9kdWxlT2IuY2hlY2tQYXRoUHJvcGVydGllcyA9IGNoZWNrUGF0aFByb3BlcnRpZXM7XHJcbiAgbW9kdWxlT2IuY2hlY2tTaGFwZXMgPSBjaGVja1NoYXBlcztcclxuICBtb2R1bGVPYi5jb21wbGV0ZUxheWVycyA9IGNvbXBsZXRlTGF5ZXJzO1xyXG5cclxuICByZXR1cm4gbW9kdWxlT2I7XHJcbn1cclxuXHJcbnZhciBkYXRhTWFuYWdlciA9IGRhdGFGdW5jdGlvbk1hbmFnZXIoKTtcclxuXHJcbi8qIGV4cG9ydGVkIGdldEZvbnRQcm9wZXJ0aWVzICovXHJcblxyXG5mdW5jdGlvbiBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSkge1xyXG4gIHZhciBzdHlsZXMgPSBmb250RGF0YS5mU3R5bGUgPyBmb250RGF0YS5mU3R5bGUuc3BsaXQoJyAnKSA6IFtdO1xyXG5cclxuICB2YXIgZldlaWdodCA9ICdub3JtYWwnOyB2YXJcclxuICAgIGZTdHlsZSA9ICdub3JtYWwnO1xyXG4gIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xyXG4gIHZhciBzdHlsZU5hbWU7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgc3R5bGVOYW1lID0gc3R5bGVzW2ldLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBzd2l0Y2ggKHN0eWxlTmFtZSkge1xyXG4gICAgICBjYXNlICdpdGFsaWMnOlxyXG4gICAgICAgIGZTdHlsZSA9ICdpdGFsaWMnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdib2xkJzpcclxuICAgICAgICBmV2VpZ2h0ID0gJzcwMCc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2JsYWNrJzpcclxuICAgICAgICBmV2VpZ2h0ID0gJzkwMCc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21lZGl1bSc6XHJcbiAgICAgICAgZldlaWdodCA9ICc1MDAnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdyZWd1bGFyJzpcclxuICAgICAgY2FzZSAnbm9ybWFsJzpcclxuICAgICAgICBmV2VpZ2h0ID0gJzQwMCc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2xpZ2h0JzpcclxuICAgICAgY2FzZSAndGhpbic6XHJcbiAgICAgICAgZldlaWdodCA9ICcyMDAnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0eWxlOiBmU3R5bGUsXHJcbiAgICB3ZWlnaHQ6IGZvbnREYXRhLmZXZWlnaHQgfHwgZldlaWdodCxcclxuICB9O1xyXG59XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlTlMsIGNyZWF0ZVRhZywgZ2V0Rm9udFByb3BlcnRpZXMgKi9cclxuLyogZXhwb3J0ZWQgRm9udE1hbmFnZXIgKi9cclxuXHJcbnZhciBGb250TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1heFdhaXRpbmdUaW1lID0gNTAwMDtcclxuICB2YXIgZW1wdHlDaGFyID0ge1xyXG4gICAgdzogMCxcclxuICAgIHNpemU6IDAsXHJcbiAgICBzaGFwZXM6IFtdLFxyXG4gIH07XHJcbiAgdmFyIGNvbWJpbmVkQ2hhcmFjdGVycyA9IFtdO1xyXG4gIC8vIEhpbmRpIGNoYXJhY3RlcnNcclxuICBjb21iaW5lZENoYXJhY3RlcnMgPSBjb21iaW5lZENoYXJhY3RlcnMuY29uY2F0KFsyMzA0LCAyMzA1LCAyMzA2LCAyMzA3LCAyMzYyLCAyMzYzLCAyMzY0LCAyMzY0LCAyMzY2LFxyXG4gICAgMjM2NywgMjM2OCwgMjM2OSwgMjM3MCwgMjM3MSwgMjM3MiwgMjM3MywgMjM3NCwgMjM3NSwgMjM3NiwgMjM3NywgMjM3OCwgMjM3OSxcclxuICAgIDIzODAsIDIzODEsIDIzODIsIDIzODMsIDIzODcsIDIzODgsIDIzODksIDIzOTAsIDIzOTEsIDI0MDIsIDI0MDNdKTtcclxuXHJcbiAgdmFyIHN1cnJvZ2F0ZU1vZGlmaWVycyA9IFtcclxuICAgICdkODNjZGZmYicsXHJcbiAgICAnZDgzY2RmZmMnLFxyXG4gICAgJ2Q4M2NkZmZkJyxcclxuICAgICdkODNjZGZmZScsXHJcbiAgICAnZDgzY2RmZmYnLFxyXG4gIF07XHJcblxyXG4gIHZhciB6ZXJvV2lkdGhKb2luZXIgPSBbNjUwMzksIDgyMDVdO1xyXG5cclxuICBmdW5jdGlvbiB0cmltRm9udE9wdGlvbnMoZm9udCkge1xyXG4gICAgdmFyIGZhbWlseUFycmF5ID0gZm9udC5zcGxpdCgnLCcpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gZmFtaWx5QXJyYXkubGVuZ3RoO1xyXG4gICAgdmFyIGVuYWJsZWRGYW1pbGllcyA9IFtdO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGlmIChmYW1pbHlBcnJheVtpXSAhPT0gJ3NhbnMtc2VyaWYnICYmIGZhbWlseUFycmF5W2ldICE9PSAnbW9ub3NwYWNlJykge1xyXG4gICAgICAgIGVuYWJsZWRGYW1pbGllcy5wdXNoKGZhbWlseUFycmF5W2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVuYWJsZWRGYW1pbGllcy5qb2luKCcsJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRVcE5vZGUoZm9udCwgZmFtaWx5KSB7XHJcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGNyZWF0ZVRhZygnc3BhbicpO1xyXG4gICAgLy8gTm9kZSBpcyBpbnZpc2libGUgdG8gc2NyZWVuIHJlYWRlcnMuXHJcbiAgICBwYXJlbnROb2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcclxuICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udEZhbWlseSA9IGZhbWlseTtcclxuICAgIHZhciBub2RlID0gY3JlYXRlVGFnKCdzcGFuJyk7XHJcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgdmFyeSBzaWduaWZpY2FudGx5IGFtb25nIGRpZmZlcmVudCBmb250c1xyXG4gICAgbm9kZS5pbm5lclRleHQgPSAnZ2lJdFQxV1F5QCEtLyMnO1xyXG4gICAgLy8gVmlzaWJsZSAtIHNvIHdlIGNhbiBtZWFzdXJlIGl0IC0gYnV0IG5vdCBvbiB0aGUgc2NyZWVuXHJcbiAgICBwYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgIHBhcmVudE5vZGUuc3R5bGUubGVmdCA9ICctMTAwMDBweCc7XHJcbiAgICBwYXJlbnROb2RlLnN0eWxlLnRvcCA9ICctMTAwMDBweCc7XHJcbiAgICAvLyBMYXJnZSBmb250IHNpemUgbWFrZXMgZXZlbiBzdWJ0bGUgY2hhbmdlcyBvYnZpb3VzXHJcbiAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRTaXplID0gJzMwMHB4JztcclxuICAgIC8vIFJlc2V0IGFueSBmb250IHByb3BlcnRpZXNcclxuICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFZhcmlhbnQgPSAnbm9ybWFsJztcclxuICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFN0eWxlID0gJ25vcm1hbCc7XHJcbiAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRXZWlnaHQgPSAnbm9ybWFsJztcclxuICAgIHBhcmVudE5vZGUuc3R5bGUubGV0dGVyU3BhY2luZyA9ICcwJztcclxuICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmVudE5vZGUpO1xyXG5cclxuICAgIC8vIFJlbWVtYmVyIHdpZHRoIHdpdGggbm8gYXBwbGllZCB3ZWIgZm9udFxyXG4gICAgdmFyIHdpZHRoID0gbm9kZS5vZmZzZXRXaWR0aDtcclxuICAgIG5vZGUuc3R5bGUuZm9udEZhbWlseSA9IHRyaW1Gb250T3B0aW9ucyhmb250KSArICcsICcgKyBmYW1pbHk7XHJcbiAgICByZXR1cm4geyBub2RlOiBub2RlLCB3OiB3aWR0aCwgcGFyZW50OiBwYXJlbnROb2RlIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjaGVja0xvYWRlZEZvbnRzKCkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5mb250cy5sZW5ndGg7XHJcbiAgICB2YXIgbm9kZTtcclxuICAgIHZhciB3O1xyXG4gICAgdmFyIGxvYWRlZENvdW50ID0gbGVuO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGlmICh0aGlzLmZvbnRzW2ldLmxvYWRlZCkge1xyXG4gICAgICAgIGxvYWRlZENvdW50IC09IDE7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250c1tpXS5mT3JpZ2luID09PSAnbicgfHwgdGhpcy5mb250c1tpXS5vcmlnaW4gPT09IDApIHtcclxuICAgICAgICB0aGlzLmZvbnRzW2ldLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZSA9IHRoaXMuZm9udHNbaV0ubW9ub0Nhc2Uubm9kZTtcclxuICAgICAgICB3ID0gdGhpcy5mb250c1tpXS5tb25vQ2FzZS53O1xyXG4gICAgICAgIGlmIChub2RlLm9mZnNldFdpZHRoICE9PSB3KSB7XHJcbiAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xyXG4gICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBub2RlID0gdGhpcy5mb250c1tpXS5zYW5zQ2FzZS5ub2RlO1xyXG4gICAgICAgICAgdyA9IHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2UudztcclxuICAgICAgICAgIGlmIChub2RlLm9mZnNldFdpZHRoICE9PSB3KSB7XHJcbiAgICAgICAgICAgIGxvYWRlZENvdW50IC09IDE7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udHNbaV0ubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZm9udHNbaV0ubG9hZGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLnBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2UucGFyZW50KTtcclxuICAgICAgICAgIHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UucGFyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb250c1tpXS5tb25vQ2FzZS5wYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChsb2FkZWRDb3VudCAhPT0gMCAmJiBEYXRlLm5vdygpIC0gdGhpcy5pbml0VGltZSA8IG1heFdhaXRpbmdUaW1lKSB7XHJcbiAgICAgIHNldFRpbWVvdXQodGhpcy5jaGVja0xvYWRlZEZvbnRzQmluZGVkLCAyMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXRUaW1lb3V0KHRoaXMuc2V0SXNMb2FkZWRCaW5kZWQsIDEwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUhlbHBlcihkZWYsIGZvbnREYXRhKSB7XHJcbiAgICB2YXIgdEhlbHBlciA9IGNyZWF0ZU5TKCd0ZXh0Jyk7XHJcbiAgICB0SGVscGVyLnN0eWxlLmZvbnRTaXplID0gJzEwMHB4JztcclxuICAgIC8vIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XHJcblxyXG4gICAgdmFyIGZvbnRQcm9wcyA9IGdldEZvbnRQcm9wZXJ0aWVzKGZvbnREYXRhKTtcclxuICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdmb250LWZhbWlseScsIGZvbnREYXRhLmZGYW1pbHkpO1xyXG4gICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc3R5bGUnLCBmb250UHJvcHMuc3R5bGUpO1xyXG4gICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtd2VpZ2h0JywgZm9udFByb3BzLndlaWdodCk7XHJcbiAgICB0SGVscGVyLnRleHRDb250ZW50ID0gJzEnO1xyXG4gICAgaWYgKGZvbnREYXRhLmZDbGFzcykge1xyXG4gICAgICB0SGVscGVyLnN0eWxlLmZvbnRGYW1pbHkgPSAnaW5oZXJpdCc7XHJcbiAgICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsIGZvbnREYXRhLmZDbGFzcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0SGVscGVyLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RGF0YS5mRmFtaWx5O1xyXG4gICAgfVxyXG4gICAgZGVmLmFwcGVuZENoaWxkKHRIZWxwZXIpO1xyXG4gICAgdmFyIHRDYW52YXNIZWxwZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICB0Q2FudmFzSGVscGVyLmZvbnQgPSBmb250RGF0YS5mV2VpZ2h0ICsgJyAnICsgZm9udERhdGEuZlN0eWxlICsgJyAxMDBweCAnICsgZm9udERhdGEuZkZhbWlseTtcclxuICAgIC8vIHRDYW52YXNIZWxwZXIuZm9udCA9ICcgMTAwcHggJysgZm9udERhdGEuZkZhbWlseTtcclxuICAgIHJldHVybiB0SGVscGVyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkRm9udHMoZm9udERhdGEsIGRlZnMpIHtcclxuICAgIGlmICghZm9udERhdGEpIHtcclxuICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNoYXJzKSB7XHJcbiAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLmZvbnRzID0gZm9udERhdGEubGlzdDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmb250QXJyID0gZm9udERhdGEubGlzdDtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGZvbnRBcnIubGVuZ3RoO1xyXG4gICAgdmFyIF9wZW5kaW5nRm9udHMgPSBsZW47XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdmFyIHNob3VsZExvYWRGb250ID0gdHJ1ZTtcclxuICAgICAgdmFyIGxvYWRlZFNlbGVjdG9yO1xyXG4gICAgICB2YXIgajtcclxuICAgICAgZm9udEFycltpXS5sb2FkZWQgPSBmYWxzZTtcclxuICAgICAgZm9udEFycltpXS5tb25vQ2FzZSA9IHNldFVwTm9kZShmb250QXJyW2ldLmZGYW1pbHksICdtb25vc3BhY2UnKTtcclxuICAgICAgZm9udEFycltpXS5zYW5zQ2FzZSA9IHNldFVwTm9kZShmb250QXJyW2ldLmZGYW1pbHksICdzYW5zLXNlcmlmJyk7XHJcbiAgICAgIGlmICghZm9udEFycltpXS5mUGF0aCkge1xyXG4gICAgICAgIGZvbnRBcnJbaV0ubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICBfcGVuZGluZ0ZvbnRzIC09IDE7XHJcbiAgICAgIH0gZWxzZSBpZiAoZm9udEFycltpXS5mT3JpZ2luID09PSAncCcgfHwgZm9udEFycltpXS5vcmlnaW4gPT09IDMpIHtcclxuICAgICAgICBsb2FkZWRTZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW2YtZm9yaWdpbj1cInBcIl1bZi1mYW1pbHk9XCInICsgZm9udEFycltpXS5mRmFtaWx5ICsgJ1wiXSwgc3R5bGVbZi1vcmlnaW49XCIzXCJdW2YtZmFtaWx5PVwiJyArIGZvbnRBcnJbaV0uZkZhbWlseSArICdcIl0nKTtcclxuXHJcbiAgICAgICAgaWYgKGxvYWRlZFNlbGVjdG9yLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHNob3VsZExvYWRGb250ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2hvdWxkTG9hZEZvbnQpIHtcclxuICAgICAgICAgIHZhciBzID0gY3JlYXRlVGFnKCdzdHlsZScpO1xyXG4gICAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ2YtZm9yaWdpbicsIGZvbnRBcnJbaV0uZk9yaWdpbik7XHJcbiAgICAgICAgICBzLnNldEF0dHJpYnV0ZSgnZi1vcmlnaW4nLCBmb250QXJyW2ldLm9yaWdpbik7XHJcbiAgICAgICAgICBzLnNldEF0dHJpYnV0ZSgnZi1mYW1pbHknLCBmb250QXJyW2ldLmZGYW1pbHkpO1xyXG4gICAgICAgICAgcy50eXBlID0gJ3RleHQvY3NzJztcclxuICAgICAgICAgIHMuaW5uZXJUZXh0ID0gJ0Bmb250LWZhY2Uge2ZvbnQtZmFtaWx5OiAnICsgZm9udEFycltpXS5mRmFtaWx5ICsgXCI7IGZvbnQtc3R5bGU6IG5vcm1hbDsgc3JjOiB1cmwoJ1wiICsgZm9udEFycltpXS5mUGF0aCArIFwiJyk7fVwiO1xyXG4gICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoZm9udEFycltpXS5mT3JpZ2luID09PSAnZycgfHwgZm9udEFycltpXS5vcmlnaW4gPT09IDEpIHtcclxuICAgICAgICBsb2FkZWRTZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZi1mb3JpZ2luPVwiZ1wiXSwgbGlua1tmLW9yaWdpbj1cIjFcIl0nKTtcclxuXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxvYWRlZFNlbGVjdG9yLmxlbmd0aDsgaiArPSAxKSB7XHJcbiAgICAgICAgICBpZiAobG9hZGVkU2VsZWN0b3Jbal0uaHJlZi5pbmRleE9mKGZvbnRBcnJbaV0uZlBhdGgpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBGb250IGlzIGFscmVhZHkgbG9hZGVkXHJcbiAgICAgICAgICAgIHNob3VsZExvYWRGb250ID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2hvdWxkTG9hZEZvbnQpIHtcclxuICAgICAgICAgIHZhciBsID0gY3JlYXRlVGFnKCdsaW5rJyk7XHJcbiAgICAgICAgICBsLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcclxuICAgICAgICAgIGwuc2V0QXR0cmlidXRlKCdmLW9yaWdpbicsIGZvbnRBcnJbaV0ub3JpZ2luKTtcclxuICAgICAgICAgIGwudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcbiAgICAgICAgICBsLnJlbCA9ICdzdHlsZXNoZWV0JztcclxuICAgICAgICAgIGwuaHJlZiA9IGZvbnRBcnJbaV0uZlBhdGg7XHJcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICd0JyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMikge1xyXG4gICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W2YtZm9yaWdpbj1cInRcIl0sIHNjcmlwdFtmLW9yaWdpbj1cIjJcIl0nKTtcclxuXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxvYWRlZFNlbGVjdG9yLmxlbmd0aDsgaiArPSAxKSB7XHJcbiAgICAgICAgICBpZiAoZm9udEFycltpXS5mUGF0aCA9PT0gbG9hZGVkU2VsZWN0b3Jbal0uc3JjKSB7XHJcbiAgICAgICAgICAgIC8vIEZvbnQgaXMgYWxyZWFkeSBsb2FkZWRcclxuICAgICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaG91bGRMb2FkRm9udCkge1xyXG4gICAgICAgICAgdmFyIHNjID0gY3JlYXRlVGFnKCdsaW5rJyk7XHJcbiAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ2YtZm9yaWdpbicsIGZvbnRBcnJbaV0uZk9yaWdpbik7XHJcbiAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ2Ytb3JpZ2luJywgZm9udEFycltpXS5vcmlnaW4pO1xyXG4gICAgICAgICAgc2Muc2V0QXR0cmlidXRlKCdyZWwnLCAnc3R5bGVzaGVldCcpO1xyXG4gICAgICAgICAgc2Muc2V0QXR0cmlidXRlKCdocmVmJywgZm9udEFycltpXS5mUGF0aCk7XHJcbiAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHNjKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZm9udEFycltpXS5oZWxwZXIgPSBjcmVhdGVIZWxwZXIoZGVmcywgZm9udEFycltpXSk7XHJcbiAgICAgIGZvbnRBcnJbaV0uY2FjaGUgPSB7fTtcclxuICAgICAgdGhpcy5mb250cy5wdXNoKGZvbnRBcnJbaV0pO1xyXG4gICAgfVxyXG4gICAgaWYgKF9wZW5kaW5nRm9udHMgPT09IDApIHtcclxuICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPbiBzb21lIGNhc2VzIGV2ZW4gaWYgdGhlIGZvbnQgaXMgbG9hZGVkLCBpdCB3b24ndCBsb2FkIGNvcnJlY3RseSB3aGVuIG1lYXN1cmluZyB0ZXh0IG9uIGNhbnZhcy5cclxuICAgICAgLy8gQWRkaW5nIHRoaXMgdGltZW91dCBzZWVtcyB0byBmaXggaXRcclxuICAgICAgc2V0VGltZW91dCh0aGlzLmNoZWNrTG9hZGVkRm9udHMuYmluZCh0aGlzKSwgMTAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZENoYXJzKGNoYXJzKSB7XHJcbiAgICBpZiAoIWNoYXJzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5jaGFycykge1xyXG4gICAgICB0aGlzLmNoYXJzID0gW107XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBjaGFycy5sZW5ndGg7XHJcbiAgICB2YXIgajtcclxuICAgIHZhciBqTGVuID0gdGhpcy5jaGFycy5sZW5ndGg7XHJcbiAgICB2YXIgZm91bmQ7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgaiA9IDA7XHJcbiAgICAgIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgIHdoaWxlIChqIDwgakxlbikge1xyXG4gICAgICAgIGlmICh0aGlzLmNoYXJzW2pdLnN0eWxlID09PSBjaGFyc1tpXS5zdHlsZSAmJiB0aGlzLmNoYXJzW2pdLmZGYW1pbHkgPT09IGNoYXJzW2ldLmZGYW1pbHkgJiYgdGhpcy5jaGFyc1tqXS5jaCA9PT0gY2hhcnNbaV0uY2gpIHtcclxuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaiArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghZm91bmQpIHtcclxuICAgICAgICB0aGlzLmNoYXJzLnB1c2goY2hhcnNbaV0pO1xyXG4gICAgICAgIGpMZW4gKz0gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q2hhckRhdGEoY2hhciwgc3R5bGUsIGZvbnQpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBsZW4gPSB0aGlzLmNoYXJzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgIGlmICh0aGlzLmNoYXJzW2ldLmNoID09PSBjaGFyICYmIHRoaXMuY2hhcnNbaV0uc3R5bGUgPT09IHN0eWxlICYmIHRoaXMuY2hhcnNbaV0uZkZhbWlseSA9PT0gZm9udCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJzW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIGlmICgoKHR5cGVvZiBjaGFyID09PSAnc3RyaW5nJyAmJiBjaGFyLmNoYXJDb2RlQXQoMCkgIT09IDEzKSB8fCAhY2hhcilcclxuICAgICAgICAgICAgJiYgY29uc29sZVxyXG4gICAgICAgICAgICAmJiBjb25zb2xlLndhcm4gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgICAgICYmICF0aGlzLl93YXJuZWRcclxuICAgICkge1xyXG4gICAgICB0aGlzLl93YXJuZWQgPSB0cnVlO1xyXG4gICAgICBjb25zb2xlLndhcm4oJ01pc3NpbmcgY2hhcmFjdGVyIGZyb20gZXhwb3J0ZWQgY2hhcmFjdGVycyBsaXN0OiAnLCBjaGFyLCBzdHlsZSwgZm9udCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVtcHR5Q2hhcjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1lYXN1cmVUZXh0KGNoYXIsIGZvbnROYW1lLCBzaXplKSB7XHJcbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdldEZvbnRCeU5hbWUoZm9udE5hbWUpO1xyXG4gICAgdmFyIGluZGV4ID0gY2hhci5jaGFyQ29kZUF0KDApO1xyXG4gICAgaWYgKCFmb250RGF0YS5jYWNoZVtpbmRleCArIDFdKSB7XHJcbiAgICAgIHZhciB0SGVscGVyID0gZm9udERhdGEuaGVscGVyO1xyXG4gICAgICAvLyBDYW52YXMgdmVyc2lvblxyXG4gICAgICAvLyBmb250RGF0YS5jYWNoZVtpbmRleF0gPSB0SGVscGVyLm1lYXN1cmVUZXh0KGNoYXIpLndpZHRoIC8gMTAwO1xyXG4gICAgICAvLyBTVkcgdmVyc2lvblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyh0SGVscGVyLmdldEJCb3goKS53aWR0aClcclxuICAgICAgaWYgKGNoYXIgPT09ICcgJykge1xyXG4gICAgICAgIHRIZWxwZXIudGV4dENvbnRlbnQgPSAnfCcgKyBjaGFyICsgJ3wnO1xyXG4gICAgICAgIHZhciBkb3VibGVTaXplID0gdEhlbHBlci5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcclxuICAgICAgICB0SGVscGVyLnRleHRDb250ZW50ID0gJ3x8JztcclxuICAgICAgICB2YXIgc2luZ2xlU2l6ZSA9IHRIZWxwZXIuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XHJcbiAgICAgICAgZm9udERhdGEuY2FjaGVbaW5kZXggKyAxXSA9IChkb3VibGVTaXplIC0gc2luZ2xlU2l6ZSkgLyAxMDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdEhlbHBlci50ZXh0Q29udGVudCA9IGNoYXI7XHJcbiAgICAgICAgZm9udERhdGEuY2FjaGVbaW5kZXggKyAxXSA9ICh0SGVscGVyLmdldENvbXB1dGVkVGV4dExlbmd0aCgpKSAvIDEwMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvbnREYXRhLmNhY2hlW2luZGV4ICsgMV0gKiBzaXplO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Rm9udEJ5TmFtZShuYW1lKSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5mb250cy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICBpZiAodGhpcy5mb250c1tpXS5mTmFtZSA9PT0gbmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRzW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmZvbnRzWzBdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNNb2RpZmllcihmaXJzdENoYXJDb2RlLCBzZWNvbmRDaGFyQ29kZSkge1xyXG4gICAgdmFyIHN1bSA9IGZpcnN0Q2hhckNvZGUudG9TdHJpbmcoMTYpICsgc2Vjb25kQ2hhckNvZGUudG9TdHJpbmcoMTYpO1xyXG4gICAgcmV0dXJuIHN1cnJvZ2F0ZU1vZGlmaWVycy5pbmRleE9mKHN1bSkgIT09IC0xO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNaZXJvV2lkdGhKb2luZXIoZmlyc3RDaGFyQ29kZSwgc2Vjb25kQ2hhckNvZGUpIHtcclxuICAgIGlmICghc2Vjb25kQ2hhckNvZGUpIHtcclxuICAgICAgcmV0dXJuIGZpcnN0Q2hhckNvZGUgPT09IHplcm9XaWR0aEpvaW5lclsxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmaXJzdENoYXJDb2RlID09PSB6ZXJvV2lkdGhKb2luZXJbMF0gJiYgc2Vjb25kQ2hhckNvZGUgPT09IHplcm9XaWR0aEpvaW5lclsxXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzQ29tYmluZWRDaGFyYWN0ZXIoY2hhcikge1xyXG4gICAgcmV0dXJuIGNvbWJpbmVkQ2hhcmFjdGVycy5pbmRleE9mKGNoYXIpICE9PSAtMTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldElzTG9hZGVkKCkge1xyXG4gICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgRm9udCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZm9udHMgPSBbXTtcclxuICAgIHRoaXMuY2hhcnMgPSBudWxsO1xyXG4gICAgdGhpcy50eXBla2l0TG9hZGVkID0gMDtcclxuICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3dhcm5lZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5pbml0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICB0aGlzLnNldElzTG9hZGVkQmluZGVkID0gdGhpcy5zZXRJc0xvYWRlZC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5jaGVja0xvYWRlZEZvbnRzQmluZGVkID0gdGhpcy5jaGVja0xvYWRlZEZvbnRzLmJpbmQodGhpcyk7XHJcbiAgfTtcclxuICBGb250LmlzTW9kaWZpZXIgPSBpc01vZGlmaWVyO1xyXG4gIEZvbnQuaXNaZXJvV2lkdGhKb2luZXIgPSBpc1plcm9XaWR0aEpvaW5lcjtcclxuICBGb250LmlzQ29tYmluZWRDaGFyYWN0ZXIgPSBpc0NvbWJpbmVkQ2hhcmFjdGVyO1xyXG5cclxuICB2YXIgZm9udFByb3RvdHlwZSA9IHtcclxuICAgIGFkZENoYXJzOiBhZGRDaGFycyxcclxuICAgIGFkZEZvbnRzOiBhZGRGb250cyxcclxuICAgIGdldENoYXJEYXRhOiBnZXRDaGFyRGF0YSxcclxuICAgIGdldEZvbnRCeU5hbWU6IGdldEZvbnRCeU5hbWUsXHJcbiAgICBtZWFzdXJlVGV4dDogbWVhc3VyZVRleHQsXHJcbiAgICBjaGVja0xvYWRlZEZvbnRzOiBjaGVja0xvYWRlZEZvbnRzLFxyXG4gICAgc2V0SXNMb2FkZWQ6IHNldElzTG9hZGVkLFxyXG4gIH07XHJcblxyXG4gIEZvbnQucHJvdG90eXBlID0gZm9udFByb3RvdHlwZTtcclxuXHJcbiAgcmV0dXJuIEZvbnQ7XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgaW5pdGlhbERlZmF1bHRGcmFtZSwgQmV6aWVyRmFjdG9yeSwgZGVnVG9SYWRzLCBiZXosIGNyZWF0ZVR5cGVkQXJyYXkgKi9cclxuLyogZXhwb3J0ZWQgUHJvcGVydHlGYWN0b3J5ICovXHJcblxyXG52YXIgUHJvcGVydHlGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaW5pdEZyYW1lID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcclxuICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xyXG5cclxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCBjYWNoaW5nKSB7XHJcbiAgICB2YXIgb2Zmc2V0VGltZSA9IHRoaXMub2Zmc2V0VGltZTtcclxuICAgIHZhciBuZXdWYWx1ZTtcclxuICAgIGlmICh0aGlzLnByb3BUeXBlID09PSAnbXVsdGlkaW1lbnNpb25hbCcpIHtcclxuICAgICAgbmV3VmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgdGhpcy5wdi5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgdmFyIGl0ZXJhdGlvbkluZGV4ID0gY2FjaGluZy5sYXN0SW5kZXg7XHJcbiAgICB2YXIgaSA9IGl0ZXJhdGlvbkluZGV4O1xyXG4gICAgdmFyIGxlbiA9IHRoaXMua2V5ZnJhbWVzLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgZmxhZyA9IHRydWU7XHJcbiAgICB2YXIga2V5RGF0YTtcclxuICAgIHZhciBuZXh0S2V5RGF0YTtcclxuXHJcbiAgICB3aGlsZSAoZmxhZykge1xyXG4gICAgICBrZXlEYXRhID0gdGhpcy5rZXlmcmFtZXNbaV07XHJcbiAgICAgIG5leHRLZXlEYXRhID0gdGhpcy5rZXlmcmFtZXNbaSArIDFdO1xyXG4gICAgICBpZiAoaSA9PT0gbGVuIC0gMSAmJiBmcmFtZU51bSA+PSBuZXh0S2V5RGF0YS50IC0gb2Zmc2V0VGltZSkge1xyXG4gICAgICAgIGlmIChrZXlEYXRhLmgpIHtcclxuICAgICAgICAgIGtleURhdGEgPSBuZXh0S2V5RGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSAwO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgobmV4dEtleURhdGEudCAtIG9mZnNldFRpbWUpID4gZnJhbWVOdW0pIHtcclxuICAgICAgICBpdGVyYXRpb25JbmRleCA9IGk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGkgPCBsZW4gLSAxKSB7XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gMDtcclxuICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaztcclxuICAgIHZhciBrTGVuO1xyXG4gICAgdmFyIHBlcmM7XHJcbiAgICB2YXIgakxlbjtcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIGZuYztcclxuICAgIHZhciBuZXh0S2V5VGltZSA9IG5leHRLZXlEYXRhLnQgLSBvZmZzZXRUaW1lO1xyXG4gICAgdmFyIGtleVRpbWUgPSBrZXlEYXRhLnQgLSBvZmZzZXRUaW1lO1xyXG4gICAgdmFyIGVuZFZhbHVlO1xyXG4gICAgaWYgKGtleURhdGEudG8pIHtcclxuICAgICAgaWYgKCFrZXlEYXRhLmJlemllckRhdGEpIHtcclxuICAgICAgICBrZXlEYXRhLmJlemllckRhdGEgPSBiZXouYnVpbGRCZXppZXJEYXRhKGtleURhdGEucywgbmV4dEtleURhdGEucyB8fCBrZXlEYXRhLmUsIGtleURhdGEudG8sIGtleURhdGEudGkpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBiZXppZXJEYXRhID0ga2V5RGF0YS5iZXppZXJEYXRhO1xyXG4gICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUgfHwgZnJhbWVOdW0gPCBrZXlUaW1lKSB7XHJcbiAgICAgICAgdmFyIGluZCA9IGZyYW1lTnVtID49IG5leHRLZXlUaW1lID8gYmV6aWVyRGF0YS5wb2ludHMubGVuZ3RoIC0gMSA6IDA7XHJcbiAgICAgICAga0xlbiA9IGJlemllckRhdGEucG9pbnRzW2luZF0ucG9pbnQubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcclxuICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbaW5kXS5wb2ludFtrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPSAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoa2V5RGF0YS5fX2ZuY3QpIHtcclxuICAgICAgICAgIGZuYyA9IGtleURhdGEuX19mbmN0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhrZXlEYXRhLm8ueCwga2V5RGF0YS5vLnksIGtleURhdGEuaS54LCBrZXlEYXRhLmkueSwga2V5RGF0YS5uKS5nZXQ7XHJcbiAgICAgICAgICBrZXlEYXRhLl9fZm5jdCA9IGZuYztcclxuICAgICAgICB9XHJcbiAgICAgICAgcGVyYyA9IGZuYygoZnJhbWVOdW0gLSBrZXlUaW1lKSAvIChuZXh0S2V5VGltZSAtIGtleVRpbWUpKTtcclxuICAgICAgICB2YXIgZGlzdGFuY2VJbkxpbmUgPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGggKiBwZXJjO1xyXG5cclxuICAgICAgICB2YXIgc2VnbWVudFBlcmM7XHJcbiAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gKGNhY2hpbmcubGFzdEZyYW1lIDwgZnJhbWVOdW0gJiYgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPT09IGkpID8gY2FjaGluZy5fbGFzdEFkZGVkTGVuZ3RoIDogMDtcclxuICAgICAgICBqID0gKGNhY2hpbmcubGFzdEZyYW1lIDwgZnJhbWVOdW0gJiYgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPT09IGkpID8gY2FjaGluZy5fbGFzdFBvaW50IDogMDtcclxuICAgICAgICBmbGFnID0gdHJ1ZTtcclxuICAgICAgICBqTGVuID0gYmV6aWVyRGF0YS5wb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChmbGFnKSB7XHJcbiAgICAgICAgICBhZGRlZExlbmd0aCArPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKGRpc3RhbmNlSW5MaW5lID09PSAwIHx8IHBlcmMgPT09IDAgfHwgaiA9PT0gYmV6aWVyRGF0YS5wb2ludHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBrTGVuID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XHJcbiAgICAgICAgICAgICAgbmV3VmFsdWVba10gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludFtrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2VJbkxpbmUgPj0gYWRkZWRMZW5ndGggJiYgZGlzdGFuY2VJbkxpbmUgPCBhZGRlZExlbmd0aCArIGJlemllckRhdGEucG9pbnRzW2ogKyAxXS5wYXJ0aWFsTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHNlZ21lbnRQZXJjID0gKGRpc3RhbmNlSW5MaW5lIC0gYWRkZWRMZW5ndGgpIC8gYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBhcnRpYWxMZW5ndGg7XHJcbiAgICAgICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcclxuICAgICAgICAgICAgICBuZXdWYWx1ZVtrXSA9IGJlemllckRhdGEucG9pbnRzW2pdLnBvaW50W2tdICsgKGJlemllckRhdGEucG9pbnRzW2ogKyAxXS5wb2ludFtrXSAtIGJlemllckRhdGEucG9pbnRzW2pdLnBvaW50W2tdKSAqIHNlZ21lbnRQZXJjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGogPCBqTGVuIC0gMSkge1xyXG4gICAgICAgICAgICBqICs9IDE7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhY2hpbmcuX2xhc3RQb2ludCA9IGo7XHJcbiAgICAgICAgY2FjaGluZy5fbGFzdEFkZGVkTGVuZ3RoID0gYWRkZWRMZW5ndGggLSBiZXppZXJEYXRhLnBvaW50c1tqXS5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgIGNhY2hpbmcuX2xhc3RLZXlmcmFtZUluZGV4ID0gaTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIG91dFg7XHJcbiAgICAgIHZhciBvdXRZO1xyXG4gICAgICB2YXIgaW5YO1xyXG4gICAgICB2YXIgaW5ZO1xyXG4gICAgICB2YXIga2V5VmFsdWU7XHJcbiAgICAgIGxlbiA9IGtleURhdGEucy5sZW5ndGg7XHJcbiAgICAgIGVuZFZhbHVlID0gbmV4dEtleURhdGEucyB8fCBrZXlEYXRhLmU7XHJcbiAgICAgIGlmICh0aGlzLnNoICYmIGtleURhdGEuaCAhPT0gMSkge1xyXG4gICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5VGltZSkge1xyXG4gICAgICAgICAgbmV3VmFsdWVbMF0gPSBlbmRWYWx1ZVswXTtcclxuICAgICAgICAgIG5ld1ZhbHVlWzFdID0gZW5kVmFsdWVbMV07XHJcbiAgICAgICAgICBuZXdWYWx1ZVsyXSA9IGVuZFZhbHVlWzJdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZnJhbWVOdW0gPD0ga2V5VGltZSkge1xyXG4gICAgICAgICAgbmV3VmFsdWVbMF0gPSBrZXlEYXRhLnNbMF07XHJcbiAgICAgICAgICBuZXdWYWx1ZVsxXSA9IGtleURhdGEuc1sxXTtcclxuICAgICAgICAgIG5ld1ZhbHVlWzJdID0ga2V5RGF0YS5zWzJdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgcXVhdFN0YXJ0ID0gY3JlYXRlUXVhdGVybmlvbihrZXlEYXRhLnMpO1xyXG4gICAgICAgICAgdmFyIHF1YXRFbmQgPSBjcmVhdGVRdWF0ZXJuaW9uKGVuZFZhbHVlKTtcclxuICAgICAgICAgIHZhciB0aW1lID0gKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKTtcclxuICAgICAgICAgIHF1YXRlcm5pb25Ub0V1bGVyKG5ld1ZhbHVlLCBzbGVycChxdWF0U3RhcnQsIHF1YXRFbmQsIHRpbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICBpZiAoa2V5RGF0YS5oICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5VGltZSkge1xyXG4gICAgICAgICAgICAgIHBlcmMgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDwga2V5VGltZSkge1xyXG4gICAgICAgICAgICAgIHBlcmMgPSAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChrZXlEYXRhLm8ueC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICgha2V5RGF0YS5fX2ZuY3QpIHtcclxuICAgICAgICAgICAgICAgICAga2V5RGF0YS5fX2ZuY3QgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgha2V5RGF0YS5fX2ZuY3RbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgb3V0WCA9ICh0eXBlb2Yga2V5RGF0YS5vLnhbaV0gPT09ICd1bmRlZmluZWQnKSA/IGtleURhdGEuby54WzBdIDoga2V5RGF0YS5vLnhbaV07XHJcbiAgICAgICAgICAgICAgICAgIG91dFkgPSAodHlwZW9mIGtleURhdGEuby55W2ldID09PSAndW5kZWZpbmVkJykgPyBrZXlEYXRhLm8ueVswXSA6IGtleURhdGEuby55W2ldO1xyXG4gICAgICAgICAgICAgICAgICBpblggPSAodHlwZW9mIGtleURhdGEuaS54W2ldID09PSAndW5kZWZpbmVkJykgPyBrZXlEYXRhLmkueFswXSA6IGtleURhdGEuaS54W2ldO1xyXG4gICAgICAgICAgICAgICAgICBpblkgPSAodHlwZW9mIGtleURhdGEuaS55W2ldID09PSAndW5kZWZpbmVkJykgPyBrZXlEYXRhLmkueVswXSA6IGtleURhdGEuaS55W2ldO1xyXG4gICAgICAgICAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhvdXRYLCBvdXRZLCBpblgsIGluWSkuZ2V0O1xyXG4gICAgICAgICAgICAgICAgICBrZXlEYXRhLl9fZm5jdFtpXSA9IGZuYztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGZuYyA9IGtleURhdGEuX19mbmN0W2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWtleURhdGEuX19mbmN0KSB7XHJcbiAgICAgICAgICAgICAgICBvdXRYID0ga2V5RGF0YS5vLng7XHJcbiAgICAgICAgICAgICAgICBvdXRZID0ga2V5RGF0YS5vLnk7XHJcbiAgICAgICAgICAgICAgICBpblggPSBrZXlEYXRhLmkueDtcclxuICAgICAgICAgICAgICAgIGluWSA9IGtleURhdGEuaS55O1xyXG4gICAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcob3V0WCwgb3V0WSwgaW5YLCBpblkpLmdldDtcclxuICAgICAgICAgICAgICAgIGtleURhdGEuX19mbmN0ID0gZm5jO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmbmMgPSBrZXlEYXRhLl9fZm5jdDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcGVyYyA9IGZuYygoZnJhbWVOdW0gLSBrZXlUaW1lKSAvIChuZXh0S2V5VGltZSAtIGtleVRpbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGVuZFZhbHVlID0gbmV4dEtleURhdGEucyB8fCBrZXlEYXRhLmU7XHJcbiAgICAgICAgICBrZXlWYWx1ZSA9IGtleURhdGEuaCA9PT0gMSA/IGtleURhdGEuc1tpXSA6IGtleURhdGEuc1tpXSArIChlbmRWYWx1ZVtpXSAtIGtleURhdGEuc1tpXSkgKiBwZXJjO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLnByb3BUeXBlID09PSAnbXVsdGlkaW1lbnNpb25hbCcpIHtcclxuICAgICAgICAgICAgbmV3VmFsdWVbaV0gPSBrZXlWYWx1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0ga2V5VmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjYWNoaW5nLmxhc3RJbmRleCA9IGl0ZXJhdGlvbkluZGV4O1xyXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLy8gYmFzZWQgb24gQFRvamkncyBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvXHJcbiAgZnVuY3Rpb24gc2xlcnAoYSwgYiwgdCkge1xyXG4gICAgdmFyIG91dCA9IFtdO1xyXG4gICAgdmFyIGF4ID0gYVswXTtcclxuICAgIHZhciBheSA9IGFbMV07XHJcbiAgICB2YXIgYXogPSBhWzJdO1xyXG4gICAgdmFyIGF3ID0gYVszXTtcclxuICAgIHZhciBieCA9IGJbMF07XHJcbiAgICB2YXIgYnkgPSBiWzFdO1xyXG4gICAgdmFyIGJ6ID0gYlsyXTtcclxuICAgIHZhciBidyA9IGJbM107XHJcblxyXG4gICAgdmFyIG9tZWdhO1xyXG4gICAgdmFyIGNvc29tO1xyXG4gICAgdmFyIHNpbm9tO1xyXG4gICAgdmFyIHNjYWxlMDtcclxuICAgIHZhciBzY2FsZTE7XHJcblxyXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xyXG4gICAgaWYgKGNvc29tIDwgMC4wKSB7XHJcbiAgICAgIGNvc29tID0gLWNvc29tO1xyXG4gICAgICBieCA9IC1ieDtcclxuICAgICAgYnkgPSAtYnk7XHJcbiAgICAgIGJ6ID0gLWJ6O1xyXG4gICAgICBidyA9IC1idztcclxuICAgIH1cclxuICAgIGlmICgoMS4wIC0gY29zb20pID4gMC4wMDAwMDEpIHtcclxuICAgICAgb21lZ2EgPSBNYXRoLmFjb3MoY29zb20pO1xyXG4gICAgICBzaW5vbSA9IE1hdGguc2luKG9tZWdhKTtcclxuICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XHJcbiAgICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XHJcbiAgICAgIHNjYWxlMSA9IHQ7XHJcbiAgICB9XHJcbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xyXG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcclxuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XHJcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBxdWF0ZXJuaW9uVG9FdWxlcihvdXQsIHF1YXQpIHtcclxuICAgIHZhciBxeCA9IHF1YXRbMF07XHJcbiAgICB2YXIgcXkgPSBxdWF0WzFdO1xyXG4gICAgdmFyIHF6ID0gcXVhdFsyXTtcclxuICAgIHZhciBxdyA9IHF1YXRbM107XHJcbiAgICB2YXIgaGVhZGluZyA9IE1hdGguYXRhbjIoMiAqIHF5ICogcXcgLSAyICogcXggKiBxeiwgMSAtIDIgKiBxeSAqIHF5IC0gMiAqIHF6ICogcXopO1xyXG4gICAgdmFyIGF0dGl0dWRlID0gTWF0aC5hc2luKDIgKiBxeCAqIHF5ICsgMiAqIHF6ICogcXcpO1xyXG4gICAgdmFyIGJhbmsgPSBNYXRoLmF0YW4yKDIgKiBxeCAqIHF3IC0gMiAqIHF5ICogcXosIDEgLSAyICogcXggKiBxeCAtIDIgKiBxeiAqIHF6KTtcclxuICAgIG91dFswXSA9IGhlYWRpbmcgLyBkZWdUb1JhZHM7XHJcbiAgICBvdXRbMV0gPSBhdHRpdHVkZSAvIGRlZ1RvUmFkcztcclxuICAgIG91dFsyXSA9IGJhbmsgLyBkZWdUb1JhZHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVRdWF0ZXJuaW9uKHZhbHVlcykge1xyXG4gICAgdmFyIGhlYWRpbmcgPSB2YWx1ZXNbMF0gKiBkZWdUb1JhZHM7XHJcbiAgICB2YXIgYXR0aXR1ZGUgPSB2YWx1ZXNbMV0gKiBkZWdUb1JhZHM7XHJcbiAgICB2YXIgYmFuayA9IHZhbHVlc1syXSAqIGRlZ1RvUmFkcztcclxuICAgIHZhciBjMSA9IE1hdGguY29zKGhlYWRpbmcgLyAyKTtcclxuICAgIHZhciBjMiA9IE1hdGguY29zKGF0dGl0dWRlIC8gMik7XHJcbiAgICB2YXIgYzMgPSBNYXRoLmNvcyhiYW5rIC8gMik7XHJcbiAgICB2YXIgczEgPSBNYXRoLnNpbihoZWFkaW5nIC8gMik7XHJcbiAgICB2YXIgczIgPSBNYXRoLnNpbihhdHRpdHVkZSAvIDIpO1xyXG4gICAgdmFyIHMzID0gTWF0aC5zaW4oYmFuayAvIDIpO1xyXG4gICAgdmFyIHcgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcbiAgICB2YXIgeCA9IHMxICogczIgKiBjMyArIGMxICogYzIgKiBzMztcclxuICAgIHZhciB5ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG4gICAgdmFyIHogPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblxyXG4gICAgcmV0dXJuIFt4LCB5LCB6LCB3XTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFZhbHVlQXRDdXJyZW50VGltZSgpIHtcclxuICAgIHZhciBmcmFtZU51bSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC0gdGhpcy5vZmZzZXRUaW1lO1xyXG4gICAgdmFyIGluaXRUaW1lID0gdGhpcy5rZXlmcmFtZXNbMF0udCAtIHRoaXMub2Zmc2V0VGltZTtcclxuICAgIHZhciBlbmRUaW1lID0gdGhpcy5rZXlmcmFtZXNbdGhpcy5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIHRoaXMub2Zmc2V0VGltZTtcclxuICAgIGlmICghKGZyYW1lTnVtID09PSB0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSB8fCAodGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgIT09IGluaXRGcmFtZSAmJiAoKHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID49IGVuZFRpbWUgJiYgZnJhbWVOdW0gPj0gZW5kVGltZSkgfHwgKHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lIDwgaW5pdFRpbWUgJiYgZnJhbWVOdW0gPCBpbml0VGltZSkpKSkpIHtcclxuICAgICAgaWYgKHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID49IGZyYW1lTnVtKSB7XHJcbiAgICAgICAgdGhpcy5fY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPSAtMTtcclxuICAgICAgICB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZW5kZXJSZXN1bHQgPSB0aGlzLmludGVycG9sYXRlVmFsdWUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmcpO1xyXG4gICAgICB0aGlzLnB2ID0gcmVuZGVyUmVzdWx0O1xyXG4gICAgfVxyXG4gICAgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPSBmcmFtZU51bTtcclxuICAgIHJldHVybiB0aGlzLnB2O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0VlZhbHVlKHZhbCkge1xyXG4gICAgdmFyIG11bHRpcGxpZWRWYWx1ZTtcclxuICAgIGlmICh0aGlzLnByb3BUeXBlID09PSAndW5pZGltZW5zaW9uYWwnKSB7XHJcbiAgICAgIG11bHRpcGxpZWRWYWx1ZSA9IHZhbCAqIHRoaXMubXVsdDtcclxuICAgICAgaWYgKG1hdGhBYnModGhpcy52IC0gbXVsdGlwbGllZFZhbHVlKSA+IDAuMDAwMDEpIHtcclxuICAgICAgICB0aGlzLnYgPSBtdWx0aXBsaWVkVmFsdWU7XHJcbiAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy52Lmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBtdWx0aXBsaWVkVmFsdWUgPSB2YWxbaV0gKiB0aGlzLm11bHQ7XHJcbiAgICAgICAgaWYgKG1hdGhBYnModGhpcy52W2ldIC0gbXVsdGlwbGllZFZhbHVlKSA+IDAuMDAwMDEpIHtcclxuICAgICAgICAgIHRoaXMudltpXSA9IG11bHRpcGxpZWRWYWx1ZTtcclxuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZSgpIHtcclxuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgfHwgIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5sb2NrKSB7XHJcbiAgICAgIHRoaXMuc2V0VlZhbHVlKHRoaXMucHYpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvY2sgPSB0cnVlO1xyXG4gICAgdGhpcy5fbWRmID0gdGhpcy5faXNGaXJzdEZyYW1lO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xyXG4gICAgdmFyIGZpbmFsVmFsdWUgPSB0aGlzLmtmID8gdGhpcy5wdiA6IHRoaXMuZGF0YS5rO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZVtpXShmaW5hbFZhbHVlKTtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0VlZhbHVlKGZpbmFsVmFsdWUpO1xyXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XHJcbiAgICB0aGlzLmxvY2sgPSBmYWxzZTtcclxuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRFZmZlY3QoZWZmZWN0RnVuY3Rpb24pIHtcclxuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xyXG4gICAgdGhpcy5jb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpIHtcclxuICAgIHRoaXMucHJvcFR5cGUgPSAndW5pZGltZW5zaW9uYWwnO1xyXG4gICAgdGhpcy5tdWx0ID0gbXVsdCB8fCAxO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMudiA9IG11bHQgPyBkYXRhLmsgKiBtdWx0IDogZGF0YS5rO1xyXG4gICAgdGhpcy5wdiA9IGRhdGEuaztcclxuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgdGhpcy5rID0gZmFsc2U7XHJcbiAgICB0aGlzLmtmID0gZmFsc2U7XHJcbiAgICB0aGlzLnZlbCA9IDA7XHJcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xyXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuICAgIHRoaXMuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xyXG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XHJcbiAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIE11bHRpRGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpIHtcclxuICAgIHRoaXMucHJvcFR5cGUgPSAnbXVsdGlkaW1lbnNpb25hbCc7XHJcbiAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgIHRoaXMua2YgPSBmYWxzZTtcclxuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gZGF0YS5rLmxlbmd0aDtcclxuICAgIHRoaXMudiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgdGhpcy5wdiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgdGhpcy52ZWwgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICB0aGlzLnZbaV0gPSBkYXRhLmtbaV0gKiB0aGlzLm11bHQ7XHJcbiAgICAgIHRoaXMucHZbaV0gPSBkYXRhLmtbaV07XHJcbiAgICB9XHJcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcclxuICAgIHRoaXMuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xyXG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XHJcbiAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIEtleWZyYW1lZFZhbHVlUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLnByb3BUeXBlID0gJ3VuaWRpbWVuc2lvbmFsJztcclxuICAgIHRoaXMua2V5ZnJhbWVzID0gZGF0YS5rO1xyXG4gICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xyXG4gICAgdGhpcy5mcmFtZUlkID0gLTE7XHJcbiAgICB0aGlzLl9jYWNoaW5nID0ge1xyXG4gICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSwgbGFzdEluZGV4OiAwLCB2YWx1ZTogMCwgX2xhc3RLZXlmcmFtZUluZGV4OiAtMSxcclxuICAgIH07XHJcbiAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgdGhpcy5rZiA9IHRydWU7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5tdWx0ID0gbXVsdCB8fCAxO1xyXG4gICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgdGhpcy52ID0gaW5pdEZyYW1lO1xyXG4gICAgdGhpcy5wdiA9IGluaXRGcmFtZTtcclxuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcclxuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xyXG4gICAgdGhpcy5pbnRlcnBvbGF0ZVZhbHVlID0gaW50ZXJwb2xhdGVWYWx1ZTtcclxuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW2dldFZhbHVlQXRDdXJyZW50VGltZS5iaW5kKHRoaXMpXTtcclxuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gS2V5ZnJhbWVkTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xyXG4gICAgdGhpcy5wcm9wVHlwZSA9ICdtdWx0aWRpbWVuc2lvbmFsJztcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGRhdGEuay5sZW5ndGg7XHJcbiAgICB2YXIgcztcclxuICAgIHZhciBlO1xyXG4gICAgdmFyIHRvO1xyXG4gICAgdmFyIHRpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkgKz0gMSkge1xyXG4gICAgICBpZiAoZGF0YS5rW2ldLnRvICYmIGRhdGEua1tpXS5zICYmIGRhdGEua1tpICsgMV0gJiYgZGF0YS5rW2kgKyAxXS5zKSB7XHJcbiAgICAgICAgcyA9IGRhdGEua1tpXS5zO1xyXG4gICAgICAgIGUgPSBkYXRhLmtbaSArIDFdLnM7XHJcbiAgICAgICAgdG8gPSBkYXRhLmtbaV0udG87XHJcbiAgICAgICAgdGkgPSBkYXRhLmtbaV0udGk7XHJcbiAgICAgICAgaWYgKChzLmxlbmd0aCA9PT0gMiAmJiAhKHNbMF0gPT09IGVbMF0gJiYgc1sxXSA9PT0gZVsxXSkgJiYgYmV6LnBvaW50T25MaW5lMkQoc1swXSwgc1sxXSwgZVswXSwgZVsxXSwgc1swXSArIHRvWzBdLCBzWzFdICsgdG9bMV0pICYmIGJlei5wb2ludE9uTGluZTJEKHNbMF0sIHNbMV0sIGVbMF0sIGVbMV0sIGVbMF0gKyB0aVswXSwgZVsxXSArIHRpWzFdKSkgfHwgKHMubGVuZ3RoID09PSAzICYmICEoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdICYmIHNbMl0gPT09IGVbMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIHNbMF0gKyB0b1swXSwgc1sxXSArIHRvWzFdLCBzWzJdICsgdG9bMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIGVbMF0gKyB0aVswXSwgZVsxXSArIHRpWzFdLCBlWzJdICsgdGlbMl0pKSkge1xyXG4gICAgICAgICAgZGF0YS5rW2ldLnRvID0gbnVsbDtcclxuICAgICAgICAgIGRhdGEua1tpXS50aSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzWzBdID09PSBlWzBdICYmIHNbMV0gPT09IGVbMV0gJiYgdG9bMF0gPT09IDAgJiYgdG9bMV0gPT09IDAgJiYgdGlbMF0gPT09IDAgJiYgdGlbMV0gPT09IDApIHtcclxuICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMiB8fCAoc1syXSA9PT0gZVsyXSAmJiB0b1syXSA9PT0gMCAmJiB0aVsyXSA9PT0gMCkpIHtcclxuICAgICAgICAgICAgZGF0YS5rW2ldLnRvID0gbnVsbDtcclxuICAgICAgICAgICAgZGF0YS5rW2ldLnRpID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW2dldFZhbHVlQXRDdXJyZW50VGltZS5iaW5kKHRoaXMpXTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLmtleWZyYW1lcyA9IGRhdGEuaztcclxuICAgIHRoaXMub2Zmc2V0VGltZSA9IGVsZW0uZGF0YS5zdDtcclxuICAgIHRoaXMuayA9IHRydWU7XHJcbiAgICB0aGlzLmtmID0gdHJ1ZTtcclxuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcclxuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xyXG4gICAgdGhpcy5pbnRlcnBvbGF0ZVZhbHVlID0gaW50ZXJwb2xhdGVWYWx1ZTtcclxuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xyXG4gICAgdmFyIGFyckxlbiA9IGRhdGEua1swXS5zLmxlbmd0aDtcclxuICAgIHRoaXMudiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pO1xyXG4gICAgdGhpcy5wdiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGFyckxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHRoaXMudltpXSA9IGluaXRGcmFtZTtcclxuICAgICAgdGhpcy5wdltpXSA9IGluaXRGcmFtZTtcclxuICAgIH1cclxuICAgIHRoaXMuX2NhY2hpbmcgPSB7IGxhc3RGcmFtZTogaW5pdEZyYW1lLCBsYXN0SW5kZXg6IDAsIHZhbHVlOiBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgYXJyTGVuKSB9O1xyXG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQcm9wKGVsZW0sIGRhdGEsIHR5cGUsIG11bHQsIGNvbnRhaW5lcikge1xyXG4gICAgdmFyIHA7XHJcbiAgICBpZiAoIWRhdGEuay5sZW5ndGgpIHtcclxuICAgICAgcCA9IG5ldyBWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiAoZGF0YS5rWzBdKSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgcCA9IG5ldyBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgIHAgPSBuZXcgS2V5ZnJhbWVkVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcCA9IG5ldyBLZXlmcmFtZWRNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHAuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xyXG4gICAgICBjb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbiAgfVxyXG5cclxuICB2YXIgb2IgPSB7XHJcbiAgICBnZXRQcm9wOiBnZXRQcm9wLFxyXG4gIH07XHJcbiAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIE1hdHJpeCwgZGVnVG9SYWRzLCBQcm9wZXJ0eUZhY3RvcnksIGV4dGVuZFByb3RvdHlwZSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyICovXHJcbi8qIGV4cG9ydGVkIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSAqL1xyXG5cclxudmFyIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGRlZmF1bHRWZWN0b3IgPSBbMCwgMF07XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5VG9NYXRyaXgobWF0KSB7XHJcbiAgICB2YXIgX21kZiA9IHRoaXMuX21kZjtcclxuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XHJcbiAgICB0aGlzLl9tZGYgPSB0aGlzLl9tZGYgfHwgX21kZjtcclxuICAgIGlmICh0aGlzLmEpIHtcclxuICAgICAgbWF0LnRyYW5zbGF0ZSgtdGhpcy5hLnZbMF0sIC10aGlzLmEudlsxXSwgdGhpcy5hLnZbMl0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucykge1xyXG4gICAgICBtYXQuc2NhbGUodGhpcy5zLnZbMF0sIHRoaXMucy52WzFdLCB0aGlzLnMudlsyXSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zaykge1xyXG4gICAgICBtYXQuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yKSB7XHJcbiAgICAgIG1hdC5yb3RhdGUoLXRoaXMuci52KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1hdC5yb3RhdGVaKC10aGlzLnJ6LnYpLnJvdGF0ZVkodGhpcy5yeS52KS5yb3RhdGVYKHRoaXMucngudikucm90YXRlWigtdGhpcy5vci52WzJdKVxyXG4gICAgICAgIC5yb3RhdGVZKHRoaXMub3IudlsxXSlcclxuICAgICAgICAucm90YXRlWCh0aGlzLm9yLnZbMF0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZGF0YS5wLnMpIHtcclxuICAgICAgaWYgKHRoaXMuZGF0YS5wLnopIHtcclxuICAgICAgICBtYXQudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAtdGhpcy5wei52KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXQudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAwKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnAudlswXSwgdGhpcy5wLnZbMV0sIC10aGlzLnAudlsyXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHByb2Nlc3NLZXlzKGZvcmNlUmVuZGVyKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9pc0RpcnR5KSB7XHJcbiAgICAgIHRoaXMucHJlY2FsY3VsYXRlTWF0cml4KCk7XHJcbiAgICAgIHRoaXMuX2lzRGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xyXG5cclxuICAgIGlmICh0aGlzLl9tZGYgfHwgZm9yY2VSZW5kZXIpIHtcclxuICAgICAgdmFyIGZyYW1lUmF0ZTtcclxuICAgICAgdGhpcy52LmNsb25lRnJvbVByb3BzKHRoaXMucHJlLnByb3BzKTtcclxuICAgICAgaWYgKHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDEpIHtcclxuICAgICAgICB0aGlzLnYudHJhbnNsYXRlKC10aGlzLmEudlswXSwgLXRoaXMuYS52WzFdLCB0aGlzLmEudlsyXSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDIpIHtcclxuICAgICAgICB0aGlzLnYuc2NhbGUodGhpcy5zLnZbMF0sIHRoaXMucy52WzFdLCB0aGlzLnMudlsyXSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc2sgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMykge1xyXG4gICAgICAgIHRoaXMudi5za2V3RnJvbUF4aXMoLXRoaXMuc2sudiwgdGhpcy5zYS52KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcclxuICAgICAgICB0aGlzLnYucm90YXRlKC10aGlzLnIudik7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XHJcbiAgICAgICAgdGhpcy52LnJvdGF0ZVooLXRoaXMucnoudikucm90YXRlWSh0aGlzLnJ5LnYpLnJvdGF0ZVgodGhpcy5yeC52KS5yb3RhdGVaKC10aGlzLm9yLnZbMl0pXHJcbiAgICAgICAgICAucm90YXRlWSh0aGlzLm9yLnZbMV0pXHJcbiAgICAgICAgICAucm90YXRlWCh0aGlzLm9yLnZbMF0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmF1dG9PcmllbnRlZCkge1xyXG4gICAgICAgIHZhciB2MTtcclxuICAgICAgICB2YXIgdjI7XHJcbiAgICAgICAgZnJhbWVSYXRlID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgICAgIGlmICh0aGlzLnAgJiYgdGhpcy5wLmtleWZyYW1lcyAmJiB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUpIHtcclxuICAgICAgICAgIGlmICh0aGlzLnAuX2NhY2hpbmcubGFzdEZyYW1lICsgdGhpcy5wLm9mZnNldFRpbWUgPD0gdGhpcy5wLmtleWZyYW1lc1swXS50KSB7XHJcbiAgICAgICAgICAgIHYxID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKHRoaXMucC5rZXlmcmFtZXNbMF0udCAvIGZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucC5fY2FjaGluZy5sYXN0RnJhbWUgKyB0aGlzLnAub2Zmc2V0VGltZSA+PSB0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCkge1xyXG4gICAgICAgICAgICB2MSA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLmtleWZyYW1lc1t0aGlzLnAua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLyBmcmFtZVJhdGUpLCAwKTtcclxuICAgICAgICAgICAgdjIgPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUoKHRoaXMucC5rZXlmcmFtZXNbdGhpcy5wLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wNSkgLyBmcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdjEgPSB0aGlzLnAucHY7XHJcbiAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAuX2NhY2hpbmcubGFzdEZyYW1lICsgdGhpcy5wLm9mZnNldFRpbWUgLSAwLjAxKSAvIGZyYW1lUmF0ZSwgdGhpcy5wLm9mZnNldFRpbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5weCAmJiB0aGlzLnB4LmtleWZyYW1lcyAmJiB0aGlzLnB5LmtleWZyYW1lcyAmJiB0aGlzLnB4LmdldFZhbHVlQXRUaW1lICYmIHRoaXMucHkuZ2V0VmFsdWVBdFRpbWUpIHtcclxuICAgICAgICAgIHYxID0gW107XHJcbiAgICAgICAgICB2MiA9IFtdO1xyXG4gICAgICAgICAgdmFyIHB4ID0gdGhpcy5weDtcclxuICAgICAgICAgIHZhciBweSA9IHRoaXMucHk7XHJcbiAgICAgICAgICBpZiAocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSA8PSBweC5rZXlmcmFtZXNbMF0udCkge1xyXG4gICAgICAgICAgICB2MVswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5rZXlmcmFtZXNbMF0udCArIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcclxuICAgICAgICAgICAgdjFbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgICAgICAgIHYyWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1swXS50KSAvIGZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgICAgICAgIHYyWzFdID0gcHkuZ2V0VmFsdWVBdFRpbWUoKHB5LmtleWZyYW1lc1swXS50KSAvIGZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHB4Ll9jYWNoaW5nLmxhc3RGcmFtZSArIHB4Lm9mZnNldFRpbWUgPj0gcHgua2V5ZnJhbWVzW3B4LmtleWZyYW1lcy5sZW5ndGggLSAxXS50KSB7XHJcbiAgICAgICAgICAgIHYxWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSksIDApO1xyXG4gICAgICAgICAgICB2MVsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5rZXlmcmFtZXNbcHkua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLyBmcmFtZVJhdGUpLCAwKTtcclxuICAgICAgICAgICAgdjJbMF0gPSBweC5nZXRWYWx1ZUF0VGltZSgocHgua2V5ZnJhbWVzW3B4LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5rZXlmcmFtZXNbcHkua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2MSA9IFtweC5wdiwgcHkucHZdO1xyXG4gICAgICAgICAgICB2MlswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5fY2FjaGluZy5sYXN0RnJhbWUgKyBweC5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHB4Lm9mZnNldFRpbWUpO1xyXG4gICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5fY2FjaGluZy5sYXN0RnJhbWUgKyBweS5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHB5Lm9mZnNldFRpbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2MiA9IGRlZmF1bHRWZWN0b3I7XHJcbiAgICAgICAgICB2MSA9IHYyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnYucm90YXRlKC1NYXRoLmF0YW4yKHYxWzFdIC0gdjJbMV0sIHYxWzBdIC0gdjJbMF0pKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5kYXRhLnAgJiYgdGhpcy5kYXRhLnAucykge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEucC56KSB7XHJcbiAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAtdGhpcy5wei52KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy52LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudi50cmFuc2xhdGUodGhpcy5wLnZbMF0sIHRoaXMucC52WzFdLCAtdGhpcy5wLnZbMl0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHJlY2FsY3VsYXRlTWF0cml4KCkge1xyXG4gICAgaWYgKCF0aGlzLmEuaykge1xyXG4gICAgICB0aGlzLnByZS50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcclxuICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5zLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5wcmUuc2NhbGUodGhpcy5zLnZbMF0sIHRoaXMucy52WzFdLCB0aGlzLnMudlsyXSk7XHJcbiAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zaykge1xyXG4gICAgICBpZiAoIXRoaXMuc2suZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5zYS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5wcmUuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XHJcbiAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLnIpIHtcclxuICAgICAgaWYgKCF0aGlzLnIuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMucHJlLnJvdGF0ZSgtdGhpcy5yLnYpO1xyXG4gICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoIXRoaXMucnouZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5yeS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICYmICF0aGlzLnJ4LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMub3IuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLnByZS5yb3RhdGVaKC10aGlzLnJ6LnYpLnJvdGF0ZVkodGhpcy5yeS52KS5yb3RhdGVYKHRoaXMucngudikucm90YXRlWigtdGhpcy5vci52WzJdKVxyXG4gICAgICAgIC5yb3RhdGVZKHRoaXMub3IudlsxXSlcclxuICAgICAgICAucm90YXRlWCh0aGlzLm9yLnZbMF0pO1xyXG4gICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSA0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYXV0b09yaWVudCgpIHtcclxuICAgIC8vXHJcbiAgICAvLyB2YXIgcHJldlAgPSB0aGlzLmdldFZhbHVlQXRUaW1lKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGREeW5hbWljUHJvcGVydHkocHJvcCkge1xyXG4gICAgdGhpcy5fYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xyXG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcclxuICAgIHRoaXMuX2lzRGlydHkgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gVHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5mcmFtZUlkID0gLTE7XHJcbiAgICB0aGlzLnByb3BUeXBlID0gJ3RyYW5zZm9ybSc7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy52ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgLy8gUHJlY2FsY3VsYXRlZCBtYXRyaXggd2l0aCBub24gYW5pbWF0ZWQgcHJvcGVydGllc1xyXG4gICAgdGhpcy5wcmUgPSBuZXcgTWF0cml4KCk7XHJcbiAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAwO1xyXG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lciB8fCBlbGVtKTtcclxuICAgIGlmIChkYXRhLnAgJiYgZGF0YS5wLnMpIHtcclxuICAgICAgdGhpcy5weCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucC54LCAwLCAwLCB0aGlzKTtcclxuICAgICAgdGhpcy5weSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucC55LCAwLCAwLCB0aGlzKTtcclxuICAgICAgaWYgKGRhdGEucC56KSB7XHJcbiAgICAgICAgdGhpcy5weiA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucC56LCAwLCAwLCB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wIHx8IHsgazogWzAsIDAsIDBdIH0sIDEsIDAsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEucngpIHtcclxuICAgICAgdGhpcy5yeCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XHJcbiAgICAgIHRoaXMucnkgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnJ5LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgICB0aGlzLnJ6ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yeiwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICAgICAgaWYgKGRhdGEub3Iua1swXS50aSkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBsZW4gPSBkYXRhLm9yLmsubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgZGF0YS5vci5rW2ldLnRvID0gbnVsbDtcclxuICAgICAgICAgIGRhdGEub3Iua1tpXS50aSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgICAvLyBzaCBJbmRpY2F0ZXMgaXQgbmVlZHMgdG8gYmUgY2FwcGVkIGJldHdlZW4gLTE4MCBhbmQgMTgwXHJcbiAgICAgIHRoaXMub3Iuc2ggPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yIHx8IHsgazogMCB9LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEuc2spIHtcclxuICAgICAgdGhpcy5zayA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuc2ssIDAsIGRlZ1RvUmFkcywgdGhpcyk7XHJcbiAgICAgIHRoaXMuc2EgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnNhLCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5hIHx8IHsgazogWzAsIDAsIDBdIH0sIDEsIDAsIHRoaXMpO1xyXG4gICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zIHx8IHsgazogWzEwMCwgMTAwLCAxMDBdIH0sIDEsIDAuMDEsIHRoaXMpO1xyXG4gICAgLy8gT3BhY2l0eSBpcyBub3QgcGFydCBvZiB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMsIHRoYXQncyB3aHkgaXQgd29uJ3QgdXNlIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMuIFRoYXQgd2F5IHRyYW5zZm9ybXMgd29uJ3QgZ2V0IHVwZGF0ZWQgaWYgb3BhY2l0eSBjaGFuZ2VzLlxyXG4gICAgaWYgKGRhdGEubykge1xyXG4gICAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIGVsZW0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5vID0geyBfbWRmOiBmYWxzZSwgdjogMSB9O1xyXG4gICAgfVxyXG4gICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XHJcbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBUcmFuc2Zvcm1Qcm9wZXJ0eS5wcm90b3R5cGUgPSB7XHJcbiAgICBhcHBseVRvTWF0cml4OiBhcHBseVRvTWF0cml4LFxyXG4gICAgZ2V0VmFsdWU6IHByb2Nlc3NLZXlzLFxyXG4gICAgcHJlY2FsY3VsYXRlTWF0cml4OiBwcmVjYWxjdWxhdGVNYXRyaXgsXHJcbiAgICBhdXRvT3JpZW50OiBhdXRvT3JpZW50LFxyXG4gIH07XHJcblxyXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVHJhbnNmb3JtUHJvcGVydHkpO1xyXG4gIFRyYW5zZm9ybVByb3BlcnR5LnByb3RvdHlwZS5hZGREeW5hbWljUHJvcGVydHkgPSBhZGREeW5hbWljUHJvcGVydHk7XHJcbiAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlLl9hZGREeW5hbWljUHJvcGVydHkgPSBEeW5hbWljUHJvcGVydHlDb250YWluZXIucHJvdG90eXBlLmFkZER5bmFtaWNQcm9wZXJ0eTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XHJcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZ2V0VHJhbnNmb3JtUHJvcGVydHk6IGdldFRyYW5zZm9ybVByb3BlcnR5LFxyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSwgY3JlYXRlU2l6ZWRBcnJheSwgcG9pbnRQb29sICovXHJcblxyXG5mdW5jdGlvbiBTaGFwZVBhdGgoKSB7XHJcbiAgdGhpcy5jID0gZmFsc2U7XHJcbiAgdGhpcy5fbGVuZ3RoID0gMDtcclxuICB0aGlzLl9tYXhMZW5ndGggPSA4O1xyXG4gIHRoaXMudiA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcclxuICB0aGlzLm8gPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XHJcbiAgdGhpcy5pID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xyXG59XHJcblxyXG5TaGFwZVBhdGgucHJvdG90eXBlLnNldFBhdGhEYXRhID0gZnVuY3Rpb24gKGNsb3NlZCwgbGVuKSB7XHJcbiAgdGhpcy5jID0gY2xvc2VkO1xyXG4gIHRoaXMuc2V0TGVuZ3RoKGxlbik7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICB0aGlzLnZbaV0gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgdGhpcy5vW2ldID0gcG9pbnRQb29sLm5ld0VsZW1lbnQoKTtcclxuICAgIHRoaXMuaVtpXSA9IHBvaW50UG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XHJcbiAgd2hpbGUgKHRoaXMuX21heExlbmd0aCA8IGxlbikge1xyXG4gICAgdGhpcy5kb3VibGVBcnJheUxlbmd0aCgpO1xyXG4gIH1cclxuICB0aGlzLl9sZW5ndGggPSBsZW47XHJcbn07XHJcblxyXG5TaGFwZVBhdGgucHJvdG90eXBlLmRvdWJsZUFycmF5TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMudiA9IHRoaXMudi5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcclxuICB0aGlzLmkgPSB0aGlzLmkuY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XHJcbiAgdGhpcy5vID0gdGhpcy5vLmNvbmNhdChjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCkpO1xyXG4gIHRoaXMuX21heExlbmd0aCAqPSAyO1xyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRYWUF0ID0gZnVuY3Rpb24gKHgsIHksIHR5cGUsIHBvcywgcmVwbGFjZSkge1xyXG4gIHZhciBhcnI7XHJcbiAgdGhpcy5fbGVuZ3RoID0gTWF0aC5tYXgodGhpcy5fbGVuZ3RoLCBwb3MgKyAxKTtcclxuICBpZiAodGhpcy5fbGVuZ3RoID49IHRoaXMuX21heExlbmd0aCkge1xyXG4gICAgdGhpcy5kb3VibGVBcnJheUxlbmd0aCgpO1xyXG4gIH1cclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgJ3YnOlxyXG4gICAgICBhcnIgPSB0aGlzLnY7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnaSc6XHJcbiAgICAgIGFyciA9IHRoaXMuaTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdvJzpcclxuICAgICAgYXJyID0gdGhpcy5vO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGFyciA9IFtdO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgaWYgKCFhcnJbcG9zXSB8fCAoYXJyW3Bvc10gJiYgIXJlcGxhY2UpKSB7XHJcbiAgICBhcnJbcG9zXSA9IHBvaW50UG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgfVxyXG4gIGFycltwb3NdWzBdID0geDtcclxuICBhcnJbcG9zXVsxXSA9IHk7XHJcbn07XHJcblxyXG5TaGFwZVBhdGgucHJvdG90eXBlLnNldFRyaXBsZUF0ID0gZnVuY3Rpb24gKHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIHBvcywgcmVwbGFjZSkge1xyXG4gIHRoaXMuc2V0WFlBdCh2WCwgdlksICd2JywgcG9zLCByZXBsYWNlKTtcclxuICB0aGlzLnNldFhZQXQob1gsIG9ZLCAnbycsIHBvcywgcmVwbGFjZSk7XHJcbiAgdGhpcy5zZXRYWUF0KGlYLCBpWSwgJ2knLCBwb3MsIHJlcGxhY2UpO1xyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBuZXdQYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xyXG4gIG5ld1BhdGguc2V0UGF0aERhdGEodGhpcy5jLCB0aGlzLl9sZW5ndGgpO1xyXG4gIHZhciB2ZXJ0aWNlcyA9IHRoaXMudjtcclxuICB2YXIgb3V0UG9pbnRzID0gdGhpcy5vO1xyXG4gIHZhciBpblBvaW50cyA9IHRoaXMuaTtcclxuICB2YXIgaW5pdCA9IDA7XHJcbiAgaWYgKHRoaXMuYykge1xyXG4gICAgbmV3UGF0aC5zZXRUcmlwbGVBdCh2ZXJ0aWNlc1swXVswXSwgdmVydGljZXNbMF1bMV0sIGluUG9pbnRzWzBdWzBdLCBpblBvaW50c1swXVsxXSwgb3V0UG9pbnRzWzBdWzBdLCBvdXRQb2ludHNbMF1bMV0sIDAsIGZhbHNlKTtcclxuICAgIGluaXQgPSAxO1xyXG4gIH1cclxuICB2YXIgY250ID0gdGhpcy5fbGVuZ3RoIC0gMTtcclxuICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoO1xyXG5cclxuICB2YXIgaTtcclxuICBmb3IgKGkgPSBpbml0OyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIG5ld1BhdGguc2V0VHJpcGxlQXQodmVydGljZXNbY250XVswXSwgdmVydGljZXNbY250XVsxXSwgaW5Qb2ludHNbY250XVswXSwgaW5Qb2ludHNbY250XVsxXSwgb3V0UG9pbnRzW2NudF1bMF0sIG91dFBvaW50c1tjbnRdWzFdLCBpLCBmYWxzZSk7XHJcbiAgICBjbnQgLT0gMTtcclxuICB9XHJcbiAgcmV0dXJuIG5ld1BhdGg7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCByb3VuZENvcm5lciwgQmV6aWVyRmFjdG9yeSwgc2hhcGVQb29sLCBkZWdUb1JhZHMsXHJcbiAgc2hhcGVDb2xsZWN0aW9uUG9vbCwgUHJvcGVydHlGYWN0b3J5LCBibU1pbiwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyICovXHJcbi8qIGV4cG9ydGVkIFNoYXBlUHJvcGVydHlGYWN0b3J5ICovXHJcblxyXG52YXIgU2hhcGVQcm9wZXJ0eUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpbml0RnJhbWUgPSAtOTk5OTk5O1xyXG5cclxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVNoYXBlKGZyYW1lTnVtLCBwcmV2aW91c1ZhbHVlLCBjYWNoaW5nKSB7XHJcbiAgICB2YXIgaXRlcmF0aW9uSW5kZXggPSBjYWNoaW5nLmxhc3RJbmRleDtcclxuICAgIHZhciBrZXlQcm9wUztcclxuICAgIHZhciBrZXlQcm9wRTtcclxuICAgIHZhciBpc0hvbGQ7XHJcbiAgICB2YXIgajtcclxuICAgIHZhciBrO1xyXG4gICAgdmFyIGpMZW47XHJcbiAgICB2YXIga0xlbjtcclxuICAgIHZhciBwZXJjO1xyXG4gICAgdmFyIHZlcnRleFZhbHVlO1xyXG4gICAgdmFyIGtmID0gdGhpcy5rZXlmcmFtZXM7XHJcbiAgICBpZiAoZnJhbWVOdW0gPCBrZlswXS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XHJcbiAgICAgIGtleVByb3BTID0ga2ZbMF0uc1swXTtcclxuICAgICAgaXNIb2xkID0gdHJ1ZTtcclxuICAgICAgaXRlcmF0aW9uSW5kZXggPSAwO1xyXG4gICAgfSBlbHNlIGlmIChmcmFtZU51bSA+PSBrZltrZi5sZW5ndGggLSAxXS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XHJcbiAgICAgIGtleVByb3BTID0ga2Zba2YubGVuZ3RoIC0gMV0ucyA/IGtmW2tmLmxlbmd0aCAtIDFdLnNbMF0gOiBrZltrZi5sZW5ndGggLSAyXS5lWzBdO1xyXG4gICAgICAvKiBpZihrZltrZi5sZW5ndGggLSAxXS5zKXtcclxuICAgICAgICAgICAgICAgIGtleVByb3BTID0ga2Zba2YubGVuZ3RoIC0gMV0uc1swXTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBrZXlQcm9wUyA9IGtmW2tmLmxlbmd0aCAtIDJdLmVbMF07XHJcbiAgICAgICAgICAgIH0gKi9cclxuICAgICAgaXNIb2xkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBpID0gaXRlcmF0aW9uSW5kZXg7XHJcbiAgICAgIHZhciBsZW4gPSBrZi5sZW5ndGggLSAxO1xyXG4gICAgICB2YXIgZmxhZyA9IHRydWU7XHJcbiAgICAgIHZhciBrZXlEYXRhO1xyXG4gICAgICB2YXIgbmV4dEtleURhdGE7XHJcbiAgICAgIHdoaWxlIChmbGFnKSB7XHJcbiAgICAgICAga2V5RGF0YSA9IGtmW2ldO1xyXG4gICAgICAgIG5leHRLZXlEYXRhID0ga2ZbaSArIDFdO1xyXG4gICAgICAgIGlmICgobmV4dEtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSkgPiBmcmFtZU51bSkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xyXG4gICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlzSG9sZCA9IGtleURhdGEuaCA9PT0gMTtcclxuICAgICAgaXRlcmF0aW9uSW5kZXggPSBpO1xyXG4gICAgICBpZiAoIWlzSG9sZCkge1xyXG4gICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XHJcbiAgICAgICAgICBwZXJjID0gMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDwga2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XHJcbiAgICAgICAgICBwZXJjID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGZuYztcclxuICAgICAgICAgIGlmIChrZXlEYXRhLl9fZm5jdCkge1xyXG4gICAgICAgICAgICBmbmMgPSBrZXlEYXRhLl9fZm5jdDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZuYyA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKGtleURhdGEuby54LCBrZXlEYXRhLm8ueSwga2V5RGF0YS5pLngsIGtleURhdGEuaS55KS5nZXQ7XHJcbiAgICAgICAgICAgIGtleURhdGEuX19mbmN0ID0gZm5jO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcGVyYyA9IGZuYygoZnJhbWVOdW0gLSAoa2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSkgLyAoKG5leHRLZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUpIC0gKGtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5UHJvcEUgPSBuZXh0S2V5RGF0YS5zID8gbmV4dEtleURhdGEuc1swXSA6IGtleURhdGEuZVswXTtcclxuICAgICAgfVxyXG4gICAgICBrZXlQcm9wUyA9IGtleURhdGEuc1swXTtcclxuICAgIH1cclxuICAgIGpMZW4gPSBwcmV2aW91c1ZhbHVlLl9sZW5ndGg7XHJcbiAgICBrTGVuID0ga2V5UHJvcFMuaVswXS5sZW5ndGg7XHJcbiAgICBjYWNoaW5nLmxhc3RJbmRleCA9IGl0ZXJhdGlvbkluZGV4O1xyXG5cclxuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xyXG4gICAgICAgIHZlcnRleFZhbHVlID0gaXNIb2xkID8ga2V5UHJvcFMuaVtqXVtrXSA6IGtleVByb3BTLmlbal1ba10gKyAoa2V5UHJvcEUuaVtqXVtrXSAtIGtleVByb3BTLmlbal1ba10pICogcGVyYztcclxuICAgICAgICBwcmV2aW91c1ZhbHVlLmlbal1ba10gPSB2ZXJ0ZXhWYWx1ZTtcclxuICAgICAgICB2ZXJ0ZXhWYWx1ZSA9IGlzSG9sZCA/IGtleVByb3BTLm9bal1ba10gOiBrZXlQcm9wUy5vW2pdW2tdICsgKGtleVByb3BFLm9bal1ba10gLSBrZXlQcm9wUy5vW2pdW2tdKSAqIHBlcmM7XHJcbiAgICAgICAgcHJldmlvdXNWYWx1ZS5vW2pdW2tdID0gdmVydGV4VmFsdWU7XHJcbiAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy52W2pdW2tdIDoga2V5UHJvcFMudltqXVtrXSArIChrZXlQcm9wRS52W2pdW2tdIC0ga2V5UHJvcFMudltqXVtrXSkgKiBwZXJjO1xyXG4gICAgICAgIHByZXZpb3VzVmFsdWUudltqXVtrXSA9IHZlcnRleFZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVNoYXBlQ3VycmVudFRpbWUoKSB7XHJcbiAgICB2YXIgZnJhbWVOdW0gPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZSAtIHRoaXMub2Zmc2V0VGltZTtcclxuICAgIHZhciBpbml0VGltZSA9IHRoaXMua2V5ZnJhbWVzWzBdLnQgLSB0aGlzLm9mZnNldFRpbWU7XHJcbiAgICB2YXIgZW5kVGltZSA9IHRoaXMua2V5ZnJhbWVzW3RoaXMua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSB0aGlzLm9mZnNldFRpbWU7XHJcbiAgICB2YXIgbGFzdEZyYW1lID0gdGhpcy5fY2FjaGluZy5sYXN0RnJhbWU7XHJcbiAgICBpZiAoIShsYXN0RnJhbWUgIT09IGluaXRGcmFtZSAmJiAoKGxhc3RGcmFtZSA8IGluaXRUaW1lICYmIGZyYW1lTnVtIDwgaW5pdFRpbWUpIHx8IChsYXN0RnJhbWUgPiBlbmRUaW1lICYmIGZyYW1lTnVtID4gZW5kVGltZSkpKSkge1xyXG4gICAgICAvLy8gL1xyXG4gICAgICB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA9IGxhc3RGcmFtZSA8IGZyYW1lTnVtID8gdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggOiAwO1xyXG4gICAgICB0aGlzLmludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHRoaXMucHYsIHRoaXMuX2NhY2hpbmcpO1xyXG4gICAgICAvLy8gL1xyXG4gICAgfVxyXG4gICAgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPSBmcmFtZU51bTtcclxuICAgIHJldHVybiB0aGlzLnB2O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVzZXRTaGFwZSgpIHtcclxuICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2hhcGVzRXF1YWwoc2hhcGUxLCBzaGFwZTIpIHtcclxuICAgIGlmIChzaGFwZTEuX2xlbmd0aCAhPT0gc2hhcGUyLl9sZW5ndGggfHwgc2hhcGUxLmMgIT09IHNoYXBlMi5jKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHNoYXBlMS5fbGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGlmIChzaGFwZTEudltpXVswXSAhPT0gc2hhcGUyLnZbaV1bMF1cclxuICAgICAgICAgICAgfHwgc2hhcGUxLnZbaV1bMV0gIT09IHNoYXBlMi52W2ldWzFdXHJcbiAgICAgICAgICAgIHx8IHNoYXBlMS5vW2ldWzBdICE9PSBzaGFwZTIub1tpXVswXVxyXG4gICAgICAgICAgICB8fCBzaGFwZTEub1tpXVsxXSAhPT0gc2hhcGUyLm9baV1bMV1cclxuICAgICAgICAgICAgfHwgc2hhcGUxLmlbaV1bMF0gIT09IHNoYXBlMi5pW2ldWzBdXHJcbiAgICAgICAgICAgIHx8IHNoYXBlMS5pW2ldWzFdICE9PSBzaGFwZTIuaVtpXVsxXSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRWVmFsdWUobmV3UGF0aCkge1xyXG4gICAgaWYgKCFzaGFwZXNFcXVhbCh0aGlzLnYsIG5ld1BhdGgpKSB7XHJcbiAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5jbG9uZShuZXdQYXRoKTtcclxuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XHJcbiAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcclxuICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlKCkge1xyXG4gICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IGlmICghdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5sb2NrKSB7XHJcbiAgICAgIHRoaXMuc2V0VlZhbHVlKHRoaXMucHYpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvY2sgPSB0cnVlO1xyXG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgICB2YXIgZmluYWxWYWx1ZTtcclxuICAgIGlmICh0aGlzLmtmKSB7XHJcbiAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLnB2O1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGEua3MpIHtcclxuICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZGF0YS5rcy5rO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZGF0YS5wdC5rO1xyXG4gICAgfVxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZVtpXShmaW5hbFZhbHVlKTtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0VlZhbHVlKGZpbmFsVmFsdWUpO1xyXG4gICAgdGhpcy5sb2NrID0gZmFsc2U7XHJcbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XHJcbiAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcclxuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgIHRoaXMuY29udGFpbmVyID0gZWxlbTtcclxuICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5rID0gZmFsc2U7XHJcbiAgICB0aGlzLmtmID0gZmFsc2U7XHJcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgIHZhciBwYXRoRGF0YSA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XHJcbiAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUocGF0aERhdGEpO1xyXG4gICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xyXG4gICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XHJcbiAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcclxuICAgIHRoaXMucmVzZXQgPSByZXNldFNoYXBlO1xyXG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZEVmZmVjdChlZmZlY3RGdW5jdGlvbikge1xyXG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UucHVzaChlZmZlY3RGdW5jdGlvbik7XHJcbiAgICB0aGlzLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XHJcbiAgfVxyXG5cclxuICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5pbnRlcnBvbGF0ZVNoYXBlID0gaW50ZXJwb2xhdGVTaGFwZTtcclxuICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XHJcbiAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xyXG4gIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuXHJcbiAgZnVuY3Rpb24gS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XHJcbiAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcclxuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGVsZW07XHJcbiAgICB0aGlzLm9mZnNldFRpbWUgPSBlbGVtLmRhdGEuc3Q7XHJcbiAgICB0aGlzLmtleWZyYW1lcyA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XHJcbiAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgdGhpcy5rZiA9IHRydWU7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5rZXlmcmFtZXNbMF0uc1swXS5pLmxlbmd0aDtcclxuICAgIHRoaXMudiA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICB0aGlzLnYuc2V0UGF0aERhdGEodGhpcy5rZXlmcmFtZXNbMF0uc1swXS5jLCBsZW4pO1xyXG4gICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xyXG4gICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XHJcbiAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcclxuICAgIHRoaXMubGFzdEZyYW1lID0gaW5pdEZyYW1lO1xyXG4gICAgdGhpcy5yZXNldCA9IHJlc2V0U2hhcGU7XHJcbiAgICB0aGlzLl9jYWNoaW5nID0geyBsYXN0RnJhbWU6IGluaXRGcmFtZSwgbGFzdEluZGV4OiAwIH07XHJcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtpbnRlcnBvbGF0ZVNoYXBlQ3VycmVudFRpbWUuYmluZCh0aGlzKV07XHJcbiAgfVxyXG4gIEtleWZyYW1lZFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcclxuICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5pbnRlcnBvbGF0ZVNoYXBlID0gaW50ZXJwb2xhdGVTaGFwZTtcclxuICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XHJcbiAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xyXG5cclxuICB2YXIgRWxsU2hhcGVQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY1BvaW50ID0gcm91bmRDb3JuZXI7XHJcblxyXG4gICAgZnVuY3Rpb24gRWxsU2hhcGVQcm9wZXJ0eUZhY3RvcnkoZWxlbSwgZGF0YSkge1xyXG4gICAgICAvKiB0aGlzLnYgPSB7XHJcbiAgICAgICAgICAgICAgICB2OiBjcmVhdGVTaXplZEFycmF5KDQpLFxyXG4gICAgICAgICAgICAgICAgaTogY3JlYXRlU2l6ZWRBcnJheSg0KSxcclxuICAgICAgICAgICAgICAgIG86IGNyZWF0ZVNpemVkQXJyYXkoNCksXHJcbiAgICAgICAgICAgICAgICBjOiB0cnVlXHJcbiAgICAgICAgICAgIH07ICovXHJcbiAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICAgIHRoaXMudi5zZXRQYXRoRGF0YSh0cnVlLCA0KTtcclxuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XHJcbiAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XHJcbiAgICAgIHRoaXMuZCA9IGRhdGEuZDtcclxuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICAgICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAsIDEsIDAsIHRoaXMpO1xyXG4gICAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDEsIDAsIHRoaXMpO1xyXG4gICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuayA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29udmVydEVsbFRvUGF0aCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRWxsU2hhcGVQcm9wZXJ0eUZhY3RvcnkucHJvdG90eXBlID0ge1xyXG4gICAgICByZXNldDogcmVzZXRTaGFwZSxcclxuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbiAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX21kZikge1xyXG4gICAgICAgICAgdGhpcy5jb252ZXJ0RWxsVG9QYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBjb252ZXJ0RWxsVG9QYXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHAwID0gdGhpcy5wLnZbMF07XHJcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wLnZbMV07XHJcbiAgICAgICAgdmFyIHMwID0gdGhpcy5zLnZbMF0gLyAyO1xyXG4gICAgICAgIHZhciBzMSA9IHRoaXMucy52WzFdIC8gMjtcclxuICAgICAgICB2YXIgX2N3ID0gdGhpcy5kICE9PSAzO1xyXG4gICAgICAgIHZhciBfdiA9IHRoaXMudjtcclxuICAgICAgICBfdi52WzBdWzBdID0gcDA7XHJcbiAgICAgICAgX3YudlswXVsxXSA9IHAxIC0gczE7XHJcbiAgICAgICAgX3YudlsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xyXG4gICAgICAgIF92LnZbMV1bMV0gPSBwMTtcclxuICAgICAgICBfdi52WzJdWzBdID0gcDA7XHJcbiAgICAgICAgX3YudlsyXVsxXSA9IHAxICsgczE7XHJcbiAgICAgICAgX3YudlszXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xyXG4gICAgICAgIF92LnZbM11bMV0gPSBwMTtcclxuICAgICAgICBfdi5pWzBdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XHJcbiAgICAgICAgX3YuaVswXVsxXSA9IHAxIC0gczE7XHJcbiAgICAgICAgX3YuaVsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xyXG4gICAgICAgIF92LmlbMV1bMV0gPSBwMSAtIHMxICogY1BvaW50O1xyXG4gICAgICAgIF92LmlbMl1bMF0gPSBfY3cgPyBwMCArIHMwICogY1BvaW50IDogcDAgLSBzMCAqIGNQb2ludDtcclxuICAgICAgICBfdi5pWzJdWzFdID0gcDEgKyBzMTtcclxuICAgICAgICBfdi5pWzNdWzBdID0gX2N3ID8gcDAgLSBzMCA6IHAwICsgczA7XHJcbiAgICAgICAgX3YuaVszXVsxXSA9IHAxICsgczEgKiBjUG9pbnQ7XHJcbiAgICAgICAgX3Yub1swXVswXSA9IF9jdyA/IHAwICsgczAgKiBjUG9pbnQgOiBwMCAtIHMwICogY1BvaW50O1xyXG4gICAgICAgIF92Lm9bMF1bMV0gPSBwMSAtIHMxO1xyXG4gICAgICAgIF92Lm9bMV1bMF0gPSBfY3cgPyBwMCArIHMwIDogcDAgLSBzMDtcclxuICAgICAgICBfdi5vWzFdWzFdID0gcDEgKyBzMSAqIGNQb2ludDtcclxuICAgICAgICBfdi5vWzJdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XHJcbiAgICAgICAgX3Yub1syXVsxXSA9IHAxICsgczE7XHJcbiAgICAgICAgX3Yub1szXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xyXG4gICAgICAgIF92Lm9bM11bMV0gPSBwMSAtIHMxICogY1BvaW50O1xyXG4gICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5KTtcclxuXHJcbiAgICByZXR1cm4gRWxsU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XHJcbiAgfSgpKTtcclxuXHJcbiAgdmFyIFN0YXJTaGFwZVByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeShlbGVtLCBkYXRhKSB7XHJcbiAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICAgIHRoaXMudi5zZXRQYXRoRGF0YSh0cnVlLCAwKTtcclxuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICAgICAgdGhpcy5kID0gZGF0YS5kO1xyXG4gICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbiAgICAgIGlmIChkYXRhLnN5ID09PSAxKSB7XHJcbiAgICAgICAgdGhpcy5pciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuaXIsIDAsIDAsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaXMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmlzLCAwLCAwLjAxLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGggPSB0aGlzLmNvbnZlcnRTdGFyVG9QYXRoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY29udmVydFRvUGF0aCA9IHRoaXMuY29udmVydFBvbHlnb25Ub1BhdGg7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wdCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucHQsIDAsIDAsIHRoaXMpO1xyXG4gICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAsIDEsIDAsIHRoaXMpO1xyXG4gICAgICB0aGlzLnIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XHJcbiAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAwLCAwLCB0aGlzKTtcclxuICAgICAgdGhpcy5vcyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEub3MsIDAsIDAuMDEsIHRoaXMpO1xyXG4gICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcclxuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xyXG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5rID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGgoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeS5wcm90b3R5cGUgPSB7XHJcbiAgICAgIHJlc2V0OiByZXNldFNoYXBlLFxyXG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxuICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xyXG4gICAgICAgIGlmICh0aGlzLl9tZGYpIHtcclxuICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgY29udmVydFN0YXJUb1BhdGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbnVtUHRzID0gTWF0aC5mbG9vcih0aGlzLnB0LnYpICogMjtcclxuICAgICAgICB2YXIgYW5nbGUgPSAoTWF0aC5QSSAqIDIpIC8gbnVtUHRzO1xyXG4gICAgICAgIC8qIHRoaXMudi52Lmxlbmd0aCA9IG51bVB0cztcclxuICAgICAgICAgICAgICAgIHRoaXMudi5pLmxlbmd0aCA9IG51bVB0cztcclxuICAgICAgICAgICAgICAgIHRoaXMudi5vLmxlbmd0aCA9IG51bVB0czsgKi9cclxuICAgICAgICB2YXIgbG9uZ0ZsYWcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBsb25nUmFkID0gdGhpcy5vci52O1xyXG4gICAgICAgIHZhciBzaG9ydFJhZCA9IHRoaXMuaXIudjtcclxuICAgICAgICB2YXIgbG9uZ1JvdW5kID0gdGhpcy5vcy52O1xyXG4gICAgICAgIHZhciBzaG9ydFJvdW5kID0gdGhpcy5pcy52O1xyXG4gICAgICAgIHZhciBsb25nUGVyaW1TZWdtZW50ID0gKDIgKiBNYXRoLlBJICogbG9uZ1JhZCkgLyAobnVtUHRzICogMik7XHJcbiAgICAgICAgdmFyIHNob3J0UGVyaW1TZWdtZW50ID0gKDIgKiBNYXRoLlBJICogc2hvcnRSYWQpIC8gKG51bVB0cyAqIDIpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciByYWQ7XHJcbiAgICAgICAgdmFyIHJvdW5kbmVzcztcclxuICAgICAgICB2YXIgcGVyaW1TZWdtZW50O1xyXG4gICAgICAgIHZhciBjdXJyZW50QW5nID0gLU1hdGguUEkgLyAyO1xyXG4gICAgICAgIGN1cnJlbnRBbmcgKz0gdGhpcy5yLnY7XHJcbiAgICAgICAgdmFyIGRpciA9IHRoaXMuZGF0YS5kID09PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHRoaXMudi5fbGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUHRzOyBpICs9IDEpIHtcclxuICAgICAgICAgIHJhZCA9IGxvbmdGbGFnID8gbG9uZ1JhZCA6IHNob3J0UmFkO1xyXG4gICAgICAgICAgcm91bmRuZXNzID0gbG9uZ0ZsYWcgPyBsb25nUm91bmQgOiBzaG9ydFJvdW5kO1xyXG4gICAgICAgICAgcGVyaW1TZWdtZW50ID0gbG9uZ0ZsYWcgPyBsb25nUGVyaW1TZWdtZW50IDogc2hvcnRQZXJpbVNlZ21lbnQ7XHJcbiAgICAgICAgICB2YXIgeCA9IHJhZCAqIE1hdGguY29zKGN1cnJlbnRBbmcpO1xyXG4gICAgICAgICAgdmFyIHkgPSByYWQgKiBNYXRoLnNpbihjdXJyZW50QW5nKTtcclxuICAgICAgICAgIHZhciBveCA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiB5IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gICAgICAgICAgdmFyIG95ID0geCA9PT0gMCAmJiB5ID09PSAwID8gMCA6IC14IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gICAgICAgICAgeCArPSArdGhpcy5wLnZbMF07XHJcbiAgICAgICAgICB5ICs9ICt0aGlzLnAudlsxXTtcclxuICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdCh4LCB5LCB4IC0gb3ggKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHkgLSBveSAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeCArIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5ICsgb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIGksIHRydWUpO1xyXG5cclxuICAgICAgICAgIC8qIHRoaXMudi52W2ldID0gW3gseV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52LmlbaV0gPSBbeCtveCpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcix5K295KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnYub1tpXSA9IFt4LW94KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyLHktb3kqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudi5fbGVuZ3RoID0gbnVtUHRzOyAqL1xyXG4gICAgICAgICAgbG9uZ0ZsYWcgPSAhbG9uZ0ZsYWc7XHJcbiAgICAgICAgICBjdXJyZW50QW5nICs9IGFuZ2xlICogZGlyO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgY29udmVydFBvbHlnb25Ub1BhdGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbnVtUHRzID0gTWF0aC5mbG9vcih0aGlzLnB0LnYpO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IChNYXRoLlBJICogMikgLyBudW1QdHM7XHJcbiAgICAgICAgdmFyIHJhZCA9IHRoaXMub3IudjtcclxuICAgICAgICB2YXIgcm91bmRuZXNzID0gdGhpcy5vcy52O1xyXG4gICAgICAgIHZhciBwZXJpbVNlZ21lbnQgPSAoMiAqIE1hdGguUEkgKiByYWQpIC8gKG51bVB0cyAqIDQpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBjdXJyZW50QW5nID0gLU1hdGguUEkgKiAwLjU7XHJcbiAgICAgICAgdmFyIGRpciA9IHRoaXMuZGF0YS5kID09PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIGN1cnJlbnRBbmcgKz0gdGhpcy5yLnY7XHJcbiAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1QdHM7IGkgKz0gMSkge1xyXG4gICAgICAgICAgdmFyIHggPSByYWQgKiBNYXRoLmNvcyhjdXJyZW50QW5nKTtcclxuICAgICAgICAgIHZhciB5ID0gcmFkICogTWF0aC5zaW4oY3VycmVudEFuZyk7XHJcbiAgICAgICAgICB2YXIgb3ggPSB4ID09PSAwICYmIHkgPT09IDAgPyAwIDogeSAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgICAgICAgIHZhciBveSA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiAteCAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgICAgICAgIHggKz0gK3RoaXMucC52WzBdO1xyXG4gICAgICAgICAgeSArPSArdGhpcy5wLnZbMV07XHJcbiAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQoeCwgeSwgeCAtIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5IC0gb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHggKyBveCAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeSArIG95ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCBpLCB0cnVlKTtcclxuICAgICAgICAgIGN1cnJlbnRBbmcgKz0gYW5nbGUgKiBkaXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGF0aHMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLnBhdGhzWzBdID0gdGhpcy52O1xyXG4gICAgICB9LFxyXG5cclxuICAgIH07XHJcbiAgICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeSk7XHJcblxyXG4gICAgcmV0dXJuIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeTtcclxuICB9KCkpO1xyXG5cclxuICB2YXIgUmVjdFNoYXBlUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcclxuICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcclxuICAgICAgdGhpcy52LmMgPSB0cnVlO1xyXG4gICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcclxuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xyXG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICAgICAgdGhpcy5kID0gZGF0YS5kO1xyXG4gICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbiAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCwgMSwgMCwgdGhpcyk7XHJcbiAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgMCwgdGhpcyk7XHJcbiAgICAgIHRoaXMuciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuciwgMCwgMCwgdGhpcyk7XHJcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuayA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5rID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb252ZXJ0UmVjdFRvUGF0aCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5LnByb3RvdHlwZSA9IHtcclxuICAgICAgY29udmVydFJlY3RUb1BhdGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcDAgPSB0aGlzLnAudlswXTtcclxuICAgICAgICB2YXIgcDEgPSB0aGlzLnAudlsxXTtcclxuICAgICAgICB2YXIgdjAgPSB0aGlzLnMudlswXSAvIDI7XHJcbiAgICAgICAgdmFyIHYxID0gdGhpcy5zLnZbMV0gLyAyO1xyXG4gICAgICAgIHZhciByb3VuZCA9IGJtTWluKHYwLCB2MSwgdGhpcy5yLnYpO1xyXG4gICAgICAgIHZhciBjUG9pbnQgPSByb3VuZCAqICgxIC0gcm91bmRDb3JuZXIpO1xyXG4gICAgICAgIHRoaXMudi5fbGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZCA9PT0gMiB8fCB0aGlzLmQgPT09IDEpIHtcclxuICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwICsgdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgKyB2MCwgcDEgLSB2MSArIGNQb2ludCwgMCwgdHJ1ZSk7XHJcbiAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gY1BvaW50LCBwMCArIHYwLCBwMSArIHYxIC0gcm91bmQsIDEsIHRydWUpO1xyXG4gICAgICAgICAgaWYgKHJvdW5kICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwIC0gcm91bmQsIHAxICsgdjEsIHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgKyB2MSwgMiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwICsgcm91bmQsIHAxICsgdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxICsgdjEsIHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgMywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSArIHYxIC0gcm91bmQsIHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgLSB2MCwgcDEgKyB2MSAtIGNQb2ludCwgNCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwIC0gdjAsIHAxIC0gdjEgKyBjUG9pbnQsIHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgNSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwICsgcm91bmQsIHAxIC0gdjEsIHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgLSB2MSwgNiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwIC0gcm91bmQsIHAxIC0gdjEsIHAwICsgdjAgLSBjUG9pbnQsIHAxIC0gdjEsIHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgNywgdHJ1ZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgKyB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgKyB2MSwgcDAgLSB2MCwgcDEgKyB2MSwgMik7XHJcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSAtIHYxLCBwMCAtIHYwLCBwMSAtIHYxICsgY1BvaW50LCBwMCAtIHYwLCBwMSAtIHYxLCAzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgKyB2MCwgcDEgLSB2MSArIGNQb2ludCwgcDAgKyB2MCwgcDEgLSB2MSArIHJvdW5kLCAwLCB0cnVlKTtcclxuICAgICAgICAgIGlmIChyb3VuZCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCBwMCArIHYwIC0gcm91bmQsIHAxIC0gdjEsIHAwICsgdjAgLSBjUG9pbnQsIHAxIC0gdjEsIDEsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCBwMCAtIHYwICsgcm91bmQsIHAxIC0gdjEsIDIsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCAtIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwIC0gdjAsIHAxIC0gdjEgKyBjUG9pbnQsIDMsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCAtIHYwLCBwMSArIHYxIC0gY1BvaW50LCBwMCAtIHYwLCBwMSArIHYxIC0gcm91bmQsIDQsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCBwMCAtIHYwICsgcm91bmQsIHAxICsgdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxICsgdjEsIDUsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSArIHYxLCBwMCArIHYwIC0gcm91bmQsIHAxICsgdjEsIDYsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gcm91bmQsIHAwICsgdjAsIHAxICsgdjEgLSBjUG9pbnQsIDcsIHRydWUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxIC0gdjEsIHAwIC0gdjAsIHAxIC0gdjEsIDEsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgKyB2MSwgcDAgLSB2MCwgcDEgKyB2MSAtIGNQb2ludCwgcDAgLSB2MCwgcDEgKyB2MSwgMiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSArIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSArIHYxLCBwMCArIHYwLCBwMSArIHYxLCAzLCB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gICAgICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX21kZikge1xyXG4gICAgICAgICAgdGhpcy5jb252ZXJ0UmVjdFRvUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgcmVzZXQ6IHJlc2V0U2hhcGUsXHJcbiAgICB9O1xyXG4gICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBSZWN0U2hhcGVQcm9wZXJ0eUZhY3RvcnkpO1xyXG5cclxuICAgIHJldHVybiBSZWN0U2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XHJcbiAgfSgpKTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0U2hhcGVQcm9wKGVsZW0sIGRhdGEsIHR5cGUpIHtcclxuICAgIHZhciBwcm9wO1xyXG4gICAgaWYgKHR5cGUgPT09IDMgfHwgdHlwZSA9PT0gNCkge1xyXG4gICAgICB2YXIgZGF0YVByb3AgPSB0eXBlID09PSAzID8gZGF0YS5wdCA6IGRhdGEua3M7XHJcbiAgICAgIHZhciBrZXlzID0gZGF0YVByb3AuaztcclxuICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcHJvcCA9IG5ldyBLZXlmcmFtZWRTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEsIHR5cGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByb3AgPSBuZXcgU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7XHJcbiAgICAgIHByb3AgPSBuZXcgUmVjdFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHtcclxuICAgICAgcHJvcCA9IG5ldyBFbGxTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSA3KSB7XHJcbiAgICAgIHByb3AgPSBuZXcgU3RhclNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvcC5rKSB7XHJcbiAgICAgIGVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3A7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRDb25zdHJ1Y3RvckZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFNoYXBlUHJvcGVydHk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIEtleWZyYW1lZFNoYXBlUHJvcGVydHk7XHJcbiAgfVxyXG5cclxuICB2YXIgb2IgPSB7fTtcclxuICBvYi5nZXRTaGFwZVByb3AgPSBnZXRTaGFwZVByb3A7XHJcbiAgb2IuZ2V0Q29uc3RydWN0b3JGdW5jdGlvbiA9IGdldENvbnN0cnVjdG9yRnVuY3Rpb247XHJcbiAgb2IuZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbiA9IGdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb247XHJcbiAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIHNoYXBlQ29sbGVjdGlvblBvb2wsIGluaXRpYWxEZWZhdWx0RnJhbWUsIGV4dGVuZFByb3RvdHlwZSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyICovXHJcbi8qIGV4cG9ydGVkIFNoYXBlTW9kaWZpZXJzICovXHJcblxyXG52YXIgU2hhcGVNb2RpZmllcnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBvYiA9IHt9O1xyXG4gIHZhciBtb2RpZmllcnMgPSB7fTtcclxuICBvYi5yZWdpc3Rlck1vZGlmaWVyID0gcmVnaXN0ZXJNb2RpZmllcjtcclxuICBvYi5nZXRNb2RpZmllciA9IGdldE1vZGlmaWVyO1xyXG5cclxuICBmdW5jdGlvbiByZWdpc3Rlck1vZGlmaWVyKG5tLCBmYWN0b3J5KSB7XHJcbiAgICBpZiAoIW1vZGlmaWVyc1tubV0pIHtcclxuICAgICAgbW9kaWZpZXJzW25tXSA9IGZhY3Rvcnk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRNb2RpZmllcihubSwgZWxlbSwgZGF0YSkge1xyXG4gICAgcmV0dXJuIG5ldyBtb2RpZmllcnNbbm1dKGVsZW0sIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuZnVuY3Rpb24gU2hhcGVNb2RpZmllcigpIHt9XHJcblNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7fTtcclxuU2hhcGVNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGVUb01vZGlmaWVyID0gZnVuY3Rpb24gKCkge307XHJcblNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICBpZiAoIXRoaXMuY2xvc2VkKSB7XHJcbiAgICAvLyBBZGRpbmcgc2hhcGUgdG8gZHluYW1pYyBwcm9wZXJ0aWVzLiBJdCBjb3ZlcnMgdGhlIGNhc2Ugd2hlcmUgYSBzaGFwZSBoYXMgbm8gZWZmZWN0cyBhcHBsaWVkLCB0byByZXNldCBpdCdzIF9tZGYgc3RhdGUgb24gZXZlcnkgdGljay5cclxuICAgIGRhdGEuc2guY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eShkYXRhLnNoKTtcclxuICAgIHZhciBzaGFwZURhdGEgPSB7IHNoYXBlOiBkYXRhLnNoLCBkYXRhOiBkYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbjogc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKSB9O1xyXG4gICAgdGhpcy5zaGFwZXMucHVzaChzaGFwZURhdGEpO1xyXG4gICAgdGhpcy5hZGRTaGFwZVRvTW9kaWZpZXIoc2hhcGVEYXRhKTtcclxuICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKSB7XHJcbiAgICAgIGRhdGEuc2V0QXNBbmltYXRlZCgpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuU2hhcGVNb2RpZmllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XHJcbiAgdGhpcy5zaGFwZXMgPSBbXTtcclxuICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcclxuICB0aGlzLmluaXRNb2RpZmllclByb3BlcnRpZXMoZWxlbSwgZGF0YSk7XHJcbiAgdGhpcy5mcmFtZUlkID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcclxuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xyXG4gIHRoaXMuayA9IGZhbHNlO1xyXG4gIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5rID0gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcclxuICB9XHJcbn07XHJcblNoYXBlTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NLZXlzID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxuICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xyXG59O1xyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTaGFwZU1vZGlmaWVyKTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIFNoYXBlTW9kaWZpZXIsIFByb3BlcnR5RmFjdG9yeSwgc2VnbWVudHNMZW5ndGhQb29sLCBiZXosIHNoYXBlUG9vbCwgU2hhcGVNb2RpZmllcnMgKi9cclxuXHJcbmZ1bmN0aW9uIFRyaW1Nb2RpZmllcigpIHtcclxufVxyXG5leHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBUcmltTW9kaWZpZXIpO1xyXG5UcmltTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xyXG4gIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMCwgMC4wMSwgdGhpcyk7XHJcbiAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAwLCAwLjAxLCB0aGlzKTtcclxuICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAsIHRoaXMpO1xyXG4gIHRoaXMuc1ZhbHVlID0gMDtcclxuICB0aGlzLmVWYWx1ZSA9IDA7XHJcbiAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XHJcbiAgdGhpcy5tID0gZGF0YS5tO1xyXG4gIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMucy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoIHx8ICEhdGhpcy5lLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggfHwgISF0aGlzLm8uZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGVUb01vZGlmaWVyID0gZnVuY3Rpb24gKHNoYXBlRGF0YSkge1xyXG4gIHNoYXBlRGF0YS5wYXRoc0RhdGEgPSBbXTtcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUuY2FsY3VsYXRlU2hhcGVFZGdlcyA9IGZ1bmN0aW9uIChzLCBlLCBzaGFwZUxlbmd0aCwgYWRkZWRMZW5ndGgsIHRvdGFsTW9kaWZpZXJMZW5ndGgpIHtcclxuICB2YXIgc2VnbWVudHMgPSBbXTtcclxuICBpZiAoZSA8PSAxKSB7XHJcbiAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgczogcyxcclxuICAgICAgZTogZSxcclxuICAgIH0pO1xyXG4gIH0gZWxzZSBpZiAocyA+PSAxKSB7XHJcbiAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgczogcyAtIDEsXHJcbiAgICAgIGU6IGUgLSAxLFxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNlZ21lbnRzLnB1c2goe1xyXG4gICAgICBzOiBzLFxyXG4gICAgICBlOiAxLFxyXG4gICAgfSk7XHJcbiAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgczogMCxcclxuICAgICAgZTogZSAtIDEsXHJcbiAgICB9KTtcclxuICB9XHJcbiAgdmFyIHNoYXBlU2VnbWVudHMgPSBbXTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xyXG4gIHZhciBzZWdtZW50T2I7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBzZWdtZW50T2IgPSBzZWdtZW50c1tpXTtcclxuICAgIGlmICghKHNlZ21lbnRPYi5lICogdG90YWxNb2RpZmllckxlbmd0aCA8IGFkZGVkTGVuZ3RoIHx8IHNlZ21lbnRPYi5zICogdG90YWxNb2RpZmllckxlbmd0aCA+IGFkZGVkTGVuZ3RoICsgc2hhcGVMZW5ndGgpKSB7XHJcbiAgICAgIHZhciBzaGFwZVM7XHJcbiAgICAgIHZhciBzaGFwZUU7XHJcbiAgICAgIGlmIChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPD0gYWRkZWRMZW5ndGgpIHtcclxuICAgICAgICBzaGFwZVMgPSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNoYXBlUyA9IChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggLSBhZGRlZExlbmd0aCkgLyBzaGFwZUxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2VnbWVudE9iLmUgKiB0b3RhbE1vZGlmaWVyTGVuZ3RoID49IGFkZGVkTGVuZ3RoICsgc2hhcGVMZW5ndGgpIHtcclxuICAgICAgICBzaGFwZUUgPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNoYXBlRSA9ICgoc2VnbWVudE9iLmUgKiB0b3RhbE1vZGlmaWVyTGVuZ3RoIC0gYWRkZWRMZW5ndGgpIC8gc2hhcGVMZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICAgIHNoYXBlU2VnbWVudHMucHVzaChbc2hhcGVTLCBzaGFwZUVdKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCFzaGFwZVNlZ21lbnRzLmxlbmd0aCkge1xyXG4gICAgc2hhcGVTZWdtZW50cy5wdXNoKFswLCAwXSk7XHJcbiAgfVxyXG4gIHJldHVybiBzaGFwZVNlZ21lbnRzO1xyXG59O1xyXG5cclxuVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5yZWxlYXNlUGF0aHNEYXRhID0gZnVuY3Rpb24gKHBhdGhzRGF0YSkge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBwYXRoc0RhdGEubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgc2VnbWVudHNMZW5ndGhQb29sLnJlbGVhc2UocGF0aHNEYXRhW2ldKTtcclxuICB9XHJcbiAgcGF0aHNEYXRhLmxlbmd0aCA9IDA7XHJcbiAgcmV0dXJuIHBhdGhzRGF0YTtcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XHJcbiAgdmFyIHM7XHJcbiAgdmFyIGU7XHJcbiAgaWYgKHRoaXMuX21kZiB8fCBfaXNGaXJzdEZyYW1lKSB7XHJcbiAgICB2YXIgbyA9ICh0aGlzLm8udiAlIDM2MCkgLyAzNjA7XHJcbiAgICBpZiAobyA8IDApIHtcclxuICAgICAgbyArPSAxO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucy52ID4gMSkge1xyXG4gICAgICBzID0gMSArIG87XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMucy52IDwgMCkge1xyXG4gICAgICBzID0gMCArIG87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzID0gdGhpcy5zLnYgKyBvO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZS52ID4gMSkge1xyXG4gICAgICBlID0gMSArIG87XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuZS52IDwgMCkge1xyXG4gICAgICBlID0gMCArIG87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlID0gdGhpcy5lLnYgKyBvO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzID4gZSkge1xyXG4gICAgICB2YXIgX3MgPSBzO1xyXG4gICAgICBzID0gZTtcclxuICAgICAgZSA9IF9zO1xyXG4gICAgfVxyXG4gICAgcyA9IE1hdGgucm91bmQocyAqIDEwMDAwKSAqIDAuMDAwMTtcclxuICAgIGUgPSBNYXRoLnJvdW5kKGUgKiAxMDAwMCkgKiAwLjAwMDE7XHJcbiAgICB0aGlzLnNWYWx1ZSA9IHM7XHJcbiAgICB0aGlzLmVWYWx1ZSA9IGU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHMgPSB0aGlzLnNWYWx1ZTtcclxuICAgIGUgPSB0aGlzLmVWYWx1ZTtcclxuICB9XHJcbiAgdmFyIHNoYXBlUGF0aHM7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcclxuICB2YXIgajtcclxuICB2YXIgakxlbjtcclxuICB2YXIgcGF0aHNEYXRhO1xyXG4gIHZhciBwYXRoRGF0YTtcclxuICB2YXIgdG90YWxTaGFwZUxlbmd0aDtcclxuICB2YXIgdG90YWxNb2RpZmllckxlbmd0aCA9IDA7XHJcblxyXG4gIGlmIChlID09PSBzKSB7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5zaGFwZXNbaV0ubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xyXG4gICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcclxuICAgICAgdGhpcy5zaGFwZXNbaV0uc2hhcGUucGF0aHMgPSB0aGlzLnNoYXBlc1tpXS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgaWYgKHRoaXMuX21kZikge1xyXG4gICAgICAgIHRoaXMuc2hhcGVzW2ldLnBhdGhzRGF0YS5sZW5ndGggPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICghKChlID09PSAxICYmIHMgPT09IDApIHx8IChlID09PSAwICYmIHMgPT09IDEpKSkge1xyXG4gICAgdmFyIHNlZ21lbnRzID0gW107XHJcbiAgICB2YXIgc2hhcGVEYXRhO1xyXG4gICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICAvLyBpZiBzaGFwZSBoYXNuJ3QgY2hhbmdlZCBhbmQgdHJpbSBwcm9wZXJ0aWVzIGhhdmVuJ3QgY2hhbmdlZCwgY2FjaGVkIHByZXZpb3VzIHBhdGggY2FuIGJlIHVzZWRcclxuICAgICAgaWYgKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lICYmIHRoaXMubSAhPT0gMikge1xyXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzO1xyXG4gICAgICAgIGpMZW4gPSBzaGFwZVBhdGhzLl9sZW5ndGg7XHJcbiAgICAgICAgdG90YWxTaGFwZUxlbmd0aCA9IDA7XHJcbiAgICAgICAgaWYgKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiBzaGFwZURhdGEucGF0aHNEYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgdG90YWxTaGFwZUxlbmd0aCA9IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwYXRoc0RhdGEgPSB0aGlzLnJlbGVhc2VQYXRoc0RhdGEoc2hhcGVEYXRhLnBhdGhzRGF0YSk7XHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgIHBhdGhEYXRhID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aHMuc2hhcGVzW2pdKTtcclxuICAgICAgICAgICAgcGF0aHNEYXRhLnB1c2gocGF0aERhdGEpO1xyXG4gICAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoICs9IHBhdGhEYXRhLnRvdGFsTGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggPSB0b3RhbFNoYXBlTGVuZ3RoO1xyXG4gICAgICAgICAgc2hhcGVEYXRhLnBhdGhzRGF0YSA9IHBhdGhzRGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRvdGFsTW9kaWZpZXJMZW5ndGggKz0gdG90YWxTaGFwZUxlbmd0aDtcclxuICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBzaGFwZVMgPSBzO1xyXG4gICAgdmFyIHNoYXBlRSA9IGU7XHJcbiAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xyXG4gICAgdmFyIGVkZ2VzO1xyXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XHJcbiAgICAgIGlmIChzaGFwZURhdGEuc2hhcGUuX21kZikge1xyXG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcclxuICAgICAgICAvLyBpZiBtID09PSAyIG1lYW5zIHBhdGhzIGFyZSB0cmltbWVkIGluZGl2aWR1YWxseSBzbyBlZGdlcyBuZWVkIHRvIGJlIGZvdW5kIGZvciB0aGlzIHNwZWNpZmljIHNoYXBlIHJlbGF0aXZlIHRvIHdob2VsIGdyb3VwXHJcbiAgICAgICAgaWYgKHRoaXMubSA9PT0gMiAmJiBsZW4gPiAxKSB7XHJcbiAgICAgICAgICBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2hhcGVFZGdlcyhzLCBlLCBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCwgYWRkZWRMZW5ndGgsIHRvdGFsTW9kaWZpZXJMZW5ndGgpO1xyXG4gICAgICAgICAgYWRkZWRMZW5ndGggKz0gc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVkZ2VzID0gW1tzaGFwZVMsIHNoYXBlRV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBqTGVuID0gZWRnZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgIHNoYXBlUyA9IGVkZ2VzW2pdWzBdO1xyXG4gICAgICAgICAgc2hhcGVFID0gZWRnZXNbal1bMV07XHJcbiAgICAgICAgICBzZWdtZW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgaWYgKHNoYXBlRSA8PSAxKSB7XHJcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVTLFxyXG4gICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVFLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGVTID49IDEpIHtcclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgczogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiAoc2hhcGVTIC0gMSksXHJcbiAgICAgICAgICAgICAgZTogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiAoc2hhcGVFIC0gMSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgczogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiBzaGFwZVMsXHJcbiAgICAgICAgICAgICAgZTogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICBzOiAwLFxyXG4gICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlRSAtIDEpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLCBzZWdtZW50c1swXSk7XHJcbiAgICAgICAgICBpZiAoc2VnbWVudHNbMF0ucyAhPT0gc2VnbWVudHNbMF0uZSkge1xyXG4gICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgIHZhciBsYXN0U2hhcGVJbkNvbGxlY3Rpb24gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzW3NoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgaWYgKGxhc3RTaGFwZUluQ29sbGVjdGlvbi5jKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFNoYXBlID0gbmV3U2hhcGVzRGF0YS5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUGF0aHMobmV3U2hhcGVzRGF0YSwgbG9jYWxTaGFwZUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgbmV3U2hhcGVzRGF0YSA9IHRoaXMuYWRkU2hhcGVzKHNoYXBlRGF0YSwgc2VnbWVudHNbMV0sIGxhc3RTaGFwZSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUGF0aHMobmV3U2hhcGVzRGF0YSwgbG9jYWxTaGFwZUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgbmV3U2hhcGVzRGF0YSA9IHRoaXMuYWRkU2hhcGVzKHNoYXBlRGF0YSwgc2VnbWVudHNbMV0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZFBhdGhzKG5ld1NoYXBlc0RhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gbG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHRoaXMuX21kZikge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIC8vIFJlbGVhc2lnbiBUcmltIENhY2hlZCBwYXRocyBkYXRhIHdoZW4gbm8gdHJpbSBhcHBsaWVkIGluIGNhc2Ugc2hhcGVzIGFyZSBtb2RpZmllZCBpbmJldHdlZW4uXHJcbiAgICAgIC8vIERvbid0IHJlbW92ZSB0aGlzIGV2ZW4gaWYgaXQncyBsb3NpbmcgY2FjaGVkIGluZm8uXHJcbiAgICAgIHRoaXMuc2hhcGVzW2ldLnBhdGhzRGF0YS5sZW5ndGggPSAwO1xyXG4gICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5UcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFBhdGhzID0gZnVuY3Rpb24gKG5ld1BhdGhzLCBsb2NhbFNoYXBlQ29sbGVjdGlvbikge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBuZXdQYXRocy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZShuZXdQYXRoc1tpXSk7XHJcbiAgfVxyXG59O1xyXG5cclxuVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTZWdtZW50ID0gZnVuY3Rpb24gKHB0MSwgcHQyLCBwdDMsIHB0NCwgc2hhcGVQYXRoLCBwb3MsIG5ld1NoYXBlKSB7XHJcbiAgc2hhcGVQYXRoLnNldFhZQXQocHQyWzBdLCBwdDJbMV0sICdvJywgcG9zKTtcclxuICBzaGFwZVBhdGguc2V0WFlBdChwdDNbMF0sIHB0M1sxXSwgJ2knLCBwb3MgKyAxKTtcclxuICBpZiAobmV3U2hhcGUpIHtcclxuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHB0MVswXSwgcHQxWzFdLCAndicsIHBvcyk7XHJcbiAgfVxyXG4gIHNoYXBlUGF0aC5zZXRYWUF0KHB0NFswXSwgcHQ0WzFdLCAndicsIHBvcyArIDEpO1xyXG59O1xyXG5cclxuVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTZWdtZW50RnJvbUFycmF5ID0gZnVuY3Rpb24gKHBvaW50cywgc2hhcGVQYXRoLCBwb3MsIG5ld1NoYXBlKSB7XHJcbiAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzFdLCBwb2ludHNbNV0sICdvJywgcG9zKTtcclxuICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbMl0sIHBvaW50c1s2XSwgJ2knLCBwb3MgKyAxKTtcclxuICBpZiAobmV3U2hhcGUpIHtcclxuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHBvaW50c1swXSwgcG9pbnRzWzRdLCAndicsIHBvcyk7XHJcbiAgfVxyXG4gIHNoYXBlUGF0aC5zZXRYWUF0KHBvaW50c1szXSwgcG9pbnRzWzddLCAndicsIHBvcyArIDEpO1xyXG59O1xyXG5cclxuVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZXMgPSBmdW5jdGlvbiAoc2hhcGVEYXRhLCBzaGFwZVNlZ21lbnQsIHNoYXBlUGF0aCkge1xyXG4gIHZhciBwYXRoc0RhdGEgPSBzaGFwZURhdGEucGF0aHNEYXRhO1xyXG4gIHZhciBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcclxuICB2YXIgY3VycmVudExlbmd0aERhdGE7XHJcbiAgdmFyIHNlZ21lbnRDb3VudDtcclxuICB2YXIgbGVuZ3RocztcclxuICB2YXIgc2VnbWVudDtcclxuICB2YXIgc2hhcGVzID0gW107XHJcbiAgdmFyIGluaXRQb3M7XHJcbiAgdmFyIG5ld1NoYXBlID0gdHJ1ZTtcclxuICBpZiAoIXNoYXBlUGF0aCkge1xyXG4gICAgc2hhcGVQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcclxuICAgIHNlZ21lbnRDb3VudCA9IDA7XHJcbiAgICBpbml0UG9zID0gMDtcclxuICB9IGVsc2Uge1xyXG4gICAgc2VnbWVudENvdW50ID0gc2hhcGVQYXRoLl9sZW5ndGg7XHJcbiAgICBpbml0UG9zID0gc2hhcGVQYXRoLl9sZW5ndGg7XHJcbiAgfVxyXG4gIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBsZW5ndGhzID0gcGF0aHNEYXRhW2ldLmxlbmd0aHM7XHJcbiAgICBzaGFwZVBhdGguYyA9IHNoYXBlUGF0aHNbaV0uYztcclxuICAgIGpMZW4gPSBzaGFwZVBhdGhzW2ldLmMgPyBsZW5ndGhzLmxlbmd0aCA6IGxlbmd0aHMubGVuZ3RoICsgMTtcclxuICAgIGZvciAoaiA9IDE7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgY3VycmVudExlbmd0aERhdGEgPSBsZW5ndGhzW2ogLSAxXTtcclxuICAgICAgaWYgKGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGggPCBzaGFwZVNlZ21lbnQucykge1xyXG4gICAgICAgIGFkZGVkTGVuZ3RoICs9IGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoO1xyXG4gICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSBpZiAoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xyXG4gICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHNoYXBlU2VnbWVudC5zIDw9IGFkZGVkTGVuZ3RoICYmIHNoYXBlU2VnbWVudC5lID49IGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgpIHtcclxuICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbal0sIHNoYXBlUGF0aHNbaV0udltqXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcclxuICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbal0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVtqXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgsIChzaGFwZVNlZ21lbnQuZSAtIGFkZGVkTGVuZ3RoKSAvIGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoLCBsZW5ndGhzW2ogLSAxXSk7XHJcbiAgICAgICAgICB0aGlzLmFkZFNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcclxuICAgICAgICAgIC8vIHRoaXMuYWRkU2VnbWVudChzZWdtZW50LnB0MSwgc2VnbWVudC5wdDMsIHNlZ21lbnQucHQ0LCBzZWdtZW50LnB0Miwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcclxuICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XHJcbiAgICAgICAgICBzaGFwZVBhdGguYyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcclxuICAgICAgICBzZWdtZW50Q291bnQgKz0gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlUGF0aHNbaV0uYyAmJiBsZW5ndGhzLmxlbmd0aCkge1xyXG4gICAgICBjdXJyZW50TGVuZ3RoRGF0YSA9IGxlbmd0aHNbaiAtIDFdO1xyXG4gICAgICBpZiAoYWRkZWRMZW5ndGggPD0gc2hhcGVTZWdtZW50LmUpIHtcclxuICAgICAgICB2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aHNbaiAtIDFdLmFkZGVkTGVuZ3RoO1xyXG4gICAgICAgIGlmIChzaGFwZVNlZ21lbnQucyA8PSBhZGRlZExlbmd0aCAmJiBzaGFwZVNlZ21lbnQuZSA+PSBhZGRlZExlbmd0aCArIHNlZ21lbnRMZW5ndGgpIHtcclxuICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbMF0sIHNoYXBlUGF0aHNbaV0udlswXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcclxuICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbMF0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVswXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgKHNoYXBlU2VnbWVudC5lIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgbGVuZ3Roc1tqIC0gMV0pO1xyXG4gICAgICAgICAgdGhpcy5hZGRTZWdtZW50RnJvbUFycmF5KHNlZ21lbnQsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XHJcbiAgICAgICAgICAvLyB0aGlzLmFkZFNlZ21lbnQoc2VnbWVudC5wdDEsIHNlZ21lbnQucHQzLCBzZWdtZW50LnB0NCwgc2VnbWVudC5wdDIsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XHJcbiAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xyXG4gICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcclxuICAgICAgc2VnbWVudENvdW50ICs9IDE7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVQYXRoLl9sZW5ndGgpIHtcclxuICAgICAgc2hhcGVQYXRoLnNldFhZQXQoc2hhcGVQYXRoLnZbaW5pdFBvc11bMF0sIHNoYXBlUGF0aC52W2luaXRQb3NdWzFdLCAnaScsIGluaXRQb3MpO1xyXG4gICAgICBzaGFwZVBhdGguc2V0WFlBdChzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzBdLCBzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzFdLCAnbycsIHNoYXBlUGF0aC5fbGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmIChpIDwgbGVuIC0gMSkge1xyXG4gICAgICBzaGFwZVBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgICBuZXdTaGFwZSA9IHRydWU7XHJcbiAgICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XHJcbiAgICAgIHNlZ21lbnRDb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzaGFwZXM7XHJcbn07XHJcblxyXG5TaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCd0bScsIFRyaW1Nb2RpZmllcik7XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBTaGFwZU1vZGlmaWVyLCBQcm9wZXJ0eUZhY3RvcnksIHNoYXBlUG9vbCwgcm91bmRDb3JuZXIsIFNoYXBlTW9kaWZpZXJzICovXHJcblxyXG5mdW5jdGlvbiBSb3VuZENvcm5lcnNNb2RpZmllcigpIHt9XHJcbmV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFJvdW5kQ29ybmVyc01vZGlmaWVyKTtcclxuUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xyXG4gIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xyXG4gIHRoaXMucmQgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIG51bGwsIHRoaXMpO1xyXG4gIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMucmQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxufTtcclxuXHJcblJvdW5kQ29ybmVyc01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByb3VuZCkge1xyXG4gIHZhciBjbG9uZWRQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcclxuICBjbG9uZWRQYXRoLmMgPSBwYXRoLmM7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHBhdGguX2xlbmd0aDtcclxuICB2YXIgY3VycmVudFY7XHJcbiAgdmFyIGN1cnJlbnRJO1xyXG4gIHZhciBjdXJyZW50TztcclxuICB2YXIgY2xvc2VyVjtcclxuICB2YXIgZGlzdGFuY2U7XHJcbiAgdmFyIG5ld1Bvc1BlcmM7XHJcbiAgdmFyIGluZGV4ID0gMDtcclxuICB2YXIgdlg7XHJcbiAgdmFyIHZZO1xyXG4gIHZhciBvWDtcclxuICB2YXIgb1k7XHJcbiAgdmFyIGlYO1xyXG4gIHZhciBpWTtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGN1cnJlbnRWID0gcGF0aC52W2ldO1xyXG4gICAgY3VycmVudE8gPSBwYXRoLm9baV07XHJcbiAgICBjdXJyZW50SSA9IHBhdGguaVtpXTtcclxuICAgIGlmIChjdXJyZW50VlswXSA9PT0gY3VycmVudE9bMF0gJiYgY3VycmVudFZbMV0gPT09IGN1cnJlbnRPWzFdICYmIGN1cnJlbnRWWzBdID09PSBjdXJyZW50SVswXSAmJiBjdXJyZW50VlsxXSA9PT0gY3VycmVudElbMV0pIHtcclxuICAgICAgaWYgKChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpICYmICFwYXRoLmMpIHtcclxuICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KGN1cnJlbnRWWzBdLCBjdXJyZW50VlsxXSwgY3VycmVudE9bMF0sIGN1cnJlbnRPWzFdLCBjdXJyZW50SVswXSwgY3VycmVudElbMV0sIGluZGV4KTtcclxuICAgICAgICAvKiBjbG9uZWRQYXRoLnZbaW5kZXhdID0gY3VycmVudFY7XHJcbiAgICAgICAgICAgICAgICBjbG9uZWRQYXRoLm9baW5kZXhdID0gY3VycmVudE87XHJcbiAgICAgICAgICAgICAgICBjbG9uZWRQYXRoLmlbaW5kZXhdID0gY3VycmVudEk7ICovXHJcbiAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgY2xvc2VyViA9IHBhdGgudltsZW4gLSAxXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2xvc2VyViA9IHBhdGgudltpIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnJlbnRWWzBdIC0gY2xvc2VyVlswXSwgMikgKyBNYXRoLnBvdyhjdXJyZW50VlsxXSAtIGNsb3NlclZbMV0sIDIpKTtcclxuICAgICAgICBuZXdQb3NQZXJjID0gZGlzdGFuY2UgPyBNYXRoLm1pbihkaXN0YW5jZSAvIDIsIHJvdW5kKSAvIGRpc3RhbmNlIDogMDtcclxuICAgICAgICBpWCA9IGN1cnJlbnRWWzBdICsgKGNsb3NlclZbMF0gLSBjdXJyZW50VlswXSkgKiBuZXdQb3NQZXJjO1xyXG4gICAgICAgIHZYID0gaVg7XHJcbiAgICAgICAgaVkgPSBjdXJyZW50VlsxXSAtIChjdXJyZW50VlsxXSAtIGNsb3NlclZbMV0pICogbmV3UG9zUGVyYztcclxuICAgICAgICB2WSA9IGlZO1xyXG4gICAgICAgIG9YID0gdlggLSAodlggLSBjdXJyZW50VlswXSkgKiByb3VuZENvcm5lcjtcclxuICAgICAgICBvWSA9IHZZIC0gKHZZIC0gY3VycmVudFZbMV0pICogcm91bmRDb3JuZXI7XHJcbiAgICAgICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdCh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBpbmRleCk7XHJcbiAgICAgICAgaW5kZXggKz0gMTtcclxuXHJcbiAgICAgICAgaWYgKGkgPT09IGxlbiAtIDEpIHtcclxuICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbaSArIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJyZW50VlswXSAtIGNsb3NlclZbMF0sIDIpICsgTWF0aC5wb3coY3VycmVudFZbMV0gLSBjbG9zZXJWWzFdLCAyKSk7XHJcbiAgICAgICAgbmV3UG9zUGVyYyA9IGRpc3RhbmNlID8gTWF0aC5taW4oZGlzdGFuY2UgLyAyLCByb3VuZCkgLyBkaXN0YW5jZSA6IDA7XHJcbiAgICAgICAgb1ggPSBjdXJyZW50VlswXSArIChjbG9zZXJWWzBdIC0gY3VycmVudFZbMF0pICogbmV3UG9zUGVyYztcclxuICAgICAgICB2WCA9IG9YO1xyXG4gICAgICAgIG9ZID0gY3VycmVudFZbMV0gKyAoY2xvc2VyVlsxXSAtIGN1cnJlbnRWWzFdKSAqIG5ld1Bvc1BlcmM7XHJcbiAgICAgICAgdlkgPSBvWTtcclxuICAgICAgICBpWCA9IHZYIC0gKHZYIC0gY3VycmVudFZbMF0pICogcm91bmRDb3JuZXI7XHJcbiAgICAgICAgaVkgPSB2WSAtICh2WSAtIGN1cnJlbnRWWzFdKSAqIHJvdW5kQ29ybmVyO1xyXG4gICAgICAgIGNsb25lZFBhdGguc2V0VHJpcGxlQXQodlgsIHZZLCBvWCwgb1ksIGlYLCBpWSwgaW5kZXgpO1xyXG4gICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNsb25lZFBhdGguc2V0VHJpcGxlQXQocGF0aC52W2ldWzBdLCBwYXRoLnZbaV1bMV0sIHBhdGgub1tpXVswXSwgcGF0aC5vW2ldWzFdLCBwYXRoLmlbaV1bMF0sIHBhdGguaVtpXVsxXSwgaW5kZXgpO1xyXG4gICAgICBpbmRleCArPSAxO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY2xvbmVkUGF0aDtcclxufTtcclxuXHJcblJvdW5kQ29ybmVyc01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcclxuICB2YXIgc2hhcGVQYXRocztcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xyXG4gIHZhciBqO1xyXG4gIHZhciBqTGVuO1xyXG4gIHZhciByZCA9IHRoaXMucmQudjtcclxuXHJcbiAgaWYgKHJkICE9PSAwKSB7XHJcbiAgICB2YXIgc2hhcGVEYXRhO1xyXG4gICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgaWYgKCEoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUpKSB7XHJcbiAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xyXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcclxuICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcclxuICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCByZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzaGFwZURhdGEuc2hhcGUucGF0aHMgPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcblNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3JkJywgUm91bmRDb3JuZXJzTW9kaWZpZXIpO1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgU2hhcGVNb2RpZmllciwgUHJvcGVydHlGYWN0b3J5LCBzaGFwZVBvb2wsIFNoYXBlTW9kaWZpZXJzICovXHJcblxyXG5mdW5jdGlvbiBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKCkge31cclxuZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgUHVja2VyQW5kQmxvYXRNb2RpZmllcik7XHJcblB1Y2tlckFuZEJsb2F0TW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xyXG4gIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xyXG4gIHRoaXMuYW1vdW50ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5hLCAwLCBudWxsLCB0aGlzKTtcclxuICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLmFtb3VudC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xyXG59O1xyXG5cclxuUHVja2VyQW5kQmxvYXRNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgYW1vdW50KSB7XHJcbiAgdmFyIHBlcmNlbnQgPSBhbW91bnQgLyAxMDA7XHJcbiAgdmFyIGNlbnRlclBvaW50ID0gWzAsIDBdO1xyXG4gIHZhciBwYXRoTGVuZ3RoID0gcGF0aC5fbGVuZ3RoO1xyXG4gIHZhciBpID0gMDtcclxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aExlbmd0aDsgaSArPSAxKSB7XHJcbiAgICBjZW50ZXJQb2ludFswXSArPSBwYXRoLnZbaV1bMF07XHJcbiAgICBjZW50ZXJQb2ludFsxXSArPSBwYXRoLnZbaV1bMV07XHJcbiAgfVxyXG4gIGNlbnRlclBvaW50WzBdIC89IHBhdGhMZW5ndGg7XHJcbiAgY2VudGVyUG9pbnRbMV0gLz0gcGF0aExlbmd0aDtcclxuICB2YXIgY2xvbmVkUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgY2xvbmVkUGF0aC5jID0gcGF0aC5jO1xyXG4gIHZhciB2WDtcclxuICB2YXIgdlk7XHJcbiAgdmFyIG9YO1xyXG4gIHZhciBvWTtcclxuICB2YXIgaVg7XHJcbiAgdmFyIGlZO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoTGVuZ3RoOyBpICs9IDEpIHtcclxuICAgIHZYID0gcGF0aC52W2ldWzBdICsgKGNlbnRlclBvaW50WzBdIC0gcGF0aC52W2ldWzBdKSAqIHBlcmNlbnQ7XHJcbiAgICB2WSA9IHBhdGgudltpXVsxXSArIChjZW50ZXJQb2ludFsxXSAtIHBhdGgudltpXVsxXSkgKiBwZXJjZW50O1xyXG4gICAgb1ggPSBwYXRoLm9baV1bMF0gKyAoY2VudGVyUG9pbnRbMF0gLSBwYXRoLm9baV1bMF0pICogLXBlcmNlbnQ7XHJcbiAgICBvWSA9IHBhdGgub1tpXVsxXSArIChjZW50ZXJQb2ludFsxXSAtIHBhdGgub1tpXVsxXSkgKiAtcGVyY2VudDtcclxuICAgIGlYID0gcGF0aC5pW2ldWzBdICsgKGNlbnRlclBvaW50WzBdIC0gcGF0aC5pW2ldWzBdKSAqIC1wZXJjZW50O1xyXG4gICAgaVkgPSBwYXRoLmlbaV1bMV0gKyAoY2VudGVyUG9pbnRbMV0gLSBwYXRoLmlbaV1bMV0pICogLXBlcmNlbnQ7XHJcbiAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIGkpO1xyXG4gIH1cclxuICByZXR1cm4gY2xvbmVkUGF0aDtcclxufTtcclxuXHJcblB1Y2tlckFuZEJsb2F0TW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xyXG4gIHZhciBzaGFwZVBhdGhzO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIGFtb3VudCA9IHRoaXMuYW1vdW50LnY7XHJcblxyXG4gIGlmIChhbW91bnQgIT09IDApIHtcclxuICAgIHZhciBzaGFwZURhdGE7XHJcbiAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XHJcbiAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgICBpZiAoISghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgIXRoaXMuX21kZiAmJiAhX2lzRmlyc3RGcmFtZSkpIHtcclxuICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XHJcbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLl9tZGYgPSB0cnVlO1xyXG4gICAgICAgIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzO1xyXG4gICAgICAgIGpMZW4gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aDtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIGFtb3VudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzaGFwZURhdGEuc2hhcGUucGF0aHMgPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gIH1cclxufTtcclxuU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcigncGInLCBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIFNoYXBlTW9kaWZpZXIsIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSwgUHJvcGVydHlGYWN0b3J5LCBNYXRyaXgsIFNoYXBlTW9kaWZpZXJzICovXHJcblxyXG5mdW5jdGlvbiBSZXBlYXRlck1vZGlmaWVyKCkge31cclxuZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgUmVwZWF0ZXJNb2RpZmllcik7XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcclxuICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcclxuICB0aGlzLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmMsIDAsIG51bGwsIHRoaXMpO1xyXG4gIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgbnVsbCwgdGhpcyk7XHJcbiAgdGhpcy50ciA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLCBkYXRhLnRyLCB0aGlzKTtcclxuICB0aGlzLnNvID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS50ci5zbywgMCwgMC4wMSwgdGhpcyk7XHJcbiAgdGhpcy5lbyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudHIuZW8sIDAsIDAuMDEsIHRoaXMpO1xyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcclxuICB9XHJcbiAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgdGhpcy5wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gIHRoaXMuck1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcclxuICB0aGlzLnNNYXRyaXggPSBuZXcgTWF0cml4KCk7XHJcbiAgdGhpcy50TWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG59O1xyXG5cclxuUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1zID0gZnVuY3Rpb24gKHBNYXRyaXgsIHJNYXRyaXgsIHNNYXRyaXgsIHRyYW5zZm9ybSwgcGVyYywgaW52KSB7XHJcbiAgdmFyIGRpciA9IGludiA/IC0xIDogMTtcclxuICB2YXIgc2NhbGVYID0gdHJhbnNmb3JtLnMudlswXSArICgxIC0gdHJhbnNmb3JtLnMudlswXSkgKiAoMSAtIHBlcmMpO1xyXG4gIHZhciBzY2FsZVkgPSB0cmFuc2Zvcm0ucy52WzFdICsgKDEgLSB0cmFuc2Zvcm0ucy52WzFdKSAqICgxIC0gcGVyYyk7XHJcbiAgcE1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLnAudlswXSAqIGRpciAqIHBlcmMsIHRyYW5zZm9ybS5wLnZbMV0gKiBkaXIgKiBwZXJjLCB0cmFuc2Zvcm0ucC52WzJdKTtcclxuICByTWF0cml4LnRyYW5zbGF0ZSgtdHJhbnNmb3JtLmEudlswXSwgLXRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xyXG4gIHJNYXRyaXgucm90YXRlKC10cmFuc2Zvcm0uci52ICogZGlyICogcGVyYyk7XHJcbiAgck1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLmEudlswXSwgdHJhbnNmb3JtLmEudlsxXSwgdHJhbnNmb3JtLmEudlsyXSk7XHJcbiAgc01hdHJpeC50cmFuc2xhdGUoLXRyYW5zZm9ybS5hLnZbMF0sIC10cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcclxuICBzTWF0cml4LnNjYWxlKGludiA/IDEgLyBzY2FsZVggOiBzY2FsZVgsIGludiA/IDEgLyBzY2FsZVkgOiBzY2FsZVkpO1xyXG4gIHNNYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybS5hLnZbMF0sIHRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xyXG59O1xyXG5cclxuUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlbGVtLCBhcnIsIHBvcywgZWxlbXNEYXRhKSB7XHJcbiAgdGhpcy5lbGVtID0gZWxlbTtcclxuICB0aGlzLmFyciA9IGFycjtcclxuICB0aGlzLnBvcyA9IHBvcztcclxuICB0aGlzLmVsZW1zRGF0YSA9IGVsZW1zRGF0YTtcclxuICB0aGlzLl9jdXJyZW50Q29waWVzID0gMDtcclxuICB0aGlzLl9lbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMuX2dyb3VwcyA9IFtdO1xyXG4gIHRoaXMuZnJhbWVJZCA9IC0xO1xyXG4gIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcclxuICB0aGlzLmluaXRNb2RpZmllclByb3BlcnRpZXMoZWxlbSwgYXJyW3Bvc10pO1xyXG4gIHdoaWxlIChwb3MgPiAwKSB7XHJcbiAgICBwb3MgLT0gMTtcclxuICAgIC8vIHRoaXMuX2VsZW1lbnRzLnVuc2hpZnQoYXJyLnNwbGljZShwb3MsMSlbMF0pO1xyXG4gICAgdGhpcy5fZWxlbWVudHMudW5zaGlmdChhcnJbcG9zXSk7XHJcbiAgfVxyXG4gIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5rID0gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcclxuICB9XHJcbn07XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5yZXNldEVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGVsZW1lbnRzW2ldLl9wcm9jZXNzZWQgPSBmYWxzZTtcclxuICAgIGlmIChlbGVtZW50c1tpXS50eSA9PT0gJ2dyJykge1xyXG4gICAgICB0aGlzLnJlc2V0RWxlbWVudHMoZWxlbWVudHNbaV0uaXQpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmNsb25lRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcclxuICB2YXIgbmV3RWxlbWVudHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnRzKSk7XHJcbiAgdGhpcy5yZXNldEVsZW1lbnRzKG5ld0VsZW1lbnRzKTtcclxuICByZXR1cm4gbmV3RWxlbWVudHM7XHJcbn07XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5jaGFuZ2VHcm91cFJlbmRlciA9IGZ1bmN0aW9uIChlbGVtZW50cywgcmVuZGVyRmxhZykge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBlbGVtZW50c1tpXS5fcmVuZGVyID0gcmVuZGVyRmxhZztcclxuICAgIGlmIChlbGVtZW50c1tpXS50eSA9PT0gJ2dyJykge1xyXG4gICAgICB0aGlzLmNoYW5nZUdyb3VwUmVuZGVyKGVsZW1lbnRzW2ldLml0LCByZW5kZXJGbGFnKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcclxuICB2YXIgaXRlbXM7XHJcbiAgdmFyIGl0ZW1zVHJhbnNmb3JtO1xyXG4gIHZhciBpO1xyXG4gIHZhciBkaXI7XHJcbiAgdmFyIGNvbnQ7XHJcbiAgdmFyIGhhc1JlbG9hZGVkID0gZmFsc2U7XHJcbiAgaWYgKHRoaXMuX21kZiB8fCBfaXNGaXJzdEZyYW1lKSB7XHJcbiAgICB2YXIgY29waWVzID0gTWF0aC5jZWlsKHRoaXMuYy52KTtcclxuICAgIGlmICh0aGlzLl9ncm91cHMubGVuZ3RoIDwgY29waWVzKSB7XHJcbiAgICAgIHdoaWxlICh0aGlzLl9ncm91cHMubGVuZ3RoIDwgY29waWVzKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwID0ge1xyXG4gICAgICAgICAgaXQ6IHRoaXMuY2xvbmVFbGVtZW50cyh0aGlzLl9lbGVtZW50cyksXHJcbiAgICAgICAgICB0eTogJ2dyJyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGdyb3VwLml0LnB1c2goe1xyXG4gICAgICAgICAgYTogeyBhOiAwLCBpeDogMSwgazogWzAsIDBdIH0sIG5tOiAnVHJhbnNmb3JtJywgbzogeyBhOiAwLCBpeDogNywgazogMTAwIH0sIHA6IHsgYTogMCwgaXg6IDIsIGs6IFswLCAwXSB9LCByOiB7IGE6IDEsIGl4OiA2LCBrOiBbeyBzOiAwLCBlOiAwLCB0OiAwIH0sIHsgczogMCwgZTogMCwgdDogMSB9XSB9LCBzOiB7IGE6IDAsIGl4OiAzLCBrOiBbMTAwLCAxMDBdIH0sIHNhOiB7IGE6IDAsIGl4OiA1LCBrOiAwIH0sIHNrOiB7IGE6IDAsIGl4OiA0LCBrOiAwIH0sIHR5OiAndHInLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFyci5zcGxpY2UoMCwgMCwgZ3JvdXApO1xyXG4gICAgICAgIHRoaXMuX2dyb3Vwcy5zcGxpY2UoMCwgMCwgZ3JvdXApO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb3BpZXMgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVsZW0ucmVsb2FkU2hhcGVzKCk7XHJcbiAgICAgIGhhc1JlbG9hZGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnQgPSAwO1xyXG4gICAgdmFyIHJlbmRlckZsYWc7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDw9IHRoaXMuX2dyb3Vwcy5sZW5ndGggLSAxOyBpICs9IDEpIHtcclxuICAgICAgcmVuZGVyRmxhZyA9IGNvbnQgPCBjb3BpZXM7XHJcbiAgICAgIHRoaXMuX2dyb3Vwc1tpXS5fcmVuZGVyID0gcmVuZGVyRmxhZztcclxuICAgICAgdGhpcy5jaGFuZ2VHcm91cFJlbmRlcih0aGlzLl9ncm91cHNbaV0uaXQsIHJlbmRlckZsYWcpO1xyXG4gICAgICBpZiAoIXJlbmRlckZsYWcpIHtcclxuICAgICAgICB2YXIgZWxlbXMgPSB0aGlzLmVsZW1zRGF0YVtpXS5pdDtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtRGF0YSA9IGVsZW1zW2VsZW1zLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC52ICE9PSAwKSB7XHJcbiAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC5fbWRmID0gdHJ1ZTtcclxuICAgICAgICAgIHRyYW5zZm9ybURhdGEudHJhbnNmb3JtLm9wLnYgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC5fbWRmID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnQgKz0gMTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jdXJyZW50Q29waWVzID0gY29waWVzO1xyXG4gICAgLy8vIC9cclxuXHJcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vLnY7XHJcbiAgICB2YXIgb2Zmc2V0TW9kdWxvID0gb2Zmc2V0ICUgMTtcclxuICAgIHZhciByb3VuZE9mZnNldCA9IG9mZnNldCA+IDAgPyBNYXRoLmZsb29yKG9mZnNldCkgOiBNYXRoLmNlaWwob2Zmc2V0KTtcclxuICAgIHZhciBwUHJvcHMgPSB0aGlzLnBNYXRyaXgucHJvcHM7XHJcbiAgICB2YXIgclByb3BzID0gdGhpcy5yTWF0cml4LnByb3BzO1xyXG4gICAgdmFyIHNQcm9wcyA9IHRoaXMuc01hdHJpeC5wcm9wcztcclxuICAgIHRoaXMucE1hdHJpeC5yZXNldCgpO1xyXG4gICAgdGhpcy5yTWF0cml4LnJlc2V0KCk7XHJcbiAgICB0aGlzLnNNYXRyaXgucmVzZXQoKTtcclxuICAgIHRoaXMudE1hdHJpeC5yZXNldCgpO1xyXG4gICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcclxuICAgIHZhciBpdGVyYXRpb24gPSAwO1xyXG5cclxuICAgIGlmIChvZmZzZXQgPiAwKSB7XHJcbiAgICAgIHdoaWxlIChpdGVyYXRpb24gPCByb3VuZE9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIGZhbHNlKTtcclxuICAgICAgICBpdGVyYXRpb24gKz0gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob2Zmc2V0TW9kdWxvKSB7XHJcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgb2Zmc2V0TW9kdWxvLCBmYWxzZSk7XHJcbiAgICAgICAgaXRlcmF0aW9uICs9IG9mZnNldE1vZHVsbztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvZmZzZXQgPCAwKSB7XHJcbiAgICAgIHdoaWxlIChpdGVyYXRpb24gPiByb3VuZE9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIHRydWUpO1xyXG4gICAgICAgIGl0ZXJhdGlvbiAtPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvZmZzZXRNb2R1bG8pIHtcclxuICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAtb2Zmc2V0TW9kdWxvLCB0cnVlKTtcclxuICAgICAgICBpdGVyYXRpb24gLT0gb2Zmc2V0TW9kdWxvO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpID0gdGhpcy5kYXRhLm0gPT09IDEgPyAwIDogdGhpcy5fY3VycmVudENvcGllcyAtIDE7XHJcbiAgICBkaXIgPSB0aGlzLmRhdGEubSA9PT0gMSA/IDEgOiAtMTtcclxuICAgIGNvbnQgPSB0aGlzLl9jdXJyZW50Q29waWVzO1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgakxlbjtcclxuICAgIHdoaWxlIChjb250KSB7XHJcbiAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XHJcbiAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xyXG4gICAgICBqTGVuID0gaXRlbXNUcmFuc2Zvcm0ubGVuZ3RoO1xyXG4gICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSB0cnVlO1xyXG4gICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ub3AuX21kZiA9IHRydWU7XHJcbiAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5vcC52ID0gdGhpcy5fY3VycmVudENvcGllcyA9PT0gMVxyXG4gICAgICAgID8gdGhpcy5zby52XHJcbiAgICAgICAgOiB0aGlzLnNvLnYgKyAodGhpcy5lby52IC0gdGhpcy5zby52KSAqIChpIC8gKHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxKSk7XHJcblxyXG4gICAgICBpZiAoaXRlcmF0aW9uICE9PSAwKSB7XHJcbiAgICAgICAgaWYgKChpICE9PSAwICYmIGRpciA9PT0gMSkgfHwgKGkgIT09IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxICYmIGRpciA9PT0gLTEpKSB7XHJcbiAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAxLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShyUHJvcHNbMF0sIHJQcm9wc1sxXSwgclByb3BzWzJdLCByUHJvcHNbM10sIHJQcm9wc1s0XSwgclByb3BzWzVdLCByUHJvcHNbNl0sIHJQcm9wc1s3XSwgclByb3BzWzhdLCByUHJvcHNbOV0sIHJQcm9wc1sxMF0sIHJQcm9wc1sxMV0sIHJQcm9wc1sxMl0sIHJQcm9wc1sxM10sIHJQcm9wc1sxNF0sIHJQcm9wc1sxNV0pO1xyXG4gICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShzUHJvcHNbMF0sIHNQcm9wc1sxXSwgc1Byb3BzWzJdLCBzUHJvcHNbM10sIHNQcm9wc1s0XSwgc1Byb3BzWzVdLCBzUHJvcHNbNl0sIHNQcm9wc1s3XSwgc1Byb3BzWzhdLCBzUHJvcHNbOV0sIHNQcm9wc1sxMF0sIHNQcm9wc1sxMV0sIHNQcm9wc1sxMl0sIHNQcm9wc1sxM10sIHNQcm9wc1sxNF0sIHNQcm9wc1sxNV0pO1xyXG4gICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShwUHJvcHNbMF0sIHBQcm9wc1sxXSwgcFByb3BzWzJdLCBwUHJvcHNbM10sIHBQcm9wc1s0XSwgcFByb3BzWzVdLCBwUHJvcHNbNl0sIHBQcm9wc1s3XSwgcFByb3BzWzhdLCBwUHJvcHNbOV0sIHBQcm9wc1sxMF0sIHBQcm9wc1sxMV0sIHBQcm9wc1sxMl0sIHBQcm9wc1sxM10sIHBQcm9wc1sxNF0sIHBQcm9wc1sxNV0pO1xyXG5cclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICBpdGVtc1RyYW5zZm9ybVtqXSA9IHRoaXMubWF0cml4LnByb3BzW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubWF0cml4LnJlc2V0KCk7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgaXRlbXNUcmFuc2Zvcm1bal0gPSB0aGlzLm1hdHJpeC5wcm9wc1tqXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaXRlcmF0aW9uICs9IDE7XHJcbiAgICAgIGNvbnQgLT0gMTtcclxuICAgICAgaSArPSBkaXI7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnQgPSB0aGlzLl9jdXJyZW50Q29waWVzO1xyXG4gICAgaSA9IDA7XHJcbiAgICBkaXIgPSAxO1xyXG4gICAgd2hpbGUgKGNvbnQpIHtcclxuICAgICAgaXRlbXMgPSB0aGlzLmVsZW1zRGF0YVtpXS5pdDtcclxuICAgICAgaXRlbXNUcmFuc2Zvcm0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLnYucHJvcHM7XHJcbiAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5tUHJvcHMuX21kZiA9IGZhbHNlO1xyXG4gICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ub3AuX21kZiA9IGZhbHNlO1xyXG4gICAgICBjb250IC09IDE7XHJcbiAgICAgIGkgKz0gZGlyO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gaGFzUmVsb2FkZWQ7XHJcbn07XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcigncnAnLCBSZXBlYXRlck1vZGlmaWVyKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5LCBzaGFwZVBvb2wgKi9cclxuXHJcbmZ1bmN0aW9uIFNoYXBlQ29sbGVjdGlvbigpIHtcclxuICB0aGlzLl9sZW5ndGggPSAwO1xyXG4gIHRoaXMuX21heExlbmd0aCA9IDQ7XHJcbiAgdGhpcy5zaGFwZXMgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XHJcbn1cclxuXHJcblNoYXBlQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoc2hhcGVEYXRhKSB7XHJcbiAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gdGhpcy5fbWF4TGVuZ3RoKSB7XHJcbiAgICB0aGlzLnNoYXBlcyA9IHRoaXMuc2hhcGVzLmNvbmNhdChjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCkpO1xyXG4gICAgdGhpcy5fbWF4TGVuZ3RoICo9IDI7XHJcbiAgfVxyXG4gIHRoaXMuc2hhcGVzW3RoaXMuX2xlbmd0aF0gPSBzaGFwZURhdGE7XHJcbiAgdGhpcy5fbGVuZ3RoICs9IDE7XHJcbn07XHJcblxyXG5TaGFwZUNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbGVhc2VTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGk7XHJcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xlbmd0aDsgaSArPSAxKSB7XHJcbiAgICBzaGFwZVBvb2wucmVsZWFzZSh0aGlzLnNoYXBlc1tpXSk7XHJcbiAgfVxyXG4gIHRoaXMuX2xlbmd0aCA9IDA7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSwgY3JlYXRlVHlwZWRBcnJheSwgUHJvcGVydHlGYWN0b3J5LCBleHRlbmRQcm90b3R5cGUsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG5cclxuZnVuY3Rpb24gRGFzaFByb3BlcnR5KGVsZW0sIGRhdGEsIHJlbmRlcmVyLCBjb250YWluZXIpIHtcclxuICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gIHRoaXMuZnJhbWVJZCA9IC0xO1xyXG4gIHRoaXMuZGF0YVByb3BzID0gY3JlYXRlU2l6ZWRBcnJheShkYXRhLmxlbmd0aCk7XHJcbiAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gIHRoaXMuayA9IGZhbHNlO1xyXG4gIHRoaXMuZGFzaFN0ciA9ICcnO1xyXG4gIHRoaXMuZGFzaEFycmF5ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGRhdGEubGVuZ3RoID8gZGF0YS5sZW5ndGggLSAxIDogMCk7XHJcbiAgdGhpcy5kYXNob2Zmc2V0ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDEpO1xyXG4gIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihjb250YWluZXIpO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBkYXRhLmxlbmd0aCB8fCAwO1xyXG4gIHZhciBwcm9wO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgcHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGFbaV0udiwgMCwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLmsgPSBwcm9wLmsgfHwgdGhpcy5rO1xyXG4gICAgdGhpcy5kYXRhUHJvcHNbaV0gPSB7IG46IGRhdGFbaV0ubiwgcDogcHJvcCB9O1xyXG4gIH1cclxuICBpZiAoIXRoaXMuaykge1xyXG4gICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcclxuICB9XHJcbiAgdGhpcy5faXNBbmltYXRlZCA9IHRoaXMuaztcclxufVxyXG5cclxuRGFzaFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgJiYgIWZvcmNlUmVuZGVyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbiAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxuICB0aGlzLl9tZGYgPSB0aGlzLl9tZGYgfHwgZm9yY2VSZW5kZXI7XHJcbiAgaWYgKHRoaXMuX21kZikge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuZGF0YVByb3BzLmxlbmd0aDtcclxuICAgIGlmICh0aGlzLnJlbmRlcmVyID09PSAnc3ZnJykge1xyXG4gICAgICB0aGlzLmRhc2hTdHIgPSAnJztcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpZiAodGhpcy5kYXRhUHJvcHNbaV0ubiAhPT0gJ28nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgICB0aGlzLmRhc2hTdHIgKz0gJyAnICsgdGhpcy5kYXRhUHJvcHNbaV0ucC52O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmRhc2hBcnJheVtpXSA9IHRoaXMuZGF0YVByb3BzW2ldLnAudjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kYXNob2Zmc2V0WzBdID0gdGhpcy5kYXRhUHJvcHNbaV0ucC52O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIERhc2hQcm9wZXJ0eSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlVHlwZWRBcnJheSwgUHJvcGVydHlGYWN0b3J5LCBleHRlbmRQcm90b3R5cGUsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciAqL1xyXG5mdW5jdGlvbiBHcmFkaWVudFByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcikge1xyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgdGhpcy5jID0gY3JlYXRlVHlwZWRBcnJheSgndWludDhjJywgZGF0YS5wICogNCk7XHJcbiAgdmFyIGNMZW5ndGggPSBkYXRhLmsua1swXS5zID8gKGRhdGEuay5rWzBdLnMubGVuZ3RoIC0gZGF0YS5wICogNCkgOiBkYXRhLmsuay5sZW5ndGggLSBkYXRhLnAgKiA0O1xyXG4gIHRoaXMubyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBjTGVuZ3RoKTtcclxuICB0aGlzLl9jbWRmID0gZmFsc2U7XHJcbiAgdGhpcy5fb21kZiA9IGZhbHNlO1xyXG4gIHRoaXMuX2NvbGxhcHNhYmxlID0gdGhpcy5jaGVja0NvbGxhcHNhYmxlKCk7XHJcbiAgdGhpcy5faGFzT3BhY2l0eSA9IGNMZW5ndGg7XHJcbiAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcbiAgdGhpcy5wcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5rLCAxLCBudWxsLCB0aGlzKTtcclxuICB0aGlzLmsgPSB0aGlzLnByb3AuaztcclxuICB0aGlzLmdldFZhbHVlKHRydWUpO1xyXG59XHJcblxyXG5HcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5jb21wYXJlUG9pbnRzID0gZnVuY3Rpb24gKHZhbHVlcywgcG9pbnRzKSB7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBsZW4gPSB0aGlzLm8ubGVuZ3RoIC8gMjtcclxuICB2YXIgZGlmZjtcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgZGlmZiA9IE1hdGguYWJzKHZhbHVlc1tpICogNF0gLSB2YWx1ZXNbcG9pbnRzICogNCArIGkgKiAyXSk7XHJcbiAgICBpZiAoZGlmZiA+IDAuMDEpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkdyYWRpZW50UHJvcGVydHkucHJvdG90eXBlLmNoZWNrQ29sbGFwc2FibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMuby5sZW5ndGggLyAyICE9PSB0aGlzLmMubGVuZ3RoIC8gNCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAodGhpcy5kYXRhLmsua1swXS5zKSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5kYXRhLmsuay5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICBpZiAoIXRoaXMuY29tcGFyZVBvaW50cyh0aGlzLmRhdGEuay5rW2ldLnMsIHRoaXMuZGF0YS5wKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICghdGhpcy5jb21wYXJlUG9pbnRzKHRoaXMuZGF0YS5rLmssIHRoaXMuZGF0YS5wKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkdyYWRpZW50UHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XHJcbiAgdGhpcy5wcm9wLmdldFZhbHVlKCk7XHJcbiAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgdGhpcy5fY21kZiA9IGZhbHNlO1xyXG4gIHRoaXMuX29tZGYgPSBmYWxzZTtcclxuICBpZiAodGhpcy5wcm9wLl9tZGYgfHwgZm9yY2VSZW5kZXIpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5wICogNDtcclxuICAgIHZhciBtdWx0O1xyXG4gICAgdmFyIHZhbDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBtdWx0ID0gaSAlIDQgPT09IDAgPyAxMDAgOiAyNTU7XHJcbiAgICAgIHZhbCA9IE1hdGgucm91bmQodGhpcy5wcm9wLnZbaV0gKiBtdWx0KTtcclxuICAgICAgaWYgKHRoaXMuY1tpXSAhPT0gdmFsKSB7XHJcbiAgICAgICAgdGhpcy5jW2ldID0gdmFsO1xyXG4gICAgICAgIHRoaXMuX2NtZGYgPSAhZm9yY2VSZW5kZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLm8ubGVuZ3RoKSB7XHJcbiAgICAgIGxlbiA9IHRoaXMucHJvcC52Lmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gdGhpcy5kYXRhLnAgKiA0OyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBtdWx0ID0gaSAlIDIgPT09IDAgPyAxMDAgOiAxO1xyXG4gICAgICAgIHZhbCA9IGkgJSAyID09PSAwID8gTWF0aC5yb3VuZCh0aGlzLnByb3AudltpXSAqIDEwMCkgOiB0aGlzLnByb3AudltpXTtcclxuICAgICAgICBpZiAodGhpcy5vW2kgLSB0aGlzLmRhdGEucCAqIDRdICE9PSB2YWwpIHtcclxuICAgICAgICAgIHRoaXMub1tpIC0gdGhpcy5kYXRhLnAgKiA0XSA9IHZhbDtcclxuICAgICAgICAgIHRoaXMuX29tZGYgPSAhZm9yY2VSZW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLl9tZGYgPSAhZm9yY2VSZW5kZXI7XHJcbiAgfVxyXG59O1xyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBHcmFkaWVudFByb3BlcnR5KTtcclxuXHJcbi8qIGV4cG9ydGVkIGJ1aWxkU2hhcGVTdHJpbmcgKi9cclxuXHJcbnZhciBidWlsZFNoYXBlU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhOb2RlcywgbGVuZ3RoLCBjbG9zZWQsIG1hdCkge1xyXG4gIGlmIChsZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcbiAgdmFyIF9vID0gcGF0aE5vZGVzLm87XHJcbiAgdmFyIF9pID0gcGF0aE5vZGVzLmk7XHJcbiAgdmFyIF92ID0gcGF0aE5vZGVzLnY7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIHNoYXBlU3RyaW5nID0gJyBNJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfdlswXVswXSwgX3ZbMF1bMV0pO1xyXG4gIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgc2hhcGVTdHJpbmcgKz0gJyBDJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfb1tpIC0gMV1bMF0sIF9vW2kgLSAxXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX2lbaV1bMF0sIF9pW2ldWzFdKSArICcgJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfdltpXVswXSwgX3ZbaV1bMV0pO1xyXG4gIH1cclxuICBpZiAoY2xvc2VkICYmIGxlbmd0aCkge1xyXG4gICAgc2hhcGVTdHJpbmcgKz0gJyBDJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfb1tpIC0gMV1bMF0sIF9vW2kgLSAxXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX2lbMF1bMF0sIF9pWzBdWzFdKSArICcgJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfdlswXVswXSwgX3ZbMF1bMV0pO1xyXG4gICAgc2hhcGVTdHJpbmcgKz0gJ3onO1xyXG4gIH1cclxuICByZXR1cm4gc2hhcGVTdHJpbmc7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgSG93bCAqL1xyXG4vKiBleHBvcnRlZCBhdWRpb0NvbnRyb2xsZXJGYWN0b3J5ICovXHJcblxyXG52YXIgYXVkaW9Db250cm9sbGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gQXVkaW9Db250cm9sbGVyKGF1ZGlvRmFjdG9yeSkge1xyXG4gICAgdGhpcy5hdWRpb3MgPSBbXTtcclxuICAgIHRoaXMuYXVkaW9GYWN0b3J5ID0gYXVkaW9GYWN0b3J5O1xyXG4gICAgdGhpcy5fdm9sdW1lID0gMTtcclxuICAgIHRoaXMuX2lzTXV0ZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIEF1ZGlvQ29udHJvbGxlci5wcm90b3R5cGUgPSB7XHJcbiAgICBhZGRBdWRpbzogZnVuY3Rpb24gKGF1ZGlvKSB7XHJcbiAgICAgIHRoaXMuYXVkaW9zLnB1c2goYXVkaW8pO1xyXG4gICAgfSxcclxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy5hdWRpb3MubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvc1tpXS5wYXVzZSgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy5hdWRpb3MubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvc1tpXS5yZXN1bWUoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNldFJhdGU6IGZ1bmN0aW9uIChyYXRlVmFsdWUpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9zW2ldLnNldFJhdGUocmF0ZVZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZUF1ZGlvOiBmdW5jdGlvbiAoYXNzZXRQYXRoKSB7XHJcbiAgICAgIGlmICh0aGlzLmF1ZGlvRmFjdG9yeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF1ZGlvRmFjdG9yeShhc3NldFBhdGgpO1xyXG4gICAgICB9IGlmIChIb3dsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIb3dsKHtcclxuICAgICAgICAgIHNyYzogW2Fzc2V0UGF0aF0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpc1BsYXlpbmc6IGZhbHNlLFxyXG4gICAgICAgIHBsYXk6IGZ1bmN0aW9uICgpIHsgdGhpcy5pc1BsYXlpbmcgPSB0cnVlOyB9LFxyXG4gICAgICAgIHNlZWs6IGZ1bmN0aW9uICgpIHsgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTsgfSxcclxuICAgICAgICBwbGF5aW5nOiBmdW5jdGlvbiAoKSB7fSxcclxuICAgICAgICByYXRlOiBmdW5jdGlvbiAoKSB7fSxcclxuICAgICAgICBzZXRWb2x1bWU6IGZ1bmN0aW9uICgpIHt9LFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIHNldEF1ZGlvRmFjdG9yeTogZnVuY3Rpb24gKGF1ZGlvRmFjdG9yeSkge1xyXG4gICAgICB0aGlzLmF1ZGlvRmFjdG9yeSA9IGF1ZGlvRmFjdG9yeTtcclxuICAgIH0sXHJcbiAgICBzZXRWb2x1bWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICB0aGlzLl92b2x1bWUgPSB2YWx1ZTtcclxuICAgICAgdGhpcy5fdXBkYXRlVm9sdW1lKCk7XHJcbiAgICB9LFxyXG4gICAgbXV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9pc011dGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fdXBkYXRlVm9sdW1lKCk7XHJcbiAgICB9LFxyXG4gICAgdW5tdXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuX2lzTXV0ZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fdXBkYXRlVm9sdW1lKCk7XHJcbiAgICB9LFxyXG4gICAgZ2V0Vm9sdW1lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl92b2x1bWU7XHJcbiAgICB9LFxyXG4gICAgX3VwZGF0ZVZvbHVtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IHRoaXMuYXVkaW9zLmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb3NbaV0udm9sdW1lKHRoaXMuX3ZvbHVtZSAqICh0aGlzLl9pc011dGVkID8gMCA6IDEpKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBdWRpb0NvbnRyb2xsZXIoKTtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVRhZywgY3JlYXRlTlMsIGlzU2FmYXJpLCBhc3NldExvYWRlciAqL1xyXG4vKiBleHBvcnRlZCBJbWFnZVByZWxvYWRlciAqL1xyXG5cclxudmFyIEltYWdlUHJlbG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHJveHlJbWFnZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY2FudmFzID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IDE7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcclxuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XHJcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG4gIH0oKSk7XHJcblxyXG4gIGZ1bmN0aW9uIGltYWdlTG9hZGVkKCkge1xyXG4gICAgdGhpcy5sb2FkZWRBc3NldHMgKz0gMTtcclxuICAgIGlmICh0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyAmJiB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPT09IHRoaXMudG90YWxGb290YWdlcykge1xyXG4gICAgICBpZiAodGhpcy5pbWFnZXNMb2FkZWRDYikge1xyXG4gICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gZm9vdGFnZUxvYWRlZCgpIHtcclxuICAgIHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudCArPSAxO1xyXG4gICAgaWYgKHRoaXMubG9hZGVkQXNzZXRzID09PSB0aGlzLnRvdGFsSW1hZ2VzICYmIHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudCA9PT0gdGhpcy50b3RhbEZvb3RhZ2VzKSB7XHJcbiAgICAgIGlmICh0aGlzLmltYWdlc0xvYWRlZENiKSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYihudWxsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIGFzc2V0c1BhdGgsIG9yaWdpbmFsUGF0aCkge1xyXG4gICAgdmFyIHBhdGggPSAnJztcclxuICAgIGlmIChhc3NldERhdGEuZSkge1xyXG4gICAgICBwYXRoID0gYXNzZXREYXRhLnA7XHJcbiAgICB9IGVsc2UgaWYgKGFzc2V0c1BhdGgpIHtcclxuICAgICAgdmFyIGltYWdlUGF0aCA9IGFzc2V0RGF0YS5wO1xyXG4gICAgICBpZiAoaW1hZ2VQYXRoLmluZGV4T2YoJ2ltYWdlcy8nKSAhPT0gLTEpIHtcclxuICAgICAgICBpbWFnZVBhdGggPSBpbWFnZVBhdGguc3BsaXQoJy8nKVsxXTtcclxuICAgICAgfVxyXG4gICAgICBwYXRoID0gYXNzZXRzUGF0aCArIGltYWdlUGF0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhdGggPSBvcmlnaW5hbFBhdGg7XHJcbiAgICAgIHBhdGggKz0gYXNzZXREYXRhLnUgPyBhc3NldERhdGEudSA6ICcnO1xyXG4gICAgICBwYXRoICs9IGFzc2V0RGF0YS5wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0ZXN0SW1hZ2VMb2FkZWQoaW1nKSB7XHJcbiAgICB2YXIgX2NvdW50ID0gMDtcclxuICAgIHZhciBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYm94ID0gaW1nLmdldEJCb3goKTtcclxuICAgICAgaWYgKGJveC53aWR0aCB8fCBfY291bnQgPiA1MDApIHtcclxuICAgICAgICB0aGlzLl9pbWFnZUxvYWRlZCgpO1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XHJcbiAgICAgIH1cclxuICAgICAgX2NvdW50ICs9IDE7XHJcbiAgICB9LmJpbmQodGhpcyksIDUwKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUltYWdlRGF0YShhc3NldERhdGEpIHtcclxuICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcclxuICAgIHZhciBpbWcgPSBjcmVhdGVOUygnaW1hZ2UnKTtcclxuICAgIGlmIChpc1NhZmFyaSkge1xyXG4gICAgICB0aGlzLnRlc3RJbWFnZUxvYWRlZChpbWcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9pbWFnZUxvYWRlZCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYi5pbWcgPSBwcm94eUltYWdlO1xyXG4gICAgICB0aGlzLl9pbWFnZUxvYWRlZCgpO1xyXG4gICAgfS5iaW5kKHRoaXMpLCBmYWxzZSk7XHJcbiAgICBpbWcuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIHBhdGgpO1xyXG4gICAgaWYgKHRoaXMuX2VsZW1lbnRIZWxwZXIuYXBwZW5kKSB7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnRIZWxwZXIuYXBwZW5kKGltZyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9lbGVtZW50SGVscGVyLmFwcGVuZENoaWxkKGltZyk7XHJcbiAgICB9XHJcbiAgICB2YXIgb2IgPSB7XHJcbiAgICAgIGltZzogaW1nLFxyXG4gICAgICBhc3NldERhdGE6IGFzc2V0RGF0YSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gb2I7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVJbWdEYXRhKGFzc2V0RGF0YSkge1xyXG4gICAgdmFyIHBhdGggPSBnZXRBc3NldHNQYXRoKGFzc2V0RGF0YSwgdGhpcy5hc3NldHNQYXRoLCB0aGlzLnBhdGgpO1xyXG4gICAgdmFyIGltZyA9IGNyZWF0ZVRhZygnaW1nJyk7XHJcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5faW1hZ2VMb2FkZWQsIGZhbHNlKTtcclxuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2IuaW1nID0gcHJveHlJbWFnZTtcclxuICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcclxuICAgIH0uYmluZCh0aGlzKSwgZmFsc2UpO1xyXG4gICAgaW1nLnNyYyA9IHBhdGg7XHJcbiAgICB2YXIgb2IgPSB7XHJcbiAgICAgIGltZzogaW1nLFxyXG4gICAgICBhc3NldERhdGE6IGFzc2V0RGF0YSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gb2I7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVGb290YWdlRGF0YShkYXRhKSB7XHJcbiAgICB2YXIgb2IgPSB7XHJcbiAgICAgIGFzc2V0RGF0YTogZGF0YSxcclxuICAgIH07XHJcbiAgICB2YXIgcGF0aCA9IGdldEFzc2V0c1BhdGgoZGF0YSwgdGhpcy5hc3NldHNQYXRoLCB0aGlzLnBhdGgpO1xyXG4gICAgYXNzZXRMb2FkZXIubG9hZChwYXRoLCBmdW5jdGlvbiAoZm9vdGFnZURhdGEpIHtcclxuICAgICAgb2IuaW1nID0gZm9vdGFnZURhdGE7XHJcbiAgICAgIHRoaXMuX2Zvb3RhZ2VMb2FkZWQoKTtcclxuICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYi5pbWcgPSB7fTtcclxuICAgICAgdGhpcy5fZm9vdGFnZUxvYWRlZCgpO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIHJldHVybiBvYjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxvYWRBc3NldHMoYXNzZXRzLCBjYikge1xyXG4gICAgdGhpcy5pbWFnZXNMb2FkZWRDYiA9IGNiO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gYXNzZXRzLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpZiAoIWFzc2V0c1tpXS5sYXllcnMpIHtcclxuICAgICAgICBpZiAoIWFzc2V0c1tpXS50IHx8IGFzc2V0c1tpXS50ID09PSAnc2VxJykge1xyXG4gICAgICAgICAgdGhpcy50b3RhbEltYWdlcyArPSAxO1xyXG4gICAgICAgICAgdGhpcy5pbWFnZXMucHVzaCh0aGlzLl9jcmVhdGVJbWFnZURhdGEoYXNzZXRzW2ldKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhc3NldHNbaV0udCA9PT0gMykge1xyXG4gICAgICAgICAgdGhpcy50b3RhbEZvb3RhZ2VzICs9IDE7XHJcbiAgICAgICAgICB0aGlzLmltYWdlcy5wdXNoKHRoaXMuY3JlYXRlRm9vdGFnZURhdGEoYXNzZXRzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRQYXRoKHBhdGgpIHtcclxuICAgIHRoaXMucGF0aCA9IHBhdGggfHwgJyc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRBc3NldHNQYXRoKHBhdGgpIHtcclxuICAgIHRoaXMuYXNzZXRzUGF0aCA9IHBhdGggfHwgJyc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRBc3NldChhc3NldERhdGEpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBsZW4gPSB0aGlzLmltYWdlcy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICBpZiAodGhpcy5pbWFnZXNbaV0uYXNzZXREYXRhID09PSBhc3NldERhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNbaV0uaW1nO1xyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IgPSBudWxsO1xyXG4gICAgdGhpcy5pbWFnZXMubGVuZ3RoID0gMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxvYWRlZEltYWdlcygpIHtcclxuICAgIHJldHVybiB0aGlzLnRvdGFsSW1hZ2VzID09PSB0aGlzLmxvYWRlZEFzc2V0cztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxvYWRlZEZvb3RhZ2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG90YWxGb290YWdlcyA9PT0gdGhpcy5sb2FkZWRGb290YWdlc0NvdW50O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0Q2FjaGVUeXBlKHR5cGUsIGVsZW1lbnRIZWxwZXIpIHtcclxuICAgIGlmICh0eXBlID09PSAnc3ZnJykge1xyXG4gICAgICB0aGlzLl9lbGVtZW50SGVscGVyID0gZWxlbWVudEhlbHBlcjtcclxuICAgICAgdGhpcy5fY3JlYXRlSW1hZ2VEYXRhID0gdGhpcy5jcmVhdGVJbWFnZURhdGEuYmluZCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2NyZWF0ZUltYWdlRGF0YSA9IHRoaXMuY3JlYXRlSW1nRGF0YS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gSW1hZ2VQcmVsb2FkZXJGYWN0b3J5KCkge1xyXG4gICAgdGhpcy5faW1hZ2VMb2FkZWQgPSBpbWFnZUxvYWRlZC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fZm9vdGFnZUxvYWRlZCA9IGZvb3RhZ2VMb2FkZWQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMudGVzdEltYWdlTG9hZGVkID0gdGVzdEltYWdlTG9hZGVkLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmNyZWF0ZUZvb3RhZ2VEYXRhID0gY3JlYXRlRm9vdGFnZURhdGEuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuYXNzZXRzUGF0aCA9ICcnO1xyXG4gICAgdGhpcy5wYXRoID0gJyc7XHJcbiAgICB0aGlzLnRvdGFsSW1hZ2VzID0gMDtcclxuICAgIHRoaXMudG90YWxGb290YWdlcyA9IDA7XHJcbiAgICB0aGlzLmxvYWRlZEFzc2V0cyA9IDA7XHJcbiAgICB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPSAwO1xyXG4gICAgdGhpcy5pbWFnZXNMb2FkZWRDYiA9IG51bGw7XHJcbiAgICB0aGlzLmltYWdlcyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgSW1hZ2VQcmVsb2FkZXJGYWN0b3J5LnByb3RvdHlwZSA9IHtcclxuICAgIGxvYWRBc3NldHM6IGxvYWRBc3NldHMsXHJcbiAgICBzZXRBc3NldHNQYXRoOiBzZXRBc3NldHNQYXRoLFxyXG4gICAgc2V0UGF0aDogc2V0UGF0aCxcclxuICAgIGxvYWRlZEltYWdlczogbG9hZGVkSW1hZ2VzLFxyXG4gICAgbG9hZGVkRm9vdGFnZXM6IGxvYWRlZEZvb3RhZ2VzLFxyXG4gICAgZGVzdHJveTogZGVzdHJveSxcclxuICAgIGdldEFzc2V0OiBnZXRBc3NldCxcclxuICAgIGNyZWF0ZUltZ0RhdGE6IGNyZWF0ZUltZ0RhdGEsXHJcbiAgICBjcmVhdGVJbWFnZURhdGE6IGNyZWF0ZUltYWdlRGF0YSxcclxuICAgIGltYWdlTG9hZGVkOiBpbWFnZUxvYWRlZCxcclxuICAgIGZvb3RhZ2VMb2FkZWQ6IGZvb3RhZ2VMb2FkZWQsXHJcbiAgICBzZXRDYWNoZVR5cGU6IHNldENhY2hlVHlwZSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gSW1hZ2VQcmVsb2FkZXJGYWN0b3J5O1xyXG59KCkpO1xyXG5cclxuLyogZXhwb3J0ZWQgZmVhdHVyZVN1cHBvcnQgKi9cclxuXHJcbnZhciBmZWF0dXJlU3VwcG9ydCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG9iID0ge1xyXG4gICAgbWFza1R5cGU6IHRydWUsXHJcbiAgfTtcclxuICBpZiAoL01TSUUgMTAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9NU0lFIDkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9ydjoxMS4wL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvRWRnZVxcL1xcZC4vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XHJcbiAgICBvYi5tYXNrVHlwZSA9IGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gb2I7XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlTlMgKi9cclxuLyogZXhwb3J0ZWQgZmlsdGVyc0ZhY3RvcnkgKi9cclxuXHJcbnZhciBmaWx0ZXJzRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG9iID0ge307XHJcbiAgb2IuY3JlYXRlRmlsdGVyID0gY3JlYXRlRmlsdGVyO1xyXG4gIG9iLmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIgPSBjcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyO1xyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVGaWx0ZXIoZmlsSWQsIHNraXBDb29yZGluYXRlcykge1xyXG4gICAgdmFyIGZpbCA9IGNyZWF0ZU5TKCdmaWx0ZXInKTtcclxuICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ2lkJywgZmlsSWQpO1xyXG4gICAgaWYgKHNraXBDb29yZGluYXRlcyAhPT0gdHJ1ZSkge1xyXG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCdmaWx0ZXJVbml0cycsICdvYmplY3RCb3VuZGluZ0JveCcpO1xyXG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCd4JywgJzAlJyk7XHJcbiAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ3knLCAnMCUnKTtcclxuICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xyXG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMTAwJScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZpbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSB7XHJcbiAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcclxuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xyXG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcwIDAgMCAxIDAgIDAgMCAwIDEgMCAgMCAwIDAgMSAwICAwIDAgMCAxIDEnKTtcclxuICAgIHJldHVybiBmZUNvbG9yTWF0cml4O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuLyogZXhwb3J0ZWQgYXNzZXRMb2FkZXIgKi9cclxuXHJcbnZhciBhc3NldExvYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gZm9ybWF0UmVzcG9uc2UoeGhyKSB7XHJcbiAgICBpZiAoeGhyLnJlc3BvbnNlICYmIHR5cGVvZiB4aHIucmVzcG9uc2UgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybiB4aHIucmVzcG9uc2U7XHJcbiAgICB9IGlmICh4aHIucmVzcG9uc2UgJiYgdHlwZW9mIHhoci5yZXNwb25zZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcclxuICAgIH0gaWYgKHhoci5yZXNwb25zZVRleHQpIHtcclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxvYWRBc3NldChwYXRoLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xyXG4gICAgdmFyIHJlc3BvbnNlO1xyXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgLy8gc2V0IHJlc3BvbnNlVHlwZSBhZnRlciBjYWxsaW5nIG9wZW4gb3IgSUUgd2lsbCBicmVhay5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRoaXMgY3Jhc2hlcyBvbiBBbmRyb2lkIFdlYlZpZXcgcHJpb3IgdG8gS2l0S2F0XHJcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XHJcbiAgICB9IGNhdGNoIChlcnIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcclxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgICAgIHJlc3BvbnNlID0gZm9ybWF0UmVzcG9uc2UoeGhyKTtcclxuICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzcG9uc2UgPSBmb3JtYXRSZXNwb25zZSh4aHIpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB4aHIub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XHJcbiAgICB4aHIuc2VuZCgpO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgbG9hZDogbG9hZEFzc2V0LFxyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSwgUHJvcGVydHlGYWN0b3J5LCBUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHksIGJleiwgYWRkSHVlVG9SR0IsXHJcbiAgYWRkU2F0dXJhdGlvblRvUkdCLCBhZGRCcmlnaHRuZXNzVG9SR0IsIExldHRlclByb3BzLCBNYXRyaXgsIGV4dGVuZFByb3RvdHlwZSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyICovXHJcblxyXG5mdW5jdGlvbiBUZXh0QW5pbWF0b3JQcm9wZXJ0eSh0ZXh0RGF0YSwgcmVuZGVyVHlwZSwgZWxlbSkge1xyXG4gIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgdGhpcy5faGFzTWFza2VkUGF0aCA9IGZhbHNlO1xyXG4gIHRoaXMuX2ZyYW1lSWQgPSAtMTtcclxuICB0aGlzLl90ZXh0RGF0YSA9IHRleHREYXRhO1xyXG4gIHRoaXMuX3JlbmRlclR5cGUgPSByZW5kZXJUeXBlO1xyXG4gIHRoaXMuX2VsZW0gPSBlbGVtO1xyXG4gIHRoaXMuX2FuaW1hdG9yc0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX3RleHREYXRhLmEubGVuZ3RoKTtcclxuICB0aGlzLl9wYXRoRGF0YSA9IHt9O1xyXG4gIHRoaXMuX21vcmVPcHRpb25zID0ge1xyXG4gICAgYWxpZ25tZW50OiB7fSxcclxuICB9O1xyXG4gIHRoaXMucmVuZGVyZWRMZXR0ZXJzID0gW107XHJcbiAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSBmYWxzZTtcclxuICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbn1cclxuXHJcblRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLl90ZXh0RGF0YS5hLmxlbmd0aDtcclxuICB2YXIgYW5pbWF0b3JQcm9wcztcclxuICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgYW5pbWF0b3JQcm9wcyA9IHRoaXMuX3RleHREYXRhLmFbaV07XHJcbiAgICB0aGlzLl9hbmltYXRvcnNEYXRhW2ldID0gbmV3IFRleHRBbmltYXRvckRhdGFQcm9wZXJ0eSh0aGlzLl9lbGVtLCBhbmltYXRvclByb3BzLCB0aGlzKTtcclxuICB9XHJcbiAgaWYgKHRoaXMuX3RleHREYXRhLnAgJiYgJ20nIGluIHRoaXMuX3RleHREYXRhLnApIHtcclxuICAgIHRoaXMuX3BhdGhEYXRhID0ge1xyXG4gICAgICBhOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAuYSwgMCwgMCwgdGhpcyksXHJcbiAgICAgIGY6IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEucC5mLCAwLCAwLCB0aGlzKSxcclxuICAgICAgbDogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLmwsIDAsIDAsIHRoaXMpLFxyXG4gICAgICByOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAuciwgMCwgMCwgdGhpcyksXHJcbiAgICAgIHA6IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEucC5wLCAwLCAwLCB0aGlzKSxcclxuICAgICAgbTogdGhpcy5fZWxlbS5tYXNrTWFuYWdlci5nZXRNYXNrUHJvcGVydHkodGhpcy5fdGV4dERhdGEucC5tKSxcclxuICAgIH07XHJcbiAgICB0aGlzLl9oYXNNYXNrZWRQYXRoID0gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5faGFzTWFza2VkUGF0aCA9IGZhbHNlO1xyXG4gIH1cclxuICB0aGlzLl9tb3JlT3B0aW9ucy5hbGlnbm1lbnQgPSBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLm0uYSwgMSwgMCwgdGhpcyk7XHJcbn07XHJcblxyXG5UZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0TWVhc3VyZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhLCBsZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcclxuICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGxldHRlcnNDaGFuZ2VkRmxhZztcclxuICBpZiAoIXRoaXMuX21kZiAmJiAhdGhpcy5faXNGaXJzdEZyYW1lICYmICFsZXR0ZXJzQ2hhbmdlZEZsYWcgJiYgKCF0aGlzLl9oYXNNYXNrZWRQYXRoIHx8ICF0aGlzLl9wYXRoRGF0YS5tLl9tZGYpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xyXG4gIHZhciBhbGlnbm1lbnQgPSB0aGlzLl9tb3JlT3B0aW9ucy5hbGlnbm1lbnQudjtcclxuICB2YXIgYW5pbWF0b3JzID0gdGhpcy5fYW5pbWF0b3JzRGF0YTtcclxuICB2YXIgdGV4dERhdGEgPSB0aGlzLl90ZXh0RGF0YTtcclxuICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xyXG4gIHZhciByZW5kZXJUeXBlID0gdGhpcy5fcmVuZGVyVHlwZTtcclxuICB2YXIgcmVuZGVyZWRMZXR0ZXJzQ291bnQgPSB0aGlzLnJlbmRlcmVkTGV0dGVycy5sZW5ndGg7XHJcbiAgdmFyIHhQb3M7XHJcbiAgdmFyIHlQb3M7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbjtcclxuICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sO1xyXG4gIHZhciBwYXRoSW5mbztcclxuICB2YXIgY3VycmVudExlbmd0aDtcclxuICB2YXIgY3VycmVudFBvaW50O1xyXG4gIHZhciBzZWdtZW50TGVuZ3RoO1xyXG4gIHZhciBmbGFnO1xyXG4gIHZhciBwb2ludEluZDtcclxuICB2YXIgc2VnbWVudEluZDtcclxuICB2YXIgcHJldlBvaW50O1xyXG4gIHZhciBwb2ludHM7XHJcbiAgdmFyIHNlZ21lbnRzO1xyXG4gIHZhciBwYXJ0aWFsTGVuZ3RoO1xyXG4gIHZhciB0b3RhbExlbmd0aDtcclxuICB2YXIgcGVyYztcclxuICB2YXIgdGFuQW5nbGU7XHJcbiAgdmFyIG1hc2s7XHJcbiAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcclxuICAgIG1hc2sgPSB0aGlzLl9wYXRoRGF0YS5tO1xyXG4gICAgaWYgKCF0aGlzLl9wYXRoRGF0YS5uIHx8IHRoaXMuX3BhdGhEYXRhLl9tZGYpIHtcclxuICAgICAgdmFyIHBhdGhzID0gbWFzay52O1xyXG4gICAgICBpZiAodGhpcy5fcGF0aERhdGEuci52KSB7XHJcbiAgICAgICAgcGF0aHMgPSBwYXRocy5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVE9ETzogcmVsZWFzZSBiZXppZXIgZGF0YSBjYWNoZWQgZnJvbSBwcmV2aW91cyBwYXRoSW5mbzogdGhpcy5fcGF0aERhdGEucGlcclxuICAgICAgcGF0aEluZm8gPSB7XHJcbiAgICAgICAgdExlbmd0aDogMCxcclxuICAgICAgICBzZWdtZW50czogW10sXHJcbiAgICAgIH07XHJcbiAgICAgIGxlbiA9IHBhdGhzLl9sZW5ndGggLSAxO1xyXG4gICAgICB2YXIgYmV6aWVyRGF0YTtcclxuICAgICAgdG90YWxMZW5ndGggPSAwO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBiZXppZXJEYXRhID0gYmV6LmJ1aWxkQmV6aWVyRGF0YShwYXRocy52W2ldLFxyXG4gICAgICAgICAgcGF0aHMudltpICsgMV0sXHJcbiAgICAgICAgICBbcGF0aHMub1tpXVswXSAtIHBhdGhzLnZbaV1bMF0sIHBhdGhzLm9baV1bMV0gLSBwYXRocy52W2ldWzFdXSxcclxuICAgICAgICAgIFtwYXRocy5pW2kgKyAxXVswXSAtIHBhdGhzLnZbaSArIDFdWzBdLCBwYXRocy5pW2kgKyAxXVsxXSAtIHBhdGhzLnZbaSArIDFdWzFdXSk7XHJcbiAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XHJcbiAgICAgICAgcGF0aEluZm8uc2VnbWVudHMucHVzaChiZXppZXJEYXRhKTtcclxuICAgICAgICB0b3RhbExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgaSA9IGxlbjtcclxuICAgICAgaWYgKG1hc2sudi5jKSB7XHJcbiAgICAgICAgYmV6aWVyRGF0YSA9IGJlei5idWlsZEJlemllckRhdGEocGF0aHMudltpXSxcclxuICAgICAgICAgIHBhdGhzLnZbMF0sXHJcbiAgICAgICAgICBbcGF0aHMub1tpXVswXSAtIHBhdGhzLnZbaV1bMF0sIHBhdGhzLm9baV1bMV0gLSBwYXRocy52W2ldWzFdXSxcclxuICAgICAgICAgIFtwYXRocy5pWzBdWzBdIC0gcGF0aHMudlswXVswXSwgcGF0aHMuaVswXVsxXSAtIHBhdGhzLnZbMF1bMV1dKTtcclxuICAgICAgICBwYXRoSW5mby50TGVuZ3RoICs9IGJlemllckRhdGEuc2VnbWVudExlbmd0aDtcclxuICAgICAgICBwYXRoSW5mby5zZWdtZW50cy5wdXNoKGJlemllckRhdGEpO1xyXG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGJlemllckRhdGEuc2VnbWVudExlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9wYXRoRGF0YS5waSA9IHBhdGhJbmZvO1xyXG4gICAgfVxyXG4gICAgcGF0aEluZm8gPSB0aGlzLl9wYXRoRGF0YS5waTtcclxuXHJcbiAgICBjdXJyZW50TGVuZ3RoID0gdGhpcy5fcGF0aERhdGEuZi52O1xyXG4gICAgc2VnbWVudEluZCA9IDA7XHJcbiAgICBwb2ludEluZCA9IDE7XHJcbiAgICBzZWdtZW50TGVuZ3RoID0gMDtcclxuICAgIGZsYWcgPSB0cnVlO1xyXG4gICAgc2VnbWVudHMgPSBwYXRoSW5mby5zZWdtZW50cztcclxuICAgIGlmIChjdXJyZW50TGVuZ3RoIDwgMCAmJiBtYXNrLnYuYykge1xyXG4gICAgICBpZiAocGF0aEluZm8udExlbmd0aCA8IE1hdGguYWJzKGN1cnJlbnRMZW5ndGgpKSB7XHJcbiAgICAgICAgY3VycmVudExlbmd0aCA9IC1NYXRoLmFicyhjdXJyZW50TGVuZ3RoKSAlIHBhdGhJbmZvLnRMZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgc2VnbWVudEluZCA9IHNlZ21lbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcclxuICAgICAgcG9pbnRJbmQgPSBwb2ludHMubGVuZ3RoIC0gMTtcclxuICAgICAgd2hpbGUgKGN1cnJlbnRMZW5ndGggPCAwKSB7XHJcbiAgICAgICAgY3VycmVudExlbmd0aCArPSBwb2ludHNbcG9pbnRJbmRdLnBhcnRpYWxMZW5ndGg7XHJcbiAgICAgICAgcG9pbnRJbmQgLT0gMTtcclxuICAgICAgICBpZiAocG9pbnRJbmQgPCAwKSB7XHJcbiAgICAgICAgICBzZWdtZW50SW5kIC09IDE7XHJcbiAgICAgICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XHJcbiAgICAgICAgICBwb2ludEluZCA9IHBvaW50cy5sZW5ndGggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xyXG4gICAgcHJldlBvaW50ID0gcG9pbnRzW3BvaW50SW5kIC0gMV07XHJcbiAgICBjdXJyZW50UG9pbnQgPSBwb2ludHNbcG9pbnRJbmRdO1xyXG4gICAgcGFydGlhbExlbmd0aCA9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgbGVuID0gbGV0dGVycy5sZW5ndGg7XHJcbiAgeFBvcyA9IDA7XHJcbiAgeVBvcyA9IDA7XHJcbiAgdmFyIHlPZmYgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yICogMC43MTQ7XHJcbiAgdmFyIGZpcnN0TGluZSA9IHRydWU7XHJcbiAgdmFyIGFuaW1hdG9yUHJvcHM7XHJcbiAgdmFyIGFuaW1hdG9yU2VsZWN0b3I7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIGxldHRlclZhbHVlO1xyXG5cclxuICBqTGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcclxuXHJcbiAgdmFyIG11bHQ7XHJcbiAgdmFyIGluZCA9IC0xO1xyXG4gIHZhciBvZmZmO1xyXG4gIHZhciB4UGF0aFBvcztcclxuICB2YXIgeVBhdGhQb3M7XHJcbiAgdmFyIGluaXRQYXRoUG9zID0gY3VycmVudExlbmd0aDtcclxuICB2YXIgaW5pdFNlZ21lbnRJbmQgPSBzZWdtZW50SW5kO1xyXG4gIHZhciBpbml0UG9pbnRJbmQgPSBwb2ludEluZDtcclxuICB2YXIgY3VycmVudExpbmUgPSAtMTtcclxuICB2YXIgZWxlbU9wYWNpdHk7XHJcbiAgdmFyIHNjO1xyXG4gIHZhciBzdztcclxuICB2YXIgZmM7XHJcbiAgdmFyIGs7XHJcbiAgdmFyIGxldHRlclN3O1xyXG4gIHZhciBsZXR0ZXJTYztcclxuICB2YXIgbGV0dGVyRmM7XHJcbiAgdmFyIGxldHRlck0gPSAnJztcclxuICB2YXIgbGV0dGVyUCA9IHRoaXMuZGVmYXVsdFByb3BzQXJyYXk7XHJcbiAgdmFyIGxldHRlck87XHJcblxyXG4gIC8vXHJcbiAgaWYgKGRvY3VtZW50RGF0YS5qID09PSAyIHx8IGRvY3VtZW50RGF0YS5qID09PSAxKSB7XHJcbiAgICB2YXIgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcclxuICAgIHZhciBhbmltYXRvckZpcnN0Q2hhck9mZnNldCA9IDA7XHJcbiAgICB2YXIganVzdGlmeU9mZnNldE11bHQgPSBkb2N1bWVudERhdGEuaiA9PT0gMiA/IC0wLjUgOiAtMTtcclxuICAgIHZhciBsYXN0SW5kZXggPSAwO1xyXG4gICAgdmFyIGlzTmV3TGluZSA9IHRydWU7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGlmIChsZXR0ZXJzW2ldLm4pIHtcclxuICAgICAgICBpZiAoYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0KSB7XHJcbiAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChsYXN0SW5kZXggPCBpKSB7XHJcbiAgICAgICAgICBsZXR0ZXJzW2xhc3RJbmRleF0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0O1xyXG4gICAgICAgICAgbGFzdEluZGV4ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCA9IDA7XHJcbiAgICAgICAgaXNOZXdMaW5lID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XHJcbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy50LnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05ld0xpbmUgJiYgZG9jdW1lbnREYXRhLmogPT09IDIpIHtcclxuICAgICAgICAgICAgICBhbmltYXRvckZpcnN0Q2hhck9mZnNldCArPSBhbmltYXRvclByb3BzLnQudiAqIGp1c3RpZnlPZmZzZXRNdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xyXG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0WzBdICoganVzdGlmeU9mZnNldE11bHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdCAqIGp1c3RpZnlPZmZzZXRNdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzTmV3TGluZSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0KSB7XHJcbiAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvckZpcnN0Q2hhck9mZnNldDtcclxuICAgIH1cclxuICAgIHdoaWxlIChsYXN0SW5kZXggPCBpKSB7XHJcbiAgICAgIGxldHRlcnNbbGFzdEluZGV4XS5hbmltYXRvckp1c3RpZnlPZmZzZXQgPSBhbmltYXRvckp1c3RpZnlPZmZzZXQ7XHJcbiAgICAgIGxhc3RJbmRleCArPSAxO1xyXG4gICAgfVxyXG4gIH1cclxuICAvL1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xyXG4gICAgZWxlbU9wYWNpdHkgPSAxO1xyXG4gICAgaWYgKGxldHRlcnNbaV0ubikge1xyXG4gICAgICB4UG9zID0gMDtcclxuICAgICAgeVBvcyArPSBkb2N1bWVudERhdGEueU9mZnNldDtcclxuICAgICAgeVBvcyArPSBmaXJzdExpbmUgPyAxIDogMDtcclxuICAgICAgY3VycmVudExlbmd0aCA9IGluaXRQYXRoUG9zO1xyXG4gICAgICBmaXJzdExpbmUgPSBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcclxuICAgICAgICBzZWdtZW50SW5kID0gaW5pdFNlZ21lbnRJbmQ7XHJcbiAgICAgICAgcG9pbnRJbmQgPSBpbml0UG9pbnRJbmQ7XHJcbiAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xyXG4gICAgICAgIHByZXZQb2ludCA9IHBvaW50c1twb2ludEluZCAtIDFdO1xyXG4gICAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XHJcbiAgICAgICAgcGFydGlhbExlbmd0aCA9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgIHNlZ21lbnRMZW5ndGggPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGxldHRlck0gPSAnJztcclxuICAgICAgbGV0dGVyRmMgPSAnJztcclxuICAgICAgbGV0dGVyU3cgPSAnJztcclxuICAgICAgbGV0dGVyTyA9ICcnO1xyXG4gICAgICBsZXR0ZXJQID0gdGhpcy5kZWZhdWx0UHJvcHNBcnJheTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lICE9PSBsZXR0ZXJzW2ldLmxpbmUpIHtcclxuICAgICAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gdG90YWxMZW5ndGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSAodG90YWxMZW5ndGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdKSAvIDI7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjdXJyZW50TGluZSA9IGxldHRlcnNbaV0ubGluZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZCAhPT0gbGV0dGVyc1tpXS5pbmQpIHtcclxuICAgICAgICAgIGlmIChsZXR0ZXJzW2luZF0pIHtcclxuICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2luZF0uZXh0cmE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGxldHRlcnNbaV0uYW4gLyAyO1xyXG4gICAgICAgICAgaW5kID0gbGV0dGVyc1tpXS5pbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRMZW5ndGggKz0gKGFsaWdubWVudFswXSAqIGxldHRlcnNbaV0uYW4pICogMC4wMDU7XHJcbiAgICAgICAgdmFyIGFuaW1hdG9yT2Zmc2V0ID0gMDtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XHJcbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5wLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xyXG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBhbmltYXRvck9mZnNldCArPSBhbmltYXRvclByb3BzLnAudlswXSAqIG11bHRbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5hLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xyXG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBhbmltYXRvck9mZnNldCArPSBhbmltYXRvclByb3BzLmEudlswXSAqIG11bHRbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5hLnZbMF0gKiBtdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgIC8vIEZvcmNlIGFsaWdubWVudCBvbmx5IHdvcmtzIHdpdGggYSBzaW5nbGUgbGluZSBmb3Igbm93XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhdGhEYXRhLmEudikge1xyXG4gICAgICAgICAgY3VycmVudExlbmd0aCA9IGxldHRlcnNbMF0uYW4gKiAwLjUgKyAoKHRvdGFsTGVuZ3RoIC0gdGhpcy5fcGF0aERhdGEuZi52IC0gbGV0dGVyc1swXS5hbiAqIDAuNSAtIGxldHRlcnNbbGV0dGVycy5sZW5ndGggLSAxXS5hbiAqIDAuNSkgKiBpbmQpIC8gKGxlbiAtIDEpO1xyXG4gICAgICAgICAgY3VycmVudExlbmd0aCArPSB0aGlzLl9wYXRoRGF0YS5mLnY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChmbGFnKSB7XHJcbiAgICAgICAgICBpZiAoc2VnbWVudExlbmd0aCArIHBhcnRpYWxMZW5ndGggPj0gY3VycmVudExlbmd0aCArIGFuaW1hdG9yT2Zmc2V0IHx8ICFwb2ludHMpIHtcclxuICAgICAgICAgICAgcGVyYyA9IChjdXJyZW50TGVuZ3RoICsgYW5pbWF0b3JPZmZzZXQgLSBzZWdtZW50TGVuZ3RoKSAvIGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICB4UGF0aFBvcyA9IHByZXZQb2ludC5wb2ludFswXSArIChjdXJyZW50UG9pbnQucG9pbnRbMF0gLSBwcmV2UG9pbnQucG9pbnRbMF0pICogcGVyYztcclxuICAgICAgICAgICAgeVBhdGhQb3MgPSBwcmV2UG9pbnQucG9pbnRbMV0gKyAoY3VycmVudFBvaW50LnBvaW50WzFdIC0gcHJldlBvaW50LnBvaW50WzFdKSAqIHBlcmM7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoKC1hbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuKSAqIDAuMDA1LCAtKGFsaWdubWVudFsxXSAqIHlPZmYpICogMC4wMSk7XHJcbiAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggKz0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XHJcbiAgICAgICAgICAgIHBvaW50SW5kICs9IDE7XHJcbiAgICAgICAgICAgIGlmIChwb2ludEluZCA+PSBwb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgcG9pbnRJbmQgPSAwO1xyXG4gICAgICAgICAgICAgIHNlZ21lbnRJbmQgKz0gMTtcclxuICAgICAgICAgICAgICBpZiAoIXNlZ21lbnRzW3NlZ21lbnRJbmRdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFzay52LmMpIHtcclxuICAgICAgICAgICAgICAgICAgcG9pbnRJbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICBzZWdtZW50SW5kID0gMDtcclxuICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCAtPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgcG9pbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50O1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XHJcbiAgICAgICAgICAgICAgcGFydGlhbExlbmd0aCA9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZmYgPSBsZXR0ZXJzW2ldLmFuIC8gMiAtIGxldHRlcnNbaV0uYWRkO1xyXG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLW9mZmYsIDAsIDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9mZmYgPSBsZXR0ZXJzW2ldLmFuIC8gMiAtIGxldHRlcnNbaV0uYWRkO1xyXG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLW9mZmYsIDAsIDApO1xyXG5cclxuICAgICAgICAvLyBHcm91cGluZyBhbGlnbm1lbnRcclxuICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKCgtYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbikgKiAwLjAwNSwgKC1hbGlnbm1lbnRbMV0gKiB5T2ZmKSAqIDAuMDEsIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xyXG4gICAgICAgIGlmIChhbmltYXRvclByb3BzLnQucHJvcFR5cGUpIHtcclxuICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcclxuICAgICAgICAgIC8vIFRoaXMgY29uZGl0aW9uIGlzIHRvIHByZXZlbnQgYXBwbHlpbmcgdHJhY2tpbmcgdG8gZmlyc3QgY2hhcmFjdGVyIGluIGVhY2ggbGluZS4gTWlnaHQgYmUgYmV0dGVyIHRvIHVzZSBhIGJvb2xlYW4gXCJpc05ld0xpbmVcIlxyXG4gICAgICAgICAgaWYgKHhQb3MgIT09IDAgfHwgZG9jdW1lbnREYXRhLmogIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcclxuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0WzBdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICB4UG9zICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdFswXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4UG9zICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSkge1xyXG4gICAgICAgIHN3ID0gZG9jdW1lbnREYXRhLnN3IHx8IDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VDb2xvckFuaW0pIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XHJcbiAgICAgICAgICBzYyA9IFtkb2N1bWVudERhdGEuc2NbMF0sIGRvY3VtZW50RGF0YS5zY1sxXSwgZG9jdW1lbnREYXRhLnNjWzJdXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2MgPSBbMCwgMCwgMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSAmJiBkb2N1bWVudERhdGEuZmMpIHtcclxuICAgICAgICBmYyA9IFtkb2N1bWVudERhdGEuZmNbMF0sIGRvY3VtZW50RGF0YS5mY1sxXSwgZG9jdW1lbnREYXRhLmZjWzJdXTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xyXG4gICAgICAgIGlmIChhbmltYXRvclByb3BzLmEucHJvcFR5cGUpIHtcclxuICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcclxuXHJcbiAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgtYW5pbWF0b3JQcm9wcy5hLnZbMF0gKiBtdWx0WzBdLCAtYW5pbWF0b3JQcm9wcy5hLnZbMV0gKiBtdWx0WzFdLCBhbmltYXRvclByb3BzLmEudlsyXSAqIG11bHRbMl0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgtYW5pbWF0b3JQcm9wcy5hLnZbMF0gKiBtdWx0LCAtYW5pbWF0b3JQcm9wcy5hLnZbMV0gKiBtdWx0LCBhbmltYXRvclByb3BzLmEudlsyXSAqIG11bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xyXG4gICAgICAgIGlmIChhbmltYXRvclByb3BzLnMucHJvcFR5cGUpIHtcclxuICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcclxuICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIuc2NhbGUoMSArICgoYW5pbWF0b3JQcm9wcy5zLnZbMF0gLSAxKSAqIG11bHRbMF0pLCAxICsgKChhbmltYXRvclByb3BzLnMudlsxXSAtIDEpICogbXVsdFsxXSksIDEpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKDEgKyAoKGFuaW1hdG9yUHJvcHMucy52WzBdIC0gMSkgKiBtdWx0KSwgMSArICgoYW5pbWF0b3JQcm9wcy5zLnZbMV0gLSAxKSAqIG11bHQpLCAxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xyXG4gICAgICAgIGlmIChhbmltYXRvclByb3BzLnNrLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnNrZXdGcm9tQXhpcygtYW5pbWF0b3JQcm9wcy5zay52ICogbXVsdFswXSwgYW5pbWF0b3JQcm9wcy5zYS52ICogbXVsdFsxXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIuc2tld0Zyb21BeGlzKC1hbmltYXRvclByb3BzLnNrLnYgKiBtdWx0LCBhbmltYXRvclByb3BzLnNhLnYgKiBtdWx0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuci5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVaKC1hbmltYXRvclByb3BzLnIudiAqIG11bHRbMl0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVooLWFuaW1hdG9yUHJvcHMuci52ICogbXVsdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbmltYXRvclByb3BzLnJ5LnByb3BUeXBlKSB7XHJcbiAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVkoYW5pbWF0b3JQcm9wcy5yeS52ICogbXVsdFsxXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWShhbmltYXRvclByb3BzLnJ5LnYgKiBtdWx0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucngucHJvcFR5cGUpIHtcclxuICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWChhbmltYXRvclByb3BzLnJ4LnYgKiBtdWx0WzBdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVYKGFuaW1hdG9yUHJvcHMucngudiAqIG11bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5vLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZWxlbU9wYWNpdHkgKz0gKChhbmltYXRvclByb3BzLm8udikgKiBtdWx0WzBdIC0gZWxlbU9wYWNpdHkpICogbXVsdFswXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1PcGFjaXR5ICs9ICgoYW5pbWF0b3JQcm9wcy5vLnYpICogbXVsdCAtIGVsZW1PcGFjaXR5KSAqIG11bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltICYmIGFuaW1hdG9yUHJvcHMuc3cucHJvcFR5cGUpIHtcclxuICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzdyArPSBhbmltYXRvclByb3BzLnN3LnYgKiBtdWx0WzBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3cgKz0gYW5pbWF0b3JQcm9wcy5zdy52ICogbXVsdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VDb2xvckFuaW0gJiYgYW5pbWF0b3JQcm9wcy5zYy5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IDM7IGsgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBzY1trXSArPSAoYW5pbWF0b3JQcm9wcy5zYy52W2tdIC0gc2Nba10pICogbXVsdFswXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzY1trXSArPSAoYW5pbWF0b3JQcm9wcy5zYy52W2tdIC0gc2Nba10pICogbXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZG9jdW1lbnREYXRhLmZpbGxDb2xvckFuaW0gJiYgZG9jdW1lbnREYXRhLmZjKSB7XHJcbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5mYy5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgMzsgayArPSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBmY1trXSArPSAoYW5pbWF0b3JQcm9wcy5mYy52W2tdIC0gZmNba10pICogbXVsdFswXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmNba10gKz0gKGFuaW1hdG9yUHJvcHMuZmMudltrXSAtIGZjW2tdKSAqIG11bHQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5maC5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBmYyA9IGFkZEh1ZVRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZoLnYgKiBtdWx0WzBdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBmYyA9IGFkZEh1ZVRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZoLnYgKiBtdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZnMucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgZmMgPSBhZGRTYXR1cmF0aW9uVG9SR0IoZmMsIGFuaW1hdG9yUHJvcHMuZnMudiAqIG11bHRbMF0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGZjID0gYWRkU2F0dXJhdGlvblRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZzLnYgKiBtdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZmIucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgZmMgPSBhZGRCcmlnaHRuZXNzVG9SR0IoZmMsIGFuaW1hdG9yUHJvcHMuZmIudiAqIG11bHRbMF0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGZjID0gYWRkQnJpZ2h0bmVzc1RvUkdCKGZjLCBhbmltYXRvclByb3BzLmZiLnYgKiBtdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuXHJcbiAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucC5wcm9wVHlwZSkge1xyXG4gICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xyXG4gICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xyXG4gICAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcclxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHRbMF0sIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHRbMV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0LCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdFswXSwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0WzFdLCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0WzJdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0LCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHQsIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSkge1xyXG4gICAgICAgIGxldHRlclN3ID0gc3cgPCAwID8gMCA6IHN3O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltKSB7XHJcbiAgICAgICAgbGV0dGVyU2MgPSAncmdiKCcgKyBNYXRoLnJvdW5kKHNjWzBdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoc2NbMV0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChzY1syXSAqIDI1NSkgKyAnKSc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYykge1xyXG4gICAgICAgIGxldHRlckZjID0gJ3JnYignICsgTWF0aC5yb3VuZChmY1swXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGZjWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoZmNbMl0gKiAyNTUpICsgJyknO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5faGFzTWFza2VkUGF0aCkge1xyXG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgLWRvY3VtZW50RGF0YS5scyk7XHJcblxyXG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgKGFsaWdubWVudFsxXSAqIHlPZmYpICogMC4wMSArIHlQb3MsIDApO1xyXG4gICAgICAgIGlmICh0aGlzLl9wYXRoRGF0YS5wLnYpIHtcclxuICAgICAgICAgIHRhbkFuZ2xlID0gKGN1cnJlbnRQb2ludC5wb2ludFsxXSAtIHByZXZQb2ludC5wb2ludFsxXSkgLyAoY3VycmVudFBvaW50LnBvaW50WzBdIC0gcHJldlBvaW50LnBvaW50WzBdKTtcclxuICAgICAgICAgIHZhciByb3QgPSAoTWF0aC5hdGFuKHRhbkFuZ2xlKSAqIDE4MCkgLyBNYXRoLlBJO1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRQb2ludC5wb2ludFswXSA8IHByZXZQb2ludC5wb2ludFswXSkge1xyXG4gICAgICAgICAgICByb3QgKz0gMTgwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZSgoLXJvdCAqIE1hdGguUEkpIC8gMTgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSh4UGF0aFBvcywgeVBhdGhQb3MsIDApO1xyXG4gICAgICAgIGN1cnJlbnRMZW5ndGggLT0gKGFsaWdubWVudFswXSAqIGxldHRlcnNbaV0uYW4pICogMC4wMDU7XHJcbiAgICAgICAgaWYgKGxldHRlcnNbaSArIDFdICYmIGluZCAhPT0gbGV0dGVyc1tpICsgMV0uaW5kKSB7XHJcbiAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGxldHRlcnNbaV0uYW4gLyAyO1xyXG4gICAgICAgICAgY3VycmVudExlbmd0aCArPSAoZG9jdW1lbnREYXRhLnRyICogMC4wMDEpICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSh4UG9zLCB5UG9zLCAwKTtcclxuXHJcbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5wcykge1xyXG4gICAgICAgICAgLy8gbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEucHNbMF0sZG9jdW1lbnREYXRhLnBzWzFdLDApO1xyXG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEucHNbMF0sIGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XHJcbiAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUobGV0dGVyc1tpXS5hbmltYXRvckp1c3RpZnlPZmZzZXQgKyBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdKSwgMCwgMCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGxldHRlcnNbaV0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICsgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGV0dGVyc1tpXS5saW5lXSkgLyAyLCAwLCAwKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCAtZG9jdW1lbnREYXRhLmxzKTtcclxuICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKG9mZmYsIDAsIDApO1xyXG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoKGFsaWdubWVudFswXSAqIGxldHRlcnNbaV0uYW4pICogMC4wMDUsIChhbGlnbm1lbnRbMV0gKiB5T2ZmKSAqIDAuMDEsIDApO1xyXG4gICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sICsgKGRvY3VtZW50RGF0YS50ciAqIDAuMDAxKSAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlbmRlclR5cGUgPT09ICdodG1sJykge1xyXG4gICAgICAgIGxldHRlck0gPSBtYXRyaXhIZWxwZXIudG9DU1MoKTtcclxuICAgICAgfSBlbHNlIGlmIChyZW5kZXJUeXBlID09PSAnc3ZnJykge1xyXG4gICAgICAgIGxldHRlck0gPSBtYXRyaXhIZWxwZXIudG8yZENTUygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldHRlclAgPSBbbWF0cml4SGVscGVyLnByb3BzWzBdLCBtYXRyaXhIZWxwZXIucHJvcHNbMV0sIG1hdHJpeEhlbHBlci5wcm9wc1syXSwgbWF0cml4SGVscGVyLnByb3BzWzNdLCBtYXRyaXhIZWxwZXIucHJvcHNbNF0sIG1hdHJpeEhlbHBlci5wcm9wc1s1XSwgbWF0cml4SGVscGVyLnByb3BzWzZdLCBtYXRyaXhIZWxwZXIucHJvcHNbN10sIG1hdHJpeEhlbHBlci5wcm9wc1s4XSwgbWF0cml4SGVscGVyLnByb3BzWzldLCBtYXRyaXhIZWxwZXIucHJvcHNbMTBdLCBtYXRyaXhIZWxwZXIucHJvcHNbMTFdLCBtYXRyaXhIZWxwZXIucHJvcHNbMTJdLCBtYXRyaXhIZWxwZXIucHJvcHNbMTNdLCBtYXRyaXhIZWxwZXIucHJvcHNbMTRdLCBtYXRyaXhIZWxwZXIucHJvcHNbMTVdXTtcclxuICAgICAgfVxyXG4gICAgICBsZXR0ZXJPID0gZWxlbU9wYWNpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlbmRlcmVkTGV0dGVyc0NvdW50IDw9IGkpIHtcclxuICAgICAgbGV0dGVyVmFsdWUgPSBuZXcgTGV0dGVyUHJvcHMobGV0dGVyTywgbGV0dGVyU3csIGxldHRlclNjLCBsZXR0ZXJGYywgbGV0dGVyTSwgbGV0dGVyUCk7XHJcbiAgICAgIHRoaXMucmVuZGVyZWRMZXR0ZXJzLnB1c2gobGV0dGVyVmFsdWUpO1xyXG4gICAgICByZW5kZXJlZExldHRlcnNDb3VudCArPSAxO1xyXG4gICAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXR0ZXJWYWx1ZSA9IHRoaXMucmVuZGVyZWRMZXR0ZXJzW2ldO1xyXG4gICAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGxldHRlclZhbHVlLnVwZGF0ZShsZXR0ZXJPLCBsZXR0ZXJTdywgbGV0dGVyU2MsIGxldHRlckZjLCBsZXR0ZXJNLCBsZXR0ZXJQKSB8fCB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZztcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5UZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMuX2VsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLl9mcmFtZUlkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMuX2ZyYW1lSWQgPSB0aGlzLl9lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxuICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xyXG59O1xyXG5cclxuVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLm1IZWxwZXIgPSBuZXcgTWF0cml4KCk7XHJcblRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5kZWZhdWx0UHJvcHNBcnJheSA9IFtdO1xyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFRleHRBbmltYXRvclByb3BlcnR5KTtcclxuXHJcbi8qIGdsb2JhbCBQcm9wZXJ0eUZhY3RvcnksIGRlZ1RvUmFkcywgVGV4dFNlbGVjdG9yUHJvcCAqL1xyXG4vKiBleHBvcnRlZCBUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHkgKi9cclxuXHJcbmZ1bmN0aW9uIFRleHRBbmltYXRvckRhdGFQcm9wZXJ0eShlbGVtLCBhbmltYXRvclByb3BzLCBjb250YWluZXIpIHtcclxuICB2YXIgZGVmYXVsdERhdGEgPSB7IHByb3BUeXBlOiBmYWxzZSB9O1xyXG4gIHZhciBnZXRQcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3A7XHJcbiAgdmFyIHRleHRBbmltYXRvckFuaW1hdGFibGVzID0gYW5pbWF0b3JQcm9wcy5hO1xyXG4gIHRoaXMuYSA9IHtcclxuICAgIHI6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnIgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnIsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgcng6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ4ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeCwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICByeTogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucnkgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ5LCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcclxuICAgIHNrOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zayA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2ssIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG4gICAgc2E6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNhID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYSwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBzOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zLCAxLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBhOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5hID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5hLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBvOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5vID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5vLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBwOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5wID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5wLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBzdzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc3cgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnN3LCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBzYzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2MgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNjLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBmYzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZmMgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZjLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBmaDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZmggPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZoLCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBmczogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZnMgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZzLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICBmYjogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZmIgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZiLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgICB0OiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy50ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy50LCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcbiAgfTtcclxuXHJcbiAgdGhpcy5zID0gVGV4dFNlbGVjdG9yUHJvcC5nZXRUZXh0U2VsZWN0b3JQcm9wKGVsZW0sIGFuaW1hdG9yUHJvcHMucywgY29udGFpbmVyKTtcclxuICB0aGlzLnMudCA9IGFuaW1hdG9yUHJvcHMucy50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBMZXR0ZXJQcm9wcyhvLCBzdywgc2MsIGZjLCBtLCBwKSB7XHJcbiAgdGhpcy5vID0gbztcclxuICB0aGlzLnN3ID0gc3c7XHJcbiAgdGhpcy5zYyA9IHNjO1xyXG4gIHRoaXMuZmMgPSBmYztcclxuICB0aGlzLm0gPSBtO1xyXG4gIHRoaXMucCA9IHA7XHJcbiAgdGhpcy5fbWRmID0ge1xyXG4gICAgbzogdHJ1ZSxcclxuICAgIHN3OiAhIXN3LFxyXG4gICAgc2M6ICEhc2MsXHJcbiAgICBmYzogISFmYyxcclxuICAgIG06IHRydWUsXHJcbiAgICBwOiB0cnVlLFxyXG4gIH07XHJcbn1cclxuXHJcbkxldHRlclByb3BzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobywgc3csIHNjLCBmYywgbSwgcCkge1xyXG4gIHRoaXMuX21kZi5vID0gZmFsc2U7XHJcbiAgdGhpcy5fbWRmLnN3ID0gZmFsc2U7XHJcbiAgdGhpcy5fbWRmLnNjID0gZmFsc2U7XHJcbiAgdGhpcy5fbWRmLmZjID0gZmFsc2U7XHJcbiAgdGhpcy5fbWRmLm0gPSBmYWxzZTtcclxuICB0aGlzLl9tZGYucCA9IGZhbHNlO1xyXG4gIHZhciB1cGRhdGVkID0gZmFsc2U7XHJcblxyXG4gIGlmICh0aGlzLm8gIT09IG8pIHtcclxuICAgIHRoaXMubyA9IG87XHJcbiAgICB0aGlzLl9tZGYubyA9IHRydWU7XHJcbiAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKHRoaXMuc3cgIT09IHN3KSB7XHJcbiAgICB0aGlzLnN3ID0gc3c7XHJcbiAgICB0aGlzLl9tZGYuc3cgPSB0cnVlO1xyXG4gICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgfVxyXG4gIGlmICh0aGlzLnNjICE9PSBzYykge1xyXG4gICAgdGhpcy5zYyA9IHNjO1xyXG4gICAgdGhpcy5fbWRmLnNjID0gdHJ1ZTtcclxuICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gIH1cclxuICBpZiAodGhpcy5mYyAhPT0gZmMpIHtcclxuICAgIHRoaXMuZmMgPSBmYztcclxuICAgIHRoaXMuX21kZi5mYyA9IHRydWU7XHJcbiAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKHRoaXMubSAhPT0gbSkge1xyXG4gICAgdGhpcy5tID0gbTtcclxuICAgIHRoaXMuX21kZi5tID0gdHJ1ZTtcclxuICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gIH1cclxuICBpZiAocC5sZW5ndGggJiYgKHRoaXMucFswXSAhPT0gcFswXSB8fCB0aGlzLnBbMV0gIT09IHBbMV0gfHwgdGhpcy5wWzRdICE9PSBwWzRdIHx8IHRoaXMucFs1XSAhPT0gcFs1XSB8fCB0aGlzLnBbMTJdICE9PSBwWzEyXSB8fCB0aGlzLnBbMTNdICE9PSBwWzEzXSkpIHtcclxuICAgIHRoaXMucCA9IHA7XHJcbiAgICB0aGlzLl9tZGYucCA9IHRydWU7XHJcbiAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHVwZGF0ZWQ7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgRm9udE1hbmFnZXIsIGluaXRpYWxEZWZhdWx0RnJhbWUsIGdldEZvbnRQcm9wZXJ0aWVzICovXHJcbi8qIGV4cG9ydGVkIFRleHRQcm9wZXJ0eSAqL1xyXG5cclxuZnVuY3Rpb24gVGV4dFByb3BlcnR5KGVsZW0sIGRhdGEpIHtcclxuICB0aGlzLl9mcmFtZUlkID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcclxuICB0aGlzLnB2ID0gJyc7XHJcbiAgdGhpcy52ID0gJyc7XHJcbiAgdGhpcy5rZiA9IGZhbHNlO1xyXG4gIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgdGhpcy5kYXRhID0gZGF0YTtcclxuICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gIHRoaXMuY29tcCA9IHRoaXMuZWxlbS5jb21wO1xyXG4gIHRoaXMua2V5c0luZGV4ID0gMDtcclxuICB0aGlzLmNhblJlc2l6ZSA9IGZhbHNlO1xyXG4gIHRoaXMubWluaW11bUZvbnRTaXplID0gMTtcclxuICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xyXG4gIHRoaXMuY3VycmVudERhdGEgPSB7XHJcbiAgICBhc2NlbnQ6IDAsXHJcbiAgICBib3hXaWR0aDogdGhpcy5kZWZhdWx0Qm94V2lkdGgsXHJcbiAgICBmOiAnJyxcclxuICAgIGZTdHlsZTogJycsXHJcbiAgICBmV2VpZ2h0OiAnJyxcclxuICAgIGZjOiAnJyxcclxuICAgIGo6ICcnLFxyXG4gICAganVzdGlmeU9mZnNldDogJycsXHJcbiAgICBsOiBbXSxcclxuICAgIGxoOiAwLFxyXG4gICAgbGluZVdpZHRoczogW10sXHJcbiAgICBsczogJycsXHJcbiAgICBvZjogJycsXHJcbiAgICBzOiAnJyxcclxuICAgIHNjOiAnJyxcclxuICAgIHN3OiAwLFxyXG4gICAgdDogMCxcclxuICAgIHRyOiAwLFxyXG4gICAgc3o6IDAsXHJcbiAgICBwczogbnVsbCxcclxuICAgIGZpbGxDb2xvckFuaW06IGZhbHNlLFxyXG4gICAgc3Ryb2tlQ29sb3JBbmltOiBmYWxzZSxcclxuICAgIHN0cm9rZVdpZHRoQW5pbTogZmFsc2UsXHJcbiAgICB5T2Zmc2V0OiAwLFxyXG4gICAgZmluYWxTaXplOiAwLFxyXG4gICAgZmluYWxUZXh0OiBbXSxcclxuICAgIGZpbmFsTGluZUhlaWdodDogMCxcclxuICAgIF9fY29tcGxldGU6IGZhbHNlLFxyXG5cclxuICB9O1xyXG4gIHRoaXMuY29weURhdGEodGhpcy5jdXJyZW50RGF0YSwgdGhpcy5kYXRhLmQua1swXS5zKTtcclxuXHJcbiAgaWYgKCF0aGlzLnNlYXJjaFByb3BlcnR5KCkpIHtcclxuICAgIHRoaXMuY29tcGxldGVUZXh0RGF0YSh0aGlzLmN1cnJlbnREYXRhKTtcclxuICB9XHJcbn1cclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZGVmYXVsdEJveFdpZHRoID0gWzAsIDBdO1xyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5jb3B5RGF0YSA9IGZ1bmN0aW9uIChvYmosIGRhdGEpIHtcclxuICBmb3IgKHZhciBzIGluIGRhdGEpIHtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgcykpIHtcclxuICAgICAgb2JqW3NdID0gZGF0YVtzXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2V0Q3VycmVudERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIGlmICghZGF0YS5fX2NvbXBsZXRlKSB7XHJcbiAgICB0aGlzLmNvbXBsZXRlVGV4dERhdGEoZGF0YSk7XHJcbiAgfVxyXG4gIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xyXG4gIHRoaXMuY3VycmVudERhdGEuYm94V2lkdGggPSB0aGlzLmN1cnJlbnREYXRhLmJveFdpZHRoIHx8IHRoaXMuZGVmYXVsdEJveFdpZHRoO1xyXG4gIHRoaXMuX21kZiA9IHRydWU7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLnNlYXJjaFByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnNlYXJjaEtleWZyYW1lcygpO1xyXG59O1xyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hLZXlmcmFtZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5rZiA9IHRoaXMuZGF0YS5kLmsubGVuZ3RoID4gMTtcclxuICBpZiAodGhpcy5rZikge1xyXG4gICAgdGhpcy5hZGRFZmZlY3QodGhpcy5nZXRLZXlmcmFtZVZhbHVlLmJpbmQodGhpcykpO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcy5rZjtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gZnVuY3Rpb24gKGVmZmVjdEZ1bmN0aW9uKSB7XHJcbiAgdGhpcy5lZmZlY3RzU2VxdWVuY2UucHVzaChlZmZlY3RGdW5jdGlvbik7XHJcbiAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoX2ZpbmFsVmFsdWUpIHtcclxuICBpZiAoKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCB8fCAhdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSAmJiAhX2ZpbmFsVmFsdWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdGhpcy5jdXJyZW50RGF0YS50ID0gdGhpcy5kYXRhLmQua1t0aGlzLmtleXNJbmRleF0ucy50O1xyXG4gIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnREYXRhO1xyXG4gIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmtleXNJbmRleDtcclxuICBpZiAodGhpcy5sb2NrKSB7XHJcbiAgICB0aGlzLnNldEN1cnJlbnREYXRhKHRoaXMuY3VycmVudERhdGEpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLmxvY2sgPSB0cnVlO1xyXG4gIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gIHZhciBpOyB2YXJcclxuICAgIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxuICB2YXIgZmluYWxWYWx1ZSA9IF9maW5hbFZhbHVlIHx8IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnM7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAvLyBDaGVja2luZyBpZiBpbmRleCBjaGFuZ2VkIHRvIHByZXZlbnQgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IGV2ZXJ5IHRpbWUgdGhlIGV4cHJlc3Npb24gdXBkYXRlcy5cclxuICAgIGlmIChjdXJyZW50SW5kZXggIT09IHRoaXMua2V5c0luZGV4KSB7XHJcbiAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZVtpXShmaW5hbFZhbHVlLCBmaW5hbFZhbHVlLnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKHRoaXMuY3VycmVudERhdGEsIGZpbmFsVmFsdWUudCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChjdXJyZW50VmFsdWUgIT09IGZpbmFsVmFsdWUpIHtcclxuICAgIHRoaXMuc2V0Q3VycmVudERhdGEoZmluYWxWYWx1ZSk7XHJcbiAgfVxyXG4gIHRoaXMudiA9IHRoaXMuY3VycmVudERhdGE7XHJcbiAgdGhpcy5wdiA9IHRoaXMudjtcclxuICB0aGlzLmxvY2sgPSBmYWxzZTtcclxuICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG59O1xyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRLZXlmcmFtZVZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB0ZXh0S2V5cyA9IHRoaXMuZGF0YS5kLms7XHJcbiAgdmFyIGZyYW1lTnVtID0gdGhpcy5lbGVtLmNvbXAucmVuZGVyZWRGcmFtZTtcclxuICB2YXIgaSA9IDA7IHZhclxyXG4gICAgbGVuID0gdGV4dEtleXMubGVuZ3RoO1xyXG4gIHdoaWxlIChpIDw9IGxlbiAtIDEpIHtcclxuICAgIGlmIChpID09PSBsZW4gLSAxIHx8IHRleHRLZXlzW2kgKyAxXS50ID4gZnJhbWVOdW0pIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG4gIGlmICh0aGlzLmtleXNJbmRleCAhPT0gaSkge1xyXG4gICAgdGhpcy5rZXlzSW5kZXggPSBpO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcy5kYXRhLmQua1t0aGlzLmtleXNJbmRleF0ucztcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuYnVpbGRGaW5hbFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gIHZhciBjaGFyYWN0ZXJzQXJyYXkgPSBbXTtcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xyXG4gIHZhciBjaGFyQ29kZTtcclxuICB2YXIgc2Vjb25kQ2hhckNvZGU7XHJcbiAgdmFyIHNob3VsZENvbWJpbmUgPSBmYWxzZTtcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XHJcbiAgICBpZiAoRm9udE1hbmFnZXIuaXNDb21iaW5lZENoYXJhY3RlcihjaGFyQ29kZSkpIHtcclxuICAgICAgY2hhcmFjdGVyc0FycmF5W2NoYXJhY3RlcnNBcnJheS5sZW5ndGggLSAxXSArPSB0ZXh0LmNoYXJBdChpKTtcclxuICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xyXG4gICAgICBzZWNvbmRDaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XHJcbiAgICAgIGlmIChzZWNvbmRDaGFyQ29kZSA+PSAweERDMDAgJiYgc2Vjb25kQ2hhckNvZGUgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgaWYgKHNob3VsZENvbWJpbmUgfHwgRm9udE1hbmFnZXIuaXNNb2RpZmllcihjaGFyQ29kZSwgc2Vjb25kQ2hhckNvZGUpKSB7XHJcbiAgICAgICAgICBjaGFyYWN0ZXJzQXJyYXlbY2hhcmFjdGVyc0FycmF5Lmxlbmd0aCAtIDFdICs9IHRleHQuc3Vic3RyKGksIDIpO1xyXG4gICAgICAgICAgc2hvdWxkQ29tYmluZSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjaGFyYWN0ZXJzQXJyYXkucHVzaCh0ZXh0LnN1YnN0cihpLCAyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGFyYWN0ZXJzQXJyYXkucHVzaCh0ZXh0LmNoYXJBdChpKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPiAweERCRkYpIHtcclxuICAgICAgc2Vjb25kQ2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpO1xyXG4gICAgICBpZiAoRm9udE1hbmFnZXIuaXNaZXJvV2lkdGhKb2luZXIoY2hhckNvZGUsIHNlY29uZENoYXJDb2RlKSkge1xyXG4gICAgICAgIHNob3VsZENvbWJpbmUgPSB0cnVlO1xyXG4gICAgICAgIGNoYXJhY3RlcnNBcnJheVtjaGFyYWN0ZXJzQXJyYXkubGVuZ3RoIC0gMV0gKz0gdGV4dC5zdWJzdHIoaSwgMik7XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJhY3RlcnNBcnJheS5wdXNoKHRleHQuY2hhckF0KGkpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChGb250TWFuYWdlci5pc1plcm9XaWR0aEpvaW5lcihjaGFyQ29kZSkpIHtcclxuICAgICAgY2hhcmFjdGVyc0FycmF5W2NoYXJhY3RlcnNBcnJheS5sZW5ndGggLSAxXSArPSB0ZXh0LmNoYXJBdChpKTtcclxuICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGFyYWN0ZXJzQXJyYXkucHVzaCh0ZXh0LmNoYXJBdChpKSk7XHJcbiAgICB9XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG4gIHJldHVybiBjaGFyYWN0ZXJzQXJyYXk7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLmNvbXBsZXRlVGV4dERhdGEgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhKSB7XHJcbiAgZG9jdW1lbnREYXRhLl9fY29tcGxldGUgPSB0cnVlO1xyXG4gIHZhciBmb250TWFuYWdlciA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyO1xyXG4gIHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG4gIHZhciBsZXR0ZXJzID0gW107XHJcbiAgdmFyIGk7IHZhclxyXG4gICAgbGVuO1xyXG4gIHZhciBuZXdMaW5lRmxhZzsgdmFyIGluZGV4ID0gMDsgdmFyXHJcbiAgICB2YWw7XHJcbiAgdmFyIGFuY2hvckdyb3VwaW5nID0gZGF0YS5tLmc7XHJcbiAgdmFyIGN1cnJlbnRTaXplID0gMDsgdmFyIGN1cnJlbnRQb3MgPSAwOyB2YXIgY3VycmVudExpbmUgPSAwOyB2YXJcclxuICAgIGxpbmVXaWR0aHMgPSBbXTtcclxuICB2YXIgbGluZVdpZHRoID0gMDtcclxuICB2YXIgbWF4TGluZVdpZHRoID0gMDtcclxuICB2YXIgajsgdmFyXHJcbiAgICBqTGVuO1xyXG4gIHZhciBmb250RGF0YSA9IGZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xyXG4gIHZhciBjaGFyRGF0YTsgdmFyXHJcbiAgICBjTGVuZ3RoID0gMDtcclxuXHJcbiAgdmFyIGZvbnRQcm9wcyA9IGdldEZvbnRQcm9wZXJ0aWVzKGZvbnREYXRhKTtcclxuICBkb2N1bWVudERhdGEuZldlaWdodCA9IGZvbnRQcm9wcy53ZWlnaHQ7XHJcbiAgZG9jdW1lbnREYXRhLmZTdHlsZSA9IGZvbnRQcm9wcy5zdHlsZTtcclxuICBkb2N1bWVudERhdGEuZmluYWxTaXplID0gZG9jdW1lbnREYXRhLnM7XHJcbiAgZG9jdW1lbnREYXRhLmZpbmFsVGV4dCA9IHRoaXMuYnVpbGRGaW5hbFRleHQoZG9jdW1lbnREYXRhLnQpO1xyXG4gIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoO1xyXG4gIGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgPSBkb2N1bWVudERhdGEubGg7XHJcbiAgdmFyIHRyYWNraW5nT2Zmc2V0ID0gKGRvY3VtZW50RGF0YS50ciAvIDEwMDApICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcclxuICB2YXIgY2hhckNvZGU7XHJcbiAgaWYgKGRvY3VtZW50RGF0YS5zeikge1xyXG4gICAgdmFyIGZsYWcgPSB0cnVlO1xyXG4gICAgdmFyIGJveFdpZHRoID0gZG9jdW1lbnREYXRhLnN6WzBdO1xyXG4gICAgdmFyIGJveEhlaWdodCA9IGRvY3VtZW50RGF0YS5zelsxXTtcclxuICAgIHZhciBjdXJyZW50SGVpZ2h0OyB2YXJcclxuICAgICAgZmluYWxUZXh0O1xyXG4gICAgd2hpbGUgKGZsYWcpIHtcclxuICAgICAgZmluYWxUZXh0ID0gdGhpcy5idWlsZEZpbmFsVGV4dChkb2N1bWVudERhdGEudCk7XHJcbiAgICAgIGN1cnJlbnRIZWlnaHQgPSAwO1xyXG4gICAgICBsaW5lV2lkdGggPSAwO1xyXG4gICAgICBsZW4gPSBmaW5hbFRleHQubGVuZ3RoO1xyXG4gICAgICB0cmFja2luZ09mZnNldCA9IChkb2N1bWVudERhdGEudHIgLyAxMDAwKSAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XHJcbiAgICAgIHZhciBsYXN0U3BhY2VJbmRleCA9IC0xO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBjaGFyQ29kZSA9IGZpbmFsVGV4dFtpXS5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIG5ld0xpbmVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGZpbmFsVGV4dFtpXSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IGk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMTMgfHwgY2hhckNvZGUgPT09IDMpIHtcclxuICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XHJcbiAgICAgICAgICBuZXdMaW5lRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICBjdXJyZW50SGVpZ2h0ICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvbnRNYW5hZ2VyLmNoYXJzKSB7XHJcbiAgICAgICAgICBjaGFyRGF0YSA9IGZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGZpbmFsVGV4dFtpXSwgZm9udERhdGEuZlN0eWxlLCBmb250RGF0YS5mRmFtaWx5KTtcclxuICAgICAgICAgIGNMZW5ndGggPSBuZXdMaW5lRmxhZyA/IDAgOiAoY2hhckRhdGEudyAqIGRvY3VtZW50RGF0YS5maW5hbFNpemUpIC8gMTAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyB0Q2FudmFzSGVscGVyLmZvbnQgPSBkb2N1bWVudERhdGEucyArICdweCAnKyBmb250RGF0YS5mRmFtaWx5O1xyXG4gICAgICAgICAgY0xlbmd0aCA9IGZvbnRNYW5hZ2VyLm1lYXN1cmVUZXh0KGZpbmFsVGV4dFtpXSwgZG9jdW1lbnREYXRhLmYsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGluZVdpZHRoICsgY0xlbmd0aCA+IGJveFdpZHRoICYmIGZpbmFsVGV4dFtpXSAhPT0gJyAnKSB7XHJcbiAgICAgICAgICBpZiAobGFzdFNwYWNlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9IGxhc3RTcGFjZUluZGV4O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3VycmVudEhlaWdodCArPSBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0IHx8IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiAxLjI7XHJcbiAgICAgICAgICBmaW5hbFRleHQuc3BsaWNlKGksIGxhc3RTcGFjZUluZGV4ID09PSBpID8gMSA6IDAsICdcXHInKTtcclxuICAgICAgICAgIC8vIGZpbmFsVGV4dCA9IGZpbmFsVGV4dC5zdWJzdHIoMCxpKSArIFwiXFxyXCIgKyBmaW5hbFRleHQuc3Vic3RyKGkgPT09IGxhc3RTcGFjZUluZGV4ID8gaSArIDEgOiBpKTtcclxuICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgICBsaW5lV2lkdGggPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsaW5lV2lkdGggKz0gY0xlbmd0aDtcclxuICAgICAgICAgIGxpbmVXaWR0aCArPSB0cmFja2luZ09mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY3VycmVudEhlaWdodCArPSAoZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSkgLyAxMDA7XHJcbiAgICAgIGlmICh0aGlzLmNhblJlc2l6ZSAmJiBkb2N1bWVudERhdGEuZmluYWxTaXplID4gdGhpcy5taW5pbXVtRm9udFNpemUgJiYgYm94SGVpZ2h0IDwgY3VycmVudEhlaWdodCkge1xyXG4gICAgICAgIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLT0gMTtcclxuICAgICAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gKGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiBkb2N1bWVudERhdGEubGgpIC8gZG9jdW1lbnREYXRhLnM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9jdW1lbnREYXRhLmZpbmFsVGV4dCA9IGZpbmFsVGV4dDtcclxuICAgICAgICBsZW4gPSBkb2N1bWVudERhdGEuZmluYWxUZXh0Lmxlbmd0aDtcclxuICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgbGluZVdpZHRoID0gLXRyYWNraW5nT2Zmc2V0O1xyXG4gIGNMZW5ndGggPSAwO1xyXG4gIHZhciB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XHJcbiAgdmFyIGN1cnJlbnRDaGFyO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgbmV3TGluZUZsYWcgPSBmYWxzZTtcclxuICAgIGN1cnJlbnRDaGFyID0gZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXTtcclxuICAgIGNoYXJDb2RlID0gY3VycmVudENoYXIuY2hhckNvZGVBdCgwKTtcclxuICAgIGlmIChjaGFyQ29kZSA9PT0gMTMgfHwgY2hhckNvZGUgPT09IDMpIHtcclxuICAgICAgdW5jb2xsYXBzZWRTcGFjZXMgPSAwO1xyXG4gICAgICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcclxuICAgICAgbWF4TGluZVdpZHRoID0gbGluZVdpZHRoID4gbWF4TGluZVdpZHRoID8gbGluZVdpZHRoIDogbWF4TGluZVdpZHRoO1xyXG4gICAgICBsaW5lV2lkdGggPSAtMiAqIHRyYWNraW5nT2Zmc2V0O1xyXG4gICAgICB2YWwgPSAnJztcclxuICAgICAgbmV3TGluZUZsYWcgPSB0cnVlO1xyXG4gICAgICBjdXJyZW50TGluZSArPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsID0gY3VycmVudENoYXI7XHJcbiAgICB9XHJcbiAgICBpZiAoZm9udE1hbmFnZXIuY2hhcnMpIHtcclxuICAgICAgY2hhckRhdGEgPSBmb250TWFuYWdlci5nZXRDaGFyRGF0YShjdXJyZW50Q2hhciwgZm9udERhdGEuZlN0eWxlLCBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcclxuICAgICAgY0xlbmd0aCA9IG5ld0xpbmVGbGFnID8gMCA6IChjaGFyRGF0YS53ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSkgLyAxMDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB2YXIgY2hhcldpZHRoID0gZm9udE1hbmFnZXIubWVhc3VyZVRleHQodmFsLCBkb2N1bWVudERhdGEuZiwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XHJcbiAgICAgIC8vIHRDYW52YXNIZWxwZXIuZm9udCA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHggJysgZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseTtcclxuICAgICAgY0xlbmd0aCA9IGZvbnRNYW5hZ2VyLm1lYXN1cmVUZXh0KHZhbCwgZG9jdW1lbnREYXRhLmYsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICBpZiAoY3VycmVudENoYXIgPT09ICcgJykge1xyXG4gICAgICB1bmNvbGxhcHNlZFNwYWNlcyArPSBjTGVuZ3RoICsgdHJhY2tpbmdPZmZzZXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsaW5lV2lkdGggKz0gY0xlbmd0aCArIHRyYWNraW5nT2Zmc2V0ICsgdW5jb2xsYXBzZWRTcGFjZXM7XHJcbiAgICAgIHVuY29sbGFwc2VkU3BhY2VzID0gMDtcclxuICAgIH1cclxuICAgIGxldHRlcnMucHVzaCh7XHJcbiAgICAgIGw6IGNMZW5ndGgsIGFuOiBjTGVuZ3RoLCBhZGQ6IGN1cnJlbnRTaXplLCBuOiBuZXdMaW5lRmxhZywgYW5JbmRleGVzOiBbXSwgdmFsOiB2YWwsIGxpbmU6IGN1cnJlbnRMaW5lLCBhbmltYXRvckp1c3RpZnlPZmZzZXQ6IDAsXHJcbiAgICB9KTtcclxuICAgIGlmIChhbmNob3JHcm91cGluZyA9PSAyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICAgIGN1cnJlbnRTaXplICs9IGNMZW5ndGg7XHJcbiAgICAgIGlmICh2YWwgPT09ICcnIHx8IHZhbCA9PT0gJyAnIHx8IGkgPT09IGxlbiAtIDEpIHtcclxuICAgICAgICBpZiAodmFsID09PSAnJyB8fCB2YWwgPT09ICcgJykge1xyXG4gICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRQb3MgPD0gaSkge1xyXG4gICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5hbiA9IGN1cnJlbnRTaXplO1xyXG4gICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5pbmQgPSBpbmRleDtcclxuICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uZXh0cmEgPSBjTGVuZ3RoO1xyXG4gICAgICAgICAgY3VycmVudFBvcyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCArPSAxO1xyXG4gICAgICAgIGN1cnJlbnRTaXplID0gMDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChhbmNob3JHcm91cGluZyA9PSAzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICAgIGN1cnJlbnRTaXplICs9IGNMZW5ndGg7XHJcbiAgICAgIGlmICh2YWwgPT09ICcnIHx8IGkgPT09IGxlbiAtIDEpIHtcclxuICAgICAgICBpZiAodmFsID09PSAnJykge1xyXG4gICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRQb3MgPD0gaSkge1xyXG4gICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5hbiA9IGN1cnJlbnRTaXplO1xyXG4gICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5pbmQgPSBpbmRleDtcclxuICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uZXh0cmEgPSBjTGVuZ3RoO1xyXG4gICAgICAgICAgY3VycmVudFBvcyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50U2l6ZSA9IDA7XHJcbiAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0dGVyc1tpbmRleF0uaW5kID0gaW5kZXg7XHJcbiAgICAgIGxldHRlcnNbaW5kZXhdLmV4dHJhID0gMDtcclxuICAgICAgaW5kZXggKz0gMTtcclxuICAgIH1cclxuICB9XHJcbiAgZG9jdW1lbnREYXRhLmwgPSBsZXR0ZXJzO1xyXG4gIG1heExpbmVXaWR0aCA9IGxpbmVXaWR0aCA+IG1heExpbmVXaWR0aCA/IGxpbmVXaWR0aCA6IG1heExpbmVXaWR0aDtcclxuICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcclxuICBpZiAoZG9jdW1lbnREYXRhLnN6KSB7XHJcbiAgICBkb2N1bWVudERhdGEuYm94V2lkdGggPSBkb2N1bWVudERhdGEuc3pbMF07XHJcbiAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IDA7XHJcbiAgfSBlbHNlIHtcclxuICAgIGRvY3VtZW50RGF0YS5ib3hXaWR0aCA9IG1heExpbmVXaWR0aDtcclxuICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gLWRvY3VtZW50RGF0YS5ib3hXaWR0aDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gLWRvY3VtZW50RGF0YS5ib3hXaWR0aCAvIDI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuICBkb2N1bWVudERhdGEubGluZVdpZHRocyA9IGxpbmVXaWR0aHM7XHJcblxyXG4gIHZhciBhbmltYXRvcnMgPSBkYXRhLmE7IHZhciBhbmltYXRvckRhdGE7IHZhclxyXG4gICAgbGV0dGVyRGF0YTtcclxuICBqTGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcclxuICB2YXIgYmFzZWQ7IHZhciBpbmQ7IHZhclxyXG4gICAgaW5kZXhlcyA9IFtdO1xyXG4gIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgIGFuaW1hdG9yRGF0YSA9IGFuaW1hdG9yc1tqXTtcclxuICAgIGlmIChhbmltYXRvckRhdGEuYS5zYykge1xyXG4gICAgICBkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChhbmltYXRvckRhdGEuYS5zdykge1xyXG4gICAgICBkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChhbmltYXRvckRhdGEuYS5mYyB8fCBhbmltYXRvckRhdGEuYS5maCB8fCBhbmltYXRvckRhdGEuYS5mcyB8fCBhbmltYXRvckRhdGEuYS5mYikge1xyXG4gICAgICBkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbmQgPSAwO1xyXG4gICAgYmFzZWQgPSBhbmltYXRvckRhdGEucy5iO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGxldHRlckRhdGEgPSBsZXR0ZXJzW2ldO1xyXG4gICAgICBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSA9IGluZDtcclxuICAgICAgaWYgKChiYXNlZCA9PSAxICYmIGxldHRlckRhdGEudmFsICE9PSAnJykgfHwgKGJhc2VkID09IDIgJiYgbGV0dGVyRGF0YS52YWwgIT09ICcnICYmIGxldHRlckRhdGEudmFsICE9PSAnICcpIHx8IChiYXNlZCA9PSAzICYmIChsZXR0ZXJEYXRhLm4gfHwgbGV0dGVyRGF0YS52YWwgPT0gJyAnIHx8IGkgPT0gbGVuIC0gMSkpIHx8IChiYXNlZCA9PSA0ICYmIChsZXR0ZXJEYXRhLm4gfHwgaSA9PSBsZW4gLSAxKSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgICBpZiAoYW5pbWF0b3JEYXRhLnMucm4gPT09IDEpIHtcclxuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmQgKz0gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGF0YS5hW2pdLnMudG90YWxDaGFycyA9IGluZDtcclxuICAgIHZhciBjdXJyZW50SW5kID0gLTE7IHZhclxyXG4gICAgICBuZXdJbmQ7XHJcbiAgICBpZiAoYW5pbWF0b3JEYXRhLnMucm4gPT09IDEpIHtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgbGV0dGVyRGF0YSA9IGxldHRlcnNbaV07XHJcbiAgICAgICAgaWYgKGN1cnJlbnRJbmQgIT0gbGV0dGVyRGF0YS5hbkluZGV4ZXNbal0pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgICAgIGN1cnJlbnRJbmQgPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXTtcclxuICAgICAgICAgIG5ld0luZCA9IGluZGV4ZXMuc3BsaWNlKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGluZGV4ZXMubGVuZ3RoKSwgMSlbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldHRlckRhdGEuYW5JbmRleGVzW2pdID0gbmV3SW5kO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGRvY3VtZW50RGF0YS55T2Zmc2V0ID0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCB8fCBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yO1xyXG4gIGRvY3VtZW50RGF0YS5scyA9IGRvY3VtZW50RGF0YS5scyB8fCAwO1xyXG4gIGRvY3VtZW50RGF0YS5hc2NlbnQgPSAoZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSkgLyAxMDA7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xyXG4gIGluZGV4ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5c0luZGV4IDogaW5kZXg7XHJcbiAgdmFyIGREYXRhID0gdGhpcy5jb3B5RGF0YSh7fSwgdGhpcy5kYXRhLmQua1tpbmRleF0ucyk7XHJcbiAgZERhdGEgPSB0aGlzLmNvcHlEYXRhKGREYXRhLCBuZXdEYXRhKTtcclxuICB0aGlzLmRhdGEuZC5rW2luZGV4XS5zID0gZERhdGE7XHJcbiAgdGhpcy5yZWNhbGN1bGF0ZShpbmRleCk7XHJcbiAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICB2YXIgZERhdGEgPSB0aGlzLmRhdGEuZC5rW2luZGV4XS5zO1xyXG4gIGREYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcclxuICB0aGlzLmtleXNJbmRleCA9IDA7XHJcbiAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuICB0aGlzLmdldFZhbHVlKGREYXRhKTtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuY2FuUmVzaXplRm9udCA9IGZ1bmN0aW9uIChfY2FuUmVzaXplKSB7XHJcbiAgdGhpcy5jYW5SZXNpemUgPSBfY2FuUmVzaXplO1xyXG4gIHRoaXMucmVjYWxjdWxhdGUodGhpcy5rZXlzSW5kZXgpO1xyXG4gIHRoaXMuZWxlbS5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLnNldE1pbmltdW1Gb250U2l6ZSA9IGZ1bmN0aW9uIChfZm9udFZhbHVlKSB7XHJcbiAgdGhpcy5taW5pbXVtRm9udFNpemUgPSBNYXRoLmZsb29yKF9mb250VmFsdWUpIHx8IDE7XHJcbiAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XHJcbiAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIEJlemllckZhY3RvcnksIFByb3BlcnR5RmFjdG9yeSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyICovXHJcbi8qIGV4cG9ydGVkIFRleHRTZWxlY3RvclByb3AgKi9cclxuXHJcbnZhciBUZXh0U2VsZWN0b3JQcm9wID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWF4ID0gTWF0aC5tYXg7XHJcbiAgdmFyIG1pbiA9IE1hdGgubWluO1xyXG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XHJcblxyXG4gIGZ1bmN0aW9uIFRleHRTZWxlY3RvclByb3BGYWN0b3J5KGVsZW0sIGRhdGEpIHtcclxuICAgIHRoaXMuX2N1cnJlbnRUZXh0TGVuZ3RoID0gLTE7XHJcbiAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgdGhpcy5maW5hbFMgPSAwO1xyXG4gICAgdGhpcy5maW5hbEUgPSAwO1xyXG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zIHx8IHsgazogMCB9LCAwLCAwLCB0aGlzKTtcclxuICAgIGlmICgnZScgaW4gZGF0YSkge1xyXG4gICAgICB0aGlzLmUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmUsIDAsIDAsIHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5lID0geyB2OiAxMDAgfTtcclxuICAgIH1cclxuICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubyB8fCB7IGs6IDAgfSwgMCwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLnhlID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS54ZSB8fCB7IGs6IDAgfSwgMCwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLm5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5uZSB8fCB7IGs6IDAgfSwgMCwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLnNtID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zbSB8fCB7IGs6IDEwMCB9LCAwLCAwLCB0aGlzKTtcclxuICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgMC4wMSwgdGhpcyk7XHJcbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuZ2V0VmFsdWUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIFRleHRTZWxlY3RvclByb3BGYWN0b3J5LnByb3RvdHlwZSA9IHtcclxuICAgIGdldE11bHQ6IGZ1bmN0aW9uIChpbmQpIHtcclxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUZXh0TGVuZ3RoICE9PSB0aGlzLmVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmwubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHZhciBlYXNlciA9IGJlei5nZXRFYXNpbmdDdXJ2ZSh0aGlzLm5lLnYvMTAwLDAsMS10aGlzLnhlLnYvMTAwLDEpO1xyXG4gICAgICB2YXIgeDEgPSAwO1xyXG4gICAgICB2YXIgeTEgPSAwO1xyXG4gICAgICB2YXIgeDIgPSAxO1xyXG4gICAgICB2YXIgeTIgPSAxO1xyXG4gICAgICBpZiAodGhpcy5uZS52ID4gMCkge1xyXG4gICAgICAgIHgxID0gdGhpcy5uZS52IC8gMTAwLjA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeTEgPSAtdGhpcy5uZS52IC8gMTAwLjA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMueGUudiA+IDApIHtcclxuICAgICAgICB4MiA9IDEuMCAtIHRoaXMueGUudiAvIDEwMC4wO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHkyID0gMS4wICsgdGhpcy54ZS52IC8gMTAwLjA7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGVhc2VyID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoeDEsIHkxLCB4MiwgeTIpLmdldDtcclxuXHJcbiAgICAgIHZhciBtdWx0ID0gMDtcclxuICAgICAgdmFyIHMgPSB0aGlzLmZpbmFsUztcclxuICAgICAgdmFyIGUgPSB0aGlzLmZpbmFsRTtcclxuICAgICAgdmFyIHR5cGUgPSB0aGlzLmRhdGEuc2g7XHJcbiAgICAgIGlmICh0eXBlID09PSAyKSB7XHJcbiAgICAgICAgaWYgKGUgPT09IHMpIHtcclxuICAgICAgICAgIG11bHQgPSBpbmQgPj0gZSA/IDEgOiAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbigwLjUgLyAoZSAtIHMpICsgKGluZCAtIHMpIC8gKGUgLSBzKSwgMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykge1xyXG4gICAgICAgIGlmIChlID09PSBzKSB7XHJcbiAgICAgICAgICBtdWx0ID0gaW5kID49IGUgPyAwIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbXVsdCA9IDEgLSBtYXgoMCwgbWluKDAuNSAvIChlIC0gcykgKyAoaW5kIC0gcykgLyAoZSAtIHMpLCAxKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xyXG4gICAgICAgIGlmIChlID09PSBzKSB7XHJcbiAgICAgICAgICBtdWx0ID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbXVsdCA9IG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcclxuICAgICAgICAgIGlmIChtdWx0IDwgMC41KSB7XHJcbiAgICAgICAgICAgIG11bHQgKj0gMjtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG11bHQgPSAxIC0gMiAqIChtdWx0IC0gMC41KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDUpIHtcclxuICAgICAgICBpZiAoZSA9PT0gcykge1xyXG4gICAgICAgICAgbXVsdCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciB0b3QgPSBlIC0gcztcclxuICAgICAgICAgIC8qIGluZCArPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdCA9IC00Lyh0b3QqdG90KSooaW5kKmluZCkrKDQvdG90KSppbmQ7ICovXHJcbiAgICAgICAgICBpbmQgPSBtaW4obWF4KDAsIGluZCArIDAuNSAtIHMpLCBlIC0gcyk7XHJcbiAgICAgICAgICB2YXIgeCA9IC10b3QgLyAyICsgaW5kO1xyXG4gICAgICAgICAgdmFyIGEgPSB0b3QgLyAyO1xyXG4gICAgICAgICAgbXVsdCA9IE1hdGguc3FydCgxIC0gKHggKiB4KSAvIChhICogYSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNikge1xyXG4gICAgICAgIGlmIChlID09PSBzKSB7XHJcbiAgICAgICAgICBtdWx0ID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW5kID0gbWluKG1heCgwLCBpbmQgKyAwLjUgLSBzKSwgZSAtIHMpO1xyXG4gICAgICAgICAgbXVsdCA9ICgxICsgKE1hdGguY29zKChNYXRoLlBJICsgTWF0aC5QSSAqIDIgKiAoaW5kKSAvIChlIC0gcykpKSkpIC8gMjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgIH1cclxuICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGluZCA+PSBmbG9vcihzKSkge1xyXG4gICAgICAgICAgaWYgKGluZCAtIHMgPCAwKSB7XHJcbiAgICAgICAgICAgIG11bHQgPSBtYXgoMCwgbWluKG1pbihlLCAxKSAtIChzIC0gaW5kKSwgMSkpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbXVsdCA9IG1heCgwLCBtaW4oZSAtIGluZCwgMSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gU21vb3RobmVzcyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgLy8gVGhlIHNtb290aG5lc3MgcmVwcmVzZW50cyBhIHJlZHVjZWQgcmFuZ2Ugb2YgdGhlIG9yaWdpbmFsIFswOyAxXSByYW5nZS5cclxuICAgICAgLy8gaWYgc21vb3RobmVzcyBpcyAyNSUsIHRoZSBuZXcgcmFuZ2Ugd2lsbCBiZSBbMC4zNzU7IDAuNjI1XVxyXG4gICAgICAvLyBTdGVwcyBhcmU6XHJcbiAgICAgIC8vIC0gZmluZCB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIG5ldyByYW5nZSAodGhyZXNob2xkKVxyXG4gICAgICAvLyAtIGlmIG11bHRpcGxpZXIgaXMgc21hbGxlciB0aGFuIHRoYXQgdmFsdWUsIGZsb29yIGl0IHRvIDBcclxuICAgICAgLy8gLSBpZiBpdCBpcyBsYXJnZXIsXHJcbiAgICAgIC8vICAgICAtIHN1YnRyYWN0IHRoZSB0aHJlc2hvbGRcclxuICAgICAgLy8gICAgIC0gZGl2aWRlIGl0IGJ5IHRoZSBzbW9vdGhuZXNzICh0aGlzIHdpbGwgcmV0dXJuIHRoZSByYW5nZSB0byBbMDsgMV0pXHJcbiAgICAgIC8vIE5vdGU6IElmIGl0IGRvZXNuJ3Qgd29yayBvbiBzb21lIHNjZW5hcmlvcywgY29uc2lkZXIgYXBwbHlpbmcgaXQgYmVmb3JlIHRoZSBlYXNlci5cclxuICAgICAgaWYgKHRoaXMuc20udiAhPT0gMTAwKSB7XHJcbiAgICAgICAgdmFyIHNtb290aG5lc3MgPSB0aGlzLnNtLnYgKiAwLjAxO1xyXG4gICAgICAgIGlmIChzbW9vdGhuZXNzID09PSAwKSB7XHJcbiAgICAgICAgICBzbW9vdGhuZXNzID0gMC4wMDAwMDAwMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IDAuNSAtIHNtb290aG5lc3MgKiAwLjU7XHJcbiAgICAgICAgaWYgKG11bHQgPCB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgIG11bHQgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtdWx0ID0gKG11bHQgLSB0aHJlc2hvbGQpIC8gc21vb3RobmVzcztcclxuICAgICAgICAgIGlmIChtdWx0ID4gMSkge1xyXG4gICAgICAgICAgICBtdWx0ID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG11bHQgKiB0aGlzLmEudjtcclxuICAgIH0sXHJcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKG5ld0NoYXJzRmxhZykge1xyXG4gICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xyXG4gICAgICB0aGlzLl9tZGYgPSBuZXdDaGFyc0ZsYWcgfHwgdGhpcy5fbWRmO1xyXG4gICAgICB0aGlzLl9jdXJyZW50VGV4dExlbmd0aCA9IHRoaXMuZWxlbS50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubC5sZW5ndGggfHwgMDtcclxuICAgICAgaWYgKG5ld0NoYXJzRmxhZyAmJiB0aGlzLmRhdGEuciA9PT0gMikge1xyXG4gICAgICAgIHRoaXMuZS52ID0gdGhpcy5fY3VycmVudFRleHRMZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGRpdmlzb3IgPSB0aGlzLmRhdGEuciA9PT0gMiA/IDEgOiAxMDAgLyB0aGlzLmRhdGEudG90YWxDaGFycztcclxuICAgICAgdmFyIG8gPSB0aGlzLm8udiAvIGRpdmlzb3I7XHJcbiAgICAgIHZhciBzID0gdGhpcy5zLnYgLyBkaXZpc29yICsgbztcclxuICAgICAgdmFyIGUgPSAodGhpcy5lLnYgLyBkaXZpc29yKSArIG87XHJcbiAgICAgIGlmIChzID4gZSkge1xyXG4gICAgICAgIHZhciBfcyA9IHM7XHJcbiAgICAgICAgcyA9IGU7XHJcbiAgICAgICAgZSA9IF9zO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZmluYWxTID0gcztcclxuICAgICAgdGhpcy5maW5hbEUgPSBlO1xyXG4gICAgfSxcclxuICB9O1xyXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkpO1xyXG5cclxuICBmdW5jdGlvbiBnZXRUZXh0U2VsZWN0b3JQcm9wKGVsZW0sIGRhdGEsIGFycikge1xyXG4gICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0b3JQcm9wRmFjdG9yeShlbGVtLCBkYXRhLCBhcnIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGdldFRleHRTZWxlY3RvclByb3A6IGdldFRleHRTZWxlY3RvclByb3AsXHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5LCBwb29saW5nICovXHJcbi8qIGV4cG9ydGVkIHBvb2xGYWN0b3J5ICovXHJcblxyXG52YXIgcG9vbEZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoaW5pdGlhbExlbmd0aCwgX2NyZWF0ZSwgX3JlbGVhc2UpIHtcclxuICAgIHZhciBfbGVuZ3RoID0gMDtcclxuICAgIHZhciBfbWF4TGVuZ3RoID0gaW5pdGlhbExlbmd0aDtcclxuICAgIHZhciBwb29sID0gY3JlYXRlU2l6ZWRBcnJheShfbWF4TGVuZ3RoKTtcclxuXHJcbiAgICB2YXIgb2IgPSB7XHJcbiAgICAgIG5ld0VsZW1lbnQ6IG5ld0VsZW1lbnQsXHJcbiAgICAgIHJlbGVhc2U6IHJlbGVhc2UsXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG5ld0VsZW1lbnQoKSB7XHJcbiAgICAgIHZhciBlbGVtZW50O1xyXG4gICAgICBpZiAoX2xlbmd0aCkge1xyXG4gICAgICAgIF9sZW5ndGggLT0gMTtcclxuICAgICAgICBlbGVtZW50ID0gcG9vbFtfbGVuZ3RoXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtZW50ID0gX2NyZWF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbGVhc2UoZWxlbWVudCkge1xyXG4gICAgICBpZiAoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xyXG4gICAgICAgIHBvb2wgPSBwb29saW5nLmRvdWJsZShwb29sKTtcclxuICAgICAgICBfbWF4TGVuZ3RoICo9IDI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9yZWxlYXNlKSB7XHJcbiAgICAgICAgX3JlbGVhc2UoZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgcG9vbFtfbGVuZ3RoXSA9IGVsZW1lbnQ7XHJcbiAgICAgIF9sZW5ndGggKz0gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2I7XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5ICovXHJcbi8qIGV4cG9ydGVkIHBvb2xpbmcgKi9cclxuXHJcbnZhciBwb29saW5nID0gKGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBkb3VibGUoYXJyKSB7XHJcbiAgICByZXR1cm4gYXJyLmNvbmNhdChjcmVhdGVTaXplZEFycmF5KGFyci5sZW5ndGgpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBkb3VibGU6IGRvdWJsZSxcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVR5cGVkQXJyYXksIHBvb2xGYWN0b3J5ICovXHJcbi8qIGV4cG9ydGVkIHBvaW50UG9vbCAqL1xyXG5cclxudmFyIHBvaW50UG9vbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAyKTtcclxuICB9XHJcbiAgcmV0dXJuIHBvb2xGYWN0b3J5KDgsIGNyZWF0ZSk7XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgU2hhcGVQYXRoLCBwb2ludFBvb2wsIHBvb2xGYWN0b3J5ICovXHJcbi8qIGV4cG9ydGVkIHNoYXBlUG9vbCAqL1xyXG5cclxudmFyIHNoYXBlUG9vbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gY3JlYXRlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTaGFwZVBhdGgoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbGVhc2Uoc2hhcGVQYXRoKSB7XHJcbiAgICB2YXIgbGVuID0gc2hhcGVQYXRoLl9sZW5ndGg7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBwb2ludFBvb2wucmVsZWFzZShzaGFwZVBhdGgudltpXSk7XHJcbiAgICAgIHBvaW50UG9vbC5yZWxlYXNlKHNoYXBlUGF0aC5pW2ldKTtcclxuICAgICAgcG9pbnRQb29sLnJlbGVhc2Uoc2hhcGVQYXRoLm9baV0pO1xyXG4gICAgICBzaGFwZVBhdGgudltpXSA9IG51bGw7XHJcbiAgICAgIHNoYXBlUGF0aC5pW2ldID0gbnVsbDtcclxuICAgICAgc2hhcGVQYXRoLm9baV0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2hhcGVQYXRoLl9sZW5ndGggPSAwO1xyXG4gICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsb25lKHNoYXBlKSB7XHJcbiAgICB2YXIgY2xvbmVkID0gZmFjdG9yeS5uZXdFbGVtZW50KCk7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBzaGFwZS5fbGVuZ3RoID09PSB1bmRlZmluZWQgPyBzaGFwZS52Lmxlbmd0aCA6IHNoYXBlLl9sZW5ndGg7XHJcbiAgICBjbG9uZWQuc2V0TGVuZ3RoKGxlbik7XHJcbiAgICBjbG9uZWQuYyA9IHNoYXBlLmM7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGNsb25lZC5zZXRUcmlwbGVBdChzaGFwZS52W2ldWzBdLCBzaGFwZS52W2ldWzFdLCBzaGFwZS5vW2ldWzBdLCBzaGFwZS5vW2ldWzFdLCBzaGFwZS5pW2ldWzBdLCBzaGFwZS5pW2ldWzFdLCBpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgfVxyXG5cclxuICB2YXIgZmFjdG9yeSA9IHBvb2xGYWN0b3J5KDQsIGNyZWF0ZSwgcmVsZWFzZSk7XHJcbiAgZmFjdG9yeS5jbG9uZSA9IGNsb25lO1xyXG5cclxuICByZXR1cm4gZmFjdG9yeTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5LCBTaGFwZUNvbGxlY3Rpb24sIHNoYXBlUG9vbCwgcG9vbGluZyAqL1xyXG4vKiBleHBvcnRlZCBzaGFwZUNvbGxlY3Rpb25Qb29sICovXHJcblxyXG52YXIgc2hhcGVDb2xsZWN0aW9uUG9vbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG9iID0ge1xyXG4gICAgbmV3U2hhcGVDb2xsZWN0aW9uOiBuZXdTaGFwZUNvbGxlY3Rpb24sXHJcbiAgICByZWxlYXNlOiByZWxlYXNlLFxyXG4gIH07XHJcblxyXG4gIHZhciBfbGVuZ3RoID0gMDtcclxuICB2YXIgX21heExlbmd0aCA9IDQ7XHJcbiAgdmFyIHBvb2wgPSBjcmVhdGVTaXplZEFycmF5KF9tYXhMZW5ndGgpO1xyXG5cclxuICBmdW5jdGlvbiBuZXdTaGFwZUNvbGxlY3Rpb24oKSB7XHJcbiAgICB2YXIgc2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgaWYgKF9sZW5ndGgpIHtcclxuICAgICAgX2xlbmd0aCAtPSAxO1xyXG4gICAgICBzaGFwZUNvbGxlY3Rpb24gPSBwb29sW19sZW5ndGhdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2hhcGVDb2xsZWN0aW9uID0gbmV3IFNoYXBlQ29sbGVjdGlvbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNoYXBlQ29sbGVjdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbGVhc2Uoc2hhcGVDb2xsZWN0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBzaGFwZUNvbGxlY3Rpb24uX2xlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBzaGFwZVBvb2wucmVsZWFzZShzaGFwZUNvbGxlY3Rpb24uc2hhcGVzW2ldKTtcclxuICAgIH1cclxuICAgIHNoYXBlQ29sbGVjdGlvbi5fbGVuZ3RoID0gMDtcclxuXHJcbiAgICBpZiAoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xyXG4gICAgICBwb29sID0gcG9vbGluZy5kb3VibGUocG9vbCk7XHJcbiAgICAgIF9tYXhMZW5ndGggKj0gMjtcclxuICAgIH1cclxuICAgIHBvb2xbX2xlbmd0aF0gPSBzaGFwZUNvbGxlY3Rpb247XHJcbiAgICBfbGVuZ3RoICs9IDE7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2I7XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgcG9vbEZhY3RvcnksIGJlemllckxlbmd0aFBvb2wgKi9cclxuLyogZXhwb3J0ZWQgc2VnbWVudHNMZW5ndGhQb29sICovXHJcblxyXG52YXIgc2VnbWVudHNMZW5ndGhQb29sID0gKGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBjcmVhdGUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsZW5ndGhzOiBbXSxcclxuICAgICAgdG90YWxMZW5ndGg6IDAsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVsZWFzZShlbGVtZW50KSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBlbGVtZW50Lmxlbmd0aHMubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGJlemllckxlbmd0aFBvb2wucmVsZWFzZShlbGVtZW50Lmxlbmd0aHNbaV0pO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudC5sZW5ndGhzLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcG9vbEZhY3RvcnkoOCwgY3JlYXRlLCByZWxlYXNlKTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVUeXBlZEFycmF5LCBkZWZhdWx0Q3VydmVTZWdtZW50cywgcG9vbEZhY3RvcnkgKi9cclxuLyogZXhwb3J0ZWQgYmV6aWVyTGVuZ3RoUG9vbCAqL1xyXG5cclxudmFyIGJlemllckxlbmd0aFBvb2wgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGFkZGVkTGVuZ3RoOiAwLFxyXG4gICAgICBwZXJjZW50czogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzKSxcclxuICAgICAgbGVuZ3RoczogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzKSxcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUpO1xyXG59KCkpO1xyXG5cclxuLyogZXhwb3J0ZWQgbWFya2VyUGFyc2VyICovXHJcblxyXG52YXIgbWFya2VyUGFyc2VyID0gKFxyXG5cclxuICBmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBwYXJzZVBheWxvYWRMaW5lcyhwYXlsb2FkKSB7XHJcbiAgICAgIHZhciBsaW5lcyA9IHBheWxvYWQuc3BsaXQoJ1xcclxcbicpO1xyXG4gICAgICB2YXIga2V5cyA9IHt9O1xyXG4gICAgICB2YXIgbGluZTtcclxuICAgICAgdmFyIGtleXNDb3VudCA9IDA7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICBsaW5lID0gbGluZXNbaV0uc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAobGluZS5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgIGtleXNbbGluZVswXV0gPSBsaW5lWzFdLnRyaW0oKTtcclxuICAgICAgICAgIGtleXNDb3VudCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoa2V5c0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfbWFya2Vycykge1xyXG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9tYXJrZXJzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgdmFyIF9tYXJrZXIgPSBfbWFya2Vyc1tpXTtcclxuICAgICAgICB2YXIgbWFya2VyRGF0YSA9IHtcclxuICAgICAgICAgIHRpbWU6IF9tYXJrZXIudG0sXHJcbiAgICAgICAgICBkdXJhdGlvbjogX21hcmtlci5kcixcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBtYXJrZXJEYXRhLnBheWxvYWQgPSBKU09OLnBhcnNlKF9tYXJrZXJzW2ldLmNtKTtcclxuICAgICAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBtYXJrZXJEYXRhLnBheWxvYWQgPSBwYXJzZVBheWxvYWRMaW5lcyhfbWFya2Vyc1tpXS5jbSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChfXykge1xyXG4gICAgICAgICAgICBtYXJrZXJEYXRhLnBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgICAgbmFtZTogX21hcmtlcnNbaV0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtlcnMucHVzaChtYXJrZXJEYXRhKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWFya2VycztcclxuICAgIH07XHJcbiAgfSgpKTtcclxuXHJcbi8qIGdsb2JhbCBBdWRpb0VsZW1lbnQsIEZvb3RhZ2VFbGVtZW50LCBGb250TWFuYWdlciAqL1xyXG5cclxuZnVuY3Rpb24gQmFzZVJlbmRlcmVyKCkge31cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jaGVja0xheWVycyA9IGZ1bmN0aW9uIChudW0pIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gIHZhciBkYXRhO1xyXG4gIHRoaXMuY29tcGxldGVMYXllcnMgPSB0cnVlO1xyXG4gIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICBpZiAoIXRoaXMuZWxlbWVudHNbaV0pIHtcclxuICAgICAgZGF0YSA9IHRoaXMubGF5ZXJzW2ldO1xyXG4gICAgICBpZiAoZGF0YS5pcCAtIGRhdGEuc3QgPD0gKG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0KSAmJiBkYXRhLm9wIC0gZGF0YS5zdCA+IChudW0gLSB0aGlzLmxheWVyc1tpXS5zdCkpIHtcclxuICAgICAgICB0aGlzLmJ1aWxkSXRlbShpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IHRoaXMuZWxlbWVudHNbaV0gPyB0aGlzLmNvbXBsZXRlTGF5ZXJzIDogZmFsc2U7XHJcbiAgfVxyXG4gIHRoaXMuY2hlY2tQZW5kaW5nRWxlbWVudHMoKTtcclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSXRlbSA9IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIHN3aXRjaCAobGF5ZXIudHkpIHtcclxuICAgIGNhc2UgMjpcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW1hZ2UobGF5ZXIpO1xyXG4gICAgY2FzZSAwOlxyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21wKGxheWVyKTtcclxuICAgIGNhc2UgMTpcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29saWQobGF5ZXIpO1xyXG4gICAgY2FzZSAzOlxyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVOdWxsKGxheWVyKTtcclxuICAgIGNhc2UgNDpcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2hhcGUobGF5ZXIpO1xyXG4gICAgY2FzZSA1OlxyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0KGxheWVyKTtcclxuICAgIGNhc2UgNjpcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQXVkaW8obGF5ZXIpO1xyXG4gICAgY2FzZSAxMzpcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2FtZXJhKGxheWVyKTtcclxuICAgIGNhc2UgMTU6XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZvb3RhZ2UobGF5ZXIpO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTnVsbChsYXllcik7XHJcbiAgfVxyXG59O1xyXG5cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKCdZb3VcXCdyZSB1c2luZyBhIDNkIGNhbWVyYS4gVHJ5IHRoZSBodG1sIHJlbmRlcmVyLicpO1xyXG59O1xyXG5cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVBdWRpbyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBBdWRpb0VsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlRm9vdGFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBGb290YWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEFsbEl0ZW1zID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLmJ1aWxkSXRlbShpKTtcclxuICB9XHJcbiAgdGhpcy5jaGVja1BlbmRpbmdFbGVtZW50cygpO1xyXG59O1xyXG5cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5pbmNsdWRlTGF5ZXJzID0gZnVuY3Rpb24gKG5ld0xheWVycykge1xyXG4gIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gbmV3TGF5ZXJzLmxlbmd0aDtcclxuICB2YXIgajtcclxuICB2YXIgakxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGogPSAwO1xyXG4gICAgd2hpbGUgKGogPCBqTGVuKSB7XHJcbiAgICAgIGlmICh0aGlzLmxheWVyc1tqXS5pZCA9PT0gbmV3TGF5ZXJzW2ldLmlkKSB7XHJcbiAgICAgICAgdGhpcy5sYXllcnNbal0gPSBuZXdMYXllcnNbaV07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaiArPSAxO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvamVjdEludGVyZmFjZSA9IGZ1bmN0aW9uIChwSW50ZXJmYWNlKSB7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UgPSBwSW50ZXJmYWNlO1xyXG59O1xyXG5cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5pbml0SXRlbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCF0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkKSB7XHJcbiAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcclxuICB9XHJcbn07XHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRFbGVtZW50UGFyZW50aW5nID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudE5hbWUsIGhpZXJhcmNoeSkge1xyXG4gIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XHJcbiAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzO1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgaWYgKGxheWVyc1tpXS5pbmQgPT0gcGFyZW50TmFtZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxyXG4gICAgICBpZiAoIWVsZW1lbnRzW2ldIHx8IGVsZW1lbnRzW2ldID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5idWlsZEl0ZW0oaSk7XHJcbiAgICAgICAgdGhpcy5hZGRQZW5kaW5nRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBoaWVyYXJjaHkucHVzaChlbGVtZW50c1tpXSk7XHJcbiAgICAgICAgZWxlbWVudHNbaV0uc2V0QXNQYXJlbnQoKTtcclxuICAgICAgICBpZiAobGF5ZXJzW2ldLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLmJ1aWxkRWxlbWVudFBhcmVudGluZyhlbGVtZW50LCBsYXllcnNbaV0ucGFyZW50LCBoaWVyYXJjaHkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbGVtZW50LnNldEhpZXJhcmNoeShoaWVyYXJjaHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuYWRkUGVuZGluZ0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHRoaXMucGVuZGluZ0VsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcbn07XHJcblxyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zID0gZnVuY3Rpb24gKGFzc2V0cykge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBhc3NldHMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKGFzc2V0c1tpXS54dCkge1xyXG4gICAgICB2YXIgY29tcCA9IHRoaXMuY3JlYXRlQ29tcChhc3NldHNbaV0pO1xyXG4gICAgICBjb21wLmluaXRFeHByZXNzaW9ucygpO1xyXG4gICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0dXBHbG9iYWxEYXRhID0gZnVuY3Rpb24gKGFuaW1EYXRhLCBmb250c0NvbnRhaW5lcikge1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlciA9IG5ldyBGb250TWFuYWdlcigpO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRDaGFycyhhbmltRGF0YS5jaGFycyk7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmFkZEZvbnRzKGFuaW1EYXRhLmZvbnRzLCBmb250c0NvbnRhaW5lcik7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0RGF0YSA9IHRoaXMuYW5pbWF0aW9uSXRlbS5nZXRBc3NldERhdGEuYmluZCh0aGlzLmFuaW1hdGlvbkl0ZW0pO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoID0gdGhpcy5hbmltYXRpb25JdGVtLmdldEFzc2V0c1BhdGguYmluZCh0aGlzLmFuaW1hdGlvbkl0ZW0pO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5pbWFnZUxvYWRlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS5pbWFnZVByZWxvYWRlcjtcclxuICB0aGlzLmdsb2JhbERhdGEuYXVkaW9Db250cm9sbGVyID0gdGhpcy5hbmltYXRpb25JdGVtLmF1ZGlvQ29udHJvbGxlcjtcclxuICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCA9IDA7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lUmF0ZSA9IGFuaW1EYXRhLmZyO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5ubSA9IGFuaW1EYXRhLm5tO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZSA9IHtcclxuICAgIHc6IGFuaW1EYXRhLncsXHJcbiAgICBoOiBhbmltRGF0YS5oLFxyXG4gIH07XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlRWxlbWVudElELCBleHRlbmRQcm90b3R5cGUsIEJhc2VSZW5kZXJlciwgTnVsbEVsZW1lbnQsIFNWR1NoYXBlRWxlbWVudCwgU1ZHVGV4dExvdHRpZUVsZW1lbnQsXHJcbklJbWFnZUVsZW1lbnQsIFNWR0NvbXBFbGVtZW50LCBJU29saWRFbGVtZW50LCBjcmVhdGVOUywgbG9jYXRpb25IcmVmLCBjcmVhdGVTaXplZEFycmF5LCBleHByZXNzaW9uc1BsdWdpbiAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHUmVuZGVyZXIoYW5pbWF0aW9uSXRlbSwgY29uZmlnKSB7XHJcbiAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcclxuICB0aGlzLmxheWVycyA9IG51bGw7XHJcbiAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XHJcbiAgdGhpcy5zdmdFbGVtZW50ID0gY3JlYXRlTlMoJ3N2ZycpO1xyXG4gIHZhciBhcmlhTGFiZWwgPSAnJztcclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy50aXRsZSkge1xyXG4gICAgdmFyIHRpdGxlRWxlbWVudCA9IGNyZWF0ZU5TKCd0aXRsZScpO1xyXG4gICAgdmFyIHRpdGxlSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICAgIHRpdGxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGl0bGVJZCk7XHJcbiAgICB0aXRsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBjb25maWcudGl0bGU7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQodGl0bGVFbGVtZW50KTtcclxuICAgIGFyaWFMYWJlbCArPSB0aXRsZUlkO1xyXG4gIH1cclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5kZXNjcmlwdGlvbikge1xyXG4gICAgdmFyIGRlc2NFbGVtZW50ID0gY3JlYXRlTlMoJ2Rlc2MnKTtcclxuICAgIHZhciBkZXNjSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICAgIGRlc2NFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBkZXNjSWQpO1xyXG4gICAgZGVzY0VsZW1lbnQudGV4dENvbnRlbnQgPSBjb25maWcuZGVzY3JpcHRpb247XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoZGVzY0VsZW1lbnQpO1xyXG4gICAgYXJpYUxhYmVsICs9ICcgJyArIGRlc2NJZDtcclxuICB9XHJcbiAgaWYgKGFyaWFMYWJlbCkge1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JywgYXJpYUxhYmVsKTtcclxuICB9XHJcbiAgdmFyIGRlZnMgPSBjcmVhdGVOUygnZGVmcycpO1xyXG4gIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChkZWZzKTtcclxuICB2YXIgbWFza0VsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xyXG4gIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChtYXNrRWxlbWVudCk7XHJcbiAgdGhpcy5sYXllckVsZW1lbnQgPSBtYXNrRWxlbWVudDtcclxuICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcclxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IChjb25maWcgJiYgY29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8pIHx8ICd4TWlkWU1pZCBtZWV0JyxcclxuICAgIGltYWdlUHJlc2VydmVBc3BlY3RSYXRpbzogKGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvKSB8fCAneE1pZFlNaWQgc2xpY2UnLFxyXG4gICAgcHJvZ3Jlc3NpdmVMb2FkOiAoY29uZmlnICYmIGNvbmZpZy5wcm9ncmVzc2l2ZUxvYWQpIHx8IGZhbHNlLFxyXG4gICAgaGlkZU9uVHJhbnNwYXJlbnQ6ICEoKGNvbmZpZyAmJiBjb25maWcuaGlkZU9uVHJhbnNwYXJlbnQgPT09IGZhbHNlKSksXHJcbiAgICB2aWV3Qm94T25seTogKGNvbmZpZyAmJiBjb25maWcudmlld0JveE9ubHkpIHx8IGZhbHNlLFxyXG4gICAgdmlld0JveFNpemU6IChjb25maWcgJiYgY29uZmlnLnZpZXdCb3hTaXplKSB8fCBmYWxzZSxcclxuICAgIGNsYXNzTmFtZTogKGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lKSB8fCAnJyxcclxuICAgIGlkOiAoY29uZmlnICYmIGNvbmZpZy5pZCkgfHwgJycsXHJcbiAgICBmb2N1c2FibGU6IGNvbmZpZyAmJiBjb25maWcuZm9jdXNhYmxlLFxyXG4gICAgZmlsdGVyU2l6ZToge1xyXG4gICAgICB3aWR0aDogKGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS53aWR0aCkgfHwgJzEwMCUnLFxyXG4gICAgICBoZWlnaHQ6IChjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUuaGVpZ2h0KSB8fCAnMTAwJScsXHJcbiAgICAgIHg6IChjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueCkgfHwgJzAlJyxcclxuICAgICAgeTogKGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS55KSB8fCAnMCUnLFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICB0aGlzLmdsb2JhbERhdGEgPSB7XHJcbiAgICBfbWRmOiBmYWxzZSxcclxuICAgIGZyYW1lTnVtOiAtMSxcclxuICAgIGRlZnM6IGRlZnMsXHJcbiAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnLFxyXG4gIH07XHJcbiAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XHJcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcclxuICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdzdmcnO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VSZW5kZXJlcl0sIFNWR1JlbmRlcmVyKTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVOdWxsID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IE51bGxFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHJldHVybiBuZXcgU1ZHU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBTVkdUZXh0TG90dGllRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUltYWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IElJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IFNWR0NvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlU29saWQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltRGF0YSkge1xyXG4gIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyk7XHJcbiAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLnZpZXdCb3hTaXplKSB7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgdGhpcy5yZW5kZXJDb25maWcudmlld0JveFNpemUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgJzAgMCAnICsgYW5pbURhdGEudyArICcgJyArIGFuaW1EYXRhLmgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94T25seSkge1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGFuaW1EYXRhLmgpO1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcclxuICB9XHJcbiAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSkge1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpO1xyXG4gIH1cclxuICBpZiAodGhpcy5yZW5kZXJDb25maWcuaWQpIHtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5yZW5kZXJDb25maWcuaWQpO1xyXG4gIH1cclxuICBpZiAodGhpcy5yZW5kZXJDb25maWcuZm9jdXNhYmxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsIHRoaXMucmVuZGVyQ29uZmlnLmZvY3VzYWJsZSk7XHJcbiAgfVxyXG4gIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCB0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcclxuICAvLyB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcclxuICAvLyB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSA9IFwiMHB4IDBweCAwcHhcIjtcclxuICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnN2Z0VsZW1lbnQpO1xyXG4gIC8vIE1hc2sgYW5pbWF0aW9uXHJcbiAgdmFyIGRlZnMgPSB0aGlzLmdsb2JhbERhdGEuZGVmcztcclxuXHJcbiAgdGhpcy5zZXR1cEdsb2JhbERhdGEoYW5pbURhdGEsIGRlZnMpO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5wcm9ncmVzc2l2ZUxvYWQgPSB0aGlzLnJlbmRlckNvbmZpZy5wcm9ncmVzc2l2ZUxvYWQ7XHJcbiAgdGhpcy5kYXRhID0gYW5pbURhdGE7XHJcblxyXG4gIHZhciBtYXNrRWxlbWVudCA9IGNyZWF0ZU5TKCdjbGlwUGF0aCcpO1xyXG4gIHZhciByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcclxuICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcclxuICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYW5pbURhdGEuaCk7XHJcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcclxuICByZWN0LnNldEF0dHJpYnV0ZSgneScsIDApO1xyXG4gIHZhciBtYXNrSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFza0lkKTtcclxuICBtYXNrRWxlbWVudC5hcHBlbmRDaGlsZChyZWN0KTtcclxuICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJyArIG1hc2tJZCArICcpJyk7XHJcblxyXG4gIGRlZnMuYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xyXG4gIHRoaXMubGF5ZXJzID0gYW5pbURhdGEubGF5ZXJzO1xyXG4gIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KGFuaW1EYXRhLmxheWVycy5sZW5ndGgpO1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcclxuICB9XHJcbiAgdGhpcy5sYXllckVsZW1lbnQgPSBudWxsO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gbnVsbDtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKHRoaXMuZWxlbWVudHNbaV0pIHtcclxuICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gMDtcclxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgdGhpcy5hbmltYXRpb25JdGVtID0gbnVsbDtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVDb250YWluZXJTaXplID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkSXRlbSA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gIGlmIChlbGVtZW50c1twb3NdIHx8IHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDk5KSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGVsZW1lbnRzW3Bvc10gPSB0cnVlO1xyXG4gIHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVJdGVtKHRoaXMubGF5ZXJzW3Bvc10pO1xyXG5cclxuICBlbGVtZW50c1twb3NdID0gZWxlbWVudDtcclxuICBpZiAoZXhwcmVzc2lvbnNQbHVnaW4pIHtcclxuICAgIGlmICh0aGlzLmxheWVyc1twb3NdLnR5ID09PSAwKSB7XHJcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLnJlZ2lzdGVyQ29tcG9zaXRpb24oZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LmluaXRFeHByZXNzaW9ucygpO1xyXG4gIH1cclxuICB0aGlzLmFwcGVuZEVsZW1lbnRJblBvcyhlbGVtZW50LCBwb3MpO1xyXG4gIGlmICh0aGlzLmxheWVyc1twb3NdLnR0KSB7XHJcbiAgICBpZiAoIXRoaXMuZWxlbWVudHNbcG9zIC0gMV0gfHwgdGhpcy5lbGVtZW50c1twb3MgLSAxXSA9PT0gdHJ1ZSkge1xyXG4gICAgICB0aGlzLmJ1aWxkSXRlbShwb3MgLSAxKTtcclxuICAgICAgdGhpcy5hZGRQZW5kaW5nRWxlbWVudChlbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsZW1lbnQuc2V0TWF0dGUoZWxlbWVudHNbcG9zIC0gMV0ubGF5ZXJJZCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNoZWNrUGVuZGluZ0VsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gIHdoaWxlICh0aGlzLnBlbmRpbmdFbGVtZW50cy5sZW5ndGgpIHtcclxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5wZW5kaW5nRWxlbWVudHMucG9wKCk7XHJcbiAgICBlbGVtZW50LmNoZWNrUGFyZW50aW5nKCk7XHJcbiAgICBpZiAoZWxlbWVudC5kYXRhLnR0KSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldID09PSBlbGVtZW50KSB7XHJcbiAgICAgICAgICBlbGVtZW50LnNldE1hdHRlKHRoaXMuZWxlbWVudHNbaSAtIDFdLmxheWVySWQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcclxuICBpZiAodGhpcy5yZW5kZXJlZEZyYW1lID09PSBudW0gfHwgdGhpcy5kZXN0cm95ZWQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKG51bSA9PT0gbnVsbCkge1xyXG4gICAgbnVtID0gdGhpcy5yZW5kZXJlZEZyYW1lO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW07XHJcbiAgfVxyXG4gIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tJyk7XHJcbiAgLy8gY29uc29sZS5sb2coJ0ZSQU1FICcsbnVtKTtcclxuICB0aGlzLmdsb2JhbERhdGEuZnJhbWVOdW0gPSBudW07XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgKz0gMTtcclxuICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5jdXJyZW50RnJhbWUgPSBudW07XHJcbiAgdGhpcy5nbG9iYWxEYXRhLl9tZGYgPSBmYWxzZTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gIGlmICghdGhpcy5jb21wbGV0ZUxheWVycykge1xyXG4gICAgdGhpcy5jaGVja0xheWVycyhudW0pO1xyXG4gIH1cclxuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZShudW0gLSB0aGlzLmxheWVyc1tpXS5zdCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh0aGlzLmdsb2JhbERhdGEuX21kZikge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuYXBwZW5kRWxlbWVudEluUG9zID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBvcykge1xyXG4gIHZhciBuZXdFbGVtZW50ID0gZWxlbWVudC5nZXRCYXNlRWxlbWVudCgpO1xyXG4gIGlmICghbmV3RWxlbWVudCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIG5leHRFbGVtZW50O1xyXG4gIHdoaWxlIChpIDwgcG9zKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50c1tpXSAmJiB0aGlzLmVsZW1lbnRzW2ldICE9PSB0cnVlICYmIHRoaXMuZWxlbWVudHNbaV0uZ2V0QmFzZUVsZW1lbnQoKSkge1xyXG4gICAgICBuZXh0RWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaV0uZ2V0QmFzZUVsZW1lbnQoKTtcclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbiAgaWYgKG5leHRFbGVtZW50KSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5pbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcclxuICB9XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5sYXllckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgQ1ZDb250ZXh0RGF0YSwgTWF0cml4LCBleHRlbmRQcm90b3R5cGUsIEJhc2VSZW5kZXJlciwgQ1ZTaGFwZUVsZW1lbnQsIENWVGV4dEVsZW1lbnQsXHJcbkNWSW1hZ2VFbGVtZW50LCBDVkNvbXBFbGVtZW50LCBDVlNvbGlkRWxlbWVudCwgU1ZHUmVuZGVyZXIsIGNyZWF0ZVRhZywgY3JlYXRlU2l6ZWRBcnJheSAqL1xyXG5cclxuZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoYW5pbWF0aW9uSXRlbSwgY29uZmlnKSB7XHJcbiAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcclxuICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcclxuICAgIGNsZWFyQ2FudmFzOiAoY29uZmlnICYmIGNvbmZpZy5jbGVhckNhbnZhcyAhPT0gdW5kZWZpbmVkKSA/IGNvbmZpZy5jbGVhckNhbnZhcyA6IHRydWUsXHJcbiAgICBjb250ZXh0OiAoY29uZmlnICYmIGNvbmZpZy5jb250ZXh0KSB8fCBudWxsLFxyXG4gICAgcHJvZ3Jlc3NpdmVMb2FkOiAoY29uZmlnICYmIGNvbmZpZy5wcm9ncmVzc2l2ZUxvYWQpIHx8IGZhbHNlLFxyXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogKGNvbmZpZyAmJiBjb25maWcucHJlc2VydmVBc3BlY3RSYXRpbykgfHwgJ3hNaWRZTWlkIG1lZXQnLFxyXG4gICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiAoY29uZmlnICYmIGNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8pIHx8ICd4TWlkWU1pZCBzbGljZScsXHJcbiAgICBjbGFzc05hbWU6IChjb25maWcgJiYgY29uZmlnLmNsYXNzTmFtZSkgfHwgJycsXHJcbiAgICBpZDogKGNvbmZpZyAmJiBjb25maWcuaWQpIHx8ICcnLFxyXG4gIH07XHJcbiAgdGhpcy5yZW5kZXJDb25maWcuZHByID0gKGNvbmZpZyAmJiBjb25maWcuZHByKSB8fCAxO1xyXG4gIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcikge1xyXG4gICAgdGhpcy5yZW5kZXJDb25maWcuZHByID0gKGNvbmZpZyAmJiBjb25maWcuZHByKSB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gIH1cclxuICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcclxuICB0aGlzLmdsb2JhbERhdGEgPSB7XHJcbiAgICBmcmFtZU51bTogLTEsXHJcbiAgICBfbWRmOiBmYWxzZSxcclxuICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWcsXHJcbiAgICBjdXJyZW50R2xvYmFsQWxwaGE6IC0xLFxyXG4gIH07XHJcbiAgdGhpcy5jb250ZXh0RGF0YSA9IG5ldyBDVkNvbnRleHREYXRhKCk7XHJcbiAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XHJcbiAgdGhpcy50cmFuc2Zvcm1NYXQgPSBuZXcgTWF0cml4KCk7XHJcbiAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xyXG4gIHRoaXMucmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBDYW52YXNSZW5kZXJlcik7XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHJldHVybiBuZXcgQ1ZTaGFwZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IENWVGV4dEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBDVkltYWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHJldHVybiBuZXcgQ1ZDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVNvbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICByZXR1cm4gbmV3IENWU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTnVsbCA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVOdWxsO1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmN0eFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gIGlmIChwcm9wc1swXSA9PT0gMSAmJiBwcm9wc1sxXSA9PT0gMCAmJiBwcm9wc1s0XSA9PT0gMCAmJiBwcm9wc1s1XSA9PT0gMSAmJiBwcm9wc1sxMl0gPT09IDAgJiYgcHJvcHNbMTNdID09PSAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICghdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC50cmFuc2Zvcm0ocHJvcHNbMF0sIHByb3BzWzFdLCBwcm9wc1s0XSwgcHJvcHNbNV0sIHByb3BzWzEyXSwgcHJvcHNbMTNdKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdGhpcy50cmFuc2Zvcm1NYXQuY2xvbmVGcm9tUHJvcHMocHJvcHMpO1xyXG4gIHZhciBjUHJvcHMgPSB0aGlzLmNvbnRleHREYXRhLmNUci5wcm9wcztcclxuICB0aGlzLnRyYW5zZm9ybU1hdC50cmFuc2Zvcm0oY1Byb3BzWzBdLCBjUHJvcHNbMV0sIGNQcm9wc1syXSwgY1Byb3BzWzNdLCBjUHJvcHNbNF0sIGNQcm9wc1s1XSwgY1Byb3BzWzZdLCBjUHJvcHNbN10sIGNQcm9wc1s4XSwgY1Byb3BzWzldLCBjUHJvcHNbMTBdLCBjUHJvcHNbMTFdLCBjUHJvcHNbMTJdLCBjUHJvcHNbMTNdLCBjUHJvcHNbMTRdLCBjUHJvcHNbMTVdKTtcclxuICAvLyB0aGlzLmNvbnRleHREYXRhLmNUci50cmFuc2Zvcm0ocHJvcHNbMF0scHJvcHNbMV0scHJvcHNbMl0scHJvcHNbM10scHJvcHNbNF0scHJvcHNbNV0scHJvcHNbNl0scHJvcHNbN10scHJvcHNbOF0scHJvcHNbOV0scHJvcHNbMTBdLHByb3BzWzExXSxwcm9wc1sxMl0scHJvcHNbMTNdLHByb3BzWzE0XSxwcm9wc1sxNV0pO1xyXG4gIHRoaXMuY29udGV4dERhdGEuY1RyLmNsb25lRnJvbVByb3BzKHRoaXMudHJhbnNmb3JtTWF0LnByb3BzKTtcclxuICB2YXIgdHJQcm9wcyA9IHRoaXMuY29udGV4dERhdGEuY1RyLnByb3BzO1xyXG4gIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0odHJQcm9wc1swXSwgdHJQcm9wc1sxXSwgdHJQcm9wc1s0XSwgdHJQcm9wc1s1XSwgdHJQcm9wc1sxMl0sIHRyUHJvcHNbMTNdKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jdHhPcGFjaXR5ID0gZnVuY3Rpb24gKG9wKSB7XHJcbiAgLyogaWYob3AgPT09IDEpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH0gKi9cclxuICBpZiAoIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzKSB7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgKj0gb3AgPCAwID8gMCA6IG9wO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmN1cnJlbnRHbG9iYWxBbHBoYSA9IHRoaXMuY29udGV4dERhdGEuY087XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMuY29udGV4dERhdGEuY08gKj0gb3AgPCAwID8gMCA6IG9wO1xyXG4gIGlmICh0aGlzLmdsb2JhbERhdGEuY3VycmVudEdsb2JhbEFscGhhICE9PSB0aGlzLmNvbnRleHREYXRhLmNPKSB7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLmNvbnRleHREYXRhLmNPO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmN1cnJlbnRHbG9iYWxBbHBoYSA9IHRoaXMuY29udGV4dERhdGEuY087XHJcbiAgfVxyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICghdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMuY29udGV4dERhdGEucmVzZXQoKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGFjdGlvbkZsYWcpIHtcclxuICBpZiAoIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzKSB7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2F2ZSgpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoYWN0aW9uRmxhZykge1xyXG4gICAgdGhpcy5jYW52YXNDb250ZXh0LnNhdmUoKTtcclxuICB9XHJcbiAgdmFyIHByb3BzID0gdGhpcy5jb250ZXh0RGF0YS5jVHIucHJvcHM7XHJcbiAgaWYgKHRoaXMuY29udGV4dERhdGEuX2xlbmd0aCA8PSB0aGlzLmNvbnRleHREYXRhLmNBcnJQb3MpIHtcclxuICAgIHRoaXMuY29udGV4dERhdGEuZHVwbGljYXRlKCk7XHJcbiAgfVxyXG4gIHZhciBpO1xyXG4gIHZhciBhcnIgPSB0aGlzLmNvbnRleHREYXRhLnNhdmVkW3RoaXMuY29udGV4dERhdGEuY0FyclBvc107XHJcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcclxuICAgIGFycltpXSA9IHByb3BzW2ldO1xyXG4gIH1cclxuICB0aGlzLmNvbnRleHREYXRhLnNhdmVkT3BbdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zXSA9IHRoaXMuY29udGV4dERhdGEuY087XHJcbiAgdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zICs9IDE7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChhY3Rpb25GbGFnKSB7XHJcbiAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xyXG4gICAgdGhpcy5jYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGFjdGlvbkZsYWcpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEuYmxlbmRNb2RlID0gJ3NvdXJjZS1vdmVyJztcclxuICB9XHJcbiAgdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zIC09IDE7XHJcbiAgdmFyIHBvcHBlZCA9IHRoaXMuY29udGV4dERhdGEuc2F2ZWRbdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zXTtcclxuICB2YXIgaTtcclxuICB2YXIgYXJyID0gdGhpcy5jb250ZXh0RGF0YS5jVHIucHJvcHM7XHJcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcclxuICAgIGFycltpXSA9IHBvcHBlZFtpXTtcclxuICB9XHJcbiAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybShwb3BwZWRbMF0sIHBvcHBlZFsxXSwgcG9wcGVkWzRdLCBwb3BwZWRbNV0sIHBvcHBlZFsxMl0sIHBvcHBlZFsxM10pO1xyXG4gIHBvcHBlZCA9IHRoaXMuY29udGV4dERhdGEuc2F2ZWRPcFt0aGlzLmNvbnRleHREYXRhLmNBcnJQb3NdO1xyXG4gIHRoaXMuY29udGV4dERhdGEuY08gPSBwb3BwZWQ7XHJcbiAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5jdXJyZW50R2xvYmFsQWxwaGEgIT09IHBvcHBlZCkge1xyXG4gICAgdGhpcy5jYW52YXNDb250ZXh0Lmdsb2JhbEFscGhhID0gcG9wcGVkO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmN1cnJlbnRHbG9iYWxBbHBoYSA9IHBvcHBlZDtcclxuICB9XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XHJcbiAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcclxuICAgIHZhciBjb250YWluZXJTdHlsZSA9IHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGU7XHJcbiAgICBjb250YWluZXJTdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgIGNvbnRhaW5lclN0eWxlLmhlaWdodCA9ICcxMDAlJztcclxuICAgIHZhciBvcmlnaW4gPSAnMHB4IDBweCAwcHgnO1xyXG4gICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xyXG4gICAgY29udGFpbmVyU3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xyXG4gICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xyXG4gICAgY29udGFpbmVyU3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBvcmlnaW47XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyKTtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpIHtcclxuICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5pZCkge1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnJlbmRlckNvbmZpZy5pZCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRleHQ7XHJcbiAgfVxyXG4gIHRoaXMuZGF0YSA9IGFuaW1EYXRhO1xyXG4gIHRoaXMubGF5ZXJzID0gYW5pbURhdGEubGF5ZXJzO1xyXG4gIHRoaXMudHJhbnNmb3JtQ2FudmFzID0ge1xyXG4gICAgdzogYW5pbURhdGEudyxcclxuICAgIGg6IGFuaW1EYXRhLmgsXHJcbiAgICBzeDogMCxcclxuICAgIHN5OiAwLFxyXG4gICAgdHg6IDAsXHJcbiAgICB0eTogMCxcclxuICB9O1xyXG4gIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkb2N1bWVudC5ib2R5KTtcclxuICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dDtcclxuICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIgPSB0aGlzO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5pc0Rhc2hlZCA9IGZhbHNlO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5wcm9ncmVzc2l2ZUxvYWQgPSB0aGlzLnJlbmRlckNvbmZpZy5wcm9ncmVzc2l2ZUxvYWQ7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyA9IHRoaXMudHJhbnNmb3JtQ2FudmFzO1xyXG4gIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KGFuaW1EYXRhLmxheWVycy5sZW5ndGgpO1xyXG5cclxuICB0aGlzLnVwZGF0ZUNvbnRhaW5lclNpemUoKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVDb250YWluZXJTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucmVzZXQoKTtcclxuICB2YXIgZWxlbWVudFdpZHRoO1xyXG4gIHZhciBlbGVtZW50SGVpZ2h0O1xyXG4gIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlciAmJiB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyKSB7XHJcbiAgICBlbGVtZW50V2lkdGggPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRXaWR0aDtcclxuICAgIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRIZWlnaHQ7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBlbGVtZW50V2lkdGggKiB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGVsZW1lbnRIZWlnaHQgKiB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlbGVtZW50V2lkdGggPSB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xyXG4gICAgZWxlbWVudEhlaWdodCA9IHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0ICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xyXG4gIH1cclxuICB2YXIgZWxlbWVudFJlbDtcclxuICB2YXIgYW5pbWF0aW9uUmVsO1xyXG4gIGlmICh0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvLmluZGV4T2YoJ21lZXQnKSAhPT0gLTEgfHwgdGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpby5pbmRleE9mKCdzbGljZScpICE9PSAtMSkge1xyXG4gICAgdmFyIHBhciA9IHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8uc3BsaXQoJyAnKTtcclxuICAgIHZhciBmaWxsVHlwZSA9IHBhclsxXSB8fCAnbWVldCc7XHJcbiAgICB2YXIgcG9zID0gcGFyWzBdIHx8ICd4TWlkWU1pZCc7XHJcbiAgICB2YXIgeFBvcyA9IHBvcy5zdWJzdHIoMCwgNCk7XHJcbiAgICB2YXIgeVBvcyA9IHBvcy5zdWJzdHIoNCk7XHJcbiAgICBlbGVtZW50UmVsID0gZWxlbWVudFdpZHRoIC8gZWxlbWVudEhlaWdodDtcclxuICAgIGFuaW1hdGlvblJlbCA9IHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oO1xyXG4gICAgaWYgKChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcpIHx8IChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSkge1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcclxuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3kgPSBlbGVtZW50V2lkdGggLyAodGhpcy50cmFuc2Zvcm1DYW52YXMudyAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IGVsZW1lbnRIZWlnaHQgLyAodGhpcy50cmFuc2Zvcm1DYW52YXMuaCAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gZWxlbWVudEhlaWdodCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy5oIC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeFBvcyA9PT0gJ3hNaWQnICYmICgoYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ21lZXQnKSB8fCAoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpKSB7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gKChlbGVtZW50V2lkdGggLSB0aGlzLnRyYW5zZm9ybUNhbnZhcy53ICogKGVsZW1lbnRIZWlnaHQgLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKSkgLyAyKSAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgIH0gZWxzZSBpZiAoeFBvcyA9PT0gJ3hNYXgnICYmICgoYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ21lZXQnKSB8fCAoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpKSB7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gKGVsZW1lbnRXaWR0aCAtIHRoaXMudHJhbnNmb3JtQ2FudmFzLncgKiAoZWxlbWVudEhlaWdodCAvIHRoaXMudHJhbnNmb3JtQ2FudmFzLmgpKSAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcclxuICAgIH1cclxuICAgIGlmICh5UG9zID09PSAnWU1pZCcgJiYgKChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcpIHx8IChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSkpIHtcclxuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAoKGVsZW1lbnRIZWlnaHQgLSB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oICogKGVsZW1lbnRXaWR0aCAvIHRoaXMudHJhbnNmb3JtQ2FudmFzLncpKSAvIDIpICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xyXG4gICAgfSBlbHNlIGlmICh5UG9zID09PSAnWU1heCcgJiYgKChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcpIHx8IChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSkpIHtcclxuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAoKGVsZW1lbnRIZWlnaHQgLSB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oICogKGVsZW1lbnRXaWR0aCAvIHRoaXMudHJhbnNmb3JtQ2FudmFzLncpKSkgKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSA9IDA7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvID09PSAnbm9uZScpIHtcclxuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN4ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3kgPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAwO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAwO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gdGhpcy5yZW5kZXJDb25maWcuZHByO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAwO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAwO1xyXG4gIH1cclxuICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5wcm9wcyA9IFt0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCwgMCwgMCwgMCwgMCwgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ksIDAsIDAsIDAsIDAsIDEsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSwgMCwgMV07XHJcbiAgLyogdmFyIGksIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICBpZih0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGF0YS50eSA9PT0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVzaXplKHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0gKi9cclxuICB0aGlzLmN0eFRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybUNhbnZhcy5wcm9wcyk7XHJcbiAgdGhpcy5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gIHRoaXMuY2FudmFzQ29udGV4dC5yZWN0KDAsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLncsIHRoaXMudHJhbnNmb3JtQ2FudmFzLmgpO1xyXG4gIHRoaXMuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcclxuICB0aGlzLmNhbnZhc0NvbnRleHQuY2xpcCgpO1xyXG5cclxuICB0aGlzLnJlbmRlckZyYW1lKHRoaXMucmVuZGVyZWRGcmFtZSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgJiYgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcclxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmlubmVyVGV4dCA9ICcnO1xyXG4gIH1cclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xyXG4gIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICB9XHJcbiAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSAwO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0ID0gbnVsbDtcclxuICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyID0gbnVsbDtcclxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAobnVtLCBmb3JjZVJlbmRlcikge1xyXG4gIGlmICgodGhpcy5yZW5kZXJlZEZyYW1lID09PSBudW0gJiYgdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgPT09IHRydWUgJiYgIWZvcmNlUmVuZGVyKSB8fCB0aGlzLmRlc3Ryb3llZCB8fCBudW0gPT09IC0xKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMucmVuZGVyZWRGcmFtZSA9IG51bTtcclxuICB0aGlzLmdsb2JhbERhdGEuZnJhbWVOdW0gPSBudW0gLSB0aGlzLmFuaW1hdGlvbkl0ZW0uX2lzRmlyc3RGcmFtZTtcclxuICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCArPSAxO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzIHx8IGZvcmNlUmVuZGVyO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLmN1cnJlbnRGcmFtZSA9IG51bTtcclxuXHJcbiAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tJyk7XHJcbiAgLy8gY29uc29sZS5sb2coJ05FVzogJyxudW0pO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgaWYgKCF0aGlzLmNvbXBsZXRlTGF5ZXJzKSB7XHJcbiAgICB0aGlzLmNoZWNrTGF5ZXJzKG51bSk7XHJcbiAgfVxyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICh0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pIHtcclxuICAgICAgdGhpcy5lbGVtZW50c1tpXS5wcmVwYXJlRnJhbWUobnVtIC0gdGhpcy5sYXllcnNbaV0uc3QpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAodGhpcy5nbG9iYWxEYXRhLl9tZGYpIHtcclxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyA9PT0gdHJ1ZSkge1xyXG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLncsIHRoaXMudHJhbnNmb3JtQ2FudmFzLmgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zYXZlKCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgIT09IHRydWUpIHtcclxuICAgICAgdGhpcy5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkSXRlbSA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gIGlmIChlbGVtZW50c1twb3NdIHx8IHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDk5KSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVJdGVtKHRoaXMubGF5ZXJzW3Bvc10sIHRoaXMsIHRoaXMuZ2xvYmFsRGF0YSk7XHJcbiAgZWxlbWVudHNbcG9zXSA9IGVsZW1lbnQ7XHJcbiAgZWxlbWVudC5pbml0RXhwcmVzc2lvbnMoKTtcclxuICAvKiBpZih0aGlzLmxheWVyc1twb3NdLnR5ID09PSAwKXtcclxuICAgICAgICBlbGVtZW50LnJlc2l6ZSh0aGlzLmdsb2JhbERhdGEudHJhbnNmb3JtQ2FudmFzKTtcclxuICAgIH0gKi9cclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xyXG4gICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xyXG4gIH1cclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBCYXNlUmVuZGVyZXIsIFNWR1JlbmRlcmVyLCBTVkdTaGFwZUVsZW1lbnQsIEhTaGFwZUVsZW1lbnQsIFNWR1RleHRMb3R0aWVFbGVtZW50LFxyXG5IVGV4dEVsZW1lbnQsIEhDYW1lcmFFbGVtZW50LCBJSW1hZ2VFbGVtZW50LCBISW1hZ2VFbGVtZW50LCBTVkdDb21wRWxlbWVudCwgSENvbXBFbGVtZW50LCBJU29saWRFbGVtZW50LFxyXG5IU29saWRFbGVtZW50LCBzdHlsZURpdiwgY3JlYXRlVGFnLCBjcmVhdGVOUyAqL1xyXG5cclxuZnVuY3Rpb24gSHlicmlkUmVuZGVyZXIoYW5pbWF0aW9uSXRlbSwgY29uZmlnKSB7XHJcbiAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcclxuICB0aGlzLmxheWVycyA9IG51bGw7XHJcbiAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XHJcbiAgdGhpcy5yZW5kZXJDb25maWcgPSB7XHJcbiAgICBjbGFzc05hbWU6IChjb25maWcgJiYgY29uZmlnLmNsYXNzTmFtZSkgfHwgJycsXHJcbiAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IChjb25maWcgJiYgY29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbykgfHwgJ3hNaWRZTWlkIHNsaWNlJyxcclxuICAgIGhpZGVPblRyYW5zcGFyZW50OiAhKGNvbmZpZyAmJiBjb25maWcuaGlkZU9uVHJhbnNwYXJlbnQgPT09IGZhbHNlKSxcclxuICAgIGZpbHRlclNpemU6IHtcclxuICAgICAgd2lkdGg6IChjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUud2lkdGgpIHx8ICc0MDAlJyxcclxuICAgICAgaGVpZ2h0OiAoY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLmhlaWdodCkgfHwgJzQwMCUnLFxyXG4gICAgICB4OiAoY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLngpIHx8ICctMTAwJScsXHJcbiAgICAgIHk6IChjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueSkgfHwgJy0xMDAlJyxcclxuICAgIH0sXHJcbiAgfTtcclxuICB0aGlzLmdsb2JhbERhdGEgPSB7XHJcbiAgICBfbWRmOiBmYWxzZSxcclxuICAgIGZyYW1lTnVtOiAtMSxcclxuICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWcsXHJcbiAgfTtcclxuICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICB0aGlzLnRocmVlREVsZW1lbnRzID0gW107XHJcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcclxuICB0aGlzLmNhbWVyYSA9IG51bGw7XHJcbiAgdGhpcy5zdXBwb3J0czNkID0gdHJ1ZTtcclxuICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdodG1sJztcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBIeWJyaWRSZW5kZXJlcik7XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRJdGVtID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkSXRlbTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xyXG4gICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xyXG4gIH1cclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5hcHBlbmRFbGVtZW50SW5Qb3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgcG9zKSB7XHJcbiAgdmFyIG5ld0RPTUVsZW1lbnQgPSBlbGVtZW50LmdldEJhc2VFbGVtZW50KCk7XHJcbiAgaWYgKCFuZXdET01FbGVtZW50KSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBsYXllciA9IHRoaXMubGF5ZXJzW3Bvc107XHJcbiAgaWYgKCFsYXllci5kZGQgfHwgIXRoaXMuc3VwcG9ydHMzZCkge1xyXG4gICAgaWYgKHRoaXMudGhyZWVERWxlbWVudHMpIHtcclxuICAgICAgdGhpcy5hZGRUbzNkQ29udGFpbmVyKG5ld0RPTUVsZW1lbnQsIHBvcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBuZXh0RE9NRWxlbWVudDtcclxuICAgICAgdmFyIG5leHRMYXllcjtcclxuICAgICAgdmFyIHRtcERPTUVsZW1lbnQ7XHJcbiAgICAgIHdoaWxlIChpIDwgcG9zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXSAhPT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KSB7XHJcbiAgICAgICAgICBuZXh0TGF5ZXIgPSB0aGlzLmVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgdG1wRE9NRWxlbWVudCA9IHRoaXMubGF5ZXJzW2ldLmRkZCA/IHRoaXMuZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MoaSkgOiBuZXh0TGF5ZXIuZ2V0QmFzZUVsZW1lbnQoKTtcclxuICAgICAgICAgIG5leHRET01FbGVtZW50ID0gdG1wRE9NRWxlbWVudCB8fCBuZXh0RE9NRWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuZXh0RE9NRWxlbWVudCkge1xyXG4gICAgICAgIGlmICghbGF5ZXIuZGRkIHx8ICF0aGlzLnN1cHBvcnRzM2QpIHtcclxuICAgICAgICAgIHRoaXMubGF5ZXJFbGVtZW50Lmluc2VydEJlZm9yZShuZXdET01FbGVtZW50LCBuZXh0RE9NRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKCFsYXllci5kZGQgfHwgIXRoaXMuc3VwcG9ydHMzZCkge1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKG5ld0RPTUVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuYWRkVG8zZENvbnRhaW5lcihuZXdET01FbGVtZW50LCBwb3MpO1xyXG4gIH1cclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcclxuICAgIHJldHVybiBuZXcgU1ZHU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgSFNoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XHJcbiAgICByZXR1cm4gbmV3IFNWR1RleHRMb3R0aWVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgSFRleHRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ2FtZXJhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICB0aGlzLmNhbWVyYSA9IG5ldyBIQ2FtZXJhRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG4gIHJldHVybiB0aGlzLmNhbWVyYTtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcclxuICAgIHJldHVybiBuZXcgSUltYWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEhJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xyXG4gICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEhDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVNvbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xyXG4gICAgcmV0dXJuIG5ldyBJU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgSFNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGwgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTnVsbDtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaHJlZURDb250YWluZXJCeVBvcyA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xyXG4gIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICBpZiAodGhpcy50aHJlZURFbGVtZW50c1tpXS5zdGFydFBvcyA8PSBwb3MgJiYgdGhpcy50aHJlZURFbGVtZW50c1tpXS5lbmRQb3MgPj0gcG9zKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRocmVlREVsZW1lbnRzW2ldLnBlcnNwZWN0aXZlRWxlbTtcclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGhyZWVEQ29udGFpbmVyID0gZnVuY3Rpb24gKHBvcywgdHlwZSkge1xyXG4gIHZhciBwZXJzcGVjdGl2ZUVsZW0gPSBjcmVhdGVUYWcoJ2RpdicpO1xyXG4gIHZhciBzdHlsZTtcclxuICB2YXIgY29udGFpbmVyU3R5bGU7XHJcbiAgc3R5bGVEaXYocGVyc3BlY3RpdmVFbGVtKTtcclxuICB2YXIgY29udGFpbmVyID0gY3JlYXRlVGFnKCdkaXYnKTtcclxuICBzdHlsZURpdihjb250YWluZXIpO1xyXG4gIGlmICh0eXBlID09PSAnM2QnKSB7XHJcbiAgICBzdHlsZSA9IHBlcnNwZWN0aXZlRWxlbS5zdHlsZTtcclxuICAgIHN0eWxlLndpZHRoID0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncgKyAncHgnO1xyXG4gICAgc3R5bGUuaGVpZ2h0ID0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggKyAncHgnO1xyXG4gICAgdmFyIGNlbnRlciA9ICc1MCUgNTAlJztcclxuICAgIHN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IGNlbnRlcjtcclxuICAgIHN0eWxlLm1velRyYW5zZm9ybU9yaWdpbiA9IGNlbnRlcjtcclxuICAgIHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGNlbnRlcjtcclxuICAgIGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG4gICAgdmFyIG1hdHJpeCA9ICdtYXRyaXgzZCgxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKSc7XHJcbiAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSBtYXRyaXg7XHJcbiAgICBjb250YWluZXJTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBtYXRyaXg7XHJcbiAgfVxyXG5cclxuICBwZXJzcGVjdGl2ZUVsZW0uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAvLyB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHBlcnNwZWN0aXZlRWxlbSk7XHJcbiAgdmFyIHRocmVlRENvbnRhaW5lckRhdGEgPSB7XHJcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcclxuICAgIHBlcnNwZWN0aXZlRWxlbTogcGVyc3BlY3RpdmVFbGVtLFxyXG4gICAgc3RhcnRQb3M6IHBvcyxcclxuICAgIGVuZFBvczogcG9zLFxyXG4gICAgdHlwZTogdHlwZSxcclxuICB9O1xyXG4gIHRoaXMudGhyZWVERWxlbWVudHMucHVzaCh0aHJlZURDb250YWluZXJEYXRhKTtcclxuICByZXR1cm4gdGhyZWVEQ29udGFpbmVyRGF0YTtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5idWlsZDNkQ29udGFpbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gIHZhciBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YTtcclxuICB2YXIgY3VycmVudENvbnRhaW5lciA9ICcnO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKHRoaXMubGF5ZXJzW2ldLmRkZCAmJiB0aGlzLmxheWVyc1tpXS50eSAhPT0gMykge1xyXG4gICAgICBpZiAoY3VycmVudENvbnRhaW5lciAhPT0gJzNkJykge1xyXG4gICAgICAgIGN1cnJlbnRDb250YWluZXIgPSAnM2QnO1xyXG4gICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhID0gdGhpcy5jcmVhdGVUaHJlZURDb250YWluZXIoaSwgJzNkJyk7XHJcbiAgICAgIH1cclxuICAgICAgbGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zID0gTWF0aC5tYXgobGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zLCBpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChjdXJyZW50Q29udGFpbmVyICE9PSAnMmQnKSB7XHJcbiAgICAgICAgY3VycmVudENvbnRhaW5lciA9ICcyZCc7XHJcbiAgICAgICAgbGFzdFRocmVlRENvbnRhaW5lckRhdGEgPSB0aGlzLmNyZWF0ZVRocmVlRENvbnRhaW5lcihpLCAnMmQnKTtcclxuICAgICAgfVxyXG4gICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MgPSBNYXRoLm1heChsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MsIGkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcclxuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgdGhpcy5yZXNpemVyRWxlbS5hcHBlbmRDaGlsZCh0aGlzLnRocmVlREVsZW1lbnRzW2ldLnBlcnNwZWN0aXZlRWxlbSk7XHJcbiAgfVxyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmFkZFRvM2RDb250YWluZXIgPSBmdW5jdGlvbiAoZWxlbSwgcG9zKSB7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgaWYgKHBvcyA8PSB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmVuZFBvcykge1xyXG4gICAgICB2YXIgaiA9IHRoaXMudGhyZWVERWxlbWVudHNbaV0uc3RhcnRQb3M7XHJcbiAgICAgIHZhciBuZXh0RWxlbWVudDtcclxuICAgICAgd2hpbGUgKGogPCBwb3MpIHtcclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50c1tqXSAmJiB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KSB7XHJcbiAgICAgICAgICBuZXh0RWxlbWVudCA9IHRoaXMuZWxlbWVudHNbal0uZ2V0QmFzZUVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaiArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuZXh0RWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMudGhyZWVERWxlbWVudHNbaV0uY29udGFpbmVyLmluc2VydEJlZm9yZShlbGVtLCBuZXh0RWxlbWVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy50aHJlZURFbGVtZW50c1tpXS5jb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltRGF0YSkge1xyXG4gIHZhciByZXNpemVyRWxlbSA9IGNyZWF0ZVRhZygnZGl2Jyk7XHJcbiAgdmFyIHdyYXBwZXIgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcjtcclxuICB2YXIgc3R5bGUgPSByZXNpemVyRWxlbS5zdHlsZTtcclxuICBzdHlsZS53aWR0aCA9IGFuaW1EYXRhLncgKyAncHgnO1xyXG4gIHN0eWxlLmhlaWdodCA9IGFuaW1EYXRhLmggKyAncHgnO1xyXG4gIHRoaXMucmVzaXplckVsZW0gPSByZXNpemVyRWxlbTtcclxuICBzdHlsZURpdihyZXNpemVyRWxlbSk7XHJcbiAgc3R5bGUudHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XHJcbiAgc3R5bGUubW96VHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XHJcbiAgc3R5bGUud2Via2l0VHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XHJcbiAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSkge1xyXG4gICAgcmVzaXplckVsZW0uc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSk7XHJcbiAgfVxyXG4gIHdyYXBwZXIuYXBwZW5kQ2hpbGQocmVzaXplckVsZW0pO1xyXG5cclxuICBzdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gIHZhciBzdmcgPSBjcmVhdGVOUygnc3ZnJyk7XHJcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMScpO1xyXG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxJyk7XHJcbiAgc3R5bGVEaXYoc3ZnKTtcclxuICB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHN2Zyk7XHJcbiAgdmFyIGRlZnMgPSBjcmVhdGVOUygnZGVmcycpO1xyXG4gIHN2Zy5hcHBlbmRDaGlsZChkZWZzKTtcclxuICB0aGlzLmRhdGEgPSBhbmltRGF0YTtcclxuICAvLyBNYXNrIGFuaW1hdGlvblxyXG4gIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBzdmcpO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gZGVmcztcclxuICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcclxuICB0aGlzLmxheWVyRWxlbWVudCA9IHRoaXMucmVzaXplckVsZW07XHJcbiAgdGhpcy5idWlsZDNkQ29udGFpbmVycygpO1xyXG4gIHRoaXMudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcclxuICB9XHJcbiAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lciA9IG51bGw7XHJcbiAgdGhpcy5nbG9iYWxEYXRhLmRlZnMgPSBudWxsO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLmxheWVycyA/IHRoaXMubGF5ZXJzLmxlbmd0aCA6IDA7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcclxuICB9XHJcbiAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSAwO1xyXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcclxuICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBudWxsO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lclNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGVsZW1lbnRXaWR0aCA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLm9mZnNldFdpZHRoO1xyXG4gIHZhciBlbGVtZW50SGVpZ2h0ID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1xyXG4gIHZhciBlbGVtZW50UmVsID0gZWxlbWVudFdpZHRoIC8gZWxlbWVudEhlaWdodDtcclxuICB2YXIgYW5pbWF0aW9uUmVsID0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncgLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcclxuICB2YXIgc3g7XHJcbiAgdmFyIHN5O1xyXG4gIHZhciB0eDtcclxuICB2YXIgdHk7XHJcbiAgaWYgKGFuaW1hdGlvblJlbCA+IGVsZW1lbnRSZWwpIHtcclxuICAgIHN4ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53KTtcclxuICAgIHN5ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53KTtcclxuICAgIHR4ID0gMDtcclxuICAgIHR5ID0gKChlbGVtZW50SGVpZ2h0IC0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggKiAoZWxlbWVudFdpZHRoIC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncpKSAvIDIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzeCA9IGVsZW1lbnRIZWlnaHQgLyAodGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmgpO1xyXG4gICAgc3kgPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oKTtcclxuICAgIHR4ID0gKGVsZW1lbnRXaWR0aCAtIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53ICogKGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCkpIC8gMjtcclxuICAgIHR5ID0gMDtcclxuICB9XHJcbiAgdmFyIHN0eWxlID0gdGhpcy5yZXNpemVyRWxlbS5zdHlsZTtcclxuICBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnbWF0cml4M2QoJyArIHN4ICsgJywwLDAsMCwwLCcgKyBzeSArICcsMCwwLDAsMCwxLDAsJyArIHR4ICsgJywnICsgdHkgKyAnLDAsMSknO1xyXG4gIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybTtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucmVzaXplckVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucmVzaXplckVsZW0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuaW5pdEl0ZW1zID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuYnVpbGRBbGxJdGVtcygpO1xyXG4gIGlmICh0aGlzLmNhbWVyYSkge1xyXG4gICAgdGhpcy5jYW1lcmEuc2V0dXAoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGNXaWR0aCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xyXG4gICAgdmFyIGNIZWlnaHQgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMudGhyZWVERWxlbWVudHNbaV0ucGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xyXG4gICAgICBzdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9IE1hdGguc3FydChNYXRoLnBvdyhjV2lkdGgsIDIpICsgTWF0aC5wb3coY0hlaWdodCwgMikpICsgJ3B4JztcclxuICAgICAgc3R5bGUucGVyc3BlY3RpdmUgPSBzdHlsZS53ZWJraXRQZXJzcGVjdGl2ZTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuc2VhcmNoRXh0cmFDb21wb3NpdGlvbnMgPSBmdW5jdGlvbiAoYXNzZXRzKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IGFzc2V0cy5sZW5ndGg7XHJcbiAgdmFyIGZsb2F0aW5nQ29udGFpbmVyID0gY3JlYXRlVGFnKCdkaXYnKTtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmIChhc3NldHNbaV0ueHQpIHtcclxuICAgICAgdmFyIGNvbXAgPSB0aGlzLmNyZWF0ZUNvbXAoYXNzZXRzW2ldLCBmbG9hdGluZ0NvbnRhaW5lciwgdGhpcy5nbG9iYWxEYXRhLmNvbXAsIG51bGwpO1xyXG4gICAgICBjb21wLmluaXRFeHByZXNzaW9ucygpO1xyXG4gICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5LCBjcmVhdGVFbGVtZW50SUQsIFByb3BlcnR5RmFjdG9yeSwgU2hhcGVQcm9wZXJ0eUZhY3RvcnksIGNyZWF0ZU5TLCBsb2NhdGlvbkhyZWYgKi9cclxuXHJcbmZ1bmN0aW9uIE1hc2tFbGVtZW50KGRhdGEsIGVsZW1lbnQsIGdsb2JhbERhdGEpIHtcclxuICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgdGhpcy5nbG9iYWxEYXRhID0gZ2xvYmFsRGF0YTtcclxuICB0aGlzLnN0b3JlZERhdGEgPSBbXTtcclxuICB0aGlzLm1hc2tzUHJvcGVydGllcyA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMgfHwgW107XHJcbiAgdGhpcy5tYXNrRWxlbWVudCA9IG51bGw7XHJcbiAgdmFyIGRlZnMgPSB0aGlzLmdsb2JhbERhdGEuZGVmcztcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMgPyB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGggOiAwO1xyXG4gIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XHJcbiAgdGhpcy5zb2xpZFBhdGggPSAnJztcclxuXHJcbiAgdmFyIHBhdGg7XHJcbiAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLm1hc2tzUHJvcGVydGllcztcclxuICB2YXIgY291bnQgPSAwO1xyXG4gIHZhciBjdXJyZW50TWFza3MgPSBbXTtcclxuICB2YXIgajtcclxuICB2YXIgakxlbjtcclxuICB2YXIgbGF5ZXJJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xyXG4gIHZhciByZWN0O1xyXG4gIHZhciBleHBhbnNvcjtcclxuICB2YXIgZmVNb3JwaDtcclxuICB2YXIgeDtcclxuICB2YXIgbWFza1R5cGUgPSAnY2xpcFBhdGgnO1xyXG4gIHZhciBtYXNrUmVmID0gJ2NsaXAtcGF0aCc7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAoKHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ2EnICYmIHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKSB8fCBwcm9wZXJ0aWVzW2ldLmludiB8fCBwcm9wZXJ0aWVzW2ldLm8uayAhPT0gMTAwIHx8IHByb3BlcnRpZXNbaV0uby54KSB7XHJcbiAgICAgIG1hc2tUeXBlID0gJ21hc2snO1xyXG4gICAgICBtYXNrUmVmID0gJ21hc2snO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgocHJvcGVydGllc1tpXS5tb2RlID09PSAncycgfHwgcHJvcGVydGllc1tpXS5tb2RlID09PSAnaScpICYmIGNvdW50ID09PSAwKSB7XHJcbiAgICAgIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xyXG4gICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsICcjZmZmZmZmJyk7XHJcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEudyB8fCAwKTtcclxuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEuaCB8fCAwKTtcclxuICAgICAgY3VycmVudE1hc2tzLnB1c2gocmVjdCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZWN0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwYXRoID0gY3JlYXRlTlMoJ3BhdGgnKTtcclxuICAgIGlmIChwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICduJykge1xyXG4gICAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxyXG4gICAgICB0aGlzLnZpZXdEYXRhW2ldID0ge1xyXG4gICAgICAgIG9wOiBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0ubywgMCwgMC4wMSwgdGhpcy5lbGVtZW50KSxcclxuICAgICAgICBwcm9wOiBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLCAzKSxcclxuICAgICAgICBlbGVtOiBwYXRoLFxyXG4gICAgICAgIGxhc3RQYXRoOiAnJyxcclxuICAgICAgfTtcclxuICAgICAgZGVmcy5hcHBlbmRDaGlsZChwYXRoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvdW50ICs9IDE7XHJcblxyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ3MnID8gJyMwMDAwMDAnIDogJyNmZmZmZmYnKTtcclxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcnVsZScsICdub256ZXJvJyk7XHJcbiAgICAgIHZhciBmaWx0ZXJJRDtcclxuXHJcbiAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLnguayAhPT0gMCkge1xyXG4gICAgICAgIG1hc2tUeXBlID0gJ21hc2snO1xyXG4gICAgICAgIG1hc2tSZWYgPSAnbWFzayc7XHJcbiAgICAgICAgeCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXS54LCAwLCBudWxsLCB0aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgIGZpbHRlcklEID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgICAgICAgZXhwYW5zb3IgPSBjcmVhdGVOUygnZmlsdGVyJyk7XHJcbiAgICAgICAgZXhwYW5zb3Iuc2V0QXR0cmlidXRlKCdpZCcsIGZpbHRlcklEKTtcclxuICAgICAgICBmZU1vcnBoID0gY3JlYXRlTlMoJ2ZlTW9ycGhvbG9neScpO1xyXG4gICAgICAgIGZlTW9ycGguc2V0QXR0cmlidXRlKCdvcGVyYXRvcicsICdlcm9kZScpO1xyXG4gICAgICAgIGZlTW9ycGguc2V0QXR0cmlidXRlKCdpbicsICdTb3VyY2VHcmFwaGljJyk7XHJcbiAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ3JhZGl1cycsICcwJyk7XHJcbiAgICAgICAgZXhwYW5zb3IuYXBwZW5kQ2hpbGQoZmVNb3JwaCk7XHJcbiAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChleHBhbnNvcik7XHJcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ3MnID8gJyMwMDAwMDAnIDogJyNmZmZmZmYnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmZU1vcnBoID0gbnVsbDtcclxuICAgICAgICB4ID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVE9ETyBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG9yIHRvIGEgY29uc3RydWN0b3JcclxuICAgICAgdGhpcy5zdG9yZWREYXRhW2ldID0ge1xyXG4gICAgICAgIGVsZW06IHBhdGgsXHJcbiAgICAgICAgeDogeCxcclxuICAgICAgICBleHBhbjogZmVNb3JwaCxcclxuICAgICAgICBsYXN0UGF0aDogJycsXHJcbiAgICAgICAgbGFzdE9wZXJhdG9yOiAnJyxcclxuICAgICAgICBmaWx0ZXJJZDogZmlsdGVySUQsXHJcbiAgICAgICAgbGFzdFJhZGl1czogMCxcclxuICAgICAgfTtcclxuICAgICAgaWYgKHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ2knKSB7XHJcbiAgICAgICAgakxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgIGcuYXBwZW5kQ2hpbGQoY3VycmVudE1hc2tzW2pdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgICAgIG1hc2suc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcclxuICAgICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBsYXllcklkICsgJ18nICsgY291bnQpO1xyXG4gICAgICAgIG1hc2suYXBwZW5kQ2hpbGQocGF0aCk7XHJcbiAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChtYXNrKTtcclxuICAgICAgICBnLnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJyArIGxheWVySWQgKyAnXycgKyBjb3VudCArICcpJyk7XHJcblxyXG4gICAgICAgIGN1cnJlbnRNYXNrcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGN1cnJlbnRNYXNrcy5wdXNoKGcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnRNYXNrcy5wdXNoKHBhdGgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLmludiAmJiAhdGhpcy5zb2xpZFBhdGgpIHtcclxuICAgICAgICB0aGlzLnNvbGlkUGF0aCA9IHRoaXMuY3JlYXRlTGF5ZXJTb2xpZFBhdGgoKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxyXG4gICAgICB0aGlzLnZpZXdEYXRhW2ldID0ge1xyXG4gICAgICAgIGVsZW06IHBhdGgsXHJcbiAgICAgICAgbGFzdFBhdGg6ICcnLFxyXG4gICAgICAgIG9wOiBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0ubywgMCwgMC4wMSwgdGhpcy5lbGVtZW50KSxcclxuICAgICAgICBwcm9wOiBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLCAzKSxcclxuICAgICAgICBpbnZSZWN0OiByZWN0LFxyXG4gICAgICB9O1xyXG4gICAgICBpZiAoIXRoaXMudmlld0RhdGFbaV0ucHJvcC5rKSB7XHJcbiAgICAgICAgdGhpcy5kcmF3UGF0aChwcm9wZXJ0aWVzW2ldLCB0aGlzLnZpZXdEYXRhW2ldLnByb3AudiwgdGhpcy52aWV3RGF0YVtpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRoaXMubWFza0VsZW1lbnQgPSBjcmVhdGVOUyhtYXNrVHlwZSk7XHJcblxyXG4gIGxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLm1hc2tFbGVtZW50LmFwcGVuZENoaWxkKGN1cnJlbnRNYXNrc1tpXSk7XHJcbiAgfVxyXG5cclxuICBpZiAoY291bnQgPiAwKSB7XHJcbiAgICB0aGlzLm1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBsYXllcklkKTtcclxuICAgIHRoaXMuZWxlbWVudC5tYXNrZWRFbGVtZW50LnNldEF0dHJpYnV0ZShtYXNrUmVmLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBsYXllcklkICsgJyknKTtcclxuICAgIGRlZnMuYXBwZW5kQ2hpbGQodGhpcy5tYXNrRWxlbWVudCk7XHJcbiAgfVxyXG4gIGlmICh0aGlzLnZpZXdEYXRhLmxlbmd0aCkge1xyXG4gICAgdGhpcy5lbGVtZW50LmFkZFJlbmRlcmFibGVDb21wb25lbnQodGhpcyk7XHJcbiAgfVxyXG59XHJcblxyXG5NYXNrRWxlbWVudC5wcm90b3R5cGUuZ2V0TWFza1Byb3BlcnR5ID0gZnVuY3Rpb24gKHBvcykge1xyXG4gIHJldHVybiB0aGlzLnZpZXdEYXRhW3Bvc10ucHJvcDtcclxufTtcclxuXHJcbk1hc2tFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChpc0ZpcnN0RnJhbWUpIHtcclxuICB2YXIgZmluYWxNYXQgPSB0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubWF0O1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAodGhpcy52aWV3RGF0YVtpXS5wcm9wLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgIHRoaXMuZHJhd1BhdGgodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0sIHRoaXMudmlld0RhdGFbaV0ucHJvcC52LCB0aGlzLnZpZXdEYXRhW2ldKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnZpZXdEYXRhW2ldLm9wLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgIHRoaXMudmlld0RhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIHRoaXMudmlld0RhdGFbaV0ub3Audik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKSB7XHJcbiAgICAgIGlmICh0aGlzLnZpZXdEYXRhW2ldLmludlJlY3QgJiYgKHRoaXMuZWxlbWVudC5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcclxuICAgICAgICB0aGlzLnZpZXdEYXRhW2ldLmludlJlY3Quc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBmaW5hbE1hdC5nZXRJbnZlcnNlTWF0cml4KCkudG8yZENTUygpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5zdG9yZWREYXRhW2ldLnggJiYgKHRoaXMuc3RvcmVkRGF0YVtpXS54Ll9tZGYgfHwgaXNGaXJzdEZyYW1lKSkge1xyXG4gICAgICAgIHZhciBmZU1vcnBoID0gdGhpcy5zdG9yZWREYXRhW2ldLmV4cGFuO1xyXG4gICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ueC52IDwgMCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgIT09ICdlcm9kZScpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmxhc3RPcGVyYXRvciA9ICdlcm9kZSc7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5lbGVtLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgJ3VybCgnICsgbG9jYXRpb25IcmVmICsgJyMnICsgdGhpcy5zdG9yZWREYXRhW2ldLmZpbHRlcklkICsgJyknKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZlTW9ycGguc2V0QXR0cmlidXRlKCdyYWRpdXMnLCAtdGhpcy5zdG9yZWREYXRhW2ldLngudik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yICE9PSAnZGlsYXRlJykge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yID0gJ2RpbGF0ZSc7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5lbGVtLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgbnVsbCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMuc3RvcmVkRGF0YVtpXS54LnYgKiAyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5NYXNrRWxlbWVudC5wcm90b3R5cGUuZ2V0TWFza2VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMubWFza0VsZW1lbnQ7XHJcbn07XHJcblxyXG5NYXNrRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlTGF5ZXJTb2xpZFBhdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHBhdGggPSAnTTAsMCAnO1xyXG4gIHBhdGggKz0gJyBoJyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xyXG4gIHBhdGggKz0gJyB2JyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xyXG4gIHBhdGggKz0gJyBoLScgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcclxuICBwYXRoICs9ICcgdi0nICsgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggKyAnICc7XHJcbiAgcmV0dXJuIHBhdGg7XHJcbn07XHJcblxyXG5NYXNrRWxlbWVudC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIHBhdGhOb2Rlcywgdmlld0RhdGEpIHtcclxuICB2YXIgcGF0aFN0cmluZyA9ICcgTScgKyBwYXRoTm9kZXMudlswXVswXSArICcsJyArIHBhdGhOb2Rlcy52WzBdWzFdO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW47XHJcbiAgbGVuID0gcGF0aE5vZGVzLl9sZW5ndGg7XHJcbiAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAvLyBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbaV1bMF0rJywnK3BhdGhOb2Rlcy5pW2ldWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbaV1bMF0rJywnK3BhdGhOb2Rlcy52W2ldWzFdO1xyXG4gICAgcGF0aFN0cmluZyArPSAnIEMnICsgcGF0aE5vZGVzLm9baSAtIDFdWzBdICsgJywnICsgcGF0aE5vZGVzLm9baSAtIDFdWzFdICsgJyAnICsgcGF0aE5vZGVzLmlbaV1bMF0gKyAnLCcgKyBwYXRoTm9kZXMuaVtpXVsxXSArICcgJyArIHBhdGhOb2Rlcy52W2ldWzBdICsgJywnICsgcGF0aE5vZGVzLnZbaV1bMV07XHJcbiAgfVxyXG4gIC8vIHBhdGhTdHJpbmcgKz0gXCIgQ1wiK3BhdGhOb2Rlcy5vW2ktMV1bMF0rJywnK3BhdGhOb2Rlcy5vW2ktMV1bMV0gKyBcIiBcIitwYXRoTm9kZXMuaVswXVswXSsnLCcrcGF0aE5vZGVzLmlbMF1bMV0gKyBcIiBcIitwYXRoTm9kZXMudlswXVswXSsnLCcrcGF0aE5vZGVzLnZbMF1bMV07XHJcbiAgaWYgKHBhdGhOb2Rlcy5jICYmIGxlbiA+IDEpIHtcclxuICAgIHBhdGhTdHJpbmcgKz0gJyBDJyArIHBhdGhOb2Rlcy5vW2kgLSAxXVswXSArICcsJyArIHBhdGhOb2Rlcy5vW2kgLSAxXVsxXSArICcgJyArIHBhdGhOb2Rlcy5pWzBdWzBdICsgJywnICsgcGF0aE5vZGVzLmlbMF1bMV0gKyAnICcgKyBwYXRoTm9kZXMudlswXVswXSArICcsJyArIHBhdGhOb2Rlcy52WzBdWzFdO1xyXG4gIH1cclxuICAvLyBwYXRoTm9kZXMuX19yZW5kZXJlZFN0cmluZyA9IHBhdGhTdHJpbmc7XHJcblxyXG4gIGlmICh2aWV3RGF0YS5sYXN0UGF0aCAhPT0gcGF0aFN0cmluZykge1xyXG4gICAgdmFyIHBhdGhTaGFwZVZhbHVlID0gJyc7XHJcbiAgICBpZiAodmlld0RhdGEuZWxlbSkge1xyXG4gICAgICBpZiAocGF0aE5vZGVzLmMpIHtcclxuICAgICAgICBwYXRoU2hhcGVWYWx1ZSA9IHBhdGhEYXRhLmludiA/IHRoaXMuc29saWRQYXRoICsgcGF0aFN0cmluZyA6IHBhdGhTdHJpbmc7XHJcbiAgICAgIH1cclxuICAgICAgdmlld0RhdGEuZWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoU2hhcGVWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICB2aWV3RGF0YS5sYXN0UGF0aCA9IHBhdGhTdHJpbmc7XHJcbiAgfVxyXG59O1xyXG5cclxuTWFza0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5lbGVtZW50ID0gbnVsbDtcclxuICB0aGlzLmdsb2JhbERhdGEgPSBudWxsO1xyXG4gIHRoaXMubWFza0VsZW1lbnQgPSBudWxsO1xyXG4gIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgdGhpcy5tYXNrc1Byb3BlcnRpZXMgPSBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlXHJcbiAqIEhhbmRsZXMgQUUncyBsYXllciBwYXJlbnRpbmcgcHJvcGVydHkuXHJcbiAqXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gSGllcmFyY2h5RWxlbWVudCgpIHt9XHJcblxyXG5IaWVyYXJjaHlFbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogSW5pdGlhbGl6ZXMgaGllcmFyY2h5IHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKi9cclxuICBpbml0SGllcmFyY2h5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBlbGVtZW50J3MgcGFyZW50IGxpc3RcclxuICAgIHRoaXMuaGllcmFyY2h5ID0gW107XHJcbiAgICAvLyBpZiBlbGVtZW50IGlzIHBhcmVudCBvZiBhbm90aGVyIGxheWVyIF9pc1BhcmVudCB3aWxsIGJlIHRydWVcclxuICAgIHRoaXMuX2lzUGFyZW50ID0gZmFsc2U7XHJcbiAgICB0aGlzLmNoZWNrUGFyZW50aW5nKCk7XHJcbiAgfSxcclxuICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogU2V0cyBsYXllcidzIGhpZXJhcmNoeS5cclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGhpZXJhcmNoXHJcbiAgICAgKiBsYXllcidzIHBhcmVudCBsaXN0XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgc2V0SGllcmFyY2h5OiBmdW5jdGlvbiAoaGllcmFyY2h5KSB7XHJcbiAgICB0aGlzLmhpZXJhcmNoeSA9IGhpZXJhcmNoeTtcclxuICB9LFxyXG4gIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBTZXRzIGxheWVyIGFzIHBhcmVudC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICBzZXRBc1BhcmVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5faXNQYXJlbnQgPSB0cnVlO1xyXG4gIH0sXHJcbiAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIFNlYXJjaGVzIGxheWVyJ3MgcGFyZW50aW5nIGNoYWluXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgY2hlY2tQYXJlbnRpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmRhdGEucGFyZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5jb21wLmJ1aWxkRWxlbWVudFBhcmVudGluZyh0aGlzLCB0aGlzLmRhdGEucGFyZW50LCBbXSk7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZVxyXG4gKiBIYW5kbGVzIGVsZW1lbnQncyBsYXllciBmcmFtZSB1cGRhdGUuXHJcbiAqIENoZWNrcyBsYXllciBpbiBwb2ludCBhbmQgb3V0IHBvaW50XHJcbiAqXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRnJhbWVFbGVtZW50KCkge31cclxuXHJcbkZyYW1lRWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEluaXRpYWxpemVzIGZyYW1lIHJlbGF0ZWQgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICBpbml0RnJhbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHNldCB0byB0cnVlIHdoZW4gaW5wb2ludCBpcyByZW5kZXJlZFxyXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XHJcbiAgICAvLyBsaXN0IG9mIGFuaW1hdGVkIHByb3BlcnRpZXNcclxuICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMgPSBbXTtcclxuICAgIC8vIElmIGxheWVyIGhhcyBiZWVuIG1vZGlmaWVkIGluIGN1cnJlbnQgdGljayB0aGlzIHdpbGwgYmUgdHJ1ZVxyXG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgfSxcclxuICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQ2FsY3VsYXRlcyBhbGwgZHluYW1pYyB2YWx1ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtXHJcbiAgICAgKiBjdXJyZW50IGZyYW1lIG51bWJlciBpbiBMYXllcidzIHRpbWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWaXNpYmxlXHJcbiAgICAgKiBpZiBsYXllcnMgaXMgY3VycmVudGx5IGluIHJhbmdlXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgcHJlcGFyZVByb3BlcnRpZXM6IGZ1bmN0aW9uIChudW0sIGlzVmlzaWJsZSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgaWYgKGlzVmlzaWJsZSB8fCAodGhpcy5faXNQYXJlbnQgJiYgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5wcm9wVHlwZSA9PT0gJ3RyYW5zZm9ybScpKSB7XHJcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcclxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gdHJ1ZTtcclxuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBhZGREeW5hbWljUHJvcGVydHk6IGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xyXG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbi8qIGdsb2JhbCBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnksIE1hdHJpeCAqL1xyXG5cclxuZnVuY3Rpb24gVHJhbnNmb3JtRWxlbWVudCgpIHt9XHJcblxyXG5UcmFuc2Zvcm1FbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICBpbml0VHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZpbmFsVHJhbnNmb3JtID0ge1xyXG4gICAgICBtUHJvcDogdGhpcy5kYXRhLmtzID8gVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5KHRoaXMsIHRoaXMuZGF0YS5rcywgdGhpcykgOiB7IG86IDAgfSxcclxuICAgICAgX21hdE1kZjogZmFsc2UsXHJcbiAgICAgIF9vcE1kZjogZmFsc2UsXHJcbiAgICAgIG1hdDogbmV3IE1hdHJpeCgpLFxyXG4gICAgfTtcclxuICAgIGlmICh0aGlzLmRhdGEuYW8pIHtcclxuICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5hdXRvT3JpZW50ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGNoZWNrIFRZUEUgMTE6IEd1aWRlZCBlbGVtZW50c1xyXG4gICAgaWYgKHRoaXMuZGF0YS50eSAhPT0gMTEpIHtcclxuICAgICAgLy8gdGhpcy5jcmVhdGVFbGVtZW50cygpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVuZGVyVHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZTtcclxuICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWU7XHJcblxyXG4gICAgaWYgKHRoaXMuaGllcmFyY2h5KSB7XHJcbiAgICAgIHZhciBtYXQ7XHJcbiAgICAgIHZhciBmaW5hbE1hdCA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0O1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7XHJcbiAgICAgIC8vIENoZWNraW5nIGlmIGFueSBvZiB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cmljZXMgaW4gdGhlIGhpZXJhcmNoeSBjaGFpbiBoYXMgY2hhbmdlZC5cclxuICAgICAgaWYgKCF0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcclxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgICAgaWYgKHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLl9tZGYpIHtcclxuICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XHJcbiAgICAgICAgbWF0ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC52LnByb3BzO1xyXG4gICAgICAgIGZpbmFsTWF0LmNsb25lRnJvbVByb3BzKG1hdCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICBtYXQgPSB0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC52LnByb3BzO1xyXG4gICAgICAgICAgZmluYWxNYXQudHJhbnNmb3JtKG1hdFswXSwgbWF0WzFdLCBtYXRbMl0sIG1hdFszXSwgbWF0WzRdLCBtYXRbNV0sIG1hdFs2XSwgbWF0WzddLCBtYXRbOF0sIG1hdFs5XSwgbWF0WzEwXSwgbWF0WzExXSwgbWF0WzEyXSwgbWF0WzEzXSwgbWF0WzE0XSwgbWF0WzE1XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBnbG9iYWxUb0xvY2FsOiBmdW5jdGlvbiAocHQpIHtcclxuICAgIHZhciB0cmFuc2Zvcm1zID0gW107XHJcbiAgICB0cmFuc2Zvcm1zLnB1c2godGhpcy5maW5hbFRyYW5zZm9ybSk7XHJcbiAgICB2YXIgZmxhZyA9IHRydWU7XHJcbiAgICB2YXIgY29tcCA9IHRoaXMuY29tcDtcclxuICAgIHdoaWxlIChmbGFnKSB7XHJcbiAgICAgIGlmIChjb21wLmZpbmFsVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgaWYgKGNvbXAuZGF0YS5oYXNNYXNrKSB7XHJcbiAgICAgICAgICB0cmFuc2Zvcm1zLnNwbGljZSgwLCAwLCBjb21wLmZpbmFsVHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcCA9IGNvbXAuY29tcDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xyXG4gICAgdmFyIHB0TmV3O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHB0TmV3ID0gdHJhbnNmb3Jtc1tpXS5tYXQuYXBwbHlUb1BvaW50QXJyYXkoMCwgMCwgMCk7XHJcbiAgICAgIC8vIHB0TmV3ID0gdHJhbnNmb3Jtc1tpXS5tYXQuYXBwbHlUb1BvaW50QXJyYXkocHRbMF0scHRbMV0scHRbMl0pO1xyXG4gICAgICBwdCA9IFtwdFswXSAtIHB0TmV3WzBdLCBwdFsxXSAtIHB0TmV3WzFdLCAwXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwdDtcclxuICB9LFxyXG4gIG1IZWxwZXI6IG5ldyBNYXRyaXgoKSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIFJlbmRlcmFibGVFbGVtZW50KCkge1xyXG5cclxufVxyXG5cclxuUmVuZGVyYWJsZUVsZW1lbnQucHJvdG90eXBlID0ge1xyXG4gIGluaXRSZW5kZXJhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBsYXllcidzIHZpc2liaWxpdHkgcmVsYXRlZCB0byBpbnBvaW50IGFuZCBvdXRwb2ludC4gUmVuYW1lIGlzVmlzaWJsZSB0byBpc0luUmFuZ2VcclxuICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7XHJcbiAgICAvLyBsYXllcidzIGRpc3BsYXkgc3RhdGVcclxuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAvLyBJZiBsYXllcidzIHRyYW5zcGFyZW5jeSBlcXVhbHMgMCwgaXQgY2FuIGJlIGhpZGRlblxyXG4gICAgdGhpcy5pc1RyYW5zcGFyZW50ID0gZmFsc2U7XHJcbiAgICAvLyBsaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcclxuICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMgPSBbXTtcclxuICB9LFxyXG4gIGFkZFJlbmRlcmFibGVDb21wb25lbnQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgIGlmICh0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KSA9PT0gLTEpIHtcclxuICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICByZW1vdmVSZW5kZXJhYmxlQ29tcG9uZW50OiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcbiAgICBpZiAodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCkgIT09IC0xKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMuc3BsaWNlKHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpLCAxKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHByZXBhcmVSZW5kZXJhYmxlRnJhbWU6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgIHRoaXMuY2hlY2tMYXllckxpbWl0cyhudW0pO1xyXG4gIH0sXHJcbiAgY2hlY2tUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udiA8PSAwKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc1RyYW5zcGFyZW50ICYmIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJDb25maWcuaGlkZU9uVHJhbnNwYXJlbnQpIHtcclxuICAgICAgICB0aGlzLmlzVHJhbnNwYXJlbnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNUcmFuc3BhcmVudCkge1xyXG4gICAgICB0aGlzLmlzVHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogSW5pdGlhbGl6ZXMgZnJhbWUgcmVsYXRlZCBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1cclxuICAgICAqIGN1cnJlbnQgZnJhbWUgbnVtYmVyIGluIExheWVyJ3MgdGltZVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gIGNoZWNrTGF5ZXJMaW1pdHM6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgIGlmICh0aGlzLmRhdGEuaXAgLSB0aGlzLmRhdGEuc3QgPD0gbnVtICYmIHRoaXMuZGF0YS5vcCAtIHRoaXMuZGF0YS5zdCA+IG51bSkge1xyXG4gICAgICBpZiAodGhpcy5pc0luUmFuZ2UgIT09IHRydWUpIHtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzSW5SYW5nZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0luUmFuZ2UgIT09IGZhbHNlKSB7XHJcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gdHJ1ZTtcclxuICAgICAgdGhpcy5pc0luUmFuZ2UgPSBmYWxzZTtcclxuICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICByZW5kZXJSZW5kZXJhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICB0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzW2ldLnJlbmRlckZyYW1lKHRoaXMuX2lzRmlyc3RGcmFtZSk7XHJcbiAgICB9XHJcbiAgICAvKiB0aGlzLm1hc2tNYW5hZ2VyLnJlbmRlckZyYW1lKHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0KTtcclxuICAgICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlci5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpOyAqL1xyXG4gIH0sXHJcbiAgc291cmNlUmVjdEF0VGltZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiAwLFxyXG4gICAgICBsZWZ0OiAwLFxyXG4gICAgICB3aWR0aDogMTAwLFxyXG4gICAgICBoZWlnaHQ6IDEwMCxcclxuICAgIH07XHJcbiAgfSxcclxuICBnZXRMYXllclNpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmRhdGEudHkgPT09IDUpIHtcclxuICAgICAgcmV0dXJuIHsgdzogdGhpcy5kYXRhLnRleHREYXRhLndpZHRoLCBoOiB0aGlzLmRhdGEudGV4dERhdGEuaGVpZ2h0IH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB3OiB0aGlzLmRhdGEud2lkdGgsIGg6IHRoaXMuZGF0YS5oZWlnaHQgfTtcclxuICB9LFxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgUmVuZGVyYWJsZUVsZW1lbnQsIGNyZWF0ZVByb3h5RnVuY3Rpb24gKi9cclxuXHJcbmZ1bmN0aW9uIFJlbmRlcmFibGVET01FbGVtZW50KCkge31cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9wcm90b3R5cGUgPSB7XHJcbiAgICBpbml0RWxlbWVudDogZnVuY3Rpb24gKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICAgICAgdGhpcy5pbml0RnJhbWUoKTtcclxuICAgICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgICAgIHRoaXMuaW5pdFRyYW5zZm9ybShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICAgICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XHJcbiAgICAgIHRoaXMuaW5pdFJlbmRlcmFibGUoKTtcclxuICAgICAgdGhpcy5pbml0UmVuZGVyZXJFbGVtZW50KCk7XHJcbiAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyRWxlbWVudHMoKTtcclxuICAgICAgdGhpcy5jcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50cygpO1xyXG4gICAgICB0aGlzLmNyZWF0ZUNvbnRlbnQoKTtcclxuICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICB9LFxyXG4gICAgaGlkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoIXRoaXMuaGlkZGVuICYmICghdGhpcy5pc0luUmFuZ2UgfHwgdGhpcy5pc1RyYW5zcGFyZW50KSkge1xyXG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlRWxlbWVudCB8fCB0aGlzLmxheWVyRWxlbWVudDtcclxuICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAodGhpcy5pc0luUmFuZ2UgJiYgIXRoaXMuaXNUcmFuc3BhcmVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmhkKSB7XHJcbiAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuYmFzZUVsZW1lbnQgfHwgdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAvLyBJZiBpdCBpcyBleHBvcnRlZCBhcyBoaWRkZW4gKGRhdGEuaGQgPT09IHRydWUpIG5vIG5lZWQgdG8gcmVuZGVyXHJcbiAgICAgIC8vIElmIGl0IGlzIG5vdCB2aXNpYmxlIG5vIG5lZWQgdG8gcmVuZGVyXHJcbiAgICAgIGlmICh0aGlzLmRhdGEuaGQgfHwgdGhpcy5oaWRkZW4pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5yZW5kZXJUcmFuc2Zvcm0oKTtcclxuICAgICAgdGhpcy5yZW5kZXJSZW5kZXJhYmxlKCk7XHJcbiAgICAgIHRoaXMucmVuZGVyRWxlbWVudCgpO1xyXG4gICAgICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xyXG4gICAgICBpZiAodGhpcy5faXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW5kZXJJbm5lckNvbnRlbnQ6IGZ1bmN0aW9uICgpIHt9LFxyXG4gICAgcHJlcGFyZUZyYW1lOiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcclxuICAgICAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRoaXMuaXNJblJhbmdlKTtcclxuICAgICAgdGhpcy5jaGVja1RyYW5zcGFyZW5jeSgpO1xyXG4gICAgfSxcclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5pbm5lckVsZW0gPSBudWxsO1xyXG4gICAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xyXG4gICAgfSxcclxuICB9O1xyXG4gIGV4dGVuZFByb3RvdHlwZShbUmVuZGVyYWJsZUVsZW1lbnQsIGNyZWF0ZVByb3h5RnVuY3Rpb24oX3Byb3RvdHlwZSldLCBSZW5kZXJhYmxlRE9NRWxlbWVudCk7XHJcbn0oKSk7XHJcblxyXG4vKiBleHBvcnRlZCBQcm9jZXNzZWRFbGVtZW50ICovXHJcblxyXG5mdW5jdGlvbiBQcm9jZXNzZWRFbGVtZW50KGVsZW1lbnQsIHBvc2l0aW9uKSB7XHJcbiAgdGhpcy5lbGVtID0gZWxlbWVudDtcclxuICB0aGlzLnBvcyA9IHBvc2l0aW9uO1xyXG59XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlTlMgKi9cclxuXHJcbmZ1bmN0aW9uIFNWR1N0eWxlRGF0YShkYXRhLCBsZXZlbCkge1xyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgdGhpcy50eXBlID0gZGF0YS50eTtcclxuICB0aGlzLmQgPSAnJztcclxuICB0aGlzLmx2bCA9IGxldmVsO1xyXG4gIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gIHRoaXMuY2xvc2VkID0gZGF0YS5oZCA9PT0gdHJ1ZTtcclxuICB0aGlzLnBFbGVtID0gY3JlYXRlTlMoJ3BhdGgnKTtcclxuICB0aGlzLm1zRWxlbSA9IG51bGw7XHJcbn1cclxuXHJcblNWR1N0eWxlRGF0YS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5kID0gJyc7XHJcbiAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBTVkdTaGFwZURhdGEodHJhbnNmb3JtZXJzLCBsZXZlbCwgc2hhcGUpIHtcclxuICB0aGlzLmNhY2hlcyA9IFtdO1xyXG4gIHRoaXMuc3R5bGVzID0gW107XHJcbiAgdGhpcy50cmFuc2Zvcm1lcnMgPSB0cmFuc2Zvcm1lcnM7XHJcbiAgdGhpcy5sU3RyID0gJyc7XHJcbiAgdGhpcy5zaCA9IHNoYXBlO1xyXG4gIHRoaXMubHZsID0gbGV2ZWw7XHJcbiAgLy8gVE9ETyBmaW5kIGlmIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIF9pc0FuaW1hdGVkIGNhbiBiZSBmYWxzZS5cclxuICAvLyBGb3Igbm93LCBzaW5jZSBzaGFwZXMgYWRkIHVwIHdpdGggb3RoZXIgc2hhcGVzLiBUaGV5IGhhdmUgdG8gYmUgY2FsY3VsYXRlZCBldmVyeSB0aW1lLlxyXG4gIC8vIE9uZSB3YXkgb2YgZmluZGluZyBvdXQgaXMgY2hlY2tpbmcgaWYgYWxsIHN0eWxlcyBhc3NvY2lhdGVkIHRvIHRoaXMgc2hhcGUgZGVwZW5kIG9ubHkgb2YgdGhpcyBzaGFwZVxyXG4gIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXNoYXBlLms7XHJcbiAgLy8gVE9ETzogY29tbWVudGluZyB0aGlzIGZvciBub3cgc2luY2UgYWxsIHNoYXBlcyBhcmUgYW5pbWF0ZWRcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIGxlbiA9IHRyYW5zZm9ybWVycy5sZW5ndGg7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGlmICh0cmFuc2Zvcm1lcnNbaV0ubVByb3BzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9pc0FuaW1hdGVkID0gdHJ1ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpICs9IDE7XHJcbiAgfVxyXG59XHJcblxyXG5TVkdTaGFwZURhdGEucHJvdG90eXBlLnNldEFzQW5pbWF0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XHJcbn07XHJcblxyXG4vKiBleHBvcnRlZCBTVkdUcmFuc2Zvcm1EYXRhICovXHJcblxyXG5mdW5jdGlvbiBTVkdUcmFuc2Zvcm1EYXRhKG1Qcm9wcywgb3AsIGNvbnRhaW5lcikge1xyXG4gIHRoaXMudHJhbnNmb3JtID0ge1xyXG4gICAgbVByb3BzOiBtUHJvcHMsXHJcbiAgICBvcDogb3AsXHJcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcclxuICB9O1xyXG4gIHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy50cmFuc2Zvcm0ubVByb3BzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCB8fCB0aGlzLnRyYW5zZm9ybS5vcC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xyXG59XHJcblxyXG4vKiBnbG9iYWwgRGFzaFByb3BlcnR5LCBQcm9wZXJ0eUZhY3RvcnksIGV4dGVuZFByb3RvdHlwZSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyICovXHJcblxyXG5mdW5jdGlvbiBTVkdTdHJva2VTdHlsZURhdGEoZWxlbSwgZGF0YSwgc3R5bGVPYikge1xyXG4gIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcclxuICB0aGlzLmdldFZhbHVlID0gdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XHJcbiAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLjAxLCB0aGlzKTtcclxuICB0aGlzLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLncsIDAsIG51bGwsIHRoaXMpO1xyXG4gIHRoaXMuZCA9IG5ldyBEYXNoUHJvcGVydHkoZWxlbSwgZGF0YS5kIHx8IHt9LCAnc3ZnJywgdGhpcyk7XHJcbiAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAxLCAyNTUsIHRoaXMpO1xyXG4gIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xyXG4gIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuX2lzQW5pbWF0ZWQ7XHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHU3Ryb2tlU3R5bGVEYXRhKTtcclxuXHJcbi8qIGdsb2JhbCBQcm9wZXJ0eUZhY3RvcnksIGV4dGVuZFByb3RvdHlwZSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyICovXHJcblxyXG5mdW5jdGlvbiBTVkdGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcclxuICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbiAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xyXG4gIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XHJcbiAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAxLCAyNTUsIHRoaXMpO1xyXG4gIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR0ZpbGxTdHlsZURhdGEpO1xyXG5cclxuLyogZ2xvYmFsIFByb3BlcnR5RmFjdG9yeSwgZGVnVG9SYWRzLCBHcmFkaWVudFByb3BlcnR5LCBjcmVhdGVFbGVtZW50SUQsIGNyZWF0ZU5TLCBsb2NhdGlvbkhyZWYsXHJcbmV4dGVuZFByb3RvdHlwZSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyLCBsaW5lQ2FwRW51bSwgbGluZUpvaW5FbnVtICovXHJcblxyXG5mdW5jdGlvbiBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEoZWxlbSwgZGF0YSwgc3R5bGVPYikge1xyXG4gIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcclxuICB0aGlzLmdldFZhbHVlID0gdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XHJcbiAgdGhpcy5pbml0R3JhZGllbnREYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpO1xyXG59XHJcblxyXG5TVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLmluaXRHcmFkaWVudERhdGEgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSwgc3R5bGVPYikge1xyXG4gIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XHJcbiAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zLCAxLCBudWxsLCB0aGlzKTtcclxuICB0aGlzLmUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmUsIDEsIG51bGwsIHRoaXMpO1xyXG4gIHRoaXMuaCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuaCB8fCB7IGs6IDAgfSwgMCwgMC4wMSwgdGhpcyk7XHJcbiAgdGhpcy5hID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5hIHx8IHsgazogMCB9LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gIHRoaXMuZyA9IG5ldyBHcmFkaWVudFByb3BlcnR5KGVsZW0sIGRhdGEuZywgdGhpcyk7XHJcbiAgdGhpcy5zdHlsZSA9IHN0eWxlT2I7XHJcbiAgdGhpcy5zdG9wcyA9IFtdO1xyXG4gIHRoaXMuc2V0R3JhZGllbnREYXRhKHN0eWxlT2IucEVsZW0sIGRhdGEpO1xyXG4gIHRoaXMuc2V0R3JhZGllbnRPcGFjaXR5KGRhdGEsIHN0eWxlT2IpO1xyXG4gIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuX2lzQW5pbWF0ZWQ7XHJcbn07XHJcblxyXG5TVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLnNldEdyYWRpZW50RGF0YSA9IGZ1bmN0aW9uIChwYXRoRWxlbWVudCwgZGF0YSkge1xyXG4gIHZhciBncmFkaWVudElkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgdmFyIGdmaWxsID0gY3JlYXRlTlMoZGF0YS50ID09PSAxID8gJ2xpbmVhckdyYWRpZW50JyA6ICdyYWRpYWxHcmFkaWVudCcpO1xyXG4gIGdmaWxsLnNldEF0dHJpYnV0ZSgnaWQnLCBncmFkaWVudElkKTtcclxuICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ3NwcmVhZE1ldGhvZCcsICdwYWQnKTtcclxuICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcclxuICB2YXIgc3RvcHMgPSBbXTtcclxuICB2YXIgc3RvcDtcclxuICB2YXIgajtcclxuICB2YXIgakxlbjtcclxuICBqTGVuID0gZGF0YS5nLnAgKiA0O1xyXG4gIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDQpIHtcclxuICAgIHN0b3AgPSBjcmVhdGVOUygnc3RvcCcpO1xyXG4gICAgZ2ZpbGwuYXBwZW5kQ2hpbGQoc3RvcCk7XHJcbiAgICBzdG9wcy5wdXNoKHN0b3ApO1xyXG4gIH1cclxuICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsJyA6ICdzdHJva2UnLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBncmFkaWVudElkICsgJyknKTtcclxuICB0aGlzLmdmID0gZ2ZpbGw7XHJcbiAgdGhpcy5jc3QgPSBzdG9wcztcclxufTtcclxuXHJcblNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YS5wcm90b3R5cGUuc2V0R3JhZGllbnRPcGFjaXR5ID0gZnVuY3Rpb24gKGRhdGEsIHN0eWxlT2IpIHtcclxuICBpZiAodGhpcy5nLl9oYXNPcGFjaXR5ICYmICF0aGlzLmcuX2NvbGxhcHNhYmxlKSB7XHJcbiAgICB2YXIgc3RvcDtcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIGpMZW47XHJcbiAgICB2YXIgbWFzayA9IGNyZWF0ZU5TKCdtYXNrJyk7XHJcbiAgICB2YXIgbWFza0VsZW1lbnQgPSBjcmVhdGVOUygncGF0aCcpO1xyXG4gICAgbWFzay5hcHBlbmRDaGlsZChtYXNrRWxlbWVudCk7XHJcbiAgICB2YXIgb3BhY2l0eUlkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgICB2YXIgbWFza0lkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgICBtYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBtYXNrSWQpO1xyXG4gICAgdmFyIG9wRmlsbCA9IGNyZWF0ZU5TKGRhdGEudCA9PT0gMSA/ICdsaW5lYXJHcmFkaWVudCcgOiAncmFkaWFsR3JhZGllbnQnKTtcclxuICAgIG9wRmlsbC5zZXRBdHRyaWJ1dGUoJ2lkJywgb3BhY2l0eUlkKTtcclxuICAgIG9wRmlsbC5zZXRBdHRyaWJ1dGUoJ3NwcmVhZE1ldGhvZCcsICdwYWQnKTtcclxuICAgIG9wRmlsbC5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcclxuICAgIGpMZW4gPSBkYXRhLmcuay5rWzBdLnMgPyBkYXRhLmcuay5rWzBdLnMubGVuZ3RoIDogZGF0YS5nLmsuay5sZW5ndGg7XHJcbiAgICB2YXIgc3RvcHMgPSB0aGlzLnN0b3BzO1xyXG4gICAgZm9yIChqID0gZGF0YS5nLnAgKiA0OyBqIDwgakxlbjsgaiArPSAyKSB7XHJcbiAgICAgIHN0b3AgPSBjcmVhdGVOUygnc3RvcCcpO1xyXG4gICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsICdyZ2IoMjU1LDI1NSwyNTUpJyk7XHJcbiAgICAgIG9wRmlsbC5hcHBlbmRDaGlsZChzdG9wKTtcclxuICAgICAgc3RvcHMucHVzaChzdG9wKTtcclxuICAgIH1cclxuICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZShkYXRhLnR5ID09PSAnZ2YnID8gJ2ZpbGwnIDogJ3N0cm9rZScsICd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJyArIG9wYWNpdHlJZCArICcpJyk7XHJcbiAgICBpZiAoZGF0YS50eSA9PT0gJ2dzJykge1xyXG4gICAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bZGF0YS5sYyB8fCAyXSk7XHJcbiAgICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl0pO1xyXG4gICAgICBpZiAoZGF0YS5saiA9PT0gMSkge1xyXG4gICAgICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW1pdGVybGltaXQnLCBkYXRhLm1sKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5vZiA9IG9wRmlsbDtcclxuICAgIHRoaXMubXMgPSBtYXNrO1xyXG4gICAgdGhpcy5vc3QgPSBzdG9wcztcclxuICAgIHRoaXMubWFza0lkID0gbWFza0lkO1xyXG4gICAgc3R5bGVPYi5tc0VsZW0gPSBtYXNrRWxlbWVudDtcclxuICB9XHJcbn07XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YSk7XHJcblxyXG4vKiBnbG9iYWwgUHJvcGVydHlGYWN0b3J5LCBEYXNoUHJvcGVydHksIGV4dGVuZFByb3RvdHlwZSwgU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLCBEeW5hbWljUHJvcGVydHlDb250YWluZXIgKi9cclxuXHJcbmZ1bmN0aW9uIFNWR0dyYWRpZW50U3Ryb2tlU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcclxuICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbiAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xyXG4gIHRoaXMudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XHJcbiAgdGhpcy5kID0gbmV3IERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLmQgfHwge30sICdzdmcnLCB0aGlzKTtcclxuICB0aGlzLmluaXRHcmFkaWVudERhdGEoZWxlbSwgZGF0YSwgc3R5bGVPYik7XHJcbiAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5faXNBbmltYXRlZDtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR0dyYWRpZW50U3Ryb2tlU3R5bGVEYXRhKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVOUyAqL1xyXG4vKiBleHBvcnRlZCBTaGFwZUdyb3VwRGF0YSAqL1xyXG5cclxuZnVuY3Rpb24gU2hhcGVHcm91cERhdGEoKSB7XHJcbiAgdGhpcy5pdCA9IFtdO1xyXG4gIHRoaXMucHJldlZpZXdEYXRhID0gW107XHJcbiAgdGhpcy5nciA9IGNyZWF0ZU5TKCdnJyk7XHJcbn1cclxuXHJcbi8qIGdsb2JhbCBNYXRyaXgsIGJ1aWxkU2hhcGVTdHJpbmcsIGJtRmxvb3IgKi9cclxuLyogZXhwb3J0ZWQgU1ZHRWxlbWVudHNSZW5kZXJlciAqL1xyXG5cclxudmFyIFNWR0VsZW1lbnRzUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBfaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4KCk7XHJcbiAgdmFyIF9tYXRyaXhIZWxwZXIgPSBuZXcgTWF0cml4KCk7XHJcblxyXG4gIHZhciBvYiA9IHtcclxuICAgIGNyZWF0ZVJlbmRlckZ1bmN0aW9uOiBjcmVhdGVSZW5kZXJGdW5jdGlvbixcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJGdW5jdGlvbihkYXRhKSB7XHJcbiAgICBzd2l0Y2ggKGRhdGEudHkpIHtcclxuICAgICAgY2FzZSAnZmwnOlxyXG4gICAgICAgIHJldHVybiByZW5kZXJGaWxsO1xyXG4gICAgICBjYXNlICdnZic6XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlckdyYWRpZW50O1xyXG4gICAgICBjYXNlICdncyc6XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlckdyYWRpZW50U3Ryb2tlO1xyXG4gICAgICBjYXNlICdzdCc6XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlclN0cm9rZTtcclxuICAgICAgY2FzZSAnc2gnOlxyXG4gICAgICBjYXNlICdlbCc6XHJcbiAgICAgIGNhc2UgJ3JjJzpcclxuICAgICAgY2FzZSAnc3InOlxyXG4gICAgICAgIHJldHVybiByZW5kZXJQYXRoO1xyXG4gICAgICBjYXNlICd0cic6XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlckNvbnRlbnRUcmFuc2Zvcm07XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW5kZXJDb250ZW50VHJhbnNmb3JtKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xyXG4gICAgaWYgKGlzRmlyc3RGcmFtZSB8fCBpdGVtRGF0YS50cmFuc2Zvcm0ub3AuX21kZikge1xyXG4gICAgICBpdGVtRGF0YS50cmFuc2Zvcm0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIGl0ZW1EYXRhLnRyYW5zZm9ybS5vcC52KTtcclxuICAgIH1cclxuICAgIGlmIChpc0ZpcnN0RnJhbWUgfHwgaXRlbURhdGEudHJhbnNmb3JtLm1Qcm9wcy5fbWRmKSB7XHJcbiAgICAgIGl0ZW1EYXRhLnRyYW5zZm9ybS5jb250YWluZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBpdGVtRGF0YS50cmFuc2Zvcm0ubVByb3BzLnYudG8yZENTUygpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbmRlclBhdGgoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICB2YXIgajtcclxuICAgIHZhciBqTGVuO1xyXG4gICAgdmFyIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcclxuICAgIHZhciByZWRyYXc7XHJcbiAgICB2YXIgcGF0aE5vZGVzO1xyXG4gICAgdmFyIGw7XHJcbiAgICB2YXIgbExlbiA9IGl0ZW1EYXRhLnN0eWxlcy5sZW5ndGg7XHJcbiAgICB2YXIgbHZsID0gaXRlbURhdGEubHZsO1xyXG4gICAgdmFyIHBhdGhzO1xyXG4gICAgdmFyIG1hdDtcclxuICAgIHZhciBwcm9wcztcclxuICAgIHZhciBpdGVyYXRpb25zO1xyXG4gICAgdmFyIGs7XHJcbiAgICBmb3IgKGwgPSAwOyBsIDwgbExlbjsgbCArPSAxKSB7XHJcbiAgICAgIHJlZHJhdyA9IGl0ZW1EYXRhLnNoLl9tZGYgfHwgaXNGaXJzdEZyYW1lO1xyXG4gICAgICBpZiAoaXRlbURhdGEuc3R5bGVzW2xdLmx2bCA8IGx2bCkge1xyXG4gICAgICAgIG1hdCA9IF9tYXRyaXhIZWxwZXIucmVzZXQoKTtcclxuICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcclxuICAgICAgICBrID0gaXRlbURhdGEudHJhbnNmb3JtZXJzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgd2hpbGUgKCFyZWRyYXcgJiYgaXRlcmF0aW9ucyA+IDApIHtcclxuICAgICAgICAgIHJlZHJhdyA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVyc1trXS5tUHJvcHMuX21kZiB8fCByZWRyYXc7XHJcbiAgICAgICAgICBpdGVyYXRpb25zIC09IDE7XHJcbiAgICAgICAgICBrIC09IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWRyYXcpIHtcclxuICAgICAgICAgIGl0ZXJhdGlvbnMgPSBsdmwgLSBpdGVtRGF0YS5zdHlsZXNbbF0ubHZsO1xyXG4gICAgICAgICAgayA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVycy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgd2hpbGUgKGl0ZXJhdGlvbnMgPiAwKSB7XHJcbiAgICAgICAgICAgIHByb3BzID0gaXRlbURhdGEudHJhbnNmb3JtZXJzW2tdLm1Qcm9wcy52LnByb3BzO1xyXG4gICAgICAgICAgICBtYXQudHJhbnNmb3JtKHByb3BzWzBdLCBwcm9wc1sxXSwgcHJvcHNbMl0sIHByb3BzWzNdLCBwcm9wc1s0XSwgcHJvcHNbNV0sIHByb3BzWzZdLCBwcm9wc1s3XSwgcHJvcHNbOF0sIHByb3BzWzldLCBwcm9wc1sxMF0sIHByb3BzWzExXSwgcHJvcHNbMTJdLCBwcm9wc1sxM10sIHByb3BzWzE0XSwgcHJvcHNbMTVdKTtcclxuICAgICAgICAgICAgaXRlcmF0aW9ucyAtPSAxO1xyXG4gICAgICAgICAgICBrIC09IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1hdCA9IF9pZGVudGl0eU1hdHJpeDtcclxuICAgICAgfVxyXG4gICAgICBwYXRocyA9IGl0ZW1EYXRhLnNoLnBhdGhzO1xyXG4gICAgICBqTGVuID0gcGF0aHMuX2xlbmd0aDtcclxuICAgICAgaWYgKHJlZHJhdykge1xyXG4gICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCA9ICcnO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgIHBhdGhOb2RlcyA9IHBhdGhzLnNoYXBlc1tqXTtcclxuICAgICAgICAgIGlmIChwYXRoTm9kZXMgJiYgcGF0aE5vZGVzLl9sZW5ndGgpIHtcclxuICAgICAgICAgICAgcGF0aFN0cmluZ1RyYW5zZm9ybWVkICs9IGJ1aWxkU2hhcGVTdHJpbmcocGF0aE5vZGVzLCBwYXRoTm9kZXMuX2xlbmd0aCwgcGF0aE5vZGVzLmMsIG1hdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGl0ZW1EYXRhLmNhY2hlc1tsXSA9IHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXRoU3RyaW5nVHJhbnNmb3JtZWQgPSBpdGVtRGF0YS5jYWNoZXNbbF07XHJcbiAgICAgIH1cclxuICAgICAgaXRlbURhdGEuc3R5bGVzW2xdLmQgKz0gc3R5bGVEYXRhLmhkID09PSB0cnVlID8gJycgOiBwYXRoU3RyaW5nVHJhbnNmb3JtZWQ7XHJcbiAgICAgIGl0ZW1EYXRhLnN0eWxlc1tsXS5fbWRmID0gcmVkcmF3IHx8IGl0ZW1EYXRhLnN0eWxlc1tsXS5fbWRmO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVuZGVyRmlsbChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcclxuXHJcbiAgICBpZiAoaXRlbURhdGEuYy5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdmaWxsJywgJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknKTtcclxuICAgIH1cclxuICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIGl0ZW1EYXRhLm8udik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW5kZXJHcmFkaWVudFN0cm9rZShzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgIHJlbmRlckdyYWRpZW50KHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSk7XHJcbiAgICByZW5kZXJTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbmRlckdyYWRpZW50KHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xyXG4gICAgdmFyIGdmaWxsID0gaXRlbURhdGEuZ2Y7XHJcbiAgICB2YXIgaGFzT3BhY2l0eSA9IGl0ZW1EYXRhLmcuX2hhc09wYWNpdHk7XHJcbiAgICB2YXIgcHQxID0gaXRlbURhdGEucy52O1xyXG4gICAgdmFyIHB0MiA9IGl0ZW1EYXRhLmUudjtcclxuXHJcbiAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICB2YXIgYXR0ciA9IHN0eWxlRGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsLW9wYWNpdHknIDogJ3N0cm9rZS1vcGFjaXR5JztcclxuICAgICAgaXRlbURhdGEuc3R5bGUucEVsZW0uc2V0QXR0cmlidXRlKGF0dHIsIGl0ZW1EYXRhLm8udik7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbURhdGEucy5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICB2YXIgYXR0cjEgPSBzdHlsZURhdGEudCA9PT0gMSA/ICd4MScgOiAnY3gnO1xyXG4gICAgICB2YXIgYXR0cjIgPSBhdHRyMSA9PT0gJ3gxJyA/ICd5MScgOiAnY3knO1xyXG4gICAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoYXR0cjEsIHB0MVswXSk7XHJcbiAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZShhdHRyMiwgcHQxWzFdKTtcclxuICAgICAgaWYgKGhhc09wYWNpdHkgJiYgIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XHJcbiAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKGF0dHIxLCBwdDFbMF0pO1xyXG4gICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZShhdHRyMiwgcHQxWzFdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHN0b3BzO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuO1xyXG4gICAgdmFyIHN0b3A7XHJcbiAgICBpZiAoaXRlbURhdGEuZy5fY21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgc3RvcHMgPSBpdGVtRGF0YS5jc3Q7XHJcbiAgICAgIHZhciBjVmFsdWVzID0gaXRlbURhdGEuZy5jO1xyXG4gICAgICBsZW4gPSBzdG9wcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIHN0b3AgPSBzdG9wc1tpXTtcclxuICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0JywgY1ZhbHVlc1tpICogNF0gKyAnJScpO1xyXG4gICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgJ3JnYignICsgY1ZhbHVlc1tpICogNCArIDFdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDJdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDNdICsgJyknKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhhc09wYWNpdHkgJiYgKGl0ZW1EYXRhLmcuX29tZGYgfHwgaXNGaXJzdEZyYW1lKSkge1xyXG4gICAgICB2YXIgb1ZhbHVlcyA9IGl0ZW1EYXRhLmcubztcclxuICAgICAgaWYgKGl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XHJcbiAgICAgICAgc3RvcHMgPSBpdGVtRGF0YS5jc3Q7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RvcHMgPSBpdGVtRGF0YS5vc3Q7XHJcbiAgICAgIH1cclxuICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBzdG9wID0gc3RvcHNbaV07XHJcbiAgICAgICAgaWYgKCFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xyXG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIG9WYWx1ZXNbaSAqIDJdICsgJyUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScsIG9WYWx1ZXNbaSAqIDIgKyAxXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzdHlsZURhdGEudCA9PT0gMSkge1xyXG4gICAgICBpZiAoaXRlbURhdGEuZS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneDInLCBwdDJbMF0pO1xyXG4gICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneTInLCBwdDJbMV0pO1xyXG4gICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xyXG4gICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCd4MicsIHB0MlswXSk7XHJcbiAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ3kyJywgcHQyWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciByYWQ7XHJcbiAgICAgIGlmIChpdGVtRGF0YS5zLl9tZGYgfHwgaXRlbURhdGEuZS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG4gICAgICAgIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XHJcbiAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdyJywgcmFkKTtcclxuICAgICAgICBpZiAoaGFzT3BhY2l0eSAmJiAhaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcclxuICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpdGVtRGF0YS5lLl9tZGYgfHwgaXRlbURhdGEuaC5fbWRmIHx8IGl0ZW1EYXRhLmEuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgICBpZiAoIXJhZCkge1xyXG4gICAgICAgICAgcmFkID0gTWF0aC5zcXJ0KE1hdGgucG93KHB0MVswXSAtIHB0MlswXSwgMikgKyBNYXRoLnBvdyhwdDFbMV0gLSBwdDJbMV0sIDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFuZyA9IE1hdGguYXRhbjIocHQyWzFdIC0gcHQxWzFdLCBwdDJbMF0gLSBwdDFbMF0pO1xyXG5cclxuICAgICAgICB2YXIgcGVyY2VudCA9IGl0ZW1EYXRhLmgudjtcclxuICAgICAgICBpZiAocGVyY2VudCA+PSAxKSB7XHJcbiAgICAgICAgICBwZXJjZW50ID0gMC45OTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPD0gLTEpIHtcclxuICAgICAgICAgIHBlcmNlbnQgPSAtMC45OTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpc3QgPSByYWQgKiBwZXJjZW50O1xyXG4gICAgICAgIHZhciB4ID0gTWF0aC5jb3MoYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMF07XHJcbiAgICAgICAgdmFyIHkgPSBNYXRoLnNpbihhbmcgKyBpdGVtRGF0YS5hLnYpICogZGlzdCArIHB0MVsxXTtcclxuICAgICAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2Z4JywgeCk7XHJcbiAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdmeScsIHkpO1xyXG4gICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xyXG4gICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xyXG4gICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeScsIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2Z5JywnMjAwJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW5kZXJTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XHJcbiAgICB2YXIgZCA9IGl0ZW1EYXRhLmQ7XHJcbiAgICBpZiAoZCAmJiAoZC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkgJiYgZC5kYXNoU3RyKSB7XHJcbiAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBkLmRhc2hTdHIpO1xyXG4gICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIGQuZGFzaG9mZnNldFswXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbURhdGEuYyAmJiAoaXRlbURhdGEuYy5fbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcclxuICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknKTtcclxuICAgIH1cclxuICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5JywgaXRlbURhdGEuby52KTtcclxuICAgIH1cclxuICAgIGlmIChpdGVtRGF0YS53Ll9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGl0ZW1EYXRhLncudik7XHJcbiAgICAgIGlmIChzdHlsZUVsZW0ubXNFbGVtKSB7XHJcbiAgICAgICAgc3R5bGVFbGVtLm1zRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGl0ZW1EYXRhLncudik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBvYjtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBNYXRyaXggKi9cclxuXHJcbmZ1bmN0aW9uIFNoYXBlVHJhbnNmb3JtTWFuYWdlcigpIHtcclxuICB0aGlzLnNlcXVlbmNlcyA9IHt9O1xyXG4gIHRoaXMuc2VxdWVuY2VMaXN0ID0gW107XHJcbiAgdGhpcy50cmFuc2Zvcm1fa2V5X2NvdW50ID0gMDtcclxufVxyXG5cclxuU2hhcGVUcmFuc2Zvcm1NYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuICBhZGRUcmFuc2Zvcm1TZXF1ZW5jZTogZnVuY3Rpb24gKHRyYW5zZm9ybXMpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xyXG4gICAgdmFyIGtleSA9ICdfJztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBrZXkgKz0gdHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ua2V5ICsgJ18nO1xyXG4gICAgfVxyXG4gICAgdmFyIHNlcXVlbmNlID0gdGhpcy5zZXF1ZW5jZXNba2V5XTtcclxuICAgIGlmICghc2VxdWVuY2UpIHtcclxuICAgICAgc2VxdWVuY2UgPSB7XHJcbiAgICAgICAgdHJhbnNmb3JtczogW10uY29uY2F0KHRyYW5zZm9ybXMpLFxyXG4gICAgICAgIGZpbmFsVHJhbnNmb3JtOiBuZXcgTWF0cml4KCksXHJcbiAgICAgICAgX21kZjogZmFsc2UsXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuc2VxdWVuY2VzW2tleV0gPSBzZXF1ZW5jZTtcclxuICAgICAgdGhpcy5zZXF1ZW5jZUxpc3QucHVzaChzZXF1ZW5jZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VxdWVuY2U7XHJcbiAgfSxcclxuICBwcm9jZXNzU2VxdWVuY2U6IGZ1bmN0aW9uIChzZXF1ZW5jZSwgaXNGaXJzdEZyYW1lKSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbGVuID0gc2VxdWVuY2UudHJhbnNmb3Jtcy5sZW5ndGg7XHJcbiAgICB2YXIgX21kZiA9IGlzRmlyc3RGcmFtZTtcclxuICAgIHdoaWxlIChpIDwgbGVuICYmICFpc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgaWYgKHNlcXVlbmNlLnRyYW5zZm9ybXNbaV0udHJhbnNmb3JtLm1Qcm9wcy5fbWRmKSB7XHJcbiAgICAgICAgX21kZiA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgaWYgKF9tZGYpIHtcclxuICAgICAgdmFyIHByb3BzO1xyXG4gICAgICBzZXF1ZW5jZS5maW5hbFRyYW5zZm9ybS5yZXNldCgpO1xyXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICAgIHByb3BzID0gc2VxdWVuY2UudHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ubVByb3BzLnYucHJvcHM7XHJcbiAgICAgICAgc2VxdWVuY2UuZmluYWxUcmFuc2Zvcm0udHJhbnNmb3JtKHByb3BzWzBdLCBwcm9wc1sxXSwgcHJvcHNbMl0sIHByb3BzWzNdLCBwcm9wc1s0XSwgcHJvcHNbNV0sIHByb3BzWzZdLCBwcm9wc1s3XSwgcHJvcHNbOF0sIHByb3BzWzldLCBwcm9wc1sxMF0sIHByb3BzWzExXSwgcHJvcHNbMTJdLCBwcm9wc1sxM10sIHByb3BzWzE0XSwgcHJvcHNbMTVdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VxdWVuY2UuX21kZiA9IF9tZGY7XHJcbiAgfSxcclxuICBwcm9jZXNzU2VxdWVuY2VzOiBmdW5jdGlvbiAoaXNGaXJzdEZyYW1lKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB0aGlzLnNlcXVlbmNlTGlzdC5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5wcm9jZXNzU2VxdWVuY2UodGhpcy5zZXF1ZW5jZUxpc3RbaV0sIGlzRmlyc3RGcmFtZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBnZXROZXdLZXk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudCArPSAxO1xyXG4gICAgcmV0dXJuICdfJyArIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudDtcclxuICB9LFxyXG59O1xyXG5cclxuLyogZ2xvYmFsIFNoYXBlUHJvcGVydHlGYWN0b3J5LCBTVkdTaGFwZURhdGEgKi9cclxuXHJcbmZ1bmN0aW9uIENWU2hhcGVEYXRhKGVsZW1lbnQsIGRhdGEsIHN0eWxlcywgdHJhbnNmb3Jtc01hbmFnZXIpIHtcclxuICB0aGlzLnN0eWxlZFNoYXBlcyA9IFtdO1xyXG4gIHRoaXMudHIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XHJcbiAgdmFyIHR5ID0gNDtcclxuICBpZiAoZGF0YS50eSA9PT0gJ3JjJykge1xyXG4gICAgdHkgPSA1O1xyXG4gIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2VsJykge1xyXG4gICAgdHkgPSA2O1xyXG4gIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ3NyJykge1xyXG4gICAgdHkgPSA3O1xyXG4gIH1cclxuICB0aGlzLnNoID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wKGVsZW1lbnQsIGRhdGEsIHR5LCBlbGVtZW50KTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gc3R5bGVzLmxlbmd0aDtcclxuICB2YXIgc3R5bGVkU2hhcGU7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAoIXN0eWxlc1tpXS5jbG9zZWQpIHtcclxuICAgICAgc3R5bGVkU2hhcGUgPSB7XHJcbiAgICAgICAgdHJhbnNmb3JtczogdHJhbnNmb3Jtc01hbmFnZXIuYWRkVHJhbnNmb3JtU2VxdWVuY2Uoc3R5bGVzW2ldLnRyYW5zZm9ybXMpLFxyXG4gICAgICAgIHRyTm9kZXM6IFtdLFxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnN0eWxlZFNoYXBlcy5wdXNoKHN0eWxlZFNoYXBlKTtcclxuICAgICAgc3R5bGVzW2ldLmVsZW1lbnRzLnB1c2goc3R5bGVkU2hhcGUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuQ1ZTaGFwZURhdGEucHJvdG90eXBlLnNldEFzQW5pbWF0ZWQgPSBTVkdTaGFwZURhdGEucHJvdG90eXBlLnNldEFzQW5pbWF0ZWQ7XHJcblxyXG4vKiBnbG9iYWwgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlLCBFZmZlY3RzRXhwcmVzc2lvbkludGVyZmFjZSwgQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UsIFNoYXBlRXhwcmVzc2lvbkludGVyZmFjZSxcclxuVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UsIGdldEJsZW5kTW9kZSxjcmVhdGVFbGVtZW50SUQsIEVmZmVjdHNNYW5hZ2VyICovXHJcblxyXG5mdW5jdGlvbiBCYXNlRWxlbWVudCgpIHtcclxufVxyXG5cclxuQmFzZUVsZW1lbnQucHJvdG90eXBlID0ge1xyXG4gIGNoZWNrTWFza3M6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghdGhpcy5kYXRhLmhhc01hc2spIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgaWYgKCh0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJyAmJiB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzW2ldLmNsICE9PSBmYWxzZSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuICBpbml0RXhwcmVzc2lvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UgPSBMYXllckV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XHJcbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2sgJiYgdGhpcy5tYXNrTWFuYWdlcikge1xyXG4gICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnJlZ2lzdGVyTWFza0ludGVyZmFjZSh0aGlzLm1hc2tNYW5hZ2VyKTtcclxuICAgIH1cclxuICAgIHZhciBlZmZlY3RzSW50ZXJmYWNlID0gRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UuY3JlYXRlRWZmZWN0c0ludGVyZmFjZSh0aGlzLCB0aGlzLmxheWVySW50ZXJmYWNlKTtcclxuICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UucmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlKGVmZmVjdHNJbnRlcmZhY2UpO1xyXG5cclxuICAgIGlmICh0aGlzLmRhdGEudHkgPT09IDAgfHwgdGhpcy5kYXRhLnh0KSB7XHJcbiAgICAgIHRoaXMuY29tcEludGVyZmFjZSA9IENvbXBFeHByZXNzaW9uSW50ZXJmYWNlKHRoaXMpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGEudHkgPT09IDQpIHtcclxuICAgICAgdGhpcy5sYXllckludGVyZmFjZS5zaGFwZUludGVyZmFjZSA9IFNoYXBlRXhwcmVzc2lvbkludGVyZmFjZSh0aGlzLnNoYXBlc0RhdGEsIHRoaXMuaXRlbXNEYXRhLCB0aGlzLmxheWVySW50ZXJmYWNlKTtcclxuICAgICAgdGhpcy5sYXllckludGVyZmFjZS5jb250ZW50ID0gdGhpcy5sYXllckludGVyZmFjZS5zaGFwZUludGVyZmFjZTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLnR5ID09PSA1KSB7XHJcbiAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UudGV4dEludGVyZmFjZSA9IFRleHRFeHByZXNzaW9uSW50ZXJmYWNlKHRoaXMpO1xyXG4gICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnRleHQgPSB0aGlzLmxheWVySW50ZXJmYWNlLnRleHRJbnRlcmZhY2U7XHJcbiAgICB9XHJcbiAgfSxcclxuICBzZXRCbGVuZE1vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBibGVuZE1vZGVWYWx1ZSA9IGdldEJsZW5kTW9kZSh0aGlzLmRhdGEuYm0pO1xyXG4gICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VFbGVtZW50IHx8IHRoaXMubGF5ZXJFbGVtZW50O1xyXG5cclxuICAgIGVsZW0uc3R5bGVbJ21peC1ibGVuZC1tb2RlJ10gPSBibGVuZE1vZGVWYWx1ZTtcclxuICB9LFxyXG4gIGluaXRCYXNlRGF0YTogZnVuY3Rpb24gKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YSA9IGdsb2JhbERhdGE7XHJcbiAgICB0aGlzLmNvbXAgPSBjb21wO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMubGF5ZXJJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xyXG5cclxuICAgIC8vIFN0cmV0Y2ggZmFjdG9yIGZvciBvbGQgYW5pbWF0aW9ucyBtaXNzaW5nIHRoaXMgcHJvcGVydHkuXHJcbiAgICBpZiAoIXRoaXMuZGF0YS5zcikge1xyXG4gICAgICB0aGlzLmRhdGEuc3IgPSAxO1xyXG4gICAgfVxyXG4gICAgLy8gZWZmZWN0cyBtYW5hZ2VyXHJcbiAgICB0aGlzLmVmZmVjdHNNYW5hZ2VyID0gbmV3IEVmZmVjdHNNYW5hZ2VyKHRoaXMuZGF0YSwgdGhpcywgdGhpcy5keW5hbWljUHJvcGVydGllcyk7XHJcbiAgfSxcclxuICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50eXBlO1xyXG4gIH0sXHJcbiAgc291cmNlUmVjdEF0VGltZTogZnVuY3Rpb24gKCkge30sXHJcbn07XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50ICovXHJcblxyXG5mdW5jdGlvbiBOdWxsRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5pbml0RnJhbWUoKTtcclxuICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICB0aGlzLmluaXRGcmFtZSgpO1xyXG4gIHRoaXMuaW5pdFRyYW5zZm9ybShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcclxufVxyXG5cclxuTnVsbEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcclxuICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5OdWxsRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5OdWxsRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5OdWxsRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbk51bGxFbGVtZW50LnByb3RvdHlwZS5zb3VyY2VSZWN0QXRUaW1lID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuTnVsbEVsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnRdLCBOdWxsRWxlbWVudCk7XHJcblxyXG4vKiBnbG9iYWwgZmlsdGVyc0ZhY3RvcnksIGZlYXR1cmVTdXBwb3J0LCBmaWx0ZXJzRmFjdG9yeSwgY3JlYXRlRWxlbWVudElELCBjcmVhdGVOUywgTWFza0VsZW1lbnQsIFNWR0VmZmVjdHMsIGxvY2F0aW9uSHJlZiAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHQmFzZUVsZW1lbnQoKSB7XHJcbn1cclxuXHJcblNWR0Jhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICBpbml0UmVuZGVyZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgfSxcclxuICBjcmVhdGVDb250YWluZXJFbGVtZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5tYXR0ZUVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcclxuICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xyXG4gICAgdGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuICAgIHZhciBsYXllckVsZW1lbnRQYXJlbnQgPSBudWxsO1xyXG4gICAgLy8gSWYgdGhpcyBsYXllciBhY3RzIGFzIGEgbWFzayBmb3IgdGhlIGZvbGxvd2luZyBsYXllclxyXG4gICAgdmFyIGZpbElkO1xyXG4gICAgdmFyIGZpbDtcclxuICAgIHZhciBnZztcclxuICAgIGlmICh0aGlzLmRhdGEudGQpIHtcclxuICAgICAgaWYgKHRoaXMuZGF0YS50ZCA9PSAzIHx8IHRoaXMuZGF0YS50ZCA9PSAxKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICAgICAgdmFyIG1hc2tlciA9IGNyZWF0ZU5TKCdtYXNrJyk7XHJcbiAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmxheWVySWQpO1xyXG4gICAgICAgIG1hc2tlci5zZXRBdHRyaWJ1dGUoJ21hc2stdHlwZScsIHRoaXMuZGF0YS50ZCA9PSAzID8gJ2x1bWluYW5jZScgOiAnYWxwaGEnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgICBtYXNrZXIuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xyXG4gICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IG1hc2tlcjtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChtYXNrZXIpO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgb25seSBmb3IgSUUgYW5kIEVkZ2Ugd2hlbiBtYXNrIGlmIG9mIHR5cGUgYWxwaGFcclxuICAgICAgICBpZiAoIWZlYXR1cmVTdXBwb3J0Lm1hc2tUeXBlICYmIHRoaXMuZGF0YS50ZCA9PSAxKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICAgICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnbHVtaW5hbmNlJyk7XHJcbiAgICAgICAgICBmaWxJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xyXG4gICAgICAgICAgZmlsID0gZmlsdGVyc0ZhY3RvcnkuY3JlYXRlRmlsdGVyKGZpbElkKTtcclxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGZpbCk7XHJcbiAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmlsdGVyc0ZhY3RvcnkuY3JlYXRlQWxwaGFUb0x1bWluYW5jZUZpbHRlcigpKTtcclxuICAgICAgICAgIGdnID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgICAgICAgIGdnLmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcclxuICAgICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IGdnO1xyXG4gICAgICAgICAgbWFza2VyLmFwcGVuZENoaWxkKGdnKTtcclxuICAgICAgICAgIGdnLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgJ3VybCgnICsgbG9jYXRpb25IcmVmICsgJyMnICsgZmlsSWQgKyAnKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEudGQgPT0gMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxyXG4gICAgICAgIHZhciBtYXNrR3JvdXAgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgICAgIG1hc2tHcm91cC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5sYXllcklkKTtcclxuICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcclxuICAgICAgICB2YXIgbWFza0dyb3VwZXIgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgICAgIG1hc2tHcm91cC5hcHBlbmRDaGlsZChtYXNrR3JvdXBlcik7XHJcbiAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICAgICAgICBmaWwgPSBmaWx0ZXJzRmFjdG9yeS5jcmVhdGVGaWx0ZXIoZmlsSWQpO1xyXG4gICAgICAgIC8vLyAvXHJcblxyXG4gICAgICAgIC8vIFRoaXMgc29sdXRpb24gZG9lc24ndCB3b3JrIG9uIEFuZHJvaWQgd2hlbiBtZXRhIHRhZyB3aXRoIHZpZXdwb3J0IGF0dHJpYnV0ZSBpcyBzZXRcclxuICAgICAgICAvKiB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XHJcbiAgICAgICAgICAgICAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcclxuICAgICAgICAgICAgICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xyXG4gICAgICAgICAgICAgICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsJzEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIC0xIDEnKTtcclxuICAgICAgICAgICAgICAgIGZpbC5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTsgKi9cclxuICAgICAgICAvLy8gL1xyXG4gICAgICAgIHZhciBmZUNUciA9IGNyZWF0ZU5TKCdmZUNvbXBvbmVudFRyYW5zZmVyJyk7XHJcbiAgICAgICAgZmVDVHIuc2V0QXR0cmlidXRlKCdpbicsICdTb3VyY2VHcmFwaGljJyk7XHJcbiAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZlQ1RyKTtcclxuICAgICAgICB2YXIgZmVGdW5jID0gY3JlYXRlTlMoJ2ZlRnVuY0EnKTtcclxuICAgICAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RhYmxlJyk7XHJcbiAgICAgICAgZmVGdW5jLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCAnMS4wIDAuMCcpO1xyXG4gICAgICAgIGZlQ1RyLmFwcGVuZENoaWxkKGZlRnVuYyk7XHJcbiAgICAgICAgLy8vIC9cclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xyXG4gICAgICAgIHZhciBhbHBoYVJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xyXG4gICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5jb21wLmRhdGEudyk7XHJcbiAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5jb21wLmRhdGEuaCk7XHJcbiAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgneCcsICcwJyk7XHJcbiAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgneScsICcwJyk7XHJcbiAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsICcjZmZmZmZmJyk7XHJcbiAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsICcwJyk7XHJcbiAgICAgICAgbWFza0dyb3VwZXIuc2V0QXR0cmlidXRlKCdmaWx0ZXInLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBmaWxJZCArICcpJyk7XHJcbiAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoYWxwaGFSZWN0KTtcclxuICAgICAgICBtYXNrR3JvdXBlci5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XHJcbiAgICAgICAgbGF5ZXJFbGVtZW50UGFyZW50ID0gbWFza0dyb3VwZXI7XHJcbiAgICAgICAgaWYgKCFmZWF0dXJlU3VwcG9ydC5tYXNrVHlwZSkge1xyXG4gICAgICAgICAgbWFza0dyb3VwLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xyXG4gICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XHJcbiAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgICAgICAgICBtYXNrR3JvdXBlci5hcHBlbmRDaGlsZChhbHBoYVJlY3QpO1xyXG4gICAgICAgICAgZ2cuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xyXG4gICAgICAgICAgbGF5ZXJFbGVtZW50UGFyZW50ID0gZ2c7XHJcbiAgICAgICAgICBtYXNrR3JvdXBlci5hcHBlbmRDaGlsZChnZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2tHcm91cCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLnR0KSB7XHJcbiAgICAgIHRoaXMubWF0dGVFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcclxuICAgICAgbGF5ZXJFbGVtZW50UGFyZW50ID0gdGhpcy5tYXR0ZUVsZW1lbnQ7XHJcbiAgICAgIHRoaXMuYmFzZUVsZW1lbnQgPSB0aGlzLm1hdHRlRWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYmFzZUVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmRhdGEubG4pIHtcclxuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5kYXRhLmNsKSB7XHJcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLmRhdGEuY2wpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2xpcHBpbmcgY29tcG9zaXRpb25zIHRvIGhpZGUgY29udGVudCB0aGF0IGV4Y2VlZHMgYm91bmRhcmllcy4gSWYgY29sbGFwc2VkIHRyYW5zZm9ybWF0aW9ucyBpcyBvbiwgY29tcG9uZW50IHNob3VsZCBub3QgYmUgY2xpcHBlZFxyXG4gICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gMCAmJiAhdGhpcy5kYXRhLmhkKSB7XHJcbiAgICAgIHZhciBjcCA9IGNyZWF0ZU5TKCdjbGlwUGF0aCcpO1xyXG4gICAgICB2YXIgcHQgPSBjcmVhdGVOUygncGF0aCcpO1xyXG4gICAgICBwdC5zZXRBdHRyaWJ1dGUoJ2QnLCAnTTAsMCBMJyArIHRoaXMuZGF0YS53ICsgJywwIEwnICsgdGhpcy5kYXRhLncgKyAnLCcgKyB0aGlzLmRhdGEuaCArICcgTDAsJyArIHRoaXMuZGF0YS5oICsgJ3onKTtcclxuICAgICAgdmFyIGNsaXBJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xyXG4gICAgICBjcC5zZXRBdHRyaWJ1dGUoJ2lkJywgY2xpcElkKTtcclxuICAgICAgY3AuYXBwZW5kQ2hpbGQocHQpO1xyXG4gICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChjcCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5jaGVja01hc2tzKCkpIHtcclxuICAgICAgICB2YXIgY3BHcm91cCA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgICAgICAgY3BHcm91cC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJyArIGNsaXBJZCArICcpJyk7XHJcbiAgICAgICAgY3BHcm91cC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSBjcEdyb3VwO1xyXG4gICAgICAgIGlmIChsYXllckVsZW1lbnRQYXJlbnQpIHtcclxuICAgICAgICAgIGxheWVyRWxlbWVudFBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuYmFzZUVsZW1lbnQgPSB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBjbGlwSWQgKyAnKScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5kYXRhLmJtICE9PSAwKSB7XHJcbiAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKCk7XHJcbiAgICB9XHJcbiAgfSxcclxuICByZW5kZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdGhpcy5maW5hbFRyYW5zZm9ybS5tYXQudG8yZENTUygpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udik7XHJcbiAgICB9XHJcbiAgfSxcclxuICBkZXN0cm95QmFzZUVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gbnVsbDtcclxuICAgIHRoaXMubWF0dGVFbGVtZW50ID0gbnVsbDtcclxuICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xyXG4gIH0sXHJcbiAgZ2V0QmFzZUVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmRhdGEuaGQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5iYXNlRWxlbWVudDtcclxuICB9LFxyXG4gIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbmV3IE1hc2tFbGVtZW50KHRoaXMuZGF0YSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcclxuICAgIHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyID0gbmV3IFNWR0VmZmVjdHModGhpcyk7XHJcbiAgfSxcclxuICBzZXRNYXR0ZTogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICBpZiAoIXRoaXMubWF0dGVFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMubWF0dGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJyArIGlkICsgJyknKTtcclxuICB9LFxyXG59O1xyXG5cclxuLyogZ2xvYmFsIFByb2Nlc3NlZEVsZW1lbnQgKi9cclxuXHJcbmZ1bmN0aW9uIElTaGFwZUVsZW1lbnQoKSB7XHJcbn1cclxuXHJcbklTaGFwZUVsZW1lbnQucHJvdG90eXBlID0ge1xyXG4gIGFkZFNoYXBlVG9Nb2RpZmllcnM6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlTW9kaWZpZXJzLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzW2ldLmFkZFNoYXBlKGRhdGEpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgaXNTaGFwZUluQW5pbWF0ZWRNb2RpZmllcnM6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICBpZiAodGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5pc0FuaW1hdGVkV2l0aFNoYXBlKGRhdGEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG4gIHJlbmRlck1vZGlmaWVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLnNoYXBlTW9kaWZpZXJzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5zaGFwZXNbaV0uc2gucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBsZW4gPSB0aGlzLnNoYXBlTW9kaWZpZXJzLmxlbmd0aDtcclxuICAgIHZhciBzaG91bGRCcmVha1Byb2Nlc3M7XHJcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICBzaG91bGRCcmVha1Byb2Nlc3MgPSB0aGlzLnNoYXBlTW9kaWZpZXJzW2ldLnByb2Nlc3NTaGFwZXModGhpcy5faXNGaXJzdEZyYW1lKTtcclxuICAgICAgLy8gd29ya2Fyb3VuZCB0byBmaXggY2FzZXMgd2hlcmUgYSByZXBlYXRlciByZXNldHMgdGhlIHNoYXBlIHNvIHRoZSBmb2xsb3dpbmcgcHJvY2Vzc2VzIGdldCBjYWxsZWQgdHdpY2VcclxuICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiBmb3IgdGhpc1xyXG4gICAgICBpZiAoc2hvdWxkQnJlYWtQcm9jZXNzKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBzZWFyY2hQcm9jZXNzZWRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5wcm9jZXNzZWRFbGVtZW50cztcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICBpZiAoZWxlbWVudHNbaV0uZWxlbSA9PT0gZWxlbSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50c1tpXS5wb3M7XHJcbiAgICAgIH1cclxuICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfSxcclxuICBhZGRQcm9jZXNzZWRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbSwgcG9zKSB7XHJcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzO1xyXG4gICAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSkge1xyXG4gICAgICBpIC09IDE7XHJcbiAgICAgIGlmIChlbGVtZW50c1tpXS5lbGVtID09PSBlbGVtKSB7XHJcbiAgICAgICAgZWxlbWVudHNbaV0ucG9zID0gcG9zO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxlbWVudHMucHVzaChuZXcgUHJvY2Vzc2VkRWxlbWVudChlbGVtLCBwb3MpKTtcclxuICB9LFxyXG4gIHByZXBhcmVGcmFtZTogZnVuY3Rpb24gKG51bSkge1xyXG4gICAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XHJcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vKiBnbG9iYWwgVGV4dFByb3BlcnR5LCBUZXh0QW5pbWF0b3JQcm9wZXJ0eSwgYnVpbGRTaGFwZVN0cmluZywgTGV0dGVyUHJvcHMgKi9cclxuXHJcbmZ1bmN0aW9uIElUZXh0RWxlbWVudCgpIHtcclxufVxyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSB0cnVlO1xyXG4gIHRoaXMuaW5pdEZyYW1lKCk7XHJcbiAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy50ZXh0UHJvcGVydHkgPSBuZXcgVGV4dFByb3BlcnR5KHRoaXMsIGRhdGEudCwgdGhpcy5keW5hbWljUHJvcGVydGllcyk7XHJcbiAgdGhpcy50ZXh0QW5pbWF0b3IgPSBuZXcgVGV4dEFuaW1hdG9yUHJvcGVydHkoZGF0YS50LCB0aGlzLnJlbmRlclR5cGUsIHRoaXMpO1xyXG4gIHRoaXMuaW5pdFRyYW5zZm9ybShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcclxuICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XHJcbiAgdGhpcy5pbml0UmVuZGVyZXJFbGVtZW50KCk7XHJcbiAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xyXG4gIHRoaXMuY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKTtcclxuICB0aGlzLmNyZWF0ZUNvbnRlbnQoKTtcclxuICB0aGlzLmhpZGUoKTtcclxuICB0aGlzLnRleHRBbmltYXRvci5zZWFyY2hQcm9wZXJ0aWVzKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xyXG59O1xyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XHJcbiAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRoaXMuaXNJblJhbmdlKTtcclxuICBpZiAodGhpcy50ZXh0UHJvcGVydHkuX21kZiB8fCB0aGlzLnRleHRQcm9wZXJ0eS5faXNGaXJzdEZyYW1lKSB7XHJcbiAgICB0aGlzLmJ1aWxkTmV3VGV4dCgpO1xyXG4gICAgdGhpcy50ZXh0UHJvcGVydHkuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xyXG4gICAgdGhpcy50ZXh0UHJvcGVydHkuX21kZiA9IGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlUGF0aFNoYXBlID0gZnVuY3Rpb24gKG1hdHJpeEhlbHBlciwgc2hhcGVzKSB7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW4gPSBzaGFwZXMubGVuZ3RoO1xyXG4gIHZhciBwYXRoTm9kZXM7XHJcbiAgdmFyIHNoYXBlU3RyID0gJyc7XHJcbiAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgcGF0aE5vZGVzID0gc2hhcGVzW2pdLmtzLms7XHJcbiAgICBzaGFwZVN0ciArPSBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgcGF0aE5vZGVzLmkubGVuZ3RoLCB0cnVlLCBtYXRyaXhIZWxwZXIpO1xyXG4gIH1cclxuICByZXR1cm4gc2hhcGVTdHI7XHJcbn07XHJcblxyXG5JVGV4dEVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xyXG4gIHRoaXMudGV4dFByb3BlcnR5LnVwZGF0ZURvY3VtZW50RGF0YShuZXdEYXRhLCBpbmRleCk7XHJcbn07XHJcblxyXG5JVGV4dEVsZW1lbnQucHJvdG90eXBlLmNhblJlc2l6ZUZvbnQgPSBmdW5jdGlvbiAoX2NhblJlc2l6ZSkge1xyXG4gIHRoaXMudGV4dFByb3BlcnR5LmNhblJlc2l6ZUZvbnQoX2NhblJlc2l6ZSk7XHJcbn07XHJcblxyXG5JVGV4dEVsZW1lbnQucHJvdG90eXBlLnNldE1pbmltdW1Gb250U2l6ZSA9IGZ1bmN0aW9uIChfZm9udFNpemUpIHtcclxuICB0aGlzLnRleHRQcm9wZXJ0eS5zZXRNaW5pbXVtRm9udFNpemUoX2ZvbnRTaXplKTtcclxufTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4ID0gZnVuY3Rpb24gKGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsaW5lTnVtYmVyLCB4UG9zLCB5UG9zKSB7XHJcbiAgaWYgKGRvY3VtZW50RGF0YS5wcykge1xyXG4gICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEucHNbMF0sIGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQsIDApO1xyXG4gIH1cclxuICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIC1kb2N1bWVudERhdGEubHMsIDApO1xyXG4gIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcclxuICAgIGNhc2UgMTpcclxuICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsaW5lTnVtYmVyXSksIDAsIDApO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMjpcclxuICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsaW5lTnVtYmVyXSkgLyAyLCAwLCAwKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSh4UG9zLCB5UG9zLCAwKTtcclxufTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUuYnVpbGRDb2xvciA9IGZ1bmN0aW9uIChjb2xvckRhdGEpIHtcclxuICByZXR1cm4gJ3JnYignICsgTWF0aC5yb3VuZChjb2xvckRhdGFbMF0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChjb2xvckRhdGFbMV0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChjb2xvckRhdGFbMl0gKiAyNTUpICsgJyknO1xyXG59O1xyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS5lbXB0eVByb3AgPSBuZXcgTGV0dGVyUHJvcHMoKTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbn07XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gSUNvbXBFbGVtZW50KCkge31cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnRdLCBJQ29tcEVsZW1lbnQpO1xyXG5cclxuSUNvbXBFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5pbml0RnJhbWUoKTtcclxuICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xyXG4gIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xyXG4gIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xyXG4gIHRoaXMuY3JlYXRlQ29udGFpbmVyRWxlbWVudHMoKTtcclxuICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XHJcbiAgaWYgKHRoaXMuZGF0YS54dCB8fCAhZ2xvYmFsRGF0YS5wcm9ncmVzc2l2ZUxvYWQpIHtcclxuICAgIHRoaXMuYnVpbGRBbGxJdGVtcygpO1xyXG4gIH1cclxuICB0aGlzLmhpZGUoKTtcclxufTtcclxuXHJcbi8qIElDb21wRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZighdGhpcy5oaWRkZW4pe1xyXG4gICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoKTtcclxuICAgICAgICB2YXIgaSxsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IoIGkgPSAwOyBpIDwgbGVuOyBpKz0xICl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07ICovXHJcblxyXG5JQ29tcEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcclxuICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcclxuICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xyXG4gIGlmICghdGhpcy5pc0luUmFuZ2UgJiYgIXRoaXMuZGF0YS54dCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF0aGlzLnRtLl9wbGFjZWhvbGRlcikge1xyXG4gICAgdmFyIHRpbWVSZW1hcHBlZCA9IHRoaXMudG0udjtcclxuICAgIGlmICh0aW1lUmVtYXBwZWQgPT09IHRoaXMuZGF0YS5vcCkge1xyXG4gICAgICB0aW1lUmVtYXBwZWQgPSB0aGlzLmRhdGEub3AgLSAxO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gdGltZVJlbWFwcGVkO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW0gLyB0aGlzLmRhdGEuc3I7XHJcbiAgfVxyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcclxuICAgIHRoaXMuY2hlY2tMYXllcnModGhpcy5yZW5kZXJlZEZyYW1lKTtcclxuICB9XHJcbiAgLy8gVGhpcyBpdGVyYXRpb24gbmVlZHMgdG8gYmUgYmFja3dhcmRzIGJlY2F1c2Ugb2YgaG93IGV4cHJlc3Npb25zIGNvbm5lY3QgYmV0d2VlbiBlYWNoIG90aGVyXHJcbiAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgIGlmICh0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pIHtcclxuICAgICAgdGhpcy5lbGVtZW50c1tpXS5wcmVwYXJlRnJhbWUodGhpcy5yZW5kZXJlZEZyYW1lIC0gdGhpcy5sYXllcnNbaV0uc3QpO1xyXG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXS5fbWRmKSB7XHJcbiAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbklDb21wRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5JQ29tcEVsZW1lbnQucHJvdG90eXBlLnNldEVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZW1zKSB7XHJcbiAgdGhpcy5lbGVtZW50cyA9IGVsZW1zO1xyXG59O1xyXG5cclxuSUNvbXBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5lbGVtZW50cztcclxufTtcclxuXHJcbklDb21wRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5JQ29tcEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5kZXN0cm95RWxlbWVudHMoKTtcclxuICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50LCBjcmVhdGVOUyAqL1xyXG5cclxuZnVuY3Rpb24gSUltYWdlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gIHRoaXMuc291cmNlUmVjdCA9IHtcclxuICAgIHRvcDogMCwgbGVmdDogMCwgd2lkdGg6IHRoaXMuYXNzZXREYXRhLncsIGhlaWdodDogdGhpcy5hc3NldERhdGEuaCxcclxuICB9O1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudF0sIElJbWFnZUVsZW1lbnQpO1xyXG5cclxuSUltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xyXG5cclxuICB0aGlzLmlubmVyRWxlbSA9IGNyZWF0ZU5TKCdpbWFnZScpO1xyXG4gIHRoaXMuaW5uZXJFbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmFzc2V0RGF0YS53ICsgJ3B4Jyk7XHJcbiAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmFzc2V0RGF0YS5oICsgJ3B4Jyk7XHJcbiAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgdGhpcy5hc3NldERhdGEucHIgfHwgdGhpcy5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8pO1xyXG4gIHRoaXMuaW5uZXJFbGVtLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCBhc3NldFBhdGgpO1xyXG5cclxuICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlubmVyRWxlbSk7XHJcbn07XHJcblxyXG5JSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5zb3VyY2VSZWN0QXRUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnNvdXJjZVJlY3Q7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBJSW1hZ2VFbGVtZW50LCBjcmVhdGVOUyAqL1xyXG5cclxuZnVuY3Rpb24gSVNvbGlkRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxufVxyXG5leHRlbmRQcm90b3R5cGUoW0lJbWFnZUVsZW1lbnRdLCBJU29saWRFbGVtZW50KTtcclxuXHJcbklTb2xpZEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xyXG4gIC8vLyAvcmVjdC5zdHlsZS53aWR0aCA9IHRoaXMuZGF0YS5zdztcclxuICAvLy8gL3JlY3Quc3R5bGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNoO1xyXG4gIC8vLyAvcmVjdC5zdHlsZS5maWxsID0gdGhpcy5kYXRhLnNjO1xyXG4gIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS5zdyk7XHJcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5zaCk7XHJcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmRhdGEuc2MpO1xyXG4gIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHJlY3QpO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIFByb3BlcnR5RmFjdG9yeSwgZXh0ZW5kUHJvdG90eXBlLCBSZW5kZXJhYmxlRWxlbWVudCwgQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gQXVkaW9FbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLmluaXRGcmFtZSgpO1xyXG4gIHRoaXMuaW5pdFJlbmRlcmFibGUoKTtcclxuICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xyXG4gIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gIHRoaXMuX2NhblBsYXkgPSBmYWxzZTtcclxuICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xyXG4gIHRoaXMuYXVkaW8gPSB0aGlzLmdsb2JhbERhdGEuYXVkaW9Db250cm9sbGVyLmNyZWF0ZUF1ZGlvKGFzc2V0UGF0aCk7XHJcbiAgdGhpcy5fY3VycmVudFRpbWUgPSAwO1xyXG4gIHRoaXMuZ2xvYmFsRGF0YS5hdWRpb0NvbnRyb2xsZXIuYWRkQXVkaW8odGhpcyk7XHJcbiAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7IF9wbGFjZWhvbGRlcjogdHJ1ZSB9O1xyXG59XHJcblxyXG5BdWRpb0VsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcclxuICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtLCB0cnVlKTtcclxuICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XHJcbiAgaWYgKCF0aGlzLnRtLl9wbGFjZWhvbGRlcikge1xyXG4gICAgdmFyIHRpbWVSZW1hcHBlZCA9IHRoaXMudG0udjtcclxuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gdGltZVJlbWFwcGVkO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IG51bSAvIHRoaXMuZGF0YS5zcjtcclxuICB9XHJcbn07XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW1JlbmRlcmFibGVFbGVtZW50LCBCYXNlRWxlbWVudCwgRnJhbWVFbGVtZW50XSwgQXVkaW9FbGVtZW50KTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMuaXNJblJhbmdlICYmIHRoaXMuX2NhblBsYXkpIHtcclxuICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgIHRoaXMuYXVkaW8ucGxheSgpO1xyXG4gICAgICB0aGlzLmF1ZGlvLnNlZWsodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmdsb2JhbERhdGEuZnJhbWVSYXRlKTtcclxuICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoIXRoaXMuYXVkaW8ucGxheWluZygpXHJcbiAgICAgIHx8IE1hdGguYWJzKHRoaXMuX2N1cnJlbnRUaW1lIC8gdGhpcy5nbG9iYWxEYXRhLmZyYW1lUmF0ZSAtIHRoaXMuYXVkaW8uc2VlaygpKSA+IDAuMVxyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuYXVkaW8uc2Vlayh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAvLyB0aGlzLmF1ZGlvLnBsYXkoKVxyXG59O1xyXG5cclxuQXVkaW9FbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuYXVkaW8ucGF1c2UoKTtcclxuICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxufTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5hdWRpby5wYXVzZSgpO1xyXG4gIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gIHRoaXMuX2NhblBsYXkgPSBmYWxzZTtcclxufTtcclxuXHJcbkF1ZGlvRWxlbWVudC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuX2NhblBsYXkgPSB0cnVlO1xyXG59O1xyXG5cclxuQXVkaW9FbGVtZW50LnByb3RvdHlwZS5zZXRSYXRlID0gZnVuY3Rpb24gKHJhdGVWYWx1ZSkge1xyXG4gIHRoaXMuYXVkaW8ucmF0ZShyYXRlVmFsdWUpO1xyXG59O1xyXG5cclxuQXVkaW9FbGVtZW50LnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lVmFsdWUpIHtcclxuICB0aGlzLmF1ZGlvLnZvbHVtZSh2b2x1bWVWYWx1ZSk7XHJcbn07XHJcblxyXG5BdWRpb0VsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuQXVkaW9FbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuQXVkaW9FbGVtZW50LnByb3RvdHlwZS5zb3VyY2VSZWN0QXRUaW1lID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuQXVkaW9FbGVtZW50LnByb3RvdHlwZS5pbml0RXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgZXh0ZW5kUHJvdG90eXBlLCBSZW5kZXJhYmxlRWxlbWVudCwgQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgRm9vdGFnZUludGVyZmFjZSAqL1xyXG5cclxuZnVuY3Rpb24gRm9vdGFnZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMuaW5pdEZyYW1lKCk7XHJcbiAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xyXG4gIHRoaXMuYXNzZXREYXRhID0gZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEoZGF0YS5yZWZJZCk7XHJcbiAgdGhpcy5mb290YWdlRGF0YSA9IGdsb2JhbERhdGEuaW1hZ2VMb2FkZXIuZ2V0QXNzZXQodGhpcy5hc3NldERhdGEpO1xyXG4gIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG59XHJcblxyXG5Gb290YWdlRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIEZvb3RhZ2VFbGVtZW50KTtcclxuXHJcbkZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbkZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbkZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuRm9vdGFnZUVsZW1lbnQucHJvdG90eXBlLmluaXRFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmxheWVySW50ZXJmYWNlID0gRm9vdGFnZUludGVyZmFjZSh0aGlzKTtcclxufTtcclxuXHJcbkZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5nZXRGb290YWdlRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5mb290YWdlRGF0YTtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5LCBQcm9wZXJ0eUZhY3RvcnksIGV4dGVuZFByb3RvdHlwZSwgU1ZHUmVuZGVyZXIsIElDb21wRWxlbWVudCwgU1ZHQmFzZUVsZW1lbnQgKi9cclxuXHJcbmZ1bmN0aW9uIFNWR0NvbXBFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLmxheWVycyA9IGRhdGEubGF5ZXJzO1xyXG4gIHRoaXMuc3VwcG9ydHMzZCA9IHRydWU7XHJcbiAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xyXG4gIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XHJcbiAgdGhpcy5lbGVtZW50cyA9IHRoaXMubGF5ZXJzID8gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLmxheWVycy5sZW5ndGgpIDogW107XHJcbiAgLy8gdGhpcy5sYXllckVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7IF9wbGFjZWhvbGRlcjogdHJ1ZSB9O1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW1NWR1JlbmRlcmVyLCBJQ29tcEVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50XSwgU1ZHQ29tcEVsZW1lbnQpO1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsXHJcblJlbmRlcmFibGVET01FbGVtZW50LCBJVGV4dEVsZW1lbnQsIGNyZWF0ZVNpemVkQXJyYXksIGNyZWF0ZU5TICovXHJcblxyXG5mdW5jdGlvbiBTVkdUZXh0TG90dGllRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy50ZXh0U3BhbnMgPSBbXTtcclxuICB0aGlzLnJlbmRlclR5cGUgPSAnc3ZnJztcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgSVRleHRFbGVtZW50XSwgU1ZHVGV4dExvdHRpZUVsZW1lbnQpO1xyXG5cclxuU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMuZGF0YS5zaW5nbGVTaGFwZSAmJiAhdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XHJcbiAgICB0aGlzLnRleHRDb250YWluZXIgPSBjcmVhdGVOUygndGV4dCcpO1xyXG4gIH1cclxufTtcclxuXHJcblNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5idWlsZFRleHRDb250ZW50cyA9IGZ1bmN0aW9uICh0ZXh0QXJyYXkpIHtcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIGxlbiA9IHRleHRBcnJheS5sZW5ndGg7XHJcbiAgdmFyIHRleHRDb250ZW50cyA9IFtdO1xyXG4gIHZhciBjdXJyZW50VGV4dENvbnRlbnQgPSAnJztcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgaWYgKHRleHRBcnJheVtpXSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMykgfHwgdGV4dEFycmF5W2ldID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMpKSB7XHJcbiAgICAgIHRleHRDb250ZW50cy5wdXNoKGN1cnJlbnRUZXh0Q29udGVudCk7XHJcbiAgICAgIGN1cnJlbnRUZXh0Q29udGVudCA9ICcnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3VycmVudFRleHRDb250ZW50ICs9IHRleHRBcnJheVtpXTtcclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbiAgdGV4dENvbnRlbnRzLnB1c2goY3VycmVudFRleHRDb250ZW50KTtcclxuICByZXR1cm4gdGV4dENvbnRlbnRzO1xyXG59O1xyXG5cclxuU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuO1xyXG5cclxuICB2YXIgZG9jdW1lbnREYXRhID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGE7XHJcbiAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBjcmVhdGVTaXplZEFycmF5KGRvY3VtZW50RGF0YSA/IGRvY3VtZW50RGF0YS5sLmxlbmd0aCA6IDApO1xyXG4gIGlmIChkb2N1bWVudERhdGEuZmMpIHtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuZmMpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsJywgJ3JnYmEoMCwwLDAsMCknKTtcclxuICB9XHJcbiAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UnLCB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKSk7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGRvY3VtZW50RGF0YS5zdyk7XHJcbiAgfVxyXG4gIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XHJcbiAgdmFyIGZvbnREYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xyXG4gIGlmIChmb250RGF0YS5mQ2xhc3MpIHtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBmb250RGF0YS5mQ2xhc3MpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtZmFtaWx5JywgZm9udERhdGEuZkZhbWlseSk7XHJcbiAgICB2YXIgZldlaWdodCA9IGRvY3VtZW50RGF0YS5mV2VpZ2h0O1xyXG4gICAgdmFyIGZTdHlsZSA9IGRvY3VtZW50RGF0YS5mU3R5bGU7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc3R5bGUnLCBmU3R5bGUpO1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsIGZXZWlnaHQpO1xyXG4gIH1cclxuICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBkb2N1bWVudERhdGEudCk7XHJcblxyXG4gIHZhciBsZXR0ZXJzID0gZG9jdW1lbnREYXRhLmwgfHwgW107XHJcbiAgdmFyIHVzZXNHbHlwaHMgPSAhIXRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycztcclxuICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcclxuXHJcbiAgdmFyIHRTcGFuO1xyXG4gIHZhciBtYXRyaXhIZWxwZXIgPSB0aGlzLm1IZWxwZXI7XHJcbiAgdmFyIHNoYXBlcztcclxuICB2YXIgc2hhcGVTdHIgPSAnJztcclxuICB2YXIgc2luZ2xlU2hhcGUgPSB0aGlzLmRhdGEuc2luZ2xlU2hhcGU7XHJcbiAgdmFyIHhQb3MgPSAwO1xyXG4gIHZhciB5UG9zID0gMDtcclxuICB2YXIgZmlyc3RMaW5lID0gdHJ1ZTtcclxuICB2YXIgdHJhY2tpbmdPZmZzZXQgPSBkb2N1bWVudERhdGEudHIgKiAwLjAwMSAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XHJcbiAgaWYgKHNpbmdsZVNoYXBlICYmICF1c2VzR2x5cGhzICYmICFkb2N1bWVudERhdGEuc3opIHtcclxuICAgIHZhciB0RWxlbWVudCA9IHRoaXMudGV4dENvbnRhaW5lcjtcclxuICAgIHZhciBqdXN0aWZ5ID0gJ3N0YXJ0JztcclxuICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGp1c3RpZnkgPSAnZW5kJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGp1c3RpZnkgPSAnbWlkZGxlJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBqdXN0aWZ5ID0gJ3N0YXJ0JztcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHRFbGVtZW50LnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCBqdXN0aWZ5KTtcclxuICAgIHRFbGVtZW50LnNldEF0dHJpYnV0ZSgnbGV0dGVyLXNwYWNpbmcnLCB0cmFja2luZ09mZnNldCk7XHJcbiAgICB2YXIgdGV4dENvbnRlbnQgPSB0aGlzLmJ1aWxkVGV4dENvbnRlbnRzKGRvY3VtZW50RGF0YS5maW5hbFRleHQpO1xyXG4gICAgbGVuID0gdGV4dENvbnRlbnQubGVuZ3RoO1xyXG4gICAgeVBvcyA9IGRvY3VtZW50RGF0YS5wcyA/IGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQgOiAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHRTcGFuID0gdGhpcy50ZXh0U3BhbnNbaV0gfHwgY3JlYXRlTlMoJ3RzcGFuJyk7XHJcbiAgICAgIHRTcGFuLnRleHRDb250ZW50ID0gdGV4dENvbnRlbnRbaV07XHJcbiAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgneCcsIDApO1xyXG4gICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3knLCB5UG9zKTtcclxuICAgICAgdFNwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcclxuICAgICAgdEVsZW1lbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xyXG4gICAgICB0aGlzLnRleHRTcGFuc1tpXSA9IHRTcGFuO1xyXG4gICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodEVsZW1lbnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY2FjaGVkU3BhbnNMZW5ndGggPSB0aGlzLnRleHRTcGFucy5sZW5ndGg7XHJcbiAgICB2YXIgc2hhcGVEYXRhO1xyXG4gICAgdmFyIGNoYXJEYXRhO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGlmICghdXNlc0dseXBocyB8fCAhc2luZ2xlU2hhcGUgfHwgaSA9PT0gMCkge1xyXG4gICAgICAgIHRTcGFuID0gY2FjaGVkU3BhbnNMZW5ndGggPiBpID8gdGhpcy50ZXh0U3BhbnNbaV0gOiBjcmVhdGVOUyh1c2VzR2x5cGhzID8gJ3BhdGgnIDogJ3RleHQnKTtcclxuICAgICAgICBpZiAoY2FjaGVkU3BhbnNMZW5ndGggPD0gaSkge1xyXG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsICdidXR0Jyk7XHJcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsICdyb3VuZCcpO1xyXG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsICc0Jyk7XHJcbiAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXSA9IHRTcGFuO1xyXG4gICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0U3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcclxuICAgICAgbWF0cml4SGVscGVyLnNjYWxlKGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAsIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDApO1xyXG4gICAgICBpZiAoc2luZ2xlU2hhcGUpIHtcclxuICAgICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XHJcbiAgICAgICAgICB4UG9zID0gLXRyYWNraW5nT2Zmc2V0O1xyXG4gICAgICAgICAgeVBvcyArPSBkb2N1bWVudERhdGEueU9mZnNldDtcclxuICAgICAgICAgIHlQb3MgKz0gZmlyc3RMaW5lID8gMSA6IDA7XHJcbiAgICAgICAgICBmaXJzdExpbmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hcHBseVRleHRQcm9wZXJ0aWVzVG9NYXRyaXgoZG9jdW1lbnREYXRhLCBtYXRyaXhIZWxwZXIsIGxldHRlcnNbaV0ubGluZSwgeFBvcywgeVBvcyk7XHJcbiAgICAgICAgeFBvcyArPSBsZXR0ZXJzW2ldLmwgfHwgMDtcclxuICAgICAgICAvLyB4UG9zICs9IGxldHRlcnNbaV0udmFsID09PSAnICcgPyAwIDogdHJhY2tpbmdPZmZzZXQ7XHJcbiAgICAgICAgeFBvcyArPSB0cmFja2luZ09mZnNldDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodXNlc0dseXBocykge1xyXG4gICAgICAgIGNoYXJEYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHkpO1xyXG4gICAgICAgIHNoYXBlRGF0YSA9IChjaGFyRGF0YSAmJiBjaGFyRGF0YS5kYXRhKSB8fCB7fTtcclxuICAgICAgICBzaGFwZXMgPSBzaGFwZURhdGEuc2hhcGVzID8gc2hhcGVEYXRhLnNoYXBlc1swXS5pdCA6IFtdO1xyXG4gICAgICAgIGlmICghc2luZ2xlU2hhcGUpIHtcclxuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMuY3JlYXRlUGF0aFNoYXBlKG1hdHJpeEhlbHBlciwgc2hhcGVzKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNoYXBlU3RyICs9IHRoaXMuY3JlYXRlUGF0aFNoYXBlKG1hdHJpeEhlbHBlciwgc2hhcGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHNpbmdsZVNoYXBlKSB7XHJcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hdHJpeEhlbHBlci5wcm9wc1sxMl0gKyAnLCcgKyBtYXRyaXhIZWxwZXIucHJvcHNbMTNdICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdFNwYW4udGV4dENvbnRlbnQgPSBsZXR0ZXJzW2ldLnZhbDtcclxuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgJ3htbDpzcGFjZScsICdwcmVzZXJ2ZScpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vXHJcbiAgICB9XHJcbiAgICBpZiAoc2luZ2xlU2hhcGUgJiYgdFNwYW4pIHtcclxuICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdkJywgc2hhcGVTdHIpO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAoaSA8IHRoaXMudGV4dFNwYW5zLmxlbmd0aCkge1xyXG4gICAgdGhpcy50ZXh0U3BhbnNbaV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIGkgKz0gMTtcclxuICB9XHJcblxyXG4gIHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxufTtcclxuXHJcblNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5zb3VyY2VSZWN0QXRUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucHJlcGFyZUZyYW1lKHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC0gdGhpcy5kYXRhLnN0KTtcclxuICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xyXG4gIGlmICh0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG4gICAgdGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuICAgIHZhciB0ZXh0Qm94ID0gdGhpcy5sYXllckVsZW1lbnQuZ2V0QkJveCgpO1xyXG4gICAgdGhpcy5iYm94ID0ge1xyXG4gICAgICB0b3A6IHRleHRCb3gueSxcclxuICAgICAgbGVmdDogdGV4dEJveC54LFxyXG4gICAgICB3aWR0aDogdGV4dEJveC53aWR0aCxcclxuICAgICAgaGVpZ2h0OiB0ZXh0Qm94LmhlaWdodCxcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzLmJib3g7XHJcbn07XHJcblxyXG5TVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICghdGhpcy5kYXRhLnNpbmdsZVNoYXBlKSB7XHJcbiAgICB0aGlzLnRleHRBbmltYXRvci5nZXRNZWFzdXJlcyh0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YSwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpO1xyXG4gICAgaWYgKHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnIHx8IHRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZykge1xyXG4gICAgICB0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuO1xyXG4gICAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xyXG5cclxuICAgICAgdmFyIGxldHRlcnMgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sO1xyXG5cclxuICAgICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XHJcbiAgICAgIHZhciByZW5kZXJlZExldHRlcjtcclxuICAgICAgdmFyIHRleHRTcGFuO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBpZiAoIWxldHRlcnNbaV0ubikge1xyXG4gICAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbaV07XHJcbiAgICAgICAgICB0ZXh0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldO1xyXG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYubSkge1xyXG4gICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHJlbmRlcmVkTGV0dGVyLm0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYubykge1xyXG4gICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCByZW5kZXJlZExldHRlci5vKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLnN3KSB7XHJcbiAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgcmVuZGVyZWRMZXR0ZXIuc3cpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYuc2MpIHtcclxuICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UnLCByZW5kZXJlZExldHRlci5zYyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5mYykge1xyXG4gICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCByZW5kZXJlZExldHRlci5mYyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBJU2hhcGVFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LFxyXG5GcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50LCBNYXRyaXgsIFNWR1N0eWxlRGF0YSwgU1ZHU3Ryb2tlU3R5bGVEYXRhLCBTVkdGaWxsU3R5bGVEYXRhLFxyXG5TVkdHcmFkaWVudEZpbGxTdHlsZURhdGEsIFNWR0dyYWRpZW50U3Ryb2tlU3R5bGVEYXRhLCBsb2NhdGlvbkhyZWYsIGdldEJsZW5kTW9kZSwgU2hhcGVHcm91cERhdGEsXHJcblRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSwgU1ZHVHJhbnNmb3JtRGF0YSwgU2hhcGVQcm9wZXJ0eUZhY3RvcnksIFNWR1NoYXBlRGF0YSwgU1ZHRWxlbWVudHNSZW5kZXJlciwgU2hhcGVNb2RpZmllcnMsXHJcbmxpbmVDYXBFbnVtLCBsaW5lSm9pbkVudW0gKi9cclxuXHJcbmZ1bmN0aW9uIFNWR1NoYXBlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgLy8gTGlzdCBvZiBkcmF3YWJsZSBlbGVtZW50c1xyXG4gIHRoaXMuc2hhcGVzID0gW107XHJcbiAgLy8gRnVsbCBzaGFwZSBkYXRhXHJcbiAgdGhpcy5zaGFwZXNEYXRhID0gZGF0YS5zaGFwZXM7XHJcbiAgLy8gTGlzdCBvZiBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXHJcbiAgdGhpcy5zdHlsZXNMaXN0ID0gW107XHJcbiAgLy8gTGlzdCBvZiBtb2RpZmllcnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXHJcbiAgdGhpcy5zaGFwZU1vZGlmaWVycyA9IFtdO1xyXG4gIC8vIExpc3Qgb2YgaXRlbXMgaW4gc2hhcGUgdHJlZVxyXG4gIHRoaXMuaXRlbXNEYXRhID0gW107XHJcbiAgLy8gTGlzdCBvZiBpdGVtcyBpbiBwcmV2aW91cyBzaGFwZSB0cmVlXHJcbiAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdO1xyXG4gIC8vIExpc3Qgb2YgYW5pbWF0ZWQgY29tcG9uZW50c1xyXG4gIHRoaXMuYW5pbWF0ZWRDb250ZW50cyA9IFtdO1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgLy8gTW92aW5nIGFueSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZ2V0IHRvbyBtdWNoIGFjY2VzcyBhZnRlciBpbml0aWFsaXphdGlvbiBiZWNhdXNlIG9mIHY4IHdheSBvZiBoYW5kbGluZyBtb3JlIHRoYW4gMTAgcHJvcGVydGllcy5cclxuICAvLyBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWRcclxuICB0aGlzLnByZXZWaWV3RGF0YSA9IFtdO1xyXG4gIC8vIE1vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBJU2hhcGVFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgU1ZHU2hhcGVFbGVtZW50KTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaW5pdFNlY29uZGFyeUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmlkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5idWlsZEV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnNlYXJjaFNoYXBlcyh0aGlzLnNoYXBlc0RhdGEsIHRoaXMuaXRlbXNEYXRhLCB0aGlzLnByZXZWaWV3RGF0YSwgdGhpcy5sYXllckVsZW1lbnQsIDAsIFtdLCB0cnVlKTtcclxuICB0aGlzLmZpbHRlclVuaXF1ZVNoYXBlcygpO1xyXG59O1xyXG5cclxuLypcclxuVGhpcyBtZXRob2Qgc2VhcmNoZXMgZm9yIG11bHRpcGxlIHNoYXBlcyB0aGF0IGFmZmVjdCBhIHNpbmdsZSBlbGVtZW50IGFuZCBvbmUgb2YgdGhlbSBpcyBhbmltYXRlZFxyXG4qL1xyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmZpbHRlclVuaXF1ZVNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xyXG4gIHZhciBzaGFwZTtcclxuICB2YXIgajtcclxuICB2YXIgakxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XHJcbiAgdmFyIHN0eWxlO1xyXG4gIHZhciB0ZW1wU2hhcGVzID0gW107XHJcbiAgdmFyIGFyZUFuaW1hdGVkID0gZmFsc2U7XHJcbiAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgc3R5bGUgPSB0aGlzLnN0eWxlc0xpc3Rbal07XHJcbiAgICBhcmVBbmltYXRlZCA9IGZhbHNlO1xyXG4gICAgdGVtcFNoYXBlcy5sZW5ndGggPSAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHNoYXBlID0gdGhpcy5zaGFwZXNbaV07XHJcbiAgICAgIGlmIChzaGFwZS5zdHlsZXMuaW5kZXhPZihzdHlsZSkgIT09IC0xKSB7XHJcbiAgICAgICAgdGVtcFNoYXBlcy5wdXNoKHNoYXBlKTtcclxuICAgICAgICBhcmVBbmltYXRlZCA9IHNoYXBlLl9pc0FuaW1hdGVkIHx8IGFyZUFuaW1hdGVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGVtcFNoYXBlcy5sZW5ndGggPiAxICYmIGFyZUFuaW1hdGVkKSB7XHJcbiAgICAgIHRoaXMuc2V0U2hhcGVzQXNBbmltYXRlZCh0ZW1wU2hhcGVzKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNldFNoYXBlc0FzQW5pbWF0ZWQgPSBmdW5jdGlvbiAoc2hhcGVzKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHNoYXBlcy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBzaGFwZXNbaV0uc2V0QXNBbmltYXRlZCgpO1xyXG4gIH1cclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGxldmVsKSB7XHJcbiAgLy8gVE9ETzogcHJldmVudCBkcmF3aW5nIG9mIGhpZGRlbiBzdHlsZXNcclxuICB2YXIgZWxlbWVudERhdGE7XHJcbiAgdmFyIHN0eWxlT2IgPSBuZXcgU1ZHU3R5bGVEYXRhKGRhdGEsIGxldmVsKTtcclxuXHJcbiAgdmFyIHBhdGhFbGVtZW50ID0gc3R5bGVPYi5wRWxlbTtcclxuICBpZiAoZGF0YS50eSA9PT0gJ3N0Jykge1xyXG4gICAgZWxlbWVudERhdGEgPSBuZXcgU1ZHU3Ryb2tlU3R5bGVEYXRhKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xyXG4gIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2ZsJykge1xyXG4gICAgZWxlbWVudERhdGEgPSBuZXcgU1ZHRmlsbFN0eWxlRGF0YSh0aGlzLCBkYXRhLCBzdHlsZU9iKTtcclxuICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdnZicgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xyXG4gICAgdmFyIEdyYWRpZW50Q29uc3RydWN0b3IgPSBkYXRhLnR5ID09PSAnZ2YnID8gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhIDogU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGE7XHJcbiAgICBlbGVtZW50RGF0YSA9IG5ldyBHcmFkaWVudENvbnN0cnVjdG9yKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEuZ2YpO1xyXG4gICAgaWYgKGVsZW1lbnREYXRhLm1hc2tJZCkge1xyXG4gICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChlbGVtZW50RGF0YS5tcyk7XHJcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGVsZW1lbnREYXRhLm9mKTtcclxuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdtYXNrJywgJ3VybCgnICsgbG9jYXRpb25IcmVmICsgJyMnICsgZWxlbWVudERhdGEubWFza0lkICsgJyknKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChkYXRhLnR5ID09PSAnc3QnIHx8IGRhdGEudHkgPT09ICdncycpIHtcclxuICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBsaW5lQ2FwRW51bVtkYXRhLmxjIHx8IDJdKTtcclxuICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl0pO1xyXG4gICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCAnMCcpO1xyXG4gICAgaWYgKGRhdGEubGogPT09IDEpIHtcclxuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsIGRhdGEubWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGEuciA9PT0gMikge1xyXG4gICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCAnZXZlbm9kZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGEubG4pIHtcclxuICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBkYXRhLmxuKTtcclxuICB9XHJcbiAgaWYgKGRhdGEuY2wpIHtcclxuICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBkYXRhLmNsKTtcclxuICB9XHJcbiAgaWYgKGRhdGEuYm0pIHtcclxuICAgIHBhdGhFbGVtZW50LnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gZ2V0QmxlbmRNb2RlKGRhdGEuYm0pO1xyXG4gIH1cclxuICB0aGlzLnN0eWxlc0xpc3QucHVzaChzdHlsZU9iKTtcclxuICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVHcm91cEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTaGFwZUdyb3VwRGF0YSgpO1xyXG4gIGlmIChkYXRhLmxuKSB7XHJcbiAgICBlbGVtZW50RGF0YS5nci5zZXRBdHRyaWJ1dGUoJ2lkJywgZGF0YS5sbik7XHJcbiAgfVxyXG4gIGlmIChkYXRhLmNsKSB7XHJcbiAgICBlbGVtZW50RGF0YS5nci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZGF0YS5jbCk7XHJcbiAgfVxyXG4gIGlmIChkYXRhLmJtKSB7XHJcbiAgICBlbGVtZW50RGF0YS5nci5zdHlsZVsnbWl4LWJsZW5kLW1vZGUnXSA9IGdldEJsZW5kTW9kZShkYXRhLmJtKTtcclxuICB9XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRhaW5lcikge1xyXG4gIHZhciB0cmFuc2Zvcm1Qcm9wZXJ0eSA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCBkYXRhLCB0aGlzKTtcclxuICB2YXIgZWxlbWVudERhdGEgPSBuZXcgU1ZHVHJhbnNmb3JtRGF0YSh0cmFuc2Zvcm1Qcm9wZXJ0eSwgdHJhbnNmb3JtUHJvcGVydHkubywgY29udGFpbmVyKTtcclxuICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgb3duVHJhbnNmb3JtZXJzLCBsZXZlbCkge1xyXG4gIHZhciB0eSA9IDQ7XHJcbiAgaWYgKGRhdGEudHkgPT09ICdyYycpIHtcclxuICAgIHR5ID0gNTtcclxuICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdlbCcpIHtcclxuICAgIHR5ID0gNjtcclxuICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdzcicpIHtcclxuICAgIHR5ID0gNztcclxuICB9XHJcbiAgdmFyIHNoYXBlUHJvcGVydHkgPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcywgZGF0YSwgdHksIHRoaXMpO1xyXG4gIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTVkdTaGFwZURhdGEob3duVHJhbnNmb3JtZXJzLCBsZXZlbCwgc2hhcGVQcm9wZXJ0eSk7XHJcbiAgdGhpcy5zaGFwZXMucHVzaChlbGVtZW50RGF0YSk7XHJcbiAgdGhpcy5hZGRTaGFwZVRvTW9kaWZpZXJzKGVsZW1lbnREYXRhKTtcclxuICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XHJcbiAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUb0FuaW1hdGVkQ29udGVudHMgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCkge1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gdGhpcy5hbmltYXRlZENvbnRlbnRzLmxlbmd0aDtcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgaWYgKHRoaXMuYW5pbWF0ZWRDb250ZW50c1tpXS5lbGVtZW50ID09PSBlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbiAgdGhpcy5hbmltYXRlZENvbnRlbnRzLnB1c2goe1xyXG4gICAgZm46IFNWR0VsZW1lbnRzUmVuZGVyZXIuY3JlYXRlUmVuZGVyRnVuY3Rpb24oZGF0YSksXHJcbiAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgZGF0YTogZGF0YSxcclxuICB9KTtcclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudFN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtZW50RGF0YSkge1xyXG4gIHZhciBhcnIgPSBlbGVtZW50RGF0YS5zdHlsZXM7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xyXG4gIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgIGlmICghdGhpcy5zdHlsZXNMaXN0W2pdLmNsb3NlZCkge1xyXG4gICAgICBhcnIucHVzaCh0aGlzLnN0eWxlc0xpc3Rbal0pO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVsb2FkU2hhcGVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuaXRlbXNEYXRhLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIHRoaXMucHJldlZpZXdEYXRhW2ldID0gdGhpcy5pdGVtc0RhdGFbaV07XHJcbiAgfVxyXG4gIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0aGlzLmxheWVyRWxlbWVudCwgMCwgW10sIHRydWUpO1xyXG4gIHRoaXMuZmlsdGVyVW5pcXVlU2hhcGVzKCk7XHJcbiAgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLmdldFZhbHVlKCk7XHJcbiAgfVxyXG4gIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XHJcbn07XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNlYXJjaFNoYXBlcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZW1zRGF0YSwgcHJldlZpZXdEYXRhLCBjb250YWluZXIsIGxldmVsLCB0cmFuc2Zvcm1lcnMsIHJlbmRlcikge1xyXG4gIHZhciBvd25UcmFuc2Zvcm1lcnMgPSBbXS5jb25jYXQodHJhbnNmb3JtZXJzKTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIG93blN0eWxlcyA9IFtdO1xyXG4gIHZhciBvd25Nb2RpZmllcnMgPSBbXTtcclxuICB2YXIgY3VycmVudFRyYW5zZm9ybTtcclxuICB2YXIgbW9kaWZpZXI7XHJcbiAgdmFyIHByb2Nlc3NlZFBvcztcclxuICBmb3IgKGkgPSBsZW47IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICBwcm9jZXNzZWRQb3MgPSB0aGlzLnNlYXJjaFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldKTtcclxuICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgIGFycltpXS5fcmVuZGVyID0gcmVuZGVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlbXNEYXRhW2ldID0gcHJldlZpZXdEYXRhW3Byb2Nlc3NlZFBvcyAtIDFdO1xyXG4gICAgfVxyXG4gICAgaWYgKGFycltpXS50eSA9PT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT09ICdzdCcgfHwgYXJyW2ldLnR5ID09PSAnZ2YnIHx8IGFycltpXS50eSA9PT0gJ2dzJykge1xyXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU3R5bGVFbGVtZW50KGFycltpXSwgbGV2ZWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXS5zdHlsZS5jbG9zZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYXJyW2ldLl9yZW5kZXIpIHtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbXNEYXRhW2ldLnN0eWxlLnBFbGVtKTtcclxuICAgICAgfVxyXG4gICAgICBvd25TdHlsZXMucHVzaChpdGVtc0RhdGFbaV0uc3R5bGUpO1xyXG4gICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZUdyb3VwRWxlbWVudChhcnJbaV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGpMZW4gPSBpdGVtc0RhdGFbaV0uaXQubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGFbal0gPSBpdGVtc0RhdGFbaV0uaXRbal07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2VhcmNoU2hhcGVzKGFycltpXS5pdCwgaXRlbXNEYXRhW2ldLml0LCBpdGVtc0RhdGFbaV0ucHJldlZpZXdEYXRhLCBpdGVtc0RhdGFbaV0uZ3IsIGxldmVsICsgMSwgb3duVHJhbnNmb3JtZXJzLCByZW5kZXIpO1xyXG4gICAgICBpZiAoYXJyW2ldLl9yZW5kZXIpIHtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbXNEYXRhW2ldLmdyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0cicpIHtcclxuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldLCBjb250YWluZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gPSBpdGVtc0RhdGFbaV0udHJhbnNmb3JtO1xyXG4gICAgICBvd25UcmFuc2Zvcm1lcnMucHVzaChjdXJyZW50VHJhbnNmb3JtKTtcclxuICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnc2gnIHx8IGFycltpXS50eSA9PT0gJ3JjJyB8fCBhcnJbaV0udHkgPT09ICdlbCcgfHwgYXJyW2ldLnR5ID09PSAnc3InKSB7XHJcbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTaGFwZUVsZW1lbnQoYXJyW2ldLCBvd25UcmFuc2Zvcm1lcnMsIGxldmVsKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZXMoaXRlbXNEYXRhW2ldKTtcclxuICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAndG0nIHx8IGFycltpXS50eSA9PT0gJ3JkJyB8fCBhcnJbaV0udHkgPT09ICdtcycgfHwgYXJyW2ldLnR5ID09PSAncGInKSB7XHJcbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xyXG4gICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcclxuICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xyXG4gICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIG93bk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAncnAnKSB7XHJcbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IG1vZGlmaWVyO1xyXG4gICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyLCBpLCBpdGVtc0RhdGEpO1xyXG4gICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgcmVuZGVyID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBpdGVtc0RhdGFbaV07XHJcbiAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XHJcbiAgfVxyXG4gIGxlbiA9IG93blN0eWxlcy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBvd25TdHlsZXNbaV0uY2xvc2VkID0gdHJ1ZTtcclxuICB9XHJcbiAgbGVuID0gb3duTW9kaWZpZXJzLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIG93bk1vZGlmaWVyc1tpXS5jbG9zZWQgPSB0cnVlO1xyXG4gIH1cclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLnN0eWxlc0xpc3RbaV0ucmVzZXQoKTtcclxuICB9XHJcbiAgdGhpcy5yZW5kZXJTaGFwZSgpO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICh0aGlzLnN0eWxlc0xpc3RbaV0uX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgaWYgKHRoaXMuc3R5bGVzTGlzdFtpXS5tc0VsZW0pIHtcclxuICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0ubXNFbGVtLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMuc3R5bGVzTGlzdFtpXS5kKTtcclxuICAgICAgICAvLyBBZGRpbmcgTTAgMCBmaXhlcyBzYW1lIG1hc2sgYnVnIG9uIGFsbCBicm93c2Vyc1xyXG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5kID0gJ00wIDAnICsgdGhpcy5zdHlsZXNMaXN0W2ldLmQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLnBFbGVtLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMuc3R5bGVzTGlzdFtpXS5kIHx8ICdNMCAwJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTaGFwZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5hbmltYXRlZENvbnRlbnRzLmxlbmd0aDtcclxuICB2YXIgYW5pbWF0ZWRDb250ZW50O1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgYW5pbWF0ZWRDb250ZW50ID0gdGhpcy5hbmltYXRlZENvbnRlbnRzW2ldO1xyXG4gICAgaWYgKCh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQuX2lzQW5pbWF0ZWQpICYmIGFuaW1hdGVkQ29udGVudC5kYXRhICE9PSB0cnVlKSB7XHJcbiAgICAgIGFuaW1hdGVkQ29udGVudC5mbihhbmltYXRlZENvbnRlbnQuZGF0YSwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQsIHRoaXMuX2lzRmlyc3RGcmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuZGVzdHJveUJhc2VFbGVtZW50KCk7XHJcbiAgdGhpcy5zaGFwZXNEYXRhID0gbnVsbDtcclxuICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlTlMgKi9cclxuXHJcbmZ1bmN0aW9uIFNWR1RpbnRGaWx0ZXIoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyKSB7XHJcbiAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcclxuICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdsaW5lYXJSR0InKTtcclxuICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAgMCAwIDEgMCcpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdyZXN1bHQnLCAnZjEnKTtcclxuICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7XHJcbiAgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAnKTtcclxuICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywgJ2YyJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xyXG4gIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb2xvck1hdHJpeDtcclxuICBpZiAoZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnYgIT09IDEwMCB8fCBmaWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAuaykge1xyXG4gICAgdmFyIGZlTWVyZ2UgPSBjcmVhdGVOUygnZmVNZXJnZScpO1xyXG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlTWVyZ2UpO1xyXG4gICAgdmFyIGZlTWVyZ2VOb2RlO1xyXG4gICAgZmVNZXJnZU5vZGUgPSBjcmVhdGVOUygnZmVNZXJnZU5vZGUnKTtcclxuICAgIGZlTWVyZ2VOb2RlLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlR3JhcGhpYycpO1xyXG4gICAgZmVNZXJnZS5hcHBlbmRDaGlsZChmZU1lcmdlTm9kZSk7XHJcbiAgICBmZU1lcmdlTm9kZSA9IGNyZWF0ZU5TKCdmZU1lcmdlTm9kZScpO1xyXG4gICAgZmVNZXJnZU5vZGUuc2V0QXR0cmlidXRlKCdpbicsICdmMicpO1xyXG4gICAgZmVNZXJnZS5hcHBlbmRDaGlsZChmZU1lcmdlTm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5TVkdUaW50RmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xyXG4gICAgdmFyIGNvbG9yQmxhY2sgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xyXG4gICAgdmFyIGNvbG9yV2hpdGUgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52O1xyXG4gICAgdmFyIG9wYWNpdHkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52IC8gMTAwO1xyXG4gICAgdGhpcy5tYXRyaXhGaWx0ZXIuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAoY29sb3JXaGl0ZVswXSAtIGNvbG9yQmxhY2tbMF0pICsgJyAwIDAgMCAnICsgY29sb3JCbGFja1swXSArICcgJyArIChjb2xvcldoaXRlWzFdIC0gY29sb3JCbGFja1sxXSkgKyAnIDAgMCAwICcgKyBjb2xvckJsYWNrWzFdICsgJyAnICsgKGNvbG9yV2hpdGVbMl0gLSBjb2xvckJsYWNrWzJdKSArICcgMCAwIDAgJyArIGNvbG9yQmxhY2tbMl0gKyAnIDAgMCAwICcgKyBvcGFjaXR5ICsgJyAwJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZU5TICovXHJcblxyXG5mdW5jdGlvbiBTVkdGaWxsRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlcikge1xyXG4gIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcbiAgdmFyIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xyXG4gIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb2xvck1hdHJpeDtcclxufVxyXG5TVkdGaWxsRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xyXG4gICAgdmFyIGNvbG9yID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudjtcclxuICAgIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzZdLnAudjtcclxuICAgIHRoaXMubWF0cml4RmlsdGVyLnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAgMCAwIDAgJyArIGNvbG9yWzBdICsgJyAwIDAgMCAwICcgKyBjb2xvclsxXSArICcgMCAwIDAgMCAnICsgY29sb3JbMl0gKyAnIDAgMCAwICcgKyBvcGFjaXR5ICsgJyAwJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZU5TICovXHJcblxyXG5mdW5jdGlvbiBTVkdHYXVzc2lhbkJsdXJFZmZlY3QoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyKSB7XHJcbiAgLy8gT3V0c2V0IHRoZSBmaWx0ZXIgcmVnaW9uIGJ5IDEwMCUgb24gYWxsIHNpZGVzIHRvIGFjY29tbW9kYXRlIGJsdXIgZXhwYW5zaW9uLlxyXG4gIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3gnLCAnLTEwMCUnKTtcclxuICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd5JywgJy0xMDAlJyk7XHJcbiAgZmlsdGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMzAwJScpO1xyXG4gIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICczMDAlJyk7XHJcblxyXG4gIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcbiAgdmFyIGZlR2F1c3NpYW5CbHVyID0gY3JlYXRlTlMoJ2ZlR2F1c3NpYW5CbHVyJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlR2F1c3NpYW5CbHVyKTtcclxuICB0aGlzLmZlR2F1c3NpYW5CbHVyID0gZmVHYXVzc2lhbkJsdXI7XHJcbn1cclxuXHJcblNWR0dhdXNzaWFuQmx1ckVmZmVjdC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcclxuICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcclxuICAgIC8vIEVtcGlyaWNhbCB2YWx1ZSwgbWF0Y2hpbmcgQUUncyBibHVyIGFwcGVhcmFuY2UuXHJcbiAgICB2YXIga0JsdXJyaW5lc3NUb1NpZ21hID0gMC4zO1xyXG4gICAgdmFyIHNpZ21hID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudiAqIGtCbHVycmluZXNzVG9TaWdtYTtcclxuXHJcbiAgICAvLyBEaW1lbnNpb25zIG1hcHBpbmc6XHJcbiAgICAvL1xyXG4gICAgLy8gICAxIC0+IGhvcml6b250YWwgJiB2ZXJ0aWNhbFxyXG4gICAgLy8gICAyIC0+IGhvcml6b250YWwgb25seVxyXG4gICAgLy8gICAzIC0+IHZlcnRpY2FsIG9ubHlcclxuICAgIC8vXHJcbiAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnY7XHJcbiAgICB2YXIgc2lnbWFYID0gKGRpbWVuc2lvbnMgPT0gMykgPyAwIDogc2lnbWE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICB2YXIgc2lnbWFZID0gKGRpbWVuc2lvbnMgPT0gMikgPyAwIDogc2lnbWE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcblxyXG4gICAgdGhpcy5mZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIHNpZ21hWCArICcgJyArIHNpZ21hWSk7XHJcblxyXG4gICAgLy8gUmVwZWF0IGVkZ2VzIG1hcHBpbmc6XHJcbiAgICAvL1xyXG4gICAgLy8gICAwIC0+IG9mZiAtPiBkdXBsaWNhdGVcclxuICAgIC8vICAgMSAtPiBvbiAgLT4gd3JhcFxyXG4gICAgdmFyIGVkZ2VNb2RlID0gKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnYgPT0gMSkgPyAnd3JhcCcgOiAnZHVwbGljYXRlJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdlZGdlTW9kZScsIGVkZ2VNb2RlKTtcclxuICB9XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlTlMsIGNyZWF0ZUVsZW1lbnRJRCwgbG9jYXRpb25IcmVmLCBibUZsb29yICovXHJcblxyXG5mdW5jdGlvbiBTVkdTdHJva2VFZmZlY3QoZWxlbSwgZmlsdGVyTWFuYWdlcikge1xyXG4gIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xyXG4gIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgdGhpcy5wYXRocyA9IFtdO1xyXG59XHJcblxyXG5TVkdTdHJva2VFZmZlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGVsZW1DaGlsZHJlbiA9IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGRyZW4gfHwgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZE5vZGVzO1xyXG4gIHZhciBwYXRoO1xyXG4gIHZhciBncm91cFBhdGg7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbjtcclxuICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudiA9PT0gMSkge1xyXG4gICAgbGVuID0gdGhpcy5lbGVtLm1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgICBpID0gMDtcclxuICB9IGVsc2Uge1xyXG4gICAgaSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnYgLSAxO1xyXG4gICAgbGVuID0gaSArIDE7XHJcbiAgfVxyXG4gIGdyb3VwUGF0aCA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XHJcbiAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKTtcclxuICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIDEpO1xyXG4gIGZvciAoaTsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBwYXRoID0gY3JlYXRlTlMoJ3BhdGgnKTtcclxuICAgIGdyb3VwUGF0aC5hcHBlbmRDaGlsZChwYXRoKTtcclxuICAgIHRoaXMucGF0aHMucHVzaCh7IHA6IHBhdGgsIG06IGkgfSk7XHJcbiAgfVxyXG4gIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMykge1xyXG4gICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgdmFyIGlkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgICBtYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XHJcbiAgICBtYXNrLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XHJcbiAgICBtYXNrLmFwcGVuZENoaWxkKGdyb3VwUGF0aCk7XHJcbiAgICB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2spO1xyXG4gICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgZy5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBpZCArICcpJyk7XHJcbiAgICB3aGlsZSAoZWxlbUNoaWxkcmVuWzBdKSB7XHJcbiAgICAgIGcuYXBwZW5kQ2hpbGQoZWxlbUNoaWxkcmVuWzBdKTtcclxuICAgIH1cclxuICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoZyk7XHJcbiAgICB0aGlzLm1hc2tlciA9IG1hc2s7XHJcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZicpO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDEgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDIpIHtcclxuICAgIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMikge1xyXG4gICAgICBlbGVtQ2hpbGRyZW4gPSB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkcmVuIHx8IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGROb2RlcztcclxuICAgICAgd2hpbGUgKGVsZW1DaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1DaGlsZHJlblswXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoZ3JvdXBQYXRoKTtcclxuICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtYXNrJyk7XHJcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZicpO1xyXG4gIH1cclxuICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICB0aGlzLnBhdGhNYXNrZXIgPSBncm91cFBhdGg7XHJcbn07XHJcblxyXG5TVkdTdHJva2VFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XHJcbiAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICB9XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMucGF0aHMubGVuZ3RoO1xyXG4gIHZhciBtYXNrO1xyXG4gIHZhciBwYXRoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKHRoaXMucGF0aHNbaV0ubSAhPT0gLTEpIHtcclxuICAgICAgbWFzayA9IHRoaXMuZWxlbS5tYXNrTWFuYWdlci52aWV3RGF0YVt0aGlzLnBhdGhzW2ldLm1dO1xyXG4gICAgICBwYXRoID0gdGhpcy5wYXRoc1tpXS5wO1xyXG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYgfHwgbWFzay5wcm9wLl9tZGYpIHtcclxuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIG1hc2subGFzdFBhdGgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOV0ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAuX21kZiB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC5fbWRmIHx8IG1hc2sucHJvcC5fbWRmKSB7XHJcbiAgICAgICAgdmFyIGRhc2hhcnJheVZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52ICE9PSAwIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLnYgIT09IDEwMCkge1xyXG4gICAgICAgICAgdmFyIHMgPSBNYXRoLm1pbih0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52LCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52KSAqIDAuMDE7XHJcbiAgICAgICAgICB2YXIgZSA9IE1hdGgubWF4KHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s3XS5wLnYsIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLnYpICogMC4wMTtcclxuICAgICAgICAgIHZhciBsID0gcGF0aC5nZXRUb3RhbExlbmd0aCgpO1xyXG4gICAgICAgICAgZGFzaGFycmF5VmFsdWUgPSAnMCAwIDAgJyArIGwgKiBzICsgJyAnO1xyXG4gICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsICogKGUgLSBzKTtcclxuICAgICAgICAgIHZhciBzZWdtZW50ID0gMSArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDE7XHJcbiAgICAgICAgICB2YXIgdW5pdHMgPSBNYXRoLmZsb29yKGxpbmVMZW5ndGggLyBzZWdtZW50KTtcclxuICAgICAgICAgIHZhciBqO1xyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHVuaXRzOyBqICs9IDEpIHtcclxuICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgKz0gJzEgJyArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDEgKyAnICc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkYXNoYXJyYXlWYWx1ZSArPSAnMCAnICsgbCAqIDEwICsgJyAwIDAnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkYXNoYXJyYXlWYWx1ZSA9ICcxICcgKyB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52ICogMiAqIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLnYgKiAwLjAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIGRhc2hhcnJheVZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZikge1xyXG4gICAgdGhpcy5wYXRoTWFza2VyLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAqIDIpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s2XS5wLl9tZGYpIHtcclxuICAgIHRoaXMucGF0aE1hc2tlci5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNl0ucC52KTtcclxuICB9XHJcbiAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAxIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XHJcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xyXG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xyXG4gICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAncmdiKCcgKyBibUZsb29yKGNvbG9yWzBdICogMjU1KSArICcsJyArIGJtRmxvb3IoY29sb3JbMV0gKiAyNTUpICsgJywnICsgYm1GbG9vcihjb2xvclsyXSAqIDI1NSkgKyAnKScpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVOUyAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHVHJpdG9uZUZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIpIHtcclxuICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xyXG4gIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcclxuICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcclxuICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2xpbmVhclJHQicpO1xyXG4gIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMCAwIDAgMSAwJyk7XHJcbiAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsICdmMScpO1xyXG4gIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcclxuICB2YXIgZmVDb21wb25lbnRUcmFuc2ZlciA9IGNyZWF0ZU5TKCdmZUNvbXBvbmVudFRyYW5zZmVyJyk7XHJcbiAgZmVDb21wb25lbnRUcmFuc2Zlci5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xyXG4gIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb21wb25lbnRUcmFuc2ZlcjtcclxuICB2YXIgZmVGdW5jUiA9IGNyZWF0ZU5TKCdmZUZ1bmNSJyk7XHJcbiAgZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcclxuICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuY1IpO1xyXG4gIHRoaXMuZmVGdW5jUiA9IGZlRnVuY1I7XHJcbiAgdmFyIGZlRnVuY0cgPSBjcmVhdGVOUygnZmVGdW5jRycpO1xyXG4gIGZlRnVuY0cuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RhYmxlJyk7XHJcbiAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmRDaGlsZChmZUZ1bmNHKTtcclxuICB0aGlzLmZlRnVuY0cgPSBmZUZ1bmNHO1xyXG4gIHZhciBmZUZ1bmNCID0gY3JlYXRlTlMoJ2ZlRnVuY0InKTtcclxuICBmZUZ1bmNCLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xyXG4gIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jQik7XHJcbiAgdGhpcy5mZUZ1bmNCID0gZmVGdW5jQjtcclxufVxyXG5cclxuU1ZHVHJpdG9uZUZpbHRlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcclxuICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcclxuICAgIHZhciBjb2xvcjEgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xyXG4gICAgdmFyIGNvbG9yMiA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnY7XHJcbiAgICB2YXIgY29sb3IzID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudjtcclxuICAgIHZhciB0YWJsZVIgPSBjb2xvcjNbMF0gKyAnICcgKyBjb2xvcjJbMF0gKyAnICcgKyBjb2xvcjFbMF07XHJcbiAgICB2YXIgdGFibGVHID0gY29sb3IzWzFdICsgJyAnICsgY29sb3IyWzFdICsgJyAnICsgY29sb3IxWzFdO1xyXG4gICAgdmFyIHRhYmxlQiA9IGNvbG9yM1syXSArICcgJyArIGNvbG9yMlsyXSArICcgJyArIGNvbG9yMVsyXTtcclxuICAgIHRoaXMuZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVSKTtcclxuICAgIHRoaXMuZmVGdW5jRy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVHKTtcclxuICAgIHRoaXMuZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVCKTtcclxuICAgIC8vIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudi8xMDA7XHJcbiAgICAvLyB0aGlzLm1hdHJpeEZpbHRlci5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsKGNvbG9yV2hpdGVbMF0tIGNvbG9yQmxhY2tbMF0pKycgMCAwIDAgJysgY29sb3JCbGFja1swXSArJyAnKyAoY29sb3JXaGl0ZVsxXS0gY29sb3JCbGFja1sxXSkgKycgMCAwIDAgJysgY29sb3JCbGFja1sxXSArJyAnKyAoY29sb3JXaGl0ZVsyXS0gY29sb3JCbGFja1syXSkgKycgMCAwIDAgJysgY29sb3JCbGFja1syXSArJyAwIDAgMCAnICsgb3BhY2l0eSArICcgMCcpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVOUyAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHUHJvTGV2ZWxzRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlcikge1xyXG4gIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcbiAgdmFyIGVmZmVjdEVsZW1lbnRzID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzO1xyXG4gIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcclxuXHJcbiAgaWYgKGVmZmVjdEVsZW1lbnRzWzEwXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTBdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1sxMV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMTJdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxMl0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzEzXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1sxNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLnYgIT09IDEpIHtcclxuICAgIHRoaXMuZmVGdW5jUiA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNSJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgfVxyXG4gIGlmIChlZmZlY3RFbGVtZW50c1sxN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE3XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMThdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTldLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syMF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzIwXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjFdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC52ICE9PSAxKSB7XHJcbiAgICB0aGlzLmZlRnVuY0cgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jRycsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xyXG4gIH1cclxuICBpZiAoZWZmZWN0RWxlbWVudHNbMjRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syNF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syNl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuayB8fCBlZmZlY3RFbGVtZW50c1syN10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI4XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjhdLnAudiAhPT0gMSkge1xyXG4gICAgdGhpcy5mZUZ1bmNCID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY0InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcclxuICB9XHJcbiAgaWYgKGVmZmVjdEVsZW1lbnRzWzMxXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzFdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzMyXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szM10ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzM0XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzRdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzM1XS5wLnYgIT09IDEpIHtcclxuICAgIHRoaXMuZmVGdW5jQSA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNBJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5mZUZ1bmNSIHx8IHRoaXMuZmVGdW5jRyB8fCB0aGlzLmZlRnVuY0IgfHwgdGhpcy5mZUZ1bmNBKSB7XHJcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcclxuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcclxuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIgPSBjcmVhdGVOUygnZmVDb21wb25lbnRUcmFuc2ZlcicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVmZmVjdEVsZW1lbnRzWzNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbNV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzZdLnAuayB8fCBlZmZlY3RFbGVtZW50c1s2XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAudiAhPT0gMSkge1xyXG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XHJcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgICB0aGlzLmZlRnVuY1JDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNSJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgICB0aGlzLmZlRnVuY0dDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNHJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgICB0aGlzLmZlRnVuY0JDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNCJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgfVxyXG59XHJcblxyXG5TVkdQcm9MZXZlbHNGaWx0ZXIucHJvdG90eXBlLmNyZWF0ZUZlRnVuYyA9IGZ1bmN0aW9uICh0eXBlLCBmZUNvbXBvbmVudFRyYW5zZmVyKSB7XHJcbiAgdmFyIGZlRnVuYyA9IGNyZWF0ZU5TKHR5cGUpO1xyXG4gIGZlRnVuYy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcclxuICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuYyk7XHJcbiAgcmV0dXJuIGZlRnVuYztcclxufTtcclxuXHJcblNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUuZ2V0VGFibGVWYWx1ZSA9IGZ1bmN0aW9uIChpbnB1dEJsYWNrLCBpbnB1dFdoaXRlLCBnYW1tYSwgb3V0cHV0QmxhY2ssIG91dHB1dFdoaXRlKSB7XHJcbiAgdmFyIGNudCA9IDA7XHJcbiAgdmFyIHNlZ21lbnRzID0gMjU2O1xyXG4gIHZhciBwZXJjO1xyXG4gIHZhciBtaW4gPSBNYXRoLm1pbihpbnB1dEJsYWNrLCBpbnB1dFdoaXRlKTtcclxuICB2YXIgbWF4ID0gTWF0aC5tYXgoaW5wdXRCbGFjaywgaW5wdXRXaGl0ZSk7XHJcbiAgdmFyIHRhYmxlID0gQXJyYXkuY2FsbChudWxsLCB7IGxlbmd0aDogc2VnbWVudHMgfSk7XHJcbiAgdmFyIGNvbG9yVmFsdWU7XHJcbiAgdmFyIHBvcyA9IDA7XHJcbiAgdmFyIG91dHB1dERlbHRhID0gb3V0cHV0V2hpdGUgLSBvdXRwdXRCbGFjaztcclxuICB2YXIgaW5wdXREZWx0YSA9IGlucHV0V2hpdGUgLSBpbnB1dEJsYWNrO1xyXG4gIHdoaWxlIChjbnQgPD0gMjU2KSB7XHJcbiAgICBwZXJjID0gY250IC8gMjU2O1xyXG4gICAgaWYgKHBlcmMgPD0gbWluKSB7XHJcbiAgICAgIGNvbG9yVmFsdWUgPSBpbnB1dERlbHRhIDwgMCA/IG91dHB1dFdoaXRlIDogb3V0cHV0QmxhY2s7XHJcbiAgICB9IGVsc2UgaWYgKHBlcmMgPj0gbWF4KSB7XHJcbiAgICAgIGNvbG9yVmFsdWUgPSBpbnB1dERlbHRhIDwgMCA/IG91dHB1dEJsYWNrIDogb3V0cHV0V2hpdGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2xvclZhbHVlID0gKG91dHB1dEJsYWNrICsgb3V0cHV0RGVsdGEgKiBNYXRoLnBvdygocGVyYyAtIGlucHV0QmxhY2spIC8gaW5wdXREZWx0YSwgMSAvIGdhbW1hKSk7XHJcbiAgICB9XHJcbiAgICB0YWJsZVtwb3NdID0gY29sb3JWYWx1ZTtcclxuICAgIHBvcyArPSAxO1xyXG4gICAgY250ICs9IDI1NiAvIChzZWdtZW50cyAtIDEpO1xyXG4gIH1cclxuICByZXR1cm4gdGFibGUuam9pbignICcpO1xyXG59O1xyXG5cclxuU1ZHUHJvTGV2ZWxzRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xyXG4gICAgdmFyIHZhbDtcclxuICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50cztcclxuICAgIGlmICh0aGlzLmZlRnVuY1JDb21wb3NlZCAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuX21kZikpIHtcclxuICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzNdLnAudiwgZWZmZWN0RWxlbWVudHNbNF0ucC52LCBlZmZlY3RFbGVtZW50c1s1XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzZdLnAudiwgZWZmZWN0RWxlbWVudHNbN10ucC52KTtcclxuICAgICAgdGhpcy5mZUZ1bmNSQ29tcG9zZWQuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XHJcbiAgICAgIHRoaXMuZmVGdW5jR0NvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xyXG4gICAgICB0aGlzLmZlRnVuY0JDb21wb3NlZC5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5mZUZ1bmNSICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTJdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLl9tZGYpKSB7XHJcbiAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1sxMF0ucC52LCBlZmZlY3RFbGVtZW50c1sxMV0ucC52LCBlZmZlY3RFbGVtZW50c1sxMl0ucC52LCBlZmZlY3RFbGVtZW50c1sxM10ucC52LCBlZmZlY3RFbGVtZW50c1sxNF0ucC52KTtcclxuICAgICAgdGhpcy5mZUZ1bmNSLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmZlRnVuY0cgJiYgKGZvcmNlUmVuZGVyIHx8IGVmZmVjdEVsZW1lbnRzWzE3XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMThdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxOV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzIwXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjFdLnAuX21kZikpIHtcclxuICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzE3XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzE4XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzE5XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzIwXS5wLnYsIGVmZmVjdEVsZW1lbnRzWzIxXS5wLnYpO1xyXG4gICAgICB0aGlzLmZlRnVuY0cuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZmVGdW5jQiAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMjRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syNV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syOF0ucC5fbWRmKSkge1xyXG4gICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMjRdLnAudiwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiwgZWZmZWN0RWxlbWVudHNbMjZdLnAudiwgZWZmZWN0RWxlbWVudHNbMjddLnAudiwgZWZmZWN0RWxlbWVudHNbMjhdLnAudik7XHJcbiAgICAgIHRoaXMuZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5mZUZ1bmNBICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1szMV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzMyXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzM1XS5wLl9tZGYpKSB7XHJcbiAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1szMV0ucC52LCBlZmZlY3RFbGVtZW50c1szMl0ucC52LCBlZmZlY3RFbGVtZW50c1szM10ucC52LCBlZmZlY3RFbGVtZW50c1szNF0ucC52LCBlZmZlY3RFbGVtZW50c1szNV0ucC52KTtcclxuICAgICAgdGhpcy5mZUZ1bmNBLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVOUywgcmdiVG9IZXgsIGRlZ1RvUmFkcyAqL1xyXG5cclxuZnVuY3Rpb24gU1ZHRHJvcFNoYWRvd0VmZmVjdChmaWx0ZXIsIGZpbHRlck1hbmFnZXIpIHtcclxuICB2YXIgZmlsdGVyU2l6ZSA9IGZpbHRlck1hbmFnZXIuY29udGFpbmVyLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmZpbHRlclNpemU7XHJcbiAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneCcsIGZpbHRlclNpemUueCk7XHJcbiAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneScsIGZpbHRlclNpemUueSk7XHJcbiAgZmlsdGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBmaWx0ZXJTaXplLndpZHRoKTtcclxuICBmaWx0ZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBmaWx0ZXJTaXplLmhlaWdodCk7XHJcbiAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcclxuXHJcbiAgdmFyIGZlR2F1c3NpYW5CbHVyID0gY3JlYXRlTlMoJ2ZlR2F1c3NpYW5CbHVyJyk7XHJcbiAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdpbicsICdTb3VyY2VBbHBoYScpO1xyXG4gIGZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgJ2Ryb3Bfc2hhZG93XzEnKTtcclxuICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsICcwJyk7XHJcbiAgdGhpcy5mZUdhdXNzaWFuQmx1ciA9IGZlR2F1c3NpYW5CbHVyO1xyXG4gIGZpbHRlci5hcHBlbmRDaGlsZChmZUdhdXNzaWFuQmx1cik7XHJcblxyXG4gIHZhciBmZU9mZnNldCA9IGNyZWF0ZU5TKCdmZU9mZnNldCcpO1xyXG4gIGZlT2Zmc2V0LnNldEF0dHJpYnV0ZSgnZHgnLCAnMjUnKTtcclxuICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R5JywgJzAnKTtcclxuICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2luJywgJ2Ryb3Bfc2hhZG93XzEnKTtcclxuICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsICdkcm9wX3NoYWRvd18yJyk7XHJcbiAgdGhpcy5mZU9mZnNldCA9IGZlT2Zmc2V0O1xyXG4gIGZpbHRlci5hcHBlbmRDaGlsZChmZU9mZnNldCk7XHJcbiAgdmFyIGZlRmxvb2QgPSBjcmVhdGVOUygnZmVGbG9vZCcpO1xyXG4gIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1jb2xvcicsICcjMDBmZjAwJyk7XHJcbiAgZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLW9wYWNpdHknLCAnMScpO1xyXG4gIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdyZXN1bHQnLCAnZHJvcF9zaGFkb3dfMycpO1xyXG4gIHRoaXMuZmVGbG9vZCA9IGZlRmxvb2Q7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlRmxvb2QpO1xyXG5cclxuICB2YXIgZmVDb21wb3NpdGUgPSBjcmVhdGVOUygnZmVDb21wb3NpdGUnKTtcclxuICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luJywgJ2Ryb3Bfc2hhZG93XzMnKTtcclxuICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luMicsICdkcm9wX3NoYWRvd18yJyk7XHJcbiAgZmVDb21wb3NpdGUuc2V0QXR0cmlidXRlKCdvcGVyYXRvcicsICdpbicpO1xyXG4gIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgJ2Ryb3Bfc2hhZG93XzQnKTtcclxuICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb3NpdGUpO1xyXG5cclxuICB2YXIgZmVNZXJnZSA9IGNyZWF0ZU5TKCdmZU1lcmdlJyk7XHJcbiAgZmlsdGVyLmFwcGVuZENoaWxkKGZlTWVyZ2UpO1xyXG4gIHZhciBmZU1lcmdlTm9kZTtcclxuICBmZU1lcmdlTm9kZSA9IGNyZWF0ZU5TKCdmZU1lcmdlTm9kZScpO1xyXG4gIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xyXG4gIGZlTWVyZ2VOb2RlID0gY3JlYXRlTlMoJ2ZlTWVyZ2VOb2RlJyk7XHJcbiAgZmVNZXJnZU5vZGUuc2V0QXR0cmlidXRlKCdpbicsICdTb3VyY2VHcmFwaGljJyk7XHJcbiAgdGhpcy5mZU1lcmdlTm9kZSA9IGZlTWVyZ2VOb2RlO1xyXG4gIHRoaXMuZmVNZXJnZSA9IGZlTWVyZ2U7XHJcbiAgdGhpcy5vcmlnaW5hbE5vZGVBZGRlZCA9IGZhbHNlO1xyXG4gIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xyXG59XHJcblxyXG5TVkdEcm9wU2hhZG93RWZmZWN0LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xyXG4gIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xyXG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLl9tZGYpIHtcclxuICAgICAgdGhpcy5mZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgLyA0KTtcclxuICAgIH1cclxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC5fbWRmKSB7XHJcbiAgICAgIHZhciBjb2wgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xyXG4gICAgICB0aGlzLmZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1jb2xvcicsIHJnYlRvSGV4KE1hdGgucm91bmQoY29sWzBdICogMjU1KSwgTWF0aC5yb3VuZChjb2xbMV0gKiAyNTUpLCBNYXRoLnJvdW5kKGNvbFsyXSAqIDI1NSkpKTtcclxuICAgIH1cclxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC5fbWRmKSB7XHJcbiAgICAgIHRoaXMuZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLW9wYWNpdHknLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52IC8gMjU1KTtcclxuICAgIH1cclxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1szXS5wLl9tZGYpIHtcclxuICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAudjtcclxuICAgICAgdmFyIGFuZ2xlID0gKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnYgLSA5MCkgKiBkZWdUb1JhZHM7XHJcbiAgICAgIHZhciB4ID0gZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgIHZhciB5ID0gZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgIHRoaXMuZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeCcsIHgpO1xyXG4gICAgICB0aGlzLmZlT2Zmc2V0LnNldEF0dHJpYnV0ZSgnZHknLCB5KTtcclxuICAgIH1cclxuICAgIC8qIGlmKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s1XS5wLl9tZGYpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNV0ucC52ID09PSAxICYmIHRoaXMub3JpZ2luYWxOb2RlQWRkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmVNZXJnZS5yZW1vdmVDaGlsZCh0aGlzLmZlTWVyZ2VOb2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxOb2RlQWRkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s1XS5wLnYgPT09IDAgJiYgIXRoaXMub3JpZ2luYWxOb2RlQWRkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmVNZXJnZS5hcHBlbmRDaGlsZCh0aGlzLmZlTWVyZ2VOb2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxOb2RlQWRkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSAqL1xyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVFbGVtZW50SUQsIGNyZWF0ZU5TICovXHJcblxyXG52YXIgX3N2Z01hdHRlU3ltYm9scyA9IFtdO1xyXG5cclxuZnVuY3Rpb24gU1ZHTWF0dGUzRWZmZWN0KGZpbHRlckVsZW0sIGZpbHRlck1hbmFnZXIsIGVsZW0pIHtcclxuICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcclxuICB0aGlzLmZpbHRlckVsZW0gPSBmaWx0ZXJFbGVtO1xyXG4gIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgZWxlbS5tYXR0ZUVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xyXG4gIGVsZW0ubWF0dGVFbGVtZW50LmFwcGVuZENoaWxkKGVsZW0ubGF5ZXJFbGVtZW50KTtcclxuICBlbGVtLm1hdHRlRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtLnRyYW5zZm9ybWVkRWxlbWVudCk7XHJcbiAgZWxlbS5iYXNlRWxlbWVudCA9IGVsZW0ubWF0dGVFbGVtZW50O1xyXG59XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLmZpbmRTeW1ib2wgPSBmdW5jdGlvbiAobWFzaykge1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gX3N2Z01hdHRlU3ltYm9scy5sZW5ndGg7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGlmIChfc3ZnTWF0dGVTeW1ib2xzW2ldID09PSBtYXNrKSB7XHJcbiAgICAgIHJldHVybiBfc3ZnTWF0dGVTeW1ib2xzW2ldO1xyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcblNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUucmVwbGFjZUluUGFyZW50ID0gZnVuY3Rpb24gKG1hc2ssIHN5bWJvbElkKSB7XHJcbiAgdmFyIHBhcmVudE5vZGUgPSBtYXNrLmxheWVyRWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIGlmICghcGFyZW50Tm9kZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgY2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkcmVuO1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICBpZiAoY2hpbGRyZW5baV0gPT09IG1hc2subGF5ZXJFbGVtZW50KSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxuICB2YXIgbmV4dENoaWxkO1xyXG4gIGlmIChpIDw9IGxlbiAtIDIpIHtcclxuICAgIG5leHRDaGlsZCA9IGNoaWxkcmVuW2kgKyAxXTtcclxuICB9XHJcbiAgdmFyIHVzZUVsZW0gPSBjcmVhdGVOUygndXNlJyk7XHJcbiAgdXNlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBzeW1ib2xJZCk7XHJcbiAgaWYgKG5leHRDaGlsZCkge1xyXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodXNlRWxlbSwgbmV4dENoaWxkKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh1c2VFbGVtKTtcclxuICB9XHJcbn07XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLnNldEVsZW1lbnRBc01hc2sgPSBmdW5jdGlvbiAoZWxlbSwgbWFzaykge1xyXG4gIGlmICghdGhpcy5maW5kU3ltYm9sKG1hc2spKSB7XHJcbiAgICB2YXIgc3ltYm9sSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcclxuICAgIHZhciBtYXNrZXIgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnaWQnLCBtYXNrLmxheWVySWQpO1xyXG4gICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XHJcbiAgICBfc3ZnTWF0dGVTeW1ib2xzLnB1c2gobWFzayk7XHJcbiAgICB2YXIgZGVmcyA9IGVsZW0uZ2xvYmFsRGF0YS5kZWZzO1xyXG4gICAgZGVmcy5hcHBlbmRDaGlsZChtYXNrZXIpO1xyXG4gICAgdmFyIHN5bWJvbCA9IGNyZWF0ZU5TKCdzeW1ib2wnKTtcclxuICAgIHN5bWJvbC5zZXRBdHRyaWJ1dGUoJ2lkJywgc3ltYm9sSWQpO1xyXG4gICAgdGhpcy5yZXBsYWNlSW5QYXJlbnQobWFzaywgc3ltYm9sSWQpO1xyXG4gICAgc3ltYm9sLmFwcGVuZENoaWxkKG1hc2subGF5ZXJFbGVtZW50KTtcclxuICAgIGRlZnMuYXBwZW5kQ2hpbGQoc3ltYm9sKTtcclxuICAgIHZhciB1c2VFbGVtID0gY3JlYXRlTlMoJ3VzZScpO1xyXG4gICAgdXNlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBzeW1ib2xJZCk7XHJcbiAgICBtYXNrZXIuYXBwZW5kQ2hpbGQodXNlRWxlbSk7XHJcbiAgICBtYXNrLmRhdGEuaGQgPSBmYWxzZTtcclxuICAgIG1hc2suc2hvdygpO1xyXG4gIH1cclxuICBlbGVtLnNldE1hdHRlKG1hc2subGF5ZXJJZCk7XHJcbn07XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGluZCA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XHJcbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtLmNvbXAuZWxlbWVudHM7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGlmIChlbGVtZW50c1tpXSAmJiBlbGVtZW50c1tpXS5kYXRhLmluZCA9PT0gaW5kKSB7XHJcbiAgICAgIHRoaXMuc2V0RWxlbWVudEFzTWFzayh0aGlzLmVsZW0sIGVsZW1lbnRzW2ldKTtcclxuICAgIH1cclxuICAgIGkgKz0gMTtcclxuICB9XHJcbiAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbn07XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZUVsZW1lbnRJRCwgZmlsdGVyc0ZhY3RvcnksIFNWR1RpbnRGaWx0ZXIsIFNWR0ZpbGxGaWx0ZXIsIFNWR1N0cm9rZUVmZmVjdCwgU1ZHVHJpdG9uZUZpbHRlcixcclxuU1ZHUHJvTGV2ZWxzRmlsdGVyLCBTVkdEcm9wU2hhZG93RWZmZWN0LCBTVkdNYXR0ZTNFZmZlY3QsIFNWR0dhdXNzaWFuQmx1ckVmZmVjdCwgbG9jYXRpb25IcmVmICovXHJcblxyXG5mdW5jdGlvbiBTVkdFZmZlY3RzKGVsZW0pIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gZWxlbS5kYXRhLmVmID8gZWxlbS5kYXRhLmVmLmxlbmd0aCA6IDA7XHJcbiAgdmFyIGZpbElkID0gY3JlYXRlRWxlbWVudElEKCk7XHJcbiAgdmFyIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCwgdHJ1ZSk7XHJcbiAgdmFyIGNvdW50ID0gMDtcclxuICB0aGlzLmZpbHRlcnMgPSBbXTtcclxuICB2YXIgZmlsdGVyTWFuYWdlcjtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGZpbHRlck1hbmFnZXIgPSBudWxsO1xyXG4gICAgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjApIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdUaW50RmlsdGVyKGZpbCwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjEpIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdGaWxsRmlsdGVyKGZpbCwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjIpIHtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdTdHJva2VFZmZlY3QoZWxlbSwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjMpIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdUcml0b25lRmlsdGVyKGZpbCwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjQpIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdQcm9MZXZlbHNGaWx0ZXIoZmlsLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldKTtcclxuICAgIH0gZWxzZSBpZiAoZWxlbS5kYXRhLmVmW2ldLnR5ID09PSAyNSkge1xyXG4gICAgICBjb3VudCArPSAxO1xyXG4gICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR0Ryb3BTaGFkb3dFZmZlY3QoZmlsLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldKTtcclxuICAgIH0gZWxzZSBpZiAoZWxlbS5kYXRhLmVmW2ldLnR5ID09PSAyOCkge1xyXG4gICAgICAvLyBjb3VudCArPSAxO1xyXG4gICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR01hdHRlM0VmZmVjdChmaWwsIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW0pO1xyXG4gICAgfSBlbHNlIGlmIChlbGVtLmRhdGEuZWZbaV0udHkgPT09IDI5KSB7XHJcbiAgICAgIGNvdW50ICs9IDE7XHJcbiAgICAgIGZpbHRlck1hbmFnZXIgPSBuZXcgU1ZHR2F1c3NpYW5CbHVyRWZmZWN0KGZpbCwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlsdGVyTWFuYWdlcikge1xyXG4gICAgICB0aGlzLmZpbHRlcnMucHVzaChmaWx0ZXJNYW5hZ2VyKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGNvdW50KSB7XHJcbiAgICBlbGVtLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xyXG4gICAgZWxlbS5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWx0ZXInLCAndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBmaWxJZCArICcpJyk7XHJcbiAgfVxyXG4gIGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICBlbGVtLmFkZFJlbmRlcmFibGVDb21wb25lbnQodGhpcyk7XHJcbiAgfVxyXG59XHJcblxyXG5TVkdFZmZlY3RzLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLmZpbHRlcnNbaV0ucmVuZGVyRnJhbWUoX2lzRmlyc3RGcmFtZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIE1hdHJpeCwgY3JlYXRlVHlwZWRBcnJheSAqL1xyXG5cclxuZnVuY3Rpb24gQ1ZDb250ZXh0RGF0YSgpIHtcclxuICB0aGlzLnNhdmVkID0gW107XHJcbiAgdGhpcy5jQXJyUG9zID0gMDtcclxuICB0aGlzLmNUciA9IG5ldyBNYXRyaXgoKTtcclxuICB0aGlzLmNPID0gMTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gMTU7XHJcbiAgdGhpcy5zYXZlZE9wID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICB0aGlzLnNhdmVkW2ldID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDE2KTtcclxuICB9XHJcbiAgdGhpcy5fbGVuZ3RoID0gbGVuO1xyXG59XHJcblxyXG5DVkNvbnRleHREYXRhLnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG5ld0xlbmd0aCA9IHRoaXMuX2xlbmd0aCAqIDI7XHJcbiAgdmFyIGN1cnJlbnRTYXZlZE9wID0gdGhpcy5zYXZlZE9wO1xyXG4gIHRoaXMuc2F2ZWRPcCA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBuZXdMZW5ndGgpO1xyXG4gIHRoaXMuc2F2ZWRPcC5zZXQoY3VycmVudFNhdmVkT3ApO1xyXG4gIHZhciBpID0gMDtcclxuICBmb3IgKGkgPSB0aGlzLl9sZW5ndGg7IGkgPCBuZXdMZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgdGhpcy5zYXZlZFtpXSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxNik7XHJcbiAgfVxyXG4gIHRoaXMuX2xlbmd0aCA9IG5ld0xlbmd0aDtcclxufTtcclxuXHJcbkNWQ29udGV4dERhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuY0FyclBvcyA9IDA7XHJcbiAgdGhpcy5jVHIucmVzZXQoKTtcclxuICB0aGlzLmNPID0gMTtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBDVkVmZmVjdHMsIGdldEJsZW5kTW9kZSwgQ1ZNYXNrRWxlbWVudCwgTWF0cml4ICovXHJcblxyXG5mdW5jdGlvbiBDVkJhc2VFbGVtZW50KCkge1xyXG59XHJcblxyXG5DVkJhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICBjcmVhdGVFbGVtZW50czogZnVuY3Rpb24gKCkge30sXHJcbiAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gKCkge30sXHJcbiAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0O1xyXG4gICAgdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIgPSBuZXcgQ1ZFZmZlY3RzKHRoaXMpO1xyXG4gIH0sXHJcbiAgY3JlYXRlQ29udGVudDogZnVuY3Rpb24gKCkge30sXHJcbiAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZ2xvYmFsRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YTtcclxuICAgIGlmIChnbG9iYWxEYXRhLmJsZW5kTW9kZSAhPT0gdGhpcy5kYXRhLmJtKSB7XHJcbiAgICAgIGdsb2JhbERhdGEuYmxlbmRNb2RlID0gdGhpcy5kYXRhLmJtO1xyXG4gICAgICB2YXIgYmxlbmRNb2RlVmFsdWUgPSBnZXRCbGVuZE1vZGUodGhpcy5kYXRhLmJtKTtcclxuICAgICAgZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZVZhbHVlO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgQ1ZNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMpO1xyXG4gIH0sXHJcbiAgaGlkZUVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghdGhpcy5oaWRkZW4gJiYgKCF0aGlzLmlzSW5SYW5nZSB8fCB0aGlzLmlzVHJhbnNwYXJlbnQpKSB7XHJcbiAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcclxuICAgIH1cclxuICB9LFxyXG4gIHNob3dFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5pc0luUmFuZ2UgJiYgIXRoaXMuaXNUcmFuc3BhcmVudCkge1xyXG4gICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmhpZGRlbiB8fCB0aGlzLmRhdGEuaGQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJUcmFuc2Zvcm0oKTtcclxuICAgIHRoaXMucmVuZGVyUmVuZGVyYWJsZSgpO1xyXG4gICAgdGhpcy5zZXRCbGVuZE1vZGUoKTtcclxuICAgIHZhciBmb3JjZVJlYWxTdGFjayA9IHRoaXMuZGF0YS50eSA9PT0gMDtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5zYXZlKGZvcmNlUmVhbFN0YWNrKTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhUcmFuc2Zvcm0odGhpcy5maW5hbFRyYW5zZm9ybS5tYXQucHJvcHMpO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eE9wYWNpdHkodGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLnYpO1xyXG4gICAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKGZvcmNlUmVhbFN0YWNrKTtcclxuICAgIGlmICh0aGlzLm1hc2tNYW5hZ2VyLmhhc01hc2tzKSB7XHJcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKHRydWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IG51bGw7XHJcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcclxuICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xyXG4gIH0sXHJcbiAgbUhlbHBlcjogbmV3IE1hdHJpeCgpLFxyXG59O1xyXG5DVkJhc2VFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUuaGlkZUVsZW1lbnQ7XHJcbkNWQmFzZUVsZW1lbnQucHJvdG90eXBlLnNob3cgPSBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5zaG93RWxlbWVudDtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCxcclxuUmVuZGVyYWJsZUVsZW1lbnQsIFNWR1NoYXBlRWxlbWVudCwgSUltYWdlRWxlbWVudCwgY3JlYXRlVGFnICovXHJcblxyXG5mdW5jdGlvbiBDVkltYWdlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcclxuICB0aGlzLmltZyA9IGdsb2JhbERhdGEuaW1hZ2VMb2FkZXIuZ2V0QXNzZXQodGhpcy5hc3NldERhdGEpO1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWSW1hZ2VFbGVtZW50KTtcclxuXHJcbkNWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQ7XHJcbkNWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBJSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWU7XHJcblxyXG5DVkltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAodGhpcy5pbWcud2lkdGggJiYgKHRoaXMuYXNzZXREYXRhLncgIT09IHRoaXMuaW1nLndpZHRoIHx8IHRoaXMuYXNzZXREYXRhLmggIT09IHRoaXMuaW1nLmhlaWdodCkpIHtcclxuICAgIHZhciBjYW52YXMgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gdGhpcy5hc3NldERhdGEudztcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmFzc2V0RGF0YS5oO1xyXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIHZhciBpbWdXID0gdGhpcy5pbWcud2lkdGg7XHJcbiAgICB2YXIgaW1nSCA9IHRoaXMuaW1nLmhlaWdodDtcclxuICAgIHZhciBpbWdSZWwgPSBpbWdXIC8gaW1nSDtcclxuICAgIHZhciBjYW52YXNSZWwgPSB0aGlzLmFzc2V0RGF0YS53IC8gdGhpcy5hc3NldERhdGEuaDtcclxuICAgIHZhciB3aWR0aENyb3A7XHJcbiAgICB2YXIgaGVpZ2h0Q3JvcDtcclxuICAgIHZhciBwYXIgPSB0aGlzLmFzc2V0RGF0YS5wciB8fCB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbztcclxuICAgIGlmICgoaW1nUmVsID4gY2FudmFzUmVsICYmIHBhciA9PT0gJ3hNaWRZTWlkIHNsaWNlJykgfHwgKGltZ1JlbCA8IGNhbnZhc1JlbCAmJiBwYXIgIT09ICd4TWlkWU1pZCBzbGljZScpKSB7XHJcbiAgICAgIGhlaWdodENyb3AgPSBpbWdIO1xyXG4gICAgICB3aWR0aENyb3AgPSBoZWlnaHRDcm9wICogY2FudmFzUmVsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2lkdGhDcm9wID0gaW1nVztcclxuICAgICAgaGVpZ2h0Q3JvcCA9IHdpZHRoQ3JvcCAvIGNhbnZhc1JlbDtcclxuICAgIH1cclxuICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWcsIChpbWdXIC0gd2lkdGhDcm9wKSAvIDIsIChpbWdIIC0gaGVpZ2h0Q3JvcCkgLyAyLCB3aWR0aENyb3AsIGhlaWdodENyb3AsIDAsIDAsIHRoaXMuYXNzZXREYXRhLncsIHRoaXMuYXNzZXREYXRhLmgpO1xyXG4gICAgdGhpcy5pbWcgPSBjYW52YXM7XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwKTtcclxufTtcclxuXHJcbkNWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuaW1nID0gbnVsbDtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVTaXplZEFycmF5LCBQcm9wZXJ0eUZhY3RvcnksIGV4dGVuZFByb3RvdHlwZSwgQ2FudmFzUmVuZGVyZXIsIElDb21wRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gQ1ZDb21wRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xyXG4gIHRoaXMubGF5ZXJzID0gZGF0YS5sYXllcnM7XHJcbiAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcclxuICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLmxheWVycy5sZW5ndGgpO1xyXG4gIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7IF9wbGFjZWhvbGRlcjogdHJ1ZSB9O1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0NhbnZhc1JlbmRlcmVyLCBJQ29tcEVsZW1lbnQsIENWQmFzZUVsZW1lbnRdLCBDVkNvbXBFbGVtZW50KTtcclxuXHJcbkNWQ29tcEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY3R4ID0gdGhpcy5jYW52YXNDb250ZXh0O1xyXG4gIGN0eC5iZWdpblBhdGgoKTtcclxuICBjdHgubW92ZVRvKDAsIDApO1xyXG4gIGN0eC5saW5lVG8odGhpcy5kYXRhLncsIDApO1xyXG4gIGN0eC5saW5lVG8odGhpcy5kYXRhLncsIHRoaXMuZGF0YS5oKTtcclxuICBjdHgubGluZVRvKDAsIHRoaXMuZGF0YS5oKTtcclxuICBjdHgubGluZVRvKDAsIDApO1xyXG4gIGN0eC5jbGlwKCk7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcclxuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZDb21wRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICB9XHJcbiAgdGhpcy5sYXllcnMgPSBudWxsO1xyXG4gIHRoaXMuZWxlbWVudHMgPSBudWxsO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVNpemVkQXJyYXksIFNoYXBlUHJvcGVydHlGYWN0b3J5LCBNYXNrRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gQ1ZNYXNrRWxlbWVudChkYXRhLCBlbGVtZW50KSB7XHJcbiAgdGhpcy5kYXRhID0gZGF0YTtcclxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gIHRoaXMubWFza3NQcm9wZXJ0aWVzID0gdGhpcy5kYXRhLm1hc2tzUHJvcGVydGllcyB8fCBbXTtcclxuICB0aGlzLnZpZXdEYXRhID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGgpO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgdmFyIGhhc01hc2tzID0gZmFsc2U7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKSB7XHJcbiAgICAgIGhhc01hc2tzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRoaXMudmlld0RhdGFbaV0gPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCB0aGlzLm1hc2tzUHJvcGVydGllc1tpXSwgMyk7XHJcbiAgfVxyXG4gIHRoaXMuaGFzTWFza3MgPSBoYXNNYXNrcztcclxuICBpZiAoaGFzTWFza3MpIHtcclxuICAgIHRoaXMuZWxlbWVudC5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xyXG4gIH1cclxufVxyXG5cclxuQ1ZNYXNrRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCF0aGlzLmhhc01hc2tzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubWF0O1xyXG4gIHZhciBjdHggPSB0aGlzLmVsZW1lbnQuY2FudmFzQ29udGV4dDtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gIHZhciBwdDtcclxuICB2YXIgcHRzO1xyXG4gIHZhciBkYXRhO1xyXG4gIGN0eC5iZWdpblBhdGgoKTtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICh0aGlzLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicpIHtcclxuICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLmludikge1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5jb21wU2l6ZS53LCAwKTtcclxuICAgICAgICBjdHgubGluZVRvKHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLncsIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLmgpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oMCwgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUuaCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcclxuICAgICAgfVxyXG4gICAgICBkYXRhID0gdGhpcy52aWV3RGF0YVtpXS52O1xyXG4gICAgICBwdCA9IHRyYW5zZm9ybS5hcHBseVRvUG9pbnRBcnJheShkYXRhLnZbMF1bMF0sIGRhdGEudlswXVsxXSwgMCk7XHJcbiAgICAgIGN0eC5tb3ZlVG8ocHRbMF0sIHB0WzFdKTtcclxuICAgICAgdmFyIGo7XHJcbiAgICAgIHZhciBqTGVuID0gZGF0YS5fbGVuZ3RoO1xyXG4gICAgICBmb3IgKGogPSAxOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgcHRzID0gdHJhbnNmb3JtLmFwcGx5VG9UcmlwbGVQb2ludHMoZGF0YS5vW2ogLSAxXSwgZGF0YS5pW2pdLCBkYXRhLnZbal0pO1xyXG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHB0c1swXSwgcHRzWzFdLCBwdHNbMl0sIHB0c1szXSwgcHRzWzRdLCBwdHNbNV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHB0cyA9IHRyYW5zZm9ybS5hcHBseVRvVHJpcGxlUG9pbnRzKGRhdGEub1tqIC0gMV0sIGRhdGEuaVswXSwgZGF0YS52WzBdKTtcclxuICAgICAgY3R4LmJlemllckN1cnZlVG8ocHRzWzBdLCBwdHNbMV0sIHB0c1syXSwgcHRzWzNdLCBwdHNbNF0sIHB0c1s1XSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLnJlbmRlcmVyLnNhdmUodHJ1ZSk7XHJcbiAgY3R4LmNsaXAoKTtcclxufTtcclxuXHJcbkNWTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eSA9IE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHk7XHJcblxyXG5DVk1hc2tFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgU2hhcGVUcmFuc2Zvcm1NYW5hZ2VyLCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LCBJU2hhcGVFbGVtZW50LFxyXG5IaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgUHJvcGVydHlGYWN0b3J5LCBkZWdUb1JhZHMsIEdyYWRpZW50UHJvcGVydHksXHJcbkRhc2hQcm9wZXJ0eSwgVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LCBDVlNoYXBlRGF0YSwgU2hhcGVNb2RpZmllcnMsIGJtRmxvb3IsIGxpbmVDYXBFbnVtLCBsaW5lSm9pbkVudW0gKi9cclxuXHJcbmZ1bmN0aW9uIENWU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLnNoYXBlcyA9IFtdO1xyXG4gIHRoaXMuc2hhcGVzRGF0YSA9IGRhdGEuc2hhcGVzO1xyXG4gIHRoaXMuc3R5bGVzTGlzdCA9IFtdO1xyXG4gIHRoaXMuaXRlbXNEYXRhID0gW107XHJcbiAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcclxuICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107XHJcbiAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdO1xyXG4gIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIgPSBuZXcgU2hhcGVUcmFuc2Zvcm1NYW5hZ2VyKCk7XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSVNoYXBlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWU2hhcGVFbGVtZW50KTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFJlbmRlcmFibGVET01FbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS50cmFuc2Zvcm1IZWxwZXIgPSB7IG9wYWNpdHk6IDEsIF9vcE1kZjogZmFsc2UgfTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5kYXNoUmVzZXR0ZXIgPSBbXTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0cnVlLCBbXSk7XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIHRyYW5zZm9ybXMpIHtcclxuICB2YXIgc3R5bGVFbGVtID0ge1xyXG4gICAgZGF0YTogZGF0YSxcclxuICAgIHR5cGU6IGRhdGEudHksXHJcbiAgICBwcmVUcmFuc2Zvcm1zOiB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLmFkZFRyYW5zZm9ybVNlcXVlbmNlKHRyYW5zZm9ybXMpLFxyXG4gICAgdHJhbnNmb3JtczogW10sXHJcbiAgICBlbGVtZW50czogW10sXHJcbiAgICBjbG9zZWQ6IGRhdGEuaGQgPT09IHRydWUsXHJcbiAgfTtcclxuICB2YXIgZWxlbWVudERhdGEgPSB7fTtcclxuICBpZiAoZGF0YS50eSA9PT0gJ2ZsJyB8fCBkYXRhLnR5ID09PSAnc3QnKSB7XHJcbiAgICBlbGVtZW50RGF0YS5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5jLCAxLCAyNTUsIHRoaXMpO1xyXG4gICAgaWYgKCFlbGVtZW50RGF0YS5jLmspIHtcclxuICAgICAgc3R5bGVFbGVtLmNvID0gJ3JnYignICsgYm1GbG9vcihlbGVtZW50RGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihlbGVtZW50RGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihlbGVtZW50RGF0YS5jLnZbMl0pICsgJyknO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2dmJyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XHJcbiAgICBlbGVtZW50RGF0YS5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5zLCAxLCBudWxsLCB0aGlzKTtcclxuICAgIGVsZW1lbnREYXRhLmUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmUsIDEsIG51bGwsIHRoaXMpO1xyXG4gICAgZWxlbWVudERhdGEuaCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEuaCB8fCB7IGs6IDAgfSwgMCwgMC4wMSwgdGhpcyk7XHJcbiAgICBlbGVtZW50RGF0YS5hID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5hIHx8IHsgazogMCB9LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgZWxlbWVudERhdGEuZyA9IG5ldyBHcmFkaWVudFByb3BlcnR5KHRoaXMsIGRhdGEuZywgdGhpcyk7XHJcbiAgfVxyXG4gIGVsZW1lbnREYXRhLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xyXG4gIGlmIChkYXRhLnR5ID09PSAnc3QnIHx8IGRhdGEudHkgPT09ICdncycpIHtcclxuICAgIHN0eWxlRWxlbS5sYyA9IGxpbmVDYXBFbnVtW2RhdGEubGMgfHwgMl07XHJcbiAgICBzdHlsZUVsZW0ubGogPSBsaW5lSm9pbkVudW1bZGF0YS5saiB8fCAyXTtcclxuICAgIGlmIChkYXRhLmxqID09IDEpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgc3R5bGVFbGVtLm1sID0gZGF0YS5tbDtcclxuICAgIH1cclxuICAgIGVsZW1lbnREYXRhLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLncsIDAsIG51bGwsIHRoaXMpO1xyXG4gICAgaWYgKCFlbGVtZW50RGF0YS53LmspIHtcclxuICAgICAgc3R5bGVFbGVtLndpID0gZWxlbWVudERhdGEudy52O1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEuZCkge1xyXG4gICAgICB2YXIgZCA9IG5ldyBEYXNoUHJvcGVydHkodGhpcywgZGF0YS5kLCAnY2FudmFzJywgdGhpcyk7XHJcbiAgICAgIGVsZW1lbnREYXRhLmQgPSBkO1xyXG4gICAgICBpZiAoIWVsZW1lbnREYXRhLmQuaykge1xyXG4gICAgICAgIHN0eWxlRWxlbS5kYSA9IGVsZW1lbnREYXRhLmQuZGFzaEFycmF5O1xyXG4gICAgICAgIHN0eWxlRWxlbS5kbyA9IGVsZW1lbnREYXRhLmQuZGFzaG9mZnNldFswXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBzdHlsZUVsZW0uciA9IGRhdGEuciA9PT0gMiA/ICdldmVub2RkJyA6ICdub256ZXJvJztcclxuICB9XHJcbiAgdGhpcy5zdHlsZXNMaXN0LnB1c2goc3R5bGVFbGVtKTtcclxuICBlbGVtZW50RGF0YS5zdHlsZSA9IHN0eWxlRWxlbTtcclxuICByZXR1cm4gZWxlbWVudERhdGE7XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlR3JvdXBFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBlbGVtZW50RGF0YSA9IHtcclxuICAgIGl0OiBbXSxcclxuICAgIHByZXZWaWV3RGF0YTogW10sXHJcbiAgfTtcclxuICByZXR1cm4gZWxlbWVudERhdGE7XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlVHJhbnNmb3JtRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgdmFyIGVsZW1lbnREYXRhID0ge1xyXG4gICAgdHJhbnNmb3JtOiB7XHJcbiAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgIF9vcE1kZjogZmFsc2UsXHJcbiAgICAgIGtleTogdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5nZXROZXdLZXkoKSxcclxuICAgICAgb3A6IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEubywgMCwgMC4wMSwgdGhpcyksXHJcbiAgICAgIG1Qcm9wczogVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5KHRoaXMsIGRhdGEsIHRoaXMpLFxyXG4gICAgfSxcclxuICB9O1xyXG4gIHJldHVybiBlbGVtZW50RGF0YTtcclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHZhciBlbGVtZW50RGF0YSA9IG5ldyBDVlNoYXBlRGF0YSh0aGlzLCBkYXRhLCB0aGlzLnN0eWxlc0xpc3QsIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIpO1xyXG5cclxuICB0aGlzLnNoYXBlcy5wdXNoKGVsZW1lbnREYXRhKTtcclxuICB0aGlzLmFkZFNoYXBlVG9Nb2RpZmllcnMoZWxlbWVudERhdGEpO1xyXG4gIHJldHVybiBlbGVtZW50RGF0YTtcclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZWxvYWRTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5pdGVtc0RhdGEubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgdGhpcy5wcmV2Vmlld0RhdGFbaV0gPSB0aGlzLml0ZW1zRGF0YVtpXTtcclxuICB9XHJcbiAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRydWUsIFtdKTtcclxuICBsZW4gPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcclxuICB9XHJcbiAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcclxuICB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLnByb2Nlc3NTZXF1ZW5jZXModGhpcy5faXNGaXJzdEZyYW1lKTtcclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUcmFuc2Zvcm1Ub1N0eWxlTGlzdCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGlmICghdGhpcy5zdHlsZXNMaXN0W2ldLmNsb3NlZCkge1xyXG4gICAgICB0aGlzLnN0eWxlc0xpc3RbaV0udHJhbnNmb3Jtcy5wdXNoKHRyYW5zZm9ybSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZVRyYW5zZm9ybUZyb21TdHlsZUxpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAoIXRoaXMuc3R5bGVzTGlzdFtpXS5jbG9zZWQpIHtcclxuICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLnRyYW5zZm9ybXMucG9wKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNsb3NlU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgc3R5bGVzW2ldLmNsb3NlZCA9IHRydWU7XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNlYXJjaFNoYXBlcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZW1zRGF0YSwgcHJldlZpZXdEYXRhLCBzaG91bGRSZW5kZXIsIHRyYW5zZm9ybXMpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIG93blN0eWxlcyA9IFtdO1xyXG4gIHZhciBvd25Nb2RpZmllcnMgPSBbXTtcclxuICB2YXIgcHJvY2Vzc2VkUG9zO1xyXG4gIHZhciBtb2RpZmllcjtcclxuICB2YXIgY3VycmVudFRyYW5zZm9ybTtcclxuICB2YXIgb3duVHJhbnNmb3JtcyA9IFtdLmNvbmNhdCh0cmFuc2Zvcm1zKTtcclxuICBmb3IgKGkgPSBsZW47IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICBwcm9jZXNzZWRQb3MgPSB0aGlzLnNlYXJjaFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldKTtcclxuICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgIGFycltpXS5fc2hvdWxkUmVuZGVyID0gc2hvdWxkUmVuZGVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlbXNEYXRhW2ldID0gcHJldlZpZXdEYXRhW3Byb2Nlc3NlZFBvcyAtIDFdO1xyXG4gICAgfVxyXG4gICAgaWYgKGFycltpXS50eSA9PT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT09ICdzdCcgfHwgYXJyW2ldLnR5ID09PSAnZ2YnIHx8IGFycltpXS50eSA9PT0gJ2dzJykge1xyXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU3R5bGVFbGVtZW50KGFycltpXSwgb3duVHJhbnNmb3Jtcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaXRlbXNEYXRhW2ldLnN0eWxlLmNsb3NlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBvd25TdHlsZXMucHVzaChpdGVtc0RhdGFbaV0uc3R5bGUpO1xyXG4gICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZUdyb3VwRWxlbWVudChhcnJbaV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGpMZW4gPSBpdGVtc0RhdGFbaV0uaXQubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGFbal0gPSBpdGVtc0RhdGFbaV0uaXRbal07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2VhcmNoU2hhcGVzKGFycltpXS5pdCwgaXRlbXNEYXRhW2ldLml0LCBpdGVtc0RhdGFbaV0ucHJldlZpZXdEYXRhLCBzaG91bGRSZW5kZXIsIG93blRyYW5zZm9ybXMpO1xyXG4gICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0cicpIHtcclxuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgICBjdXJyZW50VHJhbnNmb3JtID0gdGhpcy5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50KGFycltpXSk7XHJcbiAgICAgICAgaXRlbXNEYXRhW2ldID0gY3VycmVudFRyYW5zZm9ybTtcclxuICAgICAgfVxyXG4gICAgICBvd25UcmFuc2Zvcm1zLnB1c2goaXRlbXNEYXRhW2ldKTtcclxuICAgICAgdGhpcy5hZGRUcmFuc2Zvcm1Ub1N0eWxlTGlzdChpdGVtc0RhdGFbaV0pO1xyXG4gICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdzaCcgfHwgYXJyW2ldLnR5ID09PSAncmMnIHx8IGFycltpXS50eSA9PT0gJ2VsJyB8fCBhcnJbaV0udHkgPT09ICdzcicpIHtcclxuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVNoYXBlRWxlbWVudChhcnJbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RtJyB8fCBhcnJbaV0udHkgPT09ICdyZCcgfHwgYXJyW2ldLnR5ID09PSAncGInKSB7XHJcbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xyXG4gICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcclxuICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcclxuICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xyXG4gICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIG93bk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAncnAnKSB7XHJcbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xyXG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IG1vZGlmaWVyO1xyXG4gICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyLCBpLCBpdGVtc0RhdGEpO1xyXG4gICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgc2hvdWxkUmVuZGVyID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbW9kaWZpZXIgPSBpdGVtc0RhdGFbaV07XHJcbiAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XHJcbiAgfVxyXG4gIHRoaXMucmVtb3ZlVHJhbnNmb3JtRnJvbVN0eWxlTGlzdCgpO1xyXG4gIHRoaXMuY2xvc2VTdHlsZXMob3duU3R5bGVzKTtcclxuICBsZW4gPSBvd25Nb2RpZmllcnMubGVuZ3RoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgb3duTW9kaWZpZXJzW2ldLmNsb3NlZCA9IHRydWU7XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnRyYW5zZm9ybUhlbHBlci5vcGFjaXR5ID0gMTtcclxuICB0aGlzLnRyYW5zZm9ybUhlbHBlci5fb3BNZGYgPSBmYWxzZTtcclxuICB0aGlzLnJlbmRlck1vZGlmaWVycygpO1xyXG4gIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIucHJvY2Vzc1NlcXVlbmNlcyh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xyXG4gIHRoaXMucmVuZGVyU2hhcGUodGhpcy50cmFuc2Zvcm1IZWxwZXIsIHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRydWUpO1xyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclNoYXBlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHBhcmVudFRyYW5zZm9ybSwgZ3JvdXBUcmFuc2Zvcm0pIHtcclxuICBpZiAocGFyZW50VHJhbnNmb3JtLl9vcE1kZiB8fCBncm91cFRyYW5zZm9ybS5vcC5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eSA9IHBhcmVudFRyYW5zZm9ybS5vcGFjaXR5O1xyXG4gICAgZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eSAqPSBncm91cFRyYW5zZm9ybS5vcC52O1xyXG4gICAgZ3JvdXBUcmFuc2Zvcm0uX29wTWRmID0gdHJ1ZTtcclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZHJhd0xheWVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xyXG4gIHZhciBqO1xyXG4gIHZhciBqTGVuO1xyXG4gIHZhciBrO1xyXG4gIHZhciBrTGVuO1xyXG4gIHZhciBlbGVtcztcclxuICB2YXIgbm9kZXM7XHJcbiAgdmFyIHJlbmRlcmVyID0gdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyO1xyXG4gIHZhciBjdHggPSB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dDtcclxuICB2YXIgdHlwZTtcclxuICB2YXIgY3VycmVudFN0eWxlO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgY3VycmVudFN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2ldO1xyXG4gICAgdHlwZSA9IGN1cnJlbnRTdHlsZS50eXBlO1xyXG5cclxuICAgIC8vIFNraXBwaW5nIHN0eWxlIHdoZW5cclxuICAgIC8vIFN0cm9rZSB3aWR0aCBlcXVhbHMgMFxyXG4gICAgLy8gc3R5bGUgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCAoZXh0cmEgdW51c2VkIHJlcGVhdGVycylcclxuICAgIC8vIGN1cnJlbnQgb3BhY2l0eSBlcXVhbHMgMFxyXG4gICAgLy8gZ2xvYmFsIG9wYWNpdHkgZXF1YWxzIDBcclxuICAgIGlmICghKCgodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKSAmJiBjdXJyZW50U3R5bGUud2kgPT09IDApIHx8ICFjdXJyZW50U3R5bGUuZGF0YS5fc2hvdWxkUmVuZGVyIHx8IGN1cnJlbnRTdHlsZS5jb09wID09PSAwIHx8IHRoaXMuZ2xvYmFsRGF0YS5jdXJyZW50R2xvYmFsQWxwaGEgPT09IDApKSB7XHJcbiAgICAgIHJlbmRlcmVyLnNhdmUoKTtcclxuICAgICAgZWxlbXMgPSBjdXJyZW50U3R5bGUuZWxlbWVudHM7XHJcbiAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0eXBlID09PSAnc3QnID8gY3VycmVudFN0eWxlLmNvIDogY3VycmVudFN0eWxlLmdyZDtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gY3VycmVudFN0eWxlLndpO1xyXG4gICAgICAgIGN0eC5saW5lQ2FwID0gY3VycmVudFN0eWxlLmxjO1xyXG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGN1cnJlbnRTdHlsZS5sajtcclxuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IGN1cnJlbnRTdHlsZS5tbCB8fCAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0eXBlID09PSAnZmwnID8gY3VycmVudFN0eWxlLmNvIDogY3VycmVudFN0eWxlLmdyZDtcclxuICAgICAgfVxyXG4gICAgICByZW5kZXJlci5jdHhPcGFjaXR5KGN1cnJlbnRTdHlsZS5jb09wKTtcclxuICAgICAgaWYgKHR5cGUgIT09ICdzdCcgJiYgdHlwZSAhPT0gJ2dzJykge1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgfVxyXG4gICAgICByZW5kZXJlci5jdHhUcmFuc2Zvcm0oY3VycmVudFN0eWxlLnByZVRyYW5zZm9ybXMuZmluYWxUcmFuc2Zvcm0ucHJvcHMpO1xyXG4gICAgICBqTGVuID0gZWxlbXMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdCcgfHwgdHlwZSA9PT0gJ2dzJykge1xyXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZS5kYSkge1xyXG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goY3VycmVudFN0eWxlLmRhKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gY3VycmVudFN0eWxlLmRvO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlcyA9IGVsZW1zW2pdLnRyTm9kZXM7XHJcbiAgICAgICAga0xlbiA9IG5vZGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xyXG4gICAgICAgICAgaWYgKG5vZGVzW2tdLnQgPT09ICdtJykge1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKG5vZGVzW2tdLnBbMF0sIG5vZGVzW2tdLnBbMV0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChub2Rlc1trXS50ID09PSAnYycpIHtcclxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8obm9kZXNba10ucHRzWzBdLCBub2Rlc1trXS5wdHNbMV0sIG5vZGVzW2tdLnB0c1syXSwgbm9kZXNba10ucHRzWzNdLCBub2Rlc1trXS5wdHNbNF0sIG5vZGVzW2tdLnB0c1s1XSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcclxuICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgIGlmIChjdXJyZW50U3R5bGUuZGEpIHtcclxuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKHRoaXMuZGFzaFJlc2V0dGVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGUgIT09ICdzdCcgJiYgdHlwZSAhPT0gJ2dzJykge1xyXG4gICAgICAgIGN0eC5maWxsKGN1cnJlbnRTdHlsZS5yKTtcclxuICAgICAgfVxyXG4gICAgICByZW5kZXJlci5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclNoYXBlID0gZnVuY3Rpb24gKHBhcmVudFRyYW5zZm9ybSwgaXRlbXMsIGRhdGEsIGlzTWFpbikge1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBpdGVtcy5sZW5ndGggLSAxO1xyXG4gIHZhciBncm91cFRyYW5zZm9ybTtcclxuICBncm91cFRyYW5zZm9ybSA9IHBhcmVudFRyYW5zZm9ybTtcclxuICBmb3IgKGkgPSBsZW47IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICBpZiAoaXRlbXNbaV0udHkgPT09ICd0cicpIHtcclxuICAgICAgZ3JvdXBUcmFuc2Zvcm0gPSBkYXRhW2ldLnRyYW5zZm9ybTtcclxuICAgICAgdGhpcy5yZW5kZXJTaGFwZVRyYW5zZm9ybShwYXJlbnRUcmFuc2Zvcm0sIGdyb3VwVHJhbnNmb3JtKTtcclxuICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdzaCcgfHwgaXRlbXNbaV0udHkgPT09ICdlbCcgfHwgaXRlbXNbaV0udHkgPT09ICdyYycgfHwgaXRlbXNbaV0udHkgPT09ICdzcicpIHtcclxuICAgICAgdGhpcy5yZW5kZXJQYXRoKGl0ZW1zW2ldLCBkYXRhW2ldKTtcclxuICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdmbCcpIHtcclxuICAgICAgdGhpcy5yZW5kZXJGaWxsKGl0ZW1zW2ldLCBkYXRhW2ldLCBncm91cFRyYW5zZm9ybSk7XHJcbiAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnc3QnKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyU3Ryb2tlKGl0ZW1zW2ldLCBkYXRhW2ldLCBncm91cFRyYW5zZm9ybSk7XHJcbiAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnZ2YnIHx8IGl0ZW1zW2ldLnR5ID09PSAnZ3MnKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyR3JhZGllbnRGaWxsKGl0ZW1zW2ldLCBkYXRhW2ldLCBncm91cFRyYW5zZm9ybSk7XHJcbiAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnZ3InKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyU2hhcGUoZ3JvdXBUcmFuc2Zvcm0sIGl0ZW1zW2ldLml0LCBkYXRhW2ldLml0KTtcclxuICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICd0bScpIHtcclxuICAgICAgLy9cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGlzTWFpbikge1xyXG4gICAgdGhpcy5kcmF3TGF5ZXIoKTtcclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU3R5bGVkU2hhcGUgPSBmdW5jdGlvbiAoc3R5bGVkU2hhcGUsIHNoYXBlKSB7XHJcbiAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCBzaGFwZS5fbWRmIHx8IHN0eWxlZFNoYXBlLnRyYW5zZm9ybXMuX21kZikge1xyXG4gICAgdmFyIHNoYXBlTm9kZXMgPSBzdHlsZWRTaGFwZS50ck5vZGVzO1xyXG4gICAgdmFyIHBhdGhzID0gc2hhcGUucGF0aHM7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW47XHJcbiAgICB2YXIgajtcclxuICAgIHZhciBqTGVuID0gcGF0aHMuX2xlbmd0aDtcclxuICAgIHNoYXBlTm9kZXMubGVuZ3RoID0gMDtcclxuICAgIHZhciBncm91cFRyYW5zZm9ybU1hdCA9IHN0eWxlZFNoYXBlLnRyYW5zZm9ybXMuZmluYWxUcmFuc2Zvcm07XHJcbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgIHZhciBwYXRoTm9kZXMgPSBwYXRocy5zaGFwZXNbal07XHJcbiAgICAgIGlmIChwYXRoTm9kZXMgJiYgcGF0aE5vZGVzLnYpIHtcclxuICAgICAgICBsZW4gPSBwYXRoTm9kZXMuX2xlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgIGlmIChpID09PSAxKSB7XHJcbiAgICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgdDogJ20nLFxyXG4gICAgICAgICAgICAgIHA6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9Qb2ludEFycmF5KHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcclxuICAgICAgICAgICAgdDogJ2MnLFxyXG4gICAgICAgICAgICBwdHM6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9UcmlwbGVQb2ludHMocGF0aE5vZGVzLm9baSAtIDFdLCBwYXRoTm9kZXMuaVtpXSwgcGF0aE5vZGVzLnZbaV0pLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW4gPT09IDEpIHtcclxuICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHQ6ICdtJyxcclxuICAgICAgICAgICAgcDogZ3JvdXBUcmFuc2Zvcm1NYXQuYXBwbHlUb1BvaW50QXJyYXkocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0aE5vZGVzLmMgJiYgbGVuKSB7XHJcbiAgICAgICAgICBzaGFwZU5vZGVzLnB1c2goe1xyXG4gICAgICAgICAgICB0OiAnYycsXHJcbiAgICAgICAgICAgIHB0czogZ3JvdXBUcmFuc2Zvcm1NYXQuYXBwbHlUb1RyaXBsZVBvaW50cyhwYXRoTm9kZXMub1tpIC0gMV0sIHBhdGhOb2Rlcy5pWzBdLCBwYXRoTm9kZXMudlswXSksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHQ6ICd6JyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3R5bGVkU2hhcGUudHJOb2RlcyA9IHNoYXBlTm9kZXM7XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIGl0ZW1EYXRhKSB7XHJcbiAgaWYgKHBhdGhEYXRhLmhkICE9PSB0cnVlICYmIHBhdGhEYXRhLl9zaG91bGRSZW5kZXIpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IGl0ZW1EYXRhLnN0eWxlZFNoYXBlcy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5yZW5kZXJTdHlsZWRTaGFwZShpdGVtRGF0YS5zdHlsZWRTaGFwZXNbaV0sIGl0ZW1EYXRhLnNoKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRmlsbCA9IGZ1bmN0aW9uIChzdHlsZURhdGEsIGl0ZW1EYXRhLCBncm91cFRyYW5zZm9ybSkge1xyXG4gIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcclxuXHJcbiAgaWYgKGl0ZW1EYXRhLmMuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgIHN0eWxlRWxlbS5jbyA9ICdyZ2IoJ1xyXG4gICAgICAgICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnXHJcbiAgICAgICAgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsxXSkgKyAnLCdcclxuICAgICAgICArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJztcclxuICB9XHJcbiAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBncm91cFRyYW5zZm9ybS5fb3BNZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XHJcbiAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlckdyYWRpZW50RmlsbCA9IGZ1bmN0aW9uIChzdHlsZURhdGEsIGl0ZW1EYXRhLCBncm91cFRyYW5zZm9ybSkge1xyXG4gIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcclxuICB2YXIgZ3JkO1xyXG4gIGlmICghc3R5bGVFbGVtLmdyZCB8fCBpdGVtRGF0YS5nLl9tZGYgfHwgaXRlbURhdGEucy5fbWRmIHx8IGl0ZW1EYXRhLmUuX21kZiB8fCAoc3R5bGVEYXRhLnQgIT09IDEgJiYgKGl0ZW1EYXRhLmguX21kZiB8fCBpdGVtRGF0YS5hLl9tZGYpKSkge1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0O1xyXG4gICAgdmFyIHB0MSA9IGl0ZW1EYXRhLnMudjtcclxuICAgIHZhciBwdDIgPSBpdGVtRGF0YS5lLnY7XHJcbiAgICBpZiAoc3R5bGVEYXRhLnQgPT09IDEpIHtcclxuICAgICAgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHB0MVswXSwgcHQxWzFdLCBwdDJbMF0sIHB0MlsxXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgcmFkID0gTWF0aC5zcXJ0KE1hdGgucG93KHB0MVswXSAtIHB0MlswXSwgMikgKyBNYXRoLnBvdyhwdDFbMV0gLSBwdDJbMV0sIDIpKTtcclxuICAgICAgdmFyIGFuZyA9IE1hdGguYXRhbjIocHQyWzFdIC0gcHQxWzFdLCBwdDJbMF0gLSBwdDFbMF0pO1xyXG5cclxuICAgICAgdmFyIHBlcmNlbnQgPSBpdGVtRGF0YS5oLnY7XHJcbiAgICAgIGlmIChwZXJjZW50ID49IDEpIHtcclxuICAgICAgICBwZXJjZW50ID0gMC45OTtcclxuICAgICAgfSBlbHNlIGlmIChwZXJjZW50IDw9IC0xKSB7XHJcbiAgICAgICAgcGVyY2VudCA9IC0wLjk5O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBkaXN0ID0gcmFkICogcGVyY2VudDtcclxuICAgICAgdmFyIHggPSBNYXRoLmNvcyhhbmcgKyBpdGVtRGF0YS5hLnYpICogZGlzdCArIHB0MVswXTtcclxuICAgICAgdmFyIHkgPSBNYXRoLnNpbihhbmcgKyBpdGVtRGF0YS5hLnYpICogZGlzdCArIHB0MVsxXTtcclxuICAgICAgZ3JkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHB0MVswXSwgcHQxWzFdLCByYWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHN0eWxlRGF0YS5nLnA7XHJcbiAgICB2YXIgY1ZhbHVlcyA9IGl0ZW1EYXRhLmcuYztcclxuICAgIHZhciBvcGFjaXR5ID0gMTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgaWYgKGl0ZW1EYXRhLmcuX2hhc09wYWNpdHkgJiYgaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcclxuICAgICAgICBvcGFjaXR5ID0gaXRlbURhdGEuZy5vW2kgKiAyICsgMV07XHJcbiAgICAgIH1cclxuICAgICAgZ3JkLmFkZENvbG9yU3RvcChjVmFsdWVzW2kgKiA0XSAvIDEwMCwgJ3JnYmEoJyArIGNWYWx1ZXNbaSAqIDQgKyAxXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAyXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAzXSArICcsJyArIG9wYWNpdHkgKyAnKScpO1xyXG4gICAgfVxyXG4gICAgc3R5bGVFbGVtLmdyZCA9IGdyZDtcclxuICB9XHJcbiAgc3R5bGVFbGVtLmNvT3AgPSBpdGVtRGF0YS5vLnYgKiBncm91cFRyYW5zZm9ybS5vcGFjaXR5O1xyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclN0cm9rZSA9IGZ1bmN0aW9uIChzdHlsZURhdGEsIGl0ZW1EYXRhLCBncm91cFRyYW5zZm9ybSkge1xyXG4gIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcclxuICB2YXIgZCA9IGl0ZW1EYXRhLmQ7XHJcbiAgaWYgKGQgJiYgKGQuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpKSB7XHJcbiAgICBzdHlsZUVsZW0uZGEgPSBkLmRhc2hBcnJheTtcclxuICAgIHN0eWxlRWxlbS5kbyA9IGQuZGFzaG9mZnNldFswXTtcclxuICB9XHJcbiAgaWYgKGl0ZW1EYXRhLmMuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgIHN0eWxlRWxlbS5jbyA9ICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJztcclxuICB9XHJcbiAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBncm91cFRyYW5zZm9ybS5fb3BNZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XHJcbiAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XHJcbiAgfVxyXG4gIGlmIChpdGVtRGF0YS53Ll9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XHJcbiAgICBzdHlsZUVsZW0ud2kgPSBpdGVtRGF0YS53LnY7XHJcbiAgfVxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5zaGFwZXNEYXRhID0gbnVsbDtcclxuICB0aGlzLmdsb2JhbERhdGEgPSBudWxsO1xyXG4gIHRoaXMuY2FudmFzQ29udGV4dCA9IG51bGw7XHJcbiAgdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aCA9IDA7XHJcbiAgdGhpcy5pdGVtc0RhdGEubGVuZ3RoID0gMDtcclxufTtcclxuXHJcbi8qIGdsb2JhbCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50LFxyXG5TVkdTaGFwZUVsZW1lbnQsIElJbWFnZUVsZW1lbnQgKi9cclxuXHJcbmZ1bmN0aW9uIENWU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG59XHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBDVlNvbGlkRWxlbWVudCk7XHJcblxyXG5DVlNvbGlkRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50O1xyXG5DVlNvbGlkRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gSUltYWdlRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lO1xyXG5cclxuQ1ZTb2xpZEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY3R4ID0gdGhpcy5jYW52YXNDb250ZXh0O1xyXG4gIGN0eC5maWxsU3R5bGUgPSB0aGlzLmRhdGEuc2M7XHJcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuZGF0YS5zdywgdGhpcy5kYXRhLnNoKTtcclxuICAvL1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCxcclxuUmVuZGVyYWJsZUVsZW1lbnQsIElUZXh0RWxlbWVudCwgY3JlYXRlVGFnLCBjcmVhdGVTaXplZEFycmF5ICovXHJcblxyXG5mdW5jdGlvbiBDVlRleHRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLnRleHRTcGFucyA9IFtdO1xyXG4gIHRoaXMueU9mZnNldCA9IDA7XHJcbiAgdGhpcy5maWxsQ29sb3JBbmltID0gZmFsc2U7XHJcbiAgdGhpcy5zdHJva2VDb2xvckFuaW0gPSBmYWxzZTtcclxuICB0aGlzLnN0cm9rZVdpZHRoQW5pbSA9IGZhbHNlO1xyXG4gIHRoaXMuc3Ryb2tlID0gZmFsc2U7XHJcbiAgdGhpcy5maWxsID0gZmFsc2U7XHJcbiAgdGhpcy5qdXN0aWZ5T2Zmc2V0ID0gMDtcclxuICB0aGlzLmN1cnJlbnRSZW5kZXIgPSBudWxsO1xyXG4gIHRoaXMucmVuZGVyVHlwZSA9ICdjYW52YXMnO1xyXG4gIHRoaXMudmFsdWVzID0ge1xyXG4gICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLFxyXG4gICAgc3Ryb2tlOiAncmdiYSgwLDAsMCwwKScsXHJcbiAgICBzV2lkdGg6IDAsXHJcbiAgICBmVmFsdWU6ICcnLFxyXG4gIH07XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxufVxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50LCBJVGV4dEVsZW1lbnRdLCBDVlRleHRFbGVtZW50KTtcclxuXHJcbkNWVGV4dEVsZW1lbnQucHJvdG90eXBlLnRIZWxwZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG5DVlRleHRFbGVtZW50LnByb3RvdHlwZS5idWlsZE5ld1RleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGRvY3VtZW50RGF0YSA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhO1xyXG4gIHRoaXMucmVuZGVyZWRMZXR0ZXJzID0gY3JlYXRlU2l6ZWRBcnJheShkb2N1bWVudERhdGEubCA/IGRvY3VtZW50RGF0YS5sLmxlbmd0aCA6IDApO1xyXG5cclxuICB2YXIgaGFzRmlsbCA9IGZhbHNlO1xyXG4gIGlmIChkb2N1bWVudERhdGEuZmMpIHtcclxuICAgIGhhc0ZpbGwgPSB0cnVlO1xyXG4gICAgdGhpcy52YWx1ZXMuZmlsbCA9IHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuZmMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnZhbHVlcy5maWxsID0gJ3JnYmEoMCwwLDAsMCknO1xyXG4gIH1cclxuICB0aGlzLmZpbGwgPSBoYXNGaWxsO1xyXG4gIHZhciBoYXNTdHJva2UgPSBmYWxzZTtcclxuICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XHJcbiAgICBoYXNTdHJva2UgPSB0cnVlO1xyXG4gICAgdGhpcy52YWx1ZXMuc3Ryb2tlID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5zYyk7XHJcbiAgICB0aGlzLnZhbHVlcy5zV2lkdGggPSBkb2N1bWVudERhdGEuc3c7XHJcbiAgfVxyXG4gIHZhciBmb250RGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuO1xyXG4gIHZhciBsZXR0ZXJzID0gZG9jdW1lbnREYXRhLmw7XHJcbiAgdmFyIG1hdHJpeEhlbHBlciA9IHRoaXMubUhlbHBlcjtcclxuICB0aGlzLnN0cm9rZSA9IGhhc1N0cm9rZTtcclxuICB0aGlzLnZhbHVlcy5mVmFsdWUgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4ICcgKyB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseTtcclxuICBsZW4gPSBkb2N1bWVudERhdGEuZmluYWxUZXh0Lmxlbmd0aDtcclxuICAvLyB0aGlzLnRIZWxwZXIuZm9udCA9IHRoaXMudmFsdWVzLmZWYWx1ZTtcclxuICB2YXIgY2hhckRhdGE7XHJcbiAgdmFyIHNoYXBlRGF0YTtcclxuICB2YXIgaztcclxuICB2YXIga0xlbjtcclxuICB2YXIgc2hhcGVzO1xyXG4gIHZhciBqO1xyXG4gIHZhciBqTGVuO1xyXG4gIHZhciBwYXRoTm9kZXM7XHJcbiAgdmFyIGNvbW1hbmRzO1xyXG4gIHZhciBwYXRoQXJyO1xyXG4gIHZhciBzaW5nbGVTaGFwZSA9IHRoaXMuZGF0YS5zaW5nbGVTaGFwZTtcclxuICB2YXIgdHJhY2tpbmdPZmZzZXQgPSBkb2N1bWVudERhdGEudHIgKiAwLjAwMSAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XHJcbiAgdmFyIHhQb3MgPSAwO1xyXG4gIHZhciB5UG9zID0gMDtcclxuICB2YXIgZmlyc3RMaW5lID0gdHJ1ZTtcclxuICB2YXIgY250ID0gMDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGNoYXJEYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHkpO1xyXG4gICAgc2hhcGVEYXRhID0gKGNoYXJEYXRhICYmIGNoYXJEYXRhLmRhdGEpIHx8IHt9O1xyXG4gICAgbWF0cml4SGVscGVyLnJlc2V0KCk7XHJcbiAgICBpZiAoc2luZ2xlU2hhcGUgJiYgbGV0dGVyc1tpXS5uKSB7XHJcbiAgICAgIHhQb3MgPSAtdHJhY2tpbmdPZmZzZXQ7XHJcbiAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLnlPZmZzZXQ7XHJcbiAgICAgIHlQb3MgKz0gZmlyc3RMaW5lID8gMSA6IDA7XHJcbiAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHNoYXBlcyA9IHNoYXBlRGF0YS5zaGFwZXMgPyBzaGFwZURhdGEuc2hhcGVzWzBdLml0IDogW107XHJcbiAgICBqTGVuID0gc2hhcGVzLmxlbmd0aDtcclxuICAgIG1hdHJpeEhlbHBlci5zY2FsZShkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwLCBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwKTtcclxuICAgIGlmIChzaW5nbGVTaGFwZSkge1xyXG4gICAgICB0aGlzLmFwcGx5VGV4dFByb3BlcnRpZXNUb01hdHJpeChkb2N1bWVudERhdGEsIG1hdHJpeEhlbHBlciwgbGV0dGVyc1tpXS5saW5lLCB4UG9zLCB5UG9zKTtcclxuICAgIH1cclxuICAgIGNvbW1hbmRzID0gY3JlYXRlU2l6ZWRBcnJheShqTGVuKTtcclxuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAga0xlbiA9IHNoYXBlc1tqXS5rcy5rLmkubGVuZ3RoO1xyXG4gICAgICBwYXRoTm9kZXMgPSBzaGFwZXNbal0ua3MuaztcclxuICAgICAgcGF0aEFyciA9IFtdO1xyXG4gICAgICBmb3IgKGsgPSAxOyBrIDwga0xlbjsgayArPSAxKSB7XHJcbiAgICAgICAgaWYgKGsgPT09IDEpIHtcclxuICAgICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRoQXJyLnB1c2gobWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy5vW2sgLSAxXVswXSwgcGF0aE5vZGVzLm9bayAtIDFdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5vW2sgLSAxXVswXSwgcGF0aE5vZGVzLm9bayAtIDFdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy5pW2tdWzBdLCBwYXRoTm9kZXMuaVtrXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMuaVtrXVswXSwgcGF0aE5vZGVzLmlba11bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLnZba11bMF0sIHBhdGhOb2Rlcy52W2tdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy52W2tdWzBdLCBwYXRoTm9kZXMudltrXVsxXSwgMCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLmlbMF1bMF0sIHBhdGhOb2Rlcy5pWzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5pWzBdWzBdLCBwYXRoTm9kZXMuaVswXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSk7XHJcbiAgICAgIGNvbW1hbmRzW2pdID0gcGF0aEFycjtcclxuICAgIH1cclxuICAgIGlmIChzaW5nbGVTaGFwZSkge1xyXG4gICAgICB4UG9zICs9IGxldHRlcnNbaV0ubDtcclxuICAgICAgeFBvcyArPSB0cmFja2luZ09mZnNldDtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnRleHRTcGFuc1tjbnRdKSB7XHJcbiAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0uZWxlbSA9IGNvbW1hbmRzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy50ZXh0U3BhbnNbY250XSA9IHsgZWxlbTogY29tbWFuZHMgfTtcclxuICAgIH1cclxuICAgIGNudCArPSAxO1xyXG4gIH1cclxufTtcclxuXHJcbkNWVGV4dEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY3R4ID0gdGhpcy5jYW52YXNDb250ZXh0O1xyXG4gIGN0eC5mb250ID0gdGhpcy52YWx1ZXMuZlZhbHVlO1xyXG4gIGN0eC5saW5lQ2FwID0gJ2J1dHQnO1xyXG4gIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XHJcbiAgY3R4Lm1pdGVyTGltaXQgPSA0O1xyXG5cclxuICBpZiAoIXRoaXMuZGF0YS5zaW5nbGVTaGFwZSkge1xyXG4gICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcclxuICB9XHJcblxyXG4gIHZhciBpO1xyXG4gIHZhciBsZW47XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW47XHJcbiAgdmFyIGs7XHJcbiAgdmFyIGtMZW47XHJcbiAgdmFyIHJlbmRlcmVkTGV0dGVycyA9IHRoaXMudGV4dEFuaW1hdG9yLnJlbmRlcmVkTGV0dGVycztcclxuXHJcbiAgdmFyIGxldHRlcnMgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sO1xyXG5cclxuICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcclxuICB2YXIgcmVuZGVyZWRMZXR0ZXI7XHJcbiAgdmFyIGxhc3RGaWxsID0gbnVsbDtcclxuICB2YXIgbGFzdFN0cm9rZSA9IG51bGw7XHJcbiAgdmFyIGxhc3RTdHJva2VXID0gbnVsbDtcclxuICB2YXIgY29tbWFuZHM7XHJcbiAgdmFyIHBhdGhBcnI7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAoIWxldHRlcnNbaV0ubikge1xyXG4gICAgICByZW5kZXJlZExldHRlciA9IHJlbmRlcmVkTGV0dGVyc1tpXTtcclxuICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyKSB7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLnNhdmUoKTtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4VHJhbnNmb3JtKHJlbmRlcmVkTGV0dGVyLnApO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhPcGFjaXR5KHJlbmRlcmVkTGV0dGVyLm8pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmZpbGwpIHtcclxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuZmMpIHtcclxuICAgICAgICAgIGlmIChsYXN0RmlsbCAhPT0gcmVuZGVyZWRMZXR0ZXIuZmMpIHtcclxuICAgICAgICAgICAgbGFzdEZpbGwgPSByZW5kZXJlZExldHRlci5mYztcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHJlbmRlcmVkTGV0dGVyLmZjO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobGFzdEZpbGwgIT09IHRoaXMudmFsdWVzLmZpbGwpIHtcclxuICAgICAgICAgIGxhc3RGaWxsID0gdGhpcy52YWx1ZXMuZmlsbDtcclxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnZhbHVlcy5maWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21tYW5kcyA9IHRoaXMudGV4dFNwYW5zW2ldLmVsZW07XHJcbiAgICAgICAgakxlbiA9IGNvbW1hbmRzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICBwYXRoQXJyID0gY29tbWFuZHNbal07XHJcbiAgICAgICAgICBrTGVuID0gcGF0aEFyci5sZW5ndGg7XHJcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5tb3ZlVG8ocGF0aEFyclswXSwgcGF0aEFyclsxXSk7XHJcbiAgICAgICAgICBmb3IgKGsgPSAyOyBrIDwga0xlbjsgayArPSA2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuZmlsbCgpO1xyXG4gICAgICAgIC8vLyBjdHguZmlsbFRleHQodGhpcy50ZXh0U3BhbnNbaV0udmFsLDAsMCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc3Ryb2tlKSB7XHJcbiAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLnN3KSB7XHJcbiAgICAgICAgICBpZiAobGFzdFN0cm9rZVcgIT09IHJlbmRlcmVkTGV0dGVyLnN3KSB7XHJcbiAgICAgICAgICAgIGxhc3RTdHJva2VXID0gcmVuZGVyZWRMZXR0ZXIuc3c7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSByZW5kZXJlZExldHRlci5zdztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3RTdHJva2VXICE9PSB0aGlzLnZhbHVlcy5zV2lkdGgpIHtcclxuICAgICAgICAgIGxhc3RTdHJva2VXID0gdGhpcy52YWx1ZXMuc1dpZHRoO1xyXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMudmFsdWVzLnNXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLnNjKSB7XHJcbiAgICAgICAgICBpZiAobGFzdFN0cm9rZSAhPT0gcmVuZGVyZWRMZXR0ZXIuc2MpIHtcclxuICAgICAgICAgICAgbGFzdFN0cm9rZSA9IHJlbmRlcmVkTGV0dGVyLnNjO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSByZW5kZXJlZExldHRlci5zYztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3RTdHJva2UgIT09IHRoaXMudmFsdWVzLnN0cm9rZSkge1xyXG4gICAgICAgICAgbGFzdFN0cm9rZSA9IHRoaXMudmFsdWVzLnN0cm9rZTtcclxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMudmFsdWVzLnN0cm9rZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tbWFuZHMgPSB0aGlzLnRleHRTcGFuc1tpXS5lbGVtO1xyXG4gICAgICAgIGpMZW4gPSBjb21tYW5kcy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xyXG4gICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xyXG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xyXG4gICAgICAgICAgZm9yIChrID0gMjsgayA8IGtMZW47IGsgKz0gNikge1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5iZXppZXJDdXJ2ZVRvKHBhdGhBcnJba10sIHBhdGhBcnJbayArIDFdLCBwYXRoQXJyW2sgKyAyXSwgcGF0aEFycltrICsgM10sIHBhdGhBcnJbayArIDRdLCBwYXRoQXJyW2sgKyA1XSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgIC8vLyBjdHguc3Ryb2tlVGV4dChsZXR0ZXJzW2ldLnZhbCwwLDApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZW5kZXJlZExldHRlcikge1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBDVkVmZmVjdHMoKSB7XHJcblxyXG59XHJcbkNWRWZmZWN0cy5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVUYWcsIGNyZWF0ZU5TLCBzdHlsZURpdiwgQ1ZFZmZlY3RzLCBNYXNrRWxlbWVudCwgU1ZHQmFzZUVsZW1lbnQsIEh5YnJpZFJlbmRlcmVyICovXHJcblxyXG5mdW5jdGlvbiBIQmFzZUVsZW1lbnQoKSB7fVxyXG5IQmFzZUVsZW1lbnQucHJvdG90eXBlID0ge1xyXG4gIGNoZWNrQmxlbmRNb2RlOiBmdW5jdGlvbiAoKSB7fSxcclxuICBpbml0UmVuZGVyZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmJhc2VFbGVtZW50ID0gY3JlYXRlVGFnKHRoaXMuZGF0YS50ZyB8fCAnZGl2Jyk7XHJcbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcclxuICAgICAgdGhpcy5zdmdFbGVtZW50ID0gY3JlYXRlTlMoJ3N2ZycpO1xyXG4gICAgICB0aGlzLmxheWVyRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xyXG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xyXG4gICAgICB0aGlzLmJhc2VFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxheWVyRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBzdHlsZURpdih0aGlzLmJhc2VFbGVtZW50KTtcclxuICB9LFxyXG4gIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBDVkVmZmVjdHModGhpcyk7XHJcbiAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XHJcbiAgICB0aGlzLm1hc2tlZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcclxuICAgIGlmICh0aGlzLmRhdGEubG4pIHtcclxuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5kYXRhLmNsKSB7XHJcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLmRhdGEuY2wpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZGF0YS5ibSAhPT0gMCkge1xyXG4gICAgICB0aGlzLnNldEJsZW5kTW9kZSgpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVuZGVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHRyYW5zZm9ybWVkRWxlbWVudFN0eWxlID0gdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPyB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zdHlsZSA6IHt9O1xyXG4gICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xyXG4gICAgICB2YXIgbWF0cml4VmFsdWUgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdC50b0NTUygpO1xyXG4gICAgICB0cmFuc2Zvcm1lZEVsZW1lbnRTdHlsZS50cmFuc2Zvcm0gPSBtYXRyaXhWYWx1ZTtcclxuICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4VmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcclxuICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUub3BhY2l0eSA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52O1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIElmIGl0IGlzIGV4cG9ydGVkIGFzIGhpZGRlbiAoZGF0YS5oZCA9PT0gdHJ1ZSkgbm8gbmVlZCB0byByZW5kZXJcclxuICAgIC8vIElmIGl0IGlzIG5vdCB2aXNpYmxlIG5vIG5lZWQgdG8gcmVuZGVyXHJcbiAgICBpZiAodGhpcy5kYXRhLmhkIHx8IHRoaXMuaGlkZGVuKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XHJcbiAgICB0aGlzLnJlbmRlclJlbmRlcmFibGUoKTtcclxuICAgIHRoaXMucmVuZGVyRWxlbWVudCgpO1xyXG4gICAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcclxuICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSxcclxuICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XHJcbiAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IG51bGw7XHJcbiAgICBpZiAodGhpcy5tYXR0ZUVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubWFza01hbmFnZXIpIHtcclxuICAgICAgdGhpcy5tYXNrTWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgTWFza0VsZW1lbnQodGhpcy5kYXRhLCB0aGlzLCB0aGlzLmdsb2JhbERhdGEpO1xyXG4gIH0sXHJcbiAgYWRkRWZmZWN0czogZnVuY3Rpb24gKCkge1xyXG4gIH0sXHJcbiAgc2V0TWF0dGU6IGZ1bmN0aW9uICgpIHt9LFxyXG59O1xyXG5IQmFzZUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gU1ZHQmFzZUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50O1xyXG5IQmFzZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3lCYXNlRWxlbWVudCA9IEhCYXNlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveTtcclxuSEJhc2VFbGVtZW50LnByb3RvdHlwZS5idWlsZEVsZW1lbnRQYXJlbnRpbmcgPSBIeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRFbGVtZW50UGFyZW50aW5nO1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LFxyXG5SZW5kZXJhYmxlRE9NRWxlbWVudCwgY3JlYXRlTlMsIGNyZWF0ZVRhZyAqL1xyXG5cclxuZnVuY3Rpb24gSFNvbGlkRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxufVxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnRdLCBIU29saWRFbGVtZW50KTtcclxuXHJcbkhTb2xpZEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHJlY3Q7XHJcbiAgaWYgKHRoaXMuZGF0YS5oYXNNYXNrKSB7XHJcbiAgICByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcclxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS5zdyk7XHJcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5kYXRhLnNoKTtcclxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgdGhpcy5kYXRhLnNjKTtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5kYXRhLnN3KTtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5zaCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlY3QgPSBjcmVhdGVUYWcoJ2RpdicpO1xyXG4gICAgcmVjdC5zdHlsZS53aWR0aCA9IHRoaXMuZGF0YS5zdyArICdweCc7XHJcbiAgICByZWN0LnN0eWxlLmhlaWdodCA9IHRoaXMuZGF0YS5zaCArICdweCc7XHJcbiAgICByZWN0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZGF0YS5zYztcclxuICB9XHJcbiAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQocmVjdCk7XHJcbn07XHJcblxyXG4vKiBnbG9iYWwgY3JlYXRlU2l6ZWRBcnJheSwgUHJvcGVydHlGYWN0b3J5LCBleHRlbmRQcm90b3R5cGUsIEh5YnJpZFJlbmRlcmVyLCBJQ29tcEVsZW1lbnQsIEhCYXNlRWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gSENvbXBFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLmxheWVycyA9IGRhdGEubGF5ZXJzO1xyXG4gIHRoaXMuc3VwcG9ydHMzZCA9ICFkYXRhLmhhc01hc2s7XHJcbiAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xyXG4gIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XHJcbiAgdGhpcy5lbGVtZW50cyA9IHRoaXMubGF5ZXJzID8gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLmxheWVycy5sZW5ndGgpIDogW107XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICB0aGlzLnRtID0gZGF0YS50bSA/IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudG0sIDAsIGdsb2JhbERhdGEuZnJhbWVSYXRlLCB0aGlzKSA6IHsgX3BsYWNlaG9sZGVyOiB0cnVlIH07XHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbSHlicmlkUmVuZGVyZXIsIElDb21wRWxlbWVudCwgSEJhc2VFbGVtZW50XSwgSENvbXBFbGVtZW50KTtcclxuSENvbXBFbGVtZW50LnByb3RvdHlwZS5fY3JlYXRlQmFzZUNvbnRhaW5lckVsZW1lbnRzID0gSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJFbGVtZW50cztcclxuXHJcbkhDb21wRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGFpbmVyRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5fY3JlYXRlQmFzZUNvbnRhaW5lckVsZW1lbnRzKCk7XHJcbiAgLy8gZGl2RWxlbWVudC5zdHlsZS5jbGlwID0gJ3JlY3QoMHB4LCAnK3RoaXMuZGF0YS53KydweCwgJyt0aGlzLmRhdGEuaCsncHgsIDBweCknO1xyXG4gIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmRhdGEudyk7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmRhdGEuaCk7XHJcbiAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgfVxyXG59O1xyXG5cclxuSENvbXBFbGVtZW50LnByb3RvdHlwZS5hZGRUbzNkQ29udGFpbmVyID0gZnVuY3Rpb24gKGVsZW0sIHBvcykge1xyXG4gIHZhciBqID0gMDtcclxuICB2YXIgbmV4dEVsZW1lbnQ7XHJcbiAgd2hpbGUgKGogPCBwb3MpIHtcclxuICAgIGlmICh0aGlzLmVsZW1lbnRzW2pdICYmIHRoaXMuZWxlbWVudHNbal0uZ2V0QmFzZUVsZW1lbnQpIHtcclxuICAgICAgbmV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KCk7XHJcbiAgICB9XHJcbiAgICBqICs9IDE7XHJcbiAgfVxyXG4gIGlmIChuZXh0RWxlbWVudCkge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuaW5zZXJ0QmVmb3JlKGVsZW0sIG5leHRFbGVtZW50KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZU5TLCBleHRlbmRQcm90b3R5cGUsIEJhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIU29saWRFbGVtZW50LCBTVkdTaGFwZUVsZW1lbnQsIEhCYXNlRWxlbWVudCxcclxuSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudCwgY3JlYXRlTlMsIGJtTWluLCBibVNxcnQsIGJtTWluLCBibU1heCwgYm1Qb3cgKi9cclxuXHJcbmZ1bmN0aW9uIEhTaGFwZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIC8vIExpc3Qgb2YgZHJhd2FibGUgZWxlbWVudHNcclxuICB0aGlzLnNoYXBlcyA9IFtdO1xyXG4gIC8vIEZ1bGwgc2hhcGUgZGF0YVxyXG4gIHRoaXMuc2hhcGVzRGF0YSA9IGRhdGEuc2hhcGVzO1xyXG4gIC8vIExpc3Qgb2Ygc3R5bGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xyXG4gIHRoaXMuc3R5bGVzTGlzdCA9IFtdO1xyXG4gIC8vIExpc3Qgb2YgbW9kaWZpZXJzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xyXG4gIHRoaXMuc2hhcGVNb2RpZmllcnMgPSBbXTtcclxuICAvLyBMaXN0IG9mIGl0ZW1zIGluIHNoYXBlIHRyZWVcclxuICB0aGlzLml0ZW1zRGF0YSA9IFtdO1xyXG4gIC8vIExpc3Qgb2YgaXRlbXMgaW4gcHJldmlvdXMgc2hhcGUgdHJlZVxyXG4gIHRoaXMucHJvY2Vzc2VkRWxlbWVudHMgPSBbXTtcclxuICAvLyBMaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcclxuICB0aGlzLmFuaW1hdGVkQ29udGVudHMgPSBbXTtcclxuICB0aGlzLnNoYXBlc0NvbnRhaW5lciA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICAvLyBNb3ZpbmcgYW55IHByb3BlcnR5IHRoYXQgZG9lc24ndCBnZXQgdG9vIG11Y2ggYWNjZXNzIGFmdGVyIGluaXRpYWxpemF0aW9uIGJlY2F1c2Ugb2Ygdjggd2F5IG9mIGhhbmRsaW5nIG1vcmUgdGhhbiAxMCBwcm9wZXJ0aWVzLlxyXG4gIC8vIExpc3Qgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZFxyXG4gIHRoaXMucHJldlZpZXdEYXRhID0gW107XHJcbiAgdGhpcy5jdXJyZW50QkJveCA9IHtcclxuICAgIHg6IDk5OTk5OSxcclxuICAgIHk6IC05OTk5OTksXHJcbiAgICBoOiAwLFxyXG4gICAgdzogMCxcclxuICB9O1xyXG59XHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhTb2xpZEVsZW1lbnQsIFNWR1NoYXBlRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSFNoYXBlRWxlbWVudCk7XHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLl9yZW5kZXJTaGFwZUZyYW1lID0gSFNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50O1xyXG5cclxuSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY29udDtcclxuICB0aGlzLmJhc2VFbGVtZW50LnN0eWxlLmZvbnRTaXplID0gMDtcclxuICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2hhcGVzQ29udGFpbmVyKTtcclxuICAgIGNvbnQgPSB0aGlzLnN2Z0VsZW1lbnQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnQgPSBjcmVhdGVOUygnc3ZnJyk7XHJcbiAgICB2YXIgc2l6ZSA9IHRoaXMuY29tcC5kYXRhID8gdGhpcy5jb21wLmRhdGEgOiB0aGlzLmdsb2JhbERhdGEuY29tcFNpemU7XHJcbiAgICBjb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLncpO1xyXG4gICAgY29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUuaCk7XHJcbiAgICBjb250LmFwcGVuZENoaWxkKHRoaXMuc2hhcGVzQ29udGFpbmVyKTtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGNvbnQpO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRoaXMuc2hhcGVzQ29udGFpbmVyLCAwLCBbXSwgdHJ1ZSk7XHJcbiAgdGhpcy5maWx0ZXJVbmlxdWVTaGFwZXMoKTtcclxuICB0aGlzLnNoYXBlQ29udCA9IGNvbnQ7XHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50ID0gZnVuY3Rpb24gKHRyYW5zZm9ybWVycywgcG9pbnQpIHtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gdHJhbnNmb3JtZXJzLmxlbmd0aDtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIHBvaW50ID0gdHJhbnNmb3JtZXJzW2ldLm1Qcm9wcy52LmFwcGx5VG9Qb2ludEFycmF5KHBvaW50WzBdLCBwb2ludFsxXSwgMCk7XHJcbiAgfVxyXG4gIHJldHVybiBwb2ludDtcclxufTtcclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZVNoYXBlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoaXRlbSwgYm91bmRpbmdCb3gpIHtcclxuICB2YXIgc2hhcGUgPSBpdGVtLnNoLnY7XHJcbiAgdmFyIHRyYW5zZm9ybWVycyA9IGl0ZW0udHJhbnNmb3JtZXJzO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBzaGFwZS5fbGVuZ3RoO1xyXG4gIHZhciB2UG9pbnQ7XHJcbiAgdmFyIG9Qb2ludDtcclxuICB2YXIgbmV4dElQb2ludDtcclxuICB2YXIgbmV4dFZQb2ludDtcclxuICBpZiAobGVuIDw9IDEpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkgKz0gMSkge1xyXG4gICAgdlBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUudltpXSk7XHJcbiAgICBvUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS5vW2ldKTtcclxuICAgIG5leHRJUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS5pW2kgKyAxXSk7XHJcbiAgICBuZXh0VlBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUudltpICsgMV0pO1xyXG4gICAgdGhpcy5jaGVja0JvdW5kcyh2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCwgYm91bmRpbmdCb3gpO1xyXG4gIH1cclxuICBpZiAoc2hhcGUuYykge1xyXG4gICAgdlBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUudltpXSk7XHJcbiAgICBvUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS5vW2ldKTtcclxuICAgIG5leHRJUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS5pWzBdKTtcclxuICAgIG5leHRWUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52WzBdKTtcclxuICAgIHRoaXMuY2hlY2tCb3VuZHModlBvaW50LCBvUG9pbnQsIG5leHRJUG9pbnQsIG5leHRWUG9pbnQsIGJvdW5kaW5nQm94KTtcclxuICB9XHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jaGVja0JvdW5kcyA9IGZ1bmN0aW9uICh2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCwgYm91bmRpbmdCb3gpIHtcclxuICB0aGlzLmdldEJvdW5kc09mQ3VydmUodlBvaW50LCBvUG9pbnQsIG5leHRJUG9pbnQsIG5leHRWUG9pbnQpO1xyXG4gIHZhciBib3VuZHMgPSB0aGlzLnNoYXBlQm91bmRpbmdCb3g7XHJcbiAgYm91bmRpbmdCb3gueCA9IGJtTWluKGJvdW5kcy5sZWZ0LCBib3VuZGluZ0JveC54KTtcclxuICBib3VuZGluZ0JveC54TWF4ID0gYm1NYXgoYm91bmRzLnJpZ2h0LCBib3VuZGluZ0JveC54TWF4KTtcclxuICBib3VuZGluZ0JveC55ID0gYm1NaW4oYm91bmRzLnRvcCwgYm91bmRpbmdCb3gueSk7XHJcbiAgYm91bmRpbmdCb3gueU1heCA9IGJtTWF4KGJvdW5kcy5ib3R0b20sIGJvdW5kaW5nQm94LnlNYXgpO1xyXG59O1xyXG5cclxuSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2hhcGVCb3VuZGluZ0JveCA9IHtcclxuICBsZWZ0OiAwLFxyXG4gIHJpZ2h0OiAwLFxyXG4gIHRvcDogMCxcclxuICBib3R0b206IDAsXHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS50ZW1wQm91bmRpbmdCb3ggPSB7XHJcbiAgeDogMCxcclxuICB4TWF4OiAwLFxyXG4gIHk6IDAsXHJcbiAgeU1heDogMCxcclxuICB3aWR0aDogMCxcclxuICBoZWlnaHQ6IDAsXHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5nZXRCb3VuZHNPZkN1cnZlID0gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzKSB7XHJcbiAgdmFyIGJvdW5kcyA9IFtbcDBbMF0sIHAzWzBdXSwgW3AwWzFdLCBwM1sxXV1dO1xyXG5cclxuICBmb3IgKHZhciBhLCBiLCBjLCB0LCBiMmFjLCB0MSwgdDIsIGkgPSAwOyBpIDwgMjsgKytpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGx1c3BsdXNcclxuICAgIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xyXG4gICAgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XHJcbiAgICBjID0gMyAqIHAxW2ldIC0gMyAqIHAwW2ldO1xyXG5cclxuICAgIGIgfD0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXHJcbiAgICBhIHw9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxyXG4gICAgYyB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcclxuXHJcbiAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XHJcbiAgICAgIC8vXHJcbiAgICB9IGVsc2UgaWYgKGEgPT09IDApIHtcclxuICAgICAgdCA9IC1jIC8gYjtcclxuXHJcbiAgICAgIGlmICh0ID4gMCAmJiB0IDwgMSkge1xyXG4gICAgICAgIGJvdW5kc1tpXS5wdXNoKHRoaXMuY2FsY3VsYXRlRih0LCBwMCwgcDEsIHAyLCBwMywgaSkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XHJcblxyXG4gICAgICBpZiAoYjJhYyA+PSAwKSB7XHJcbiAgICAgICAgdDEgPSAoLWIgKyBibVNxcnQoYjJhYykpIC8gKDIgKiBhKTtcclxuICAgICAgICBpZiAodDEgPiAwICYmIHQxIDwgMSkgYm91bmRzW2ldLnB1c2godGhpcy5jYWxjdWxhdGVGKHQxLCBwMCwgcDEsIHAyLCBwMywgaSkpO1xyXG4gICAgICAgIHQyID0gKC1iIC0gYm1TcXJ0KGIyYWMpKSAvICgyICogYSk7XHJcbiAgICAgICAgaWYgKHQyID4gMCAmJiB0MiA8IDEpIGJvdW5kc1tpXS5wdXNoKHRoaXMuY2FsY3VsYXRlRih0MiwgcDAsIHAxLCBwMiwgcDMsIGkpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LmxlZnQgPSBibU1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pO1xyXG4gIHRoaXMuc2hhcGVCb3VuZGluZ0JveC50b3AgPSBibU1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pO1xyXG4gIHRoaXMuc2hhcGVCb3VuZGluZ0JveC5yaWdodCA9IGJtTWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XHJcbiAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LmJvdHRvbSA9IGJtTWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jYWxjdWxhdGVGID0gZnVuY3Rpb24gKHQsIHAwLCBwMSwgcDIsIHAzLCBpKSB7XHJcbiAgcmV0dXJuIGJtUG93KDEgLSB0LCAzKSAqIHAwW2ldXHJcbiAgICAgICAgKyAzICogYm1Qb3coMSAtIHQsIDIpICogdCAqIHAxW2ldXHJcbiAgICAgICAgKyAzICogKDEgLSB0KSAqIGJtUG93KHQsIDIpICogcDJbaV1cclxuICAgICAgICArIGJtUG93KHQsIDMpICogcDNbaV07XHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jYWxjdWxhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChpdGVtc0RhdGEsIGJvdW5kaW5nQm94KSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IGl0ZW1zRGF0YS5sZW5ndGg7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAoaXRlbXNEYXRhW2ldICYmIGl0ZW1zRGF0YVtpXS5zaCkge1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVNoYXBlQm91bmRpbmdCb3goaXRlbXNEYXRhW2ldLCBib3VuZGluZ0JveCk7XHJcbiAgICB9IGVsc2UgaWYgKGl0ZW1zRGF0YVtpXSAmJiBpdGVtc0RhdGFbaV0uaXQpIHtcclxuICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZGluZ0JveChpdGVtc0RhdGFbaV0uaXQsIGJvdW5kaW5nQm94KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jdXJyZW50Qm94Q29udGFpbnMgPSBmdW5jdGlvbiAoYm94KSB7XHJcbiAgcmV0dXJuIHRoaXMuY3VycmVudEJCb3gueCA8PSBib3gueFxyXG4gICAgJiYgdGhpcy5jdXJyZW50QkJveC55IDw9IGJveC55XHJcbiAgICAmJiB0aGlzLmN1cnJlbnRCQm94LndpZHRoICsgdGhpcy5jdXJyZW50QkJveC54ID49IGJveC54ICsgYm94LndpZHRoXHJcbiAgICAmJiB0aGlzLmN1cnJlbnRCQm94LmhlaWdodCArIHRoaXMuY3VycmVudEJCb3gueSA+PSBib3gueSArIGJveC5oZWlnaHQ7XHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5fcmVuZGVyU2hhcGVGcmFtZSgpO1xyXG5cclxuICBpZiAoIXRoaXMuaGlkZGVuICYmICh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgdGhpcy5fbWRmKSkge1xyXG4gICAgdmFyIHRlbXBCb3VuZGluZ0JveCA9IHRoaXMudGVtcEJvdW5kaW5nQm94O1xyXG4gICAgdmFyIG1heCA9IDk5OTk5OTtcclxuICAgIHRlbXBCb3VuZGluZ0JveC54ID0gbWF4O1xyXG4gICAgdGVtcEJvdW5kaW5nQm94LnhNYXggPSAtbWF4O1xyXG4gICAgdGVtcEJvdW5kaW5nQm94LnkgPSBtYXg7XHJcbiAgICB0ZW1wQm91bmRpbmdCb3gueU1heCA9IC1tYXg7XHJcbiAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kaW5nQm94KHRoaXMuaXRlbXNEYXRhLCB0ZW1wQm91bmRpbmdCb3gpO1xyXG4gICAgdGVtcEJvdW5kaW5nQm94LndpZHRoID0gdGVtcEJvdW5kaW5nQm94LnhNYXggPCB0ZW1wQm91bmRpbmdCb3gueCA/IDAgOiB0ZW1wQm91bmRpbmdCb3gueE1heCAtIHRlbXBCb3VuZGluZ0JveC54O1xyXG4gICAgdGVtcEJvdW5kaW5nQm94LmhlaWdodCA9IHRlbXBCb3VuZGluZ0JveC55TWF4IDwgdGVtcEJvdW5kaW5nQm94LnkgPyAwIDogdGVtcEJvdW5kaW5nQm94LnlNYXggLSB0ZW1wQm91bmRpbmdCb3gueTtcclxuICAgIC8vIHZhciB0ZW1wQm91bmRpbmdCb3ggPSB0aGlzLnNoYXBlQ29udC5nZXRCQm94KCk7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50Qm94Q29udGFpbnModGVtcEJvdW5kaW5nQm94KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgaWYgKHRoaXMuY3VycmVudEJCb3gudyAhPT0gdGVtcEJvdW5kaW5nQm94LndpZHRoKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IHRlbXBCb3VuZGluZ0JveC53aWR0aDtcclxuICAgICAgdGhpcy5zaGFwZUNvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRlbXBCb3VuZGluZ0JveC53aWR0aCk7XHJcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY3VycmVudEJCb3guaCAhPT0gdGVtcEJvdW5kaW5nQm94LmhlaWdodCkge1xyXG4gICAgICB0aGlzLmN1cnJlbnRCQm94LmggPSB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0O1xyXG4gICAgICB0aGlzLnNoYXBlQ29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRlbXBCb3VuZGluZ0JveC5oZWlnaHQpO1xyXG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChjaGFuZ2VkIHx8IHRoaXMuY3VycmVudEJCb3gueCAhPT0gdGVtcEJvdW5kaW5nQm94LnggfHwgdGhpcy5jdXJyZW50QkJveC55ICE9PSB0ZW1wQm91bmRpbmdCb3gueSkge1xyXG4gICAgICB0aGlzLmN1cnJlbnRCQm94LncgPSB0ZW1wQm91bmRpbmdCb3gud2lkdGg7XHJcbiAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQ7XHJcbiAgICAgIHRoaXMuY3VycmVudEJCb3gueCA9IHRlbXBCb3VuZGluZ0JveC54O1xyXG4gICAgICB0aGlzLmN1cnJlbnRCQm94LnkgPSB0ZW1wQm91bmRpbmdCb3gueTtcclxuXHJcbiAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHRoaXMuY3VycmVudEJCb3gueCArICcgJyArIHRoaXMuY3VycmVudEJCb3gueSArICcgJyArIHRoaXMuY3VycmVudEJCb3gudyArICcgJyArIHRoaXMuY3VycmVudEJCb3guaCk7XHJcbiAgICAgIHZhciBzaGFwZVN0eWxlID0gdGhpcy5zaGFwZUNvbnQuc3R5bGU7XHJcbiAgICAgIHZhciBzaGFwZVRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHRoaXMuY3VycmVudEJCb3gueCArICdweCwnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJ3B4KSc7XHJcbiAgICAgIHNoYXBlU3R5bGUudHJhbnNmb3JtID0gc2hhcGVUcmFuc2Zvcm07XHJcbiAgICAgIHNoYXBlU3R5bGUud2Via2l0VHJhbnNmb3JtID0gc2hhcGVUcmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LFxyXG5SZW5kZXJhYmxlRE9NRWxlbWVudCwgSVRleHRFbGVtZW50LCBjcmVhdGVTaXplZEFycmF5LCBjcmVhdGVUYWcsIHN0eWxlRGl2LCBjcmVhdGVOUywgbGluZUpvaW5FbnVtLCBsaW5lQ2FwRW51bSAqL1xyXG5cclxuZnVuY3Rpb24gSFRleHRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICB0aGlzLnRleHRTcGFucyA9IFtdO1xyXG4gIHRoaXMudGV4dFBhdGhzID0gW107XHJcbiAgdGhpcy5jdXJyZW50QkJveCA9IHtcclxuICAgIHg6IDk5OTk5OSxcclxuICAgIHk6IC05OTk5OTksXHJcbiAgICBoOiAwLFxyXG4gICAgdzogMCxcclxuICB9O1xyXG4gIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xyXG4gIHRoaXMuaXNNYXNrZWQgPSBmYWxzZTtcclxuICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG59XHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgSVRleHRFbGVtZW50XSwgSFRleHRFbGVtZW50KTtcclxuXHJcbkhUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmlzTWFza2VkID0gdGhpcy5jaGVja01hc2tzKCk7XHJcbiAgaWYgKHRoaXMuaXNNYXNrZWQpIHtcclxuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xyXG4gICAgdGhpcy5jb21wVyA9IHRoaXMuY29tcC5kYXRhLnc7XHJcbiAgICB0aGlzLmNvbXBIID0gdGhpcy5jb21wLmRhdGEuaDtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5jb21wVyk7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmNvbXBIKTtcclxuICAgIHZhciBnID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgIHRoaXMubWFza2VkRWxlbWVudC5hcHBlbmRDaGlsZChnKTtcclxuICAgIHRoaXMuaW5uZXJFbGVtID0gZztcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5yZW5kZXJUeXBlID0gJ2h0bWwnO1xyXG4gICAgdGhpcy5pbm5lckVsZW0gPSB0aGlzLmxheWVyRWxlbWVudDtcclxuICB9XHJcblxyXG4gIHRoaXMuY2hlY2tQYXJlbnRpbmcoKTtcclxufTtcclxuXHJcbkhUZXh0RWxlbWVudC5wcm90b3R5cGUuYnVpbGROZXdUZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcclxuICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IGNyZWF0ZVNpemVkQXJyYXkoZG9jdW1lbnREYXRhLmwgPyBkb2N1bWVudERhdGEubC5sZW5ndGggOiAwKTtcclxuICB2YXIgaW5uZXJFbGVtU3R5bGUgPSB0aGlzLmlubmVyRWxlbS5zdHlsZTtcclxuICB2YXIgdGV4dENvbG9yID0gZG9jdW1lbnREYXRhLmZjID8gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5mYykgOiAncmdiYSgwLDAsMCwwKSc7XHJcbiAgaW5uZXJFbGVtU3R5bGUuZmlsbCA9IHRleHRDb2xvcjtcclxuICBpbm5lckVsZW1TdHlsZS5jb2xvciA9IHRleHRDb2xvcjtcclxuICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XHJcbiAgICBpbm5lckVsZW1TdHlsZS5zdHJva2UgPSB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKTtcclxuICAgIGlubmVyRWxlbVN0eWxlLnN0cm9rZVdpZHRoID0gZG9jdW1lbnREYXRhLnN3ICsgJ3B4JztcclxuICB9XHJcbiAgdmFyIGZvbnREYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xyXG4gIGlmICghdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XHJcbiAgICBpbm5lckVsZW1TdHlsZS5mb250U2l6ZSA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHgnO1xyXG4gICAgaW5uZXJFbGVtU3R5bGUubGluZUhlaWdodCA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHgnO1xyXG4gICAgaWYgKGZvbnREYXRhLmZDbGFzcykge1xyXG4gICAgICB0aGlzLmlubmVyRWxlbS5jbGFzc05hbWUgPSBmb250RGF0YS5mQ2xhc3M7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbm5lckVsZW1TdHlsZS5mb250RmFtaWx5ID0gZm9udERhdGEuZkZhbWlseTtcclxuICAgICAgdmFyIGZXZWlnaHQgPSBkb2N1bWVudERhdGEuZldlaWdodDtcclxuICAgICAgdmFyIGZTdHlsZSA9IGRvY3VtZW50RGF0YS5mU3R5bGU7XHJcbiAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRTdHlsZSA9IGZTdHlsZTtcclxuICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFdlaWdodCA9IGZXZWlnaHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBpO1xyXG4gIHZhciBsZW47XHJcblxyXG4gIHZhciBsZXR0ZXJzID0gZG9jdW1lbnREYXRhLmw7XHJcbiAgbGVuID0gbGV0dGVycy5sZW5ndGg7XHJcbiAgdmFyIHRTcGFuO1xyXG4gIHZhciB0UGFyZW50O1xyXG4gIHZhciB0Q29udDtcclxuICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xyXG4gIHZhciBzaGFwZXM7XHJcbiAgdmFyIHNoYXBlU3RyID0gJyc7XHJcbiAgdmFyIGNudCA9IDA7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBpZiAodGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XHJcbiAgICAgIGlmICghdGhpcy50ZXh0UGF0aHNbY250XSkge1xyXG4gICAgICAgIHRTcGFuID0gY3JlYXRlTlMoJ3BhdGgnKTtcclxuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bMV0pO1xyXG4gICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtWzJdKTtcclxuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1taXRlcmxpbWl0JywgJzQnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLmlzTWFza2VkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGV4dFNwYW5zW2NudF0pIHtcclxuICAgICAgICAgIHRQYXJlbnQgPSB0aGlzLnRleHRTcGFuc1tjbnRdO1xyXG4gICAgICAgICAgdENvbnQgPSB0UGFyZW50LmNoaWxkcmVuWzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0UGFyZW50ID0gY3JlYXRlVGFnKCdkaXYnKTtcclxuICAgICAgICAgIHRQYXJlbnQuc3R5bGUubGluZUhlaWdodCA9IDA7XHJcbiAgICAgICAgICB0Q29udCA9IGNyZWF0ZU5TKCdzdmcnKTtcclxuICAgICAgICAgIHRDb250LmFwcGVuZENoaWxkKHRTcGFuKTtcclxuICAgICAgICAgIHN0eWxlRGl2KHRQYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc01hc2tlZCkge1xyXG4gICAgICBpZiAodGhpcy50ZXh0U3BhbnNbY250XSkge1xyXG4gICAgICAgIHRQYXJlbnQgPSB0aGlzLnRleHRTcGFuc1tjbnRdO1xyXG4gICAgICAgIHRTcGFuID0gdGhpcy50ZXh0UGF0aHNbY250XTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0UGFyZW50ID0gY3JlYXRlVGFnKCdzcGFuJyk7XHJcbiAgICAgICAgc3R5bGVEaXYodFBhcmVudCk7XHJcbiAgICAgICAgdFNwYW4gPSBjcmVhdGVUYWcoJ3NwYW4nKTtcclxuICAgICAgICBzdHlsZURpdih0U3Bhbik7XHJcbiAgICAgICAgdFBhcmVudC5hcHBlbmRDaGlsZCh0U3Bhbik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRTcGFuID0gdGhpcy50ZXh0UGF0aHNbY250XSA/IHRoaXMudGV4dFBhdGhzW2NudF0gOiBjcmVhdGVOUygndGV4dCcpO1xyXG4gICAgfVxyXG4gICAgLy8gdFNwYW4uc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xyXG4gICAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xyXG4gICAgICB2YXIgY2hhckRhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXSwgZm9udERhdGEuZlN0eWxlLCB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XHJcbiAgICAgIHZhciBzaGFwZURhdGE7XHJcbiAgICAgIGlmIChjaGFyRGF0YSkge1xyXG4gICAgICAgIHNoYXBlRGF0YSA9IGNoYXJEYXRhLmRhdGE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hhcGVEYXRhID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcclxuICAgICAgaWYgKHNoYXBlRGF0YSAmJiBzaGFwZURhdGEuc2hhcGVzKSB7XHJcbiAgICAgICAgc2hhcGVzID0gc2hhcGVEYXRhLnNoYXBlc1swXS5pdDtcclxuICAgICAgICBtYXRyaXhIZWxwZXIuc2NhbGUoZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCk7XHJcbiAgICAgICAgc2hhcGVTdHIgPSB0aGlzLmNyZWF0ZVBhdGhTaGFwZShtYXRyaXhIZWxwZXIsIHNoYXBlcyk7XHJcbiAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdkJywgc2hhcGVTdHIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xyXG4gICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRQYXJlbnQpO1xyXG4gICAgICAgIGlmIChzaGFwZURhdGEgJiYgc2hhcGVEYXRhLnNoYXBlcykge1xyXG4gICAgICAgICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCBpcyBuZWVkZWQgdG8gZ2V0IGV4YWN0IG1lYXN1cmUgb2Ygc2hhcGVcclxuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodENvbnQpO1xyXG4gICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdENvbnQuZ2V0QkJveCgpO1xyXG4gICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJvdW5kaW5nQm94LndpZHRoICsgMik7XHJcbiAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGJvdW5kaW5nQm94LmhlaWdodCArIDIpO1xyXG4gICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgKGJvdW5kaW5nQm94LnggLSAxKSArICcgJyArIChib3VuZGluZ0JveC55IC0gMSkgKyAnICcgKyAoYm91bmRpbmdCb3gud2lkdGggKyAyKSArICcgJyArIChib3VuZGluZ0JveC5oZWlnaHQgKyAyKSk7XHJcbiAgICAgICAgICB2YXIgdENvbnRTdHlsZSA9IHRDb250LnN0eWxlO1xyXG4gICAgICAgICAgdmFyIHRDb250VHJhbnNsYXRpb24gPSAndHJhbnNsYXRlKCcgKyAoYm91bmRpbmdCb3gueCAtIDEpICsgJ3B4LCcgKyAoYm91bmRpbmdCb3gueSAtIDEpICsgJ3B4KSc7XHJcbiAgICAgICAgICB0Q29udFN0eWxlLnRyYW5zZm9ybSA9IHRDb250VHJhbnNsYXRpb247XHJcbiAgICAgICAgICB0Q29udFN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRDb250VHJhbnNsYXRpb247XHJcblxyXG4gICAgICAgICAgbGV0dGVyc1tpXS55T2Zmc2V0ID0gYm91bmRpbmdCb3gueSAtIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAxKTtcclxuICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRQYXJlbnQuYXBwZW5kQ2hpbGQodENvbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRTcGFuKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdFNwYW4udGV4dENvbnRlbnQgPSBsZXR0ZXJzW2ldLnZhbDtcclxuICAgICAgdFNwYW4uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsICd4bWw6c3BhY2UnLCAncHJlc2VydmUnKTtcclxuICAgICAgaWYgKCF0aGlzLmlzTWFza2VkKSB7XHJcbiAgICAgICAgdGhpcy5pbm5lckVsZW0uYXBwZW5kQ2hpbGQodFBhcmVudCk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICB2YXIgdFN0eWxlID0gdFNwYW4uc3R5bGU7XHJcbiAgICAgICAgdmFyIHRTcGFuVHJhbnNsYXRpb24gPSAndHJhbnNsYXRlM2QoMCwnICsgLWRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxLjIgKyAncHgsMCknO1xyXG4gICAgICAgIHRTdHlsZS50cmFuc2Zvcm0gPSB0U3BhblRyYW5zbGF0aW9uO1xyXG4gICAgICAgIHRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0U3BhblRyYW5zbGF0aW9uO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRTcGFuKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy9cclxuICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xyXG4gICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0gdFBhcmVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0gPSB0U3BhbjtcclxuICAgIH1cclxuICAgIHRoaXMudGV4dFNwYW5zW2NudF0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICB0aGlzLnRleHRQYXRoc1tjbnRdID0gdFNwYW47XHJcbiAgICBjbnQgKz0gMTtcclxuICB9XHJcbiAgd2hpbGUgKGNudCA8IHRoaXMudGV4dFNwYW5zLmxlbmd0aCkge1xyXG4gICAgdGhpcy50ZXh0U3BhbnNbY250XS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgY250ICs9IDE7XHJcbiAgfVxyXG59O1xyXG5cclxuSFRleHRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHN2Z1N0eWxlO1xyXG4gIGlmICh0aGlzLmRhdGEuc2luZ2xlU2hhcGUpIHtcclxuICAgIGlmICghdGhpcy5faXNGaXJzdEZyYW1lICYmICF0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IGlmICh0aGlzLmlzTWFza2VkICYmIHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xyXG4gICAgICAvLyBUb2RvIEJlbmNobWFyayBpZiB1c2luZyB0aGlzIGlzIGJldHRlciB0aGFuIGdldEJCb3hcclxuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlswXSArICcgJyArIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlsxXSArICcgJyArIHRoaXMuY29tcFcgKyAnICcgKyB0aGlzLmNvbXBIKTtcclxuICAgICAgc3ZnU3R5bGUgPSB0aGlzLnN2Z0VsZW1lbnQuc3R5bGU7XHJcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9ICd0cmFuc2xhdGUoJyArIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlswXSArICdweCwnICsgLXRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AucC52WzFdICsgJ3B4KSc7XHJcbiAgICAgIHN2Z1N0eWxlLnRyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xyXG4gICAgICBzdmdTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2xhdGlvbjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRoaXMudGV4dEFuaW1hdG9yLmdldE1lYXN1cmVzKHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLCB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyk7XHJcbiAgaWYgKCF0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyAmJiAhdGhpcy50ZXh0QW5pbWF0b3IubGV0dGVyc0NoYW5nZWRGbGFnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBpO1xyXG4gIHZhciBsZW47XHJcbiAgdmFyIGNvdW50ID0gMDtcclxuICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xyXG5cclxuICB2YXIgbGV0dGVycyA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmw7XHJcblxyXG4gIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xyXG4gIHZhciByZW5kZXJlZExldHRlcjtcclxuICB2YXIgdGV4dFNwYW47XHJcbiAgdmFyIHRleHRQYXRoO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgaWYgKGxldHRlcnNbaV0ubikge1xyXG4gICAgICBjb3VudCArPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGV4dFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXTtcclxuICAgICAgdGV4dFBhdGggPSB0aGlzLnRleHRQYXRoc1tpXTtcclxuICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbY291bnRdO1xyXG4gICAgICBjb3VudCArPSAxO1xyXG4gICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5tKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzTWFza2VkKSB7XHJcbiAgICAgICAgICB0ZXh0U3Bhbi5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSByZW5kZXJlZExldHRlci5tO1xyXG4gICAgICAgICAgdGV4dFNwYW4uc3R5bGUudHJhbnNmb3JtID0gcmVuZGVyZWRMZXR0ZXIubTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCByZW5kZXJlZExldHRlci5tKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8vIC90ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLHJlbmRlcmVkTGV0dGVyLm8pO1xyXG4gICAgICB0ZXh0U3Bhbi5zdHlsZS5vcGFjaXR5ID0gcmVuZGVyZWRMZXR0ZXIubztcclxuICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLnN3ICYmIHJlbmRlcmVkTGV0dGVyLl9tZGYuc3cpIHtcclxuICAgICAgICB0ZXh0UGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHJlbmRlcmVkTGV0dGVyLnN3KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuc2MgJiYgcmVuZGVyZWRMZXR0ZXIuX21kZi5zYykge1xyXG4gICAgICAgIHRleHRQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgcmVuZGVyZWRMZXR0ZXIuc2MpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZW5kZXJlZExldHRlci5mYyAmJiByZW5kZXJlZExldHRlci5fbWRmLmZjKSB7XHJcbiAgICAgICAgdGV4dFBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgcmVuZGVyZWRMZXR0ZXIuZmMpO1xyXG4gICAgICAgIHRleHRQYXRoLnN0eWxlLmNvbG9yID0gcmVuZGVyZWRMZXR0ZXIuZmM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0aGlzLmlubmVyRWxlbS5nZXRCQm94ICYmICF0aGlzLmhpZGRlbiAmJiAodGhpcy5faXNGaXJzdEZyYW1lIHx8IHRoaXMuX21kZikpIHtcclxuICAgIHZhciBib3VuZGluZ0JveCA9IHRoaXMuaW5uZXJFbGVtLmdldEJCb3goKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50QkJveC53ICE9PSBib3VuZGluZ0JveC53aWR0aCkge1xyXG4gICAgICB0aGlzLmN1cnJlbnRCQm94LncgPSBib3VuZGluZ0JveC53aWR0aDtcclxuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBib3VuZGluZ0JveC53aWR0aCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jdXJyZW50QkJveC5oICE9PSBib3VuZGluZ0JveC5oZWlnaHQpIHtcclxuICAgICAgdGhpcy5jdXJyZW50QkJveC5oID0gYm91bmRpbmdCb3guaGVpZ2h0O1xyXG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBib3VuZGluZ0JveC5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtYXJnaW4gPSAxO1xyXG4gICAgaWYgKHRoaXMuY3VycmVudEJCb3gudyAhPT0gKGJvdW5kaW5nQm94LndpZHRoICsgbWFyZ2luICogMikgfHwgdGhpcy5jdXJyZW50QkJveC5oICE9PSAoYm91bmRpbmdCb3guaGVpZ2h0ICsgbWFyZ2luICogMikgfHwgdGhpcy5jdXJyZW50QkJveC54ICE9PSAoYm91bmRpbmdCb3gueCAtIG1hcmdpbikgfHwgdGhpcy5jdXJyZW50QkJveC55ICE9PSAoYm91bmRpbmdCb3gueSAtIG1hcmdpbikpIHtcclxuICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gYm91bmRpbmdCb3gud2lkdGggKyBtYXJnaW4gKiAyO1xyXG4gICAgICB0aGlzLmN1cnJlbnRCQm94LmggPSBib3VuZGluZ0JveC5oZWlnaHQgKyBtYXJnaW4gKiAyO1xyXG4gICAgICB0aGlzLmN1cnJlbnRCQm94LnggPSBib3VuZGluZ0JveC54IC0gbWFyZ2luO1xyXG4gICAgICB0aGlzLmN1cnJlbnRCQm94LnkgPSBib3VuZGluZ0JveC55IC0gbWFyZ2luO1xyXG5cclxuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHRoaXMuY3VycmVudEJCb3gueCArICcgJyArIHRoaXMuY3VycmVudEJCb3gueSArICcgJyArIHRoaXMuY3VycmVudEJCb3gudyArICcgJyArIHRoaXMuY3VycmVudEJCb3guaCk7XHJcbiAgICAgIHN2Z1N0eWxlID0gdGhpcy5zdmdFbGVtZW50LnN0eWxlO1xyXG4gICAgICB2YXIgc3ZnVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgdGhpcy5jdXJyZW50QkJveC54ICsgJ3B4LCcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAncHgpJztcclxuICAgICAgc3ZnU3R5bGUudHJhbnNmb3JtID0gc3ZnVHJhbnNmb3JtO1xyXG4gICAgICBzdmdTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdmdUcmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhCYXNlRWxlbWVudCwgSFNvbGlkRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCxcclxuRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudCwgY3JlYXRlTlMgKi9cclxuXHJcbmZ1bmN0aW9uIEhJbWFnZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMuYXNzZXREYXRhID0gZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEoZGF0YS5yZWZJZCk7XHJcbiAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIU29saWRFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSEltYWdlRWxlbWVudCk7XHJcblxyXG5ISW1hZ2VFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBhc3NldFBhdGggPSB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCh0aGlzLmFzc2V0RGF0YSk7XHJcbiAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG5cclxuICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcclxuICAgIHRoaXMuaW1hZ2VFbGVtID0gY3JlYXRlTlMoJ2ltYWdlJyk7XHJcbiAgICB0aGlzLmltYWdlRWxlbS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5hc3NldERhdGEudyArICdweCcpO1xyXG4gICAgdGhpcy5pbWFnZUVsZW0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmFzc2V0RGF0YS5oICsgJ3B4Jyk7XHJcbiAgICB0aGlzLmltYWdlRWxlbS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgYXNzZXRQYXRoKTtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaW1hZ2VFbGVtKTtcclxuICAgIHRoaXMuYmFzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuYXNzZXREYXRhLncpO1xyXG4gICAgdGhpcy5iYXNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuYXNzZXREYXRhLmgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChpbWcpO1xyXG4gIH1cclxuICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICBpbWcuc3JjID0gYXNzZXRQYXRoO1xyXG4gIGlmICh0aGlzLmRhdGEubG4pIHtcclxuICAgIHRoaXMuYmFzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XHJcbiAgfVxyXG59O1xyXG5cclxuLyogZ2xvYmFsIFByb3BlcnR5RmFjdG9yeSwgZGVnVG9SYWRzLCBNYXRyaXgsIGV4dGVuZFByb3RvdHlwZSwgQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCAqL1xyXG5cclxuZnVuY3Rpb24gSENhbWVyYUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xyXG4gIHRoaXMuaW5pdEZyYW1lKCk7XHJcbiAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgdGhpcy5pbml0SGllcmFyY2h5KCk7XHJcbiAgdmFyIGdldFByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcDtcclxuICB0aGlzLnBlID0gZ2V0UHJvcCh0aGlzLCBkYXRhLnBlLCAwLCAwLCB0aGlzKTtcclxuICBpZiAoZGF0YS5rcy5wLnMpIHtcclxuICAgIHRoaXMucHggPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucC54LCAxLCAwLCB0aGlzKTtcclxuICAgIHRoaXMucHkgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucC55LCAxLCAwLCB0aGlzKTtcclxuICAgIHRoaXMucHogPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucC56LCAxLCAwLCB0aGlzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5wID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAsIDEsIDAsIHRoaXMpO1xyXG4gIH1cclxuICBpZiAoZGF0YS5rcy5hKSB7XHJcbiAgICB0aGlzLmEgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MuYSwgMSwgMCwgdGhpcyk7XHJcbiAgfVxyXG4gIGlmIChkYXRhLmtzLm9yLmsubGVuZ3RoICYmIGRhdGEua3Mub3Iua1swXS50bykge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gZGF0YS5rcy5vci5rLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBkYXRhLmtzLm9yLmtbaV0udG8gPSBudWxsO1xyXG4gICAgICBkYXRhLmtzLm9yLmtbaV0udGkgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLm9yID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gIHRoaXMub3Iuc2ggPSB0cnVlO1xyXG4gIHRoaXMucnggPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XHJcbiAgdGhpcy5yeSA9IGdldFByb3AodGhpcywgZGF0YS5rcy5yeSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICB0aGlzLnJ6ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnJ6LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gIHRoaXMubWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gIHRoaXMuX3ByZXZNYXQgPSBuZXcgTWF0cml4KCk7XHJcbiAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuXHJcbiAgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gbWFrZSB0aGUgSENhbWVyYSBlbGVtZW50IHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgTGF5ZXJJbnRlcmZhY2UgYW5kIFRyYW5zZm9ybUludGVyZmFjZS5cclxuICB0aGlzLmZpbmFsVHJhbnNmb3JtID0ge1xyXG4gICAgbVByb3A6IHRoaXMsXHJcbiAgfTtcclxufVxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnRdLCBIQ2FtZXJhRWxlbWVudCk7XHJcblxyXG5IQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIGxlbiA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50cy5sZW5ndGg7XHJcbiAgdmFyIGNvbXA7XHJcbiAgdmFyIHBlcnNwZWN0aXZlU3R5bGU7XHJcbiAgdmFyIGNvbnRhaW5lclN0eWxlO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgLy8gW3BlcnNwZWN0aXZlRWxlbSxjb250YWluZXJdXHJcbiAgICBjb21wID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzW2ldO1xyXG4gICAgaWYgKGNvbXAudHlwZSA9PT0gJzNkJykge1xyXG4gICAgICBwZXJzcGVjdGl2ZVN0eWxlID0gY29tcC5wZXJzcGVjdGl2ZUVsZW0uc3R5bGU7XHJcbiAgICAgIGNvbnRhaW5lclN0eWxlID0gY29tcC5jb250YWluZXIuc3R5bGU7XHJcbiAgICAgIHZhciBwZXJzcGVjdGl2ZSA9IHRoaXMucGUudiArICdweCc7XHJcbiAgICAgIHZhciBvcmlnaW4gPSAnMHB4IDBweCAwcHgnO1xyXG4gICAgICB2YXIgbWF0cml4ID0gJ21hdHJpeDNkKDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDEpJztcclxuICAgICAgcGVyc3BlY3RpdmVTdHlsZS5wZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlO1xyXG4gICAgICBwZXJzcGVjdGl2ZVN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmU7XHJcbiAgICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcclxuICAgICAgY29udGFpbmVyU3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xyXG4gICAgICBjb250YWluZXJTdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XHJcbiAgICAgIHBlcnNwZWN0aXZlU3R5bGUudHJhbnNmb3JtID0gbWF0cml4O1xyXG4gICAgICBwZXJzcGVjdGl2ZVN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IG1hdHJpeDtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5IQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5IQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbkhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX21kZiA9IHRoaXMuX2lzRmlyc3RGcmFtZTtcclxuICB2YXIgaTtcclxuICB2YXIgbGVuO1xyXG4gIGlmICh0aGlzLmhpZXJhcmNoeSkge1xyXG4gICAgbGVuID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIF9tZGYgPSB0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmIHx8IF9tZGY7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChfbWRmIHx8IHRoaXMucGUuX21kZiB8fCAodGhpcy5wICYmIHRoaXMucC5fbWRmKSB8fCAodGhpcy5weCAmJiAodGhpcy5weC5fbWRmIHx8IHRoaXMucHkuX21kZiB8fCB0aGlzLnB6Ll9tZGYpKSB8fCB0aGlzLnJ4Ll9tZGYgfHwgdGhpcy5yeS5fbWRmIHx8IHRoaXMucnouX21kZiB8fCB0aGlzLm9yLl9tZGYgfHwgKHRoaXMuYSAmJiB0aGlzLmEuX21kZikpIHtcclxuICAgIHRoaXMubWF0LnJlc2V0KCk7XHJcblxyXG4gICAgaWYgKHRoaXMuaGllcmFyY2h5KSB7XHJcbiAgICAgIGxlbiA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aCAtIDE7XHJcbiAgICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICB2YXIgbVRyYW5zZiA9IHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xyXG4gICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtbVRyYW5zZi5wLnZbMF0sIC1tVHJhbnNmLnAudlsxXSwgbVRyYW5zZi5wLnZbMl0pO1xyXG4gICAgICAgIHRoaXMubWF0LnJvdGF0ZVgoLW1UcmFuc2Yub3IudlswXSkucm90YXRlWSgtbVRyYW5zZi5vci52WzFdKS5yb3RhdGVaKG1UcmFuc2Yub3IudlsyXSk7XHJcbiAgICAgICAgdGhpcy5tYXQucm90YXRlWCgtbVRyYW5zZi5yeC52KS5yb3RhdGVZKC1tVHJhbnNmLnJ5LnYpLnJvdGF0ZVoobVRyYW5zZi5yei52KTtcclxuICAgICAgICB0aGlzLm1hdC5zY2FsZSgxIC8gbVRyYW5zZi5zLnZbMF0sIDEgLyBtVHJhbnNmLnMudlsxXSwgMSAvIG1UcmFuc2Yucy52WzJdKTtcclxuICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUobVRyYW5zZi5hLnZbMF0sIG1UcmFuc2YuYS52WzFdLCBtVHJhbnNmLmEudlsyXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLnApIHtcclxuICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKC10aGlzLnAudlswXSwgLXRoaXMucC52WzFdLCB0aGlzLnAudlsyXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm1hdC50cmFuc2xhdGUoLXRoaXMucHgudiwgLXRoaXMucHkudiwgdGhpcy5wei52KTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmEpIHtcclxuICAgICAgdmFyIGRpZmZWZWN0b3I7XHJcbiAgICAgIGlmICh0aGlzLnApIHtcclxuICAgICAgICBkaWZmVmVjdG9yID0gW3RoaXMucC52WzBdIC0gdGhpcy5hLnZbMF0sIHRoaXMucC52WzFdIC0gdGhpcy5hLnZbMV0sIHRoaXMucC52WzJdIC0gdGhpcy5hLnZbMl1dO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpZmZWZWN0b3IgPSBbdGhpcy5weC52IC0gdGhpcy5hLnZbMF0sIHRoaXMucHkudiAtIHRoaXMuYS52WzFdLCB0aGlzLnB6LnYgLSB0aGlzLmEudlsyXV07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG1hZyA9IE1hdGguc3FydChNYXRoLnBvdyhkaWZmVmVjdG9yWzBdLCAyKSArIE1hdGgucG93KGRpZmZWZWN0b3JbMV0sIDIpICsgTWF0aC5wb3coZGlmZlZlY3RvclsyXSwgMikpO1xyXG4gICAgICAvLyB2YXIgbG9va0RpciA9IGdldE5vcm1hbGl6ZWRQb2ludChnZXREaWZmVmVjdG9yKHRoaXMuYS52LHRoaXMucC52KSk7XHJcbiAgICAgIHZhciBsb29rRGlyID0gW2RpZmZWZWN0b3JbMF0gLyBtYWcsIGRpZmZWZWN0b3JbMV0gLyBtYWcsIGRpZmZWZWN0b3JbMl0gLyBtYWddO1xyXG4gICAgICB2YXIgbG9va0xlbmd0aE9uWFogPSBNYXRoLnNxcnQobG9va0RpclsyXSAqIGxvb2tEaXJbMl0gKyBsb29rRGlyWzBdICogbG9va0RpclswXSk7XHJcbiAgICAgIHZhciBtUm90YXRpb25YID0gKE1hdGguYXRhbjIobG9va0RpclsxXSwgbG9va0xlbmd0aE9uWFopKTtcclxuICAgICAgdmFyIG1Sb3RhdGlvblkgPSAoTWF0aC5hdGFuMihsb29rRGlyWzBdLCAtbG9va0RpclsyXSkpO1xyXG4gICAgICB0aGlzLm1hdC5yb3RhdGVZKG1Sb3RhdGlvblkpLnJvdGF0ZVgoLW1Sb3RhdGlvblgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5tYXQucm90YXRlWCgtdGhpcy5yeC52KS5yb3RhdGVZKC10aGlzLnJ5LnYpLnJvdGF0ZVoodGhpcy5yei52KTtcclxuICAgIHRoaXMubWF0LnJvdGF0ZVgoLXRoaXMub3IudlswXSkucm90YXRlWSgtdGhpcy5vci52WzFdKS5yb3RhdGVaKHRoaXMub3IudlsyXSk7XHJcbiAgICB0aGlzLm1hdC50cmFuc2xhdGUodGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncgLyAyLCB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCAvIDIsIDApO1xyXG4gICAgdGhpcy5tYXQudHJhbnNsYXRlKDAsIDAsIHRoaXMucGUudik7XHJcblxyXG4gICAgdmFyIGhhc01hdHJpeENoYW5nZWQgPSAhdGhpcy5fcHJldk1hdC5lcXVhbHModGhpcy5tYXQpO1xyXG4gICAgaWYgKChoYXNNYXRyaXhDaGFuZ2VkIHx8IHRoaXMucGUuX21kZikgJiYgdGhpcy5jb21wLnRocmVlREVsZW1lbnRzKSB7XHJcbiAgICAgIGxlbiA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgIHZhciBjb21wO1xyXG4gICAgICB2YXIgcGVyc3BlY3RpdmVTdHlsZTtcclxuICAgICAgdmFyIGNvbnRhaW5lclN0eWxlO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBjb21wID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzW2ldO1xyXG4gICAgICAgIGlmIChjb21wLnR5cGUgPT09ICczZCcpIHtcclxuICAgICAgICAgIGlmIChoYXNNYXRyaXhDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRWYWx1ZSA9IHRoaXMubWF0LnRvQ1NTKCk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlID0gY29tcC5jb250YWluZXIuc3R5bGU7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9IG1hdFZhbHVlO1xyXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBtYXRWYWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLnBlLl9tZGYpIHtcclxuICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZSA9IGNvbXAucGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xyXG4gICAgICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcclxuICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9IHRoaXMucGUudiArICdweCc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubWF0LmNsb25lKHRoaXMuX3ByZXZNYXQpO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxufTtcclxuXHJcbkhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRydWUpO1xyXG59O1xyXG5cclxuSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcbkhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XHJcblxyXG5mdW5jdGlvbiBIRWZmZWN0cygpIHtcclxufVxyXG5IRWZmZWN0cy5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVUYWcsIEFuaW1hdGlvbkl0ZW0gKi9cclxuLyogZXhwb3J0ZWQgYW5pbWF0aW9uTWFuYWdlciAqL1xyXG5cclxudmFyIGFuaW1hdGlvbk1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtb2R1bGVPYiA9IHt9O1xyXG4gIHZhciByZWdpc3RlcmVkQW5pbWF0aW9ucyA9IFtdO1xyXG4gIHZhciBpbml0VGltZSA9IDA7XHJcbiAgdmFyIGxlbiA9IDA7XHJcbiAgdmFyIHBsYXlpbmdBbmltYXRpb25zTnVtID0gMDtcclxuICB2YXIgX3N0b3BwZWQgPSB0cnVlO1xyXG4gIHZhciBfaXNGcm96ZW4gPSBmYWxzZTtcclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChldikge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIGFuaW1JdGVtID0gZXYudGFyZ2V0O1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgaWYgKHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbiA9PT0gYW5pbUl0ZW0pIHtcclxuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9ucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgaSAtPSAxO1xyXG4gICAgICAgIGxlbiAtPSAxO1xyXG4gICAgICAgIGlmICghYW5pbUl0ZW0uaXNQYXVzZWQpIHtcclxuICAgICAgICAgIHN1YnRyYWN0UGxheWluZ0NvdW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQW5pbWF0aW9uKGVsZW1lbnQsIGFuaW1hdGlvbkRhdGEpIHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgIGlmIChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5lbGVtID09PSBlbGVtZW50ICYmIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmVsZW0gIT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIHZhciBhbmltSXRlbSA9IG5ldyBBbmltYXRpb25JdGVtKCk7XHJcbiAgICBzZXR1cEFuaW1hdGlvbihhbmltSXRlbSwgZWxlbWVudCk7XHJcbiAgICBhbmltSXRlbS5zZXREYXRhKGVsZW1lbnQsIGFuaW1hdGlvbkRhdGEpO1xyXG4gICAgcmV0dXJuIGFuaW1JdGVtO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMoKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW5BbmltcyA9IHJlZ2lzdGVyZWRBbmltYXRpb25zLmxlbmd0aDtcclxuICAgIHZhciBhbmltYXRpb25zID0gW107XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQW5pbXM7IGkgKz0gMSkge1xyXG4gICAgICBhbmltYXRpb25zLnB1c2gocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhbmltYXRpb25zO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkUGxheWluZ0NvdW50KCkge1xyXG4gICAgcGxheWluZ0FuaW1hdGlvbnNOdW0gKz0gMTtcclxuICAgIGFjdGl2YXRlKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdWJ0cmFjdFBsYXlpbmdDb3VudCgpIHtcclxuICAgIHBsYXlpbmdBbmltYXRpb25zTnVtIC09IDE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXR1cEFuaW1hdGlvbihhbmltSXRlbSwgZWxlbWVudCkge1xyXG4gICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignZGVzdHJveScsIHJlbW92ZUVsZW1lbnQpO1xyXG4gICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignX2FjdGl2ZScsIGFkZFBsYXlpbmdDb3VudCk7XHJcbiAgICBhbmltSXRlbS5hZGRFdmVudExpc3RlbmVyKCdfaWRsZScsIHN1YnRyYWN0UGxheWluZ0NvdW50KTtcclxuICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zLnB1c2goeyBlbGVtOiBlbGVtZW50LCBhbmltYXRpb246IGFuaW1JdGVtIH0pO1xyXG4gICAgbGVuICs9IDE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcykge1xyXG4gICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcclxuICAgIHNldHVwQW5pbWF0aW9uKGFuaW1JdGVtLCBudWxsKTtcclxuICAgIGFuaW1JdGVtLnNldFBhcmFtcyhwYXJhbXMpO1xyXG4gICAgcmV0dXJuIGFuaW1JdGVtO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0U3BlZWQodmFsLCBhbmltYXRpb24pIHtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zZXRTcGVlZCh2YWwsIGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXREaXJlY3Rpb24odmFsLCBhbmltYXRpb24pIHtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zZXREaXJlY3Rpb24odmFsLCBhbmltYXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGxheShhbmltYXRpb24pIHtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5wbGF5KGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlc3VtZShub3dUaW1lKSB7XHJcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3dUaW1lIC0gaW5pdFRpbWU7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uYWR2YW5jZVRpbWUoZWxhcHNlZFRpbWUpO1xyXG4gICAgfVxyXG4gICAgaW5pdFRpbWUgPSBub3dUaW1lO1xyXG4gICAgaWYgKHBsYXlpbmdBbmltYXRpb25zTnVtICYmICFfaXNGcm96ZW4pIHtcclxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmlyc3Qobm93VGltZSkge1xyXG4gICAgaW5pdFRpbWUgPSBub3dUaW1lO1xyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGF1c2UoYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ucGF1c2UoYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdvVG9BbmRTdG9wKHZhbHVlLCBpc0ZyYW1lLCBhbmltYXRpb24pIHtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5nb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSwgYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0b3AoYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc3RvcChhbmltYXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9nZ2xlUGF1c2UoYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24udG9nZ2xlUGF1c2UoYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlc3Ryb3koYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IChsZW4gLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLmRlc3Ryb3koYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNlYXJjaEFuaW1hdGlvbnMoYW5pbWF0aW9uRGF0YSwgc3RhbmRhbG9uZSwgcmVuZGVyZXIpIHtcclxuICAgIHZhciBhbmltRWxlbWVudHMgPSBbXS5jb25jYXQoW10uc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsb3R0aWUnKSksXHJcbiAgICAgIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYm9keW1vdmluJykpKTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbkFuaW1zID0gYW5pbUVsZW1lbnRzLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5BbmltczsgaSArPSAxKSB7XHJcbiAgICAgIGlmIChyZW5kZXJlcikge1xyXG4gICAgICAgIGFuaW1FbGVtZW50c1tpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtYm0tdHlwZScsIHJlbmRlcmVyKTtcclxuICAgICAgfVxyXG4gICAgICByZWdpc3RlckFuaW1hdGlvbihhbmltRWxlbWVudHNbaV0sIGFuaW1hdGlvbkRhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YW5kYWxvbmUgJiYgbGVuQW5pbXMgPT09IDApIHtcclxuICAgICAgaWYgKCFyZW5kZXJlcikge1xyXG4gICAgICAgIHJlbmRlcmVyID0gJ3N2Zyc7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xyXG4gICAgICBib2R5LmlubmVyVGV4dCA9ICcnO1xyXG4gICAgICB2YXIgZGl2ID0gY3JlYXRlVGFnKCdkaXYnKTtcclxuICAgICAgZGl2LnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG4gICAgICBkaXYuc2V0QXR0cmlidXRlKCdkYXRhLWJtLXR5cGUnLCByZW5kZXJlcik7XHJcbiAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcclxuICAgICAgcmVnaXN0ZXJBbmltYXRpb24oZGl2LCBhbmltYXRpb25EYXRhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2l6ZSgpIHtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5yZXNpemUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFjdGl2YXRlKCkge1xyXG4gICAgaWYgKCFfaXNGcm96ZW4gJiYgcGxheWluZ0FuaW1hdGlvbnNOdW0pIHtcclxuICAgICAgaWYgKF9zdG9wcGVkKSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmaXJzdCk7XHJcbiAgICAgICAgX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZnJlZXplKCkge1xyXG4gICAgX2lzRnJvemVuID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVuZnJlZXplKCkge1xyXG4gICAgX2lzRnJvemVuID0gZmFsc2U7XHJcbiAgICBhY3RpdmF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0Vm9sdW1lKHZhbCwgYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc2V0Vm9sdW1lKHZhbCwgYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG11dGUoYW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ubXV0ZShhbmltYXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdW5tdXRlKGFuaW1hdGlvbikge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnVubXV0ZShhbmltYXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbW9kdWxlT2IucmVnaXN0ZXJBbmltYXRpb24gPSByZWdpc3RlckFuaW1hdGlvbjtcclxuICBtb2R1bGVPYi5sb2FkQW5pbWF0aW9uID0gbG9hZEFuaW1hdGlvbjtcclxuICBtb2R1bGVPYi5zZXRTcGVlZCA9IHNldFNwZWVkO1xyXG4gIG1vZHVsZU9iLnNldERpcmVjdGlvbiA9IHNldERpcmVjdGlvbjtcclxuICBtb2R1bGVPYi5wbGF5ID0gcGxheTtcclxuICBtb2R1bGVPYi5wYXVzZSA9IHBhdXNlO1xyXG4gIG1vZHVsZU9iLnN0b3AgPSBzdG9wO1xyXG4gIG1vZHVsZU9iLnRvZ2dsZVBhdXNlID0gdG9nZ2xlUGF1c2U7XHJcbiAgbW9kdWxlT2Iuc2VhcmNoQW5pbWF0aW9ucyA9IHNlYXJjaEFuaW1hdGlvbnM7XHJcbiAgbW9kdWxlT2IucmVzaXplID0gcmVzaXplO1xyXG4gIC8vIG1vZHVsZU9iLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgbW9kdWxlT2IuZ29Ub0FuZFN0b3AgPSBnb1RvQW5kU3RvcDtcclxuICBtb2R1bGVPYi5kZXN0cm95ID0gZGVzdHJveTtcclxuICBtb2R1bGVPYi5mcmVlemUgPSBmcmVlemU7XHJcbiAgbW9kdWxlT2IudW5mcmVlemUgPSB1bmZyZWV6ZTtcclxuICBtb2R1bGVPYi5zZXRWb2x1bWUgPSBzZXRWb2x1bWU7XHJcbiAgbW9kdWxlT2IubXV0ZSA9IG11dGU7XHJcbiAgbW9kdWxlT2IudW5tdXRlID0gdW5tdXRlO1xyXG4gIG1vZHVsZU9iLmdldFJlZ2lzdGVyZWRBbmltYXRpb25zID0gZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnM7XHJcbiAgcmV0dXJuIG1vZHVsZU9iO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZUVsZW1lbnRJRCwgc3ViZnJhbWVFbmFibGVkLCBQcm9qZWN0SW50ZXJmYWNlLCBJbWFnZVByZWxvYWRlciwgYXVkaW9Db250cm9sbGVyRmFjdG9yeSwgZXh0ZW5kUHJvdG90eXBlLCBCYXNlRXZlbnQsXHJcbkNhbnZhc1JlbmRlcmVyLCBTVkdSZW5kZXJlciwgSHlicmlkUmVuZGVyZXIsIGFzc2V0TG9hZGVyLCBkYXRhTWFuYWdlciwgZXhwcmVzc2lvbnNQbHVnaW4sIEJNRW50ZXJGcmFtZUV2ZW50LCBCTUNvbXBsZXRlTG9vcEV2ZW50LFxyXG5CTUNvbXBsZXRlRXZlbnQsIEJNU2VnbWVudFN0YXJ0RXZlbnQsIEJNRGVzdHJveUV2ZW50LCBCTUVudGVyRnJhbWVFdmVudCwgQk1Db21wbGV0ZUxvb3BFdmVudCwgQk1Db21wbGV0ZUV2ZW50LCBCTVNlZ21lbnRTdGFydEV2ZW50LFxyXG5CTURlc3Ryb3lFdmVudCwgQk1SZW5kZXJGcmFtZUVycm9yRXZlbnQsIEJNQ29uZmlnRXJyb3JFdmVudCwgbWFya2VyUGFyc2VyICovXHJcblxyXG52YXIgQW5pbWF0aW9uSXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLl9jYnMgPSBbXTtcclxuICB0aGlzLm5hbWUgPSAnJztcclxuICB0aGlzLnBhdGggPSAnJztcclxuICB0aGlzLmlzTG9hZGVkID0gZmFsc2U7XHJcbiAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gIHRoaXMuY3VycmVudFJhd0ZyYW1lID0gMDtcclxuICB0aGlzLmZpcnN0RnJhbWUgPSAwO1xyXG4gIHRoaXMudG90YWxGcmFtZXMgPSAwO1xyXG4gIHRoaXMuZnJhbWVSYXRlID0gMDtcclxuICB0aGlzLmZyYW1lTXVsdCA9IDA7XHJcbiAgdGhpcy5wbGF5U3BlZWQgPSAxO1xyXG4gIHRoaXMucGxheURpcmVjdGlvbiA9IDE7XHJcbiAgdGhpcy5wbGF5Q291bnQgPSAwO1xyXG4gIHRoaXMuYW5pbWF0aW9uRGF0YSA9IHt9O1xyXG4gIHRoaXMuYXNzZXRzID0gW107XHJcbiAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XHJcbiAgdGhpcy5hdXRvcGxheSA9IGZhbHNlO1xyXG4gIHRoaXMubG9vcCA9IHRydWU7XHJcbiAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgdGhpcy5hbmltYXRpb25JRCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xyXG4gIHRoaXMuYXNzZXRzUGF0aCA9ICcnO1xyXG4gIHRoaXMudGltZUNvbXBsZXRlZCA9IDA7XHJcbiAgdGhpcy5zZWdtZW50UG9zID0gMDtcclxuICB0aGlzLmlzU3ViZnJhbWVFbmFibGVkID0gc3ViZnJhbWVFbmFibGVkO1xyXG4gIHRoaXMuc2VnbWVudHMgPSBbXTtcclxuICB0aGlzLl9pZGxlID0gdHJ1ZTtcclxuICB0aGlzLl9jb21wbGV0ZWRMb29wID0gZmFsc2U7XHJcbiAgdGhpcy5wcm9qZWN0SW50ZXJmYWNlID0gUHJvamVjdEludGVyZmFjZSgpO1xyXG4gIHRoaXMuaW1hZ2VQcmVsb2FkZXIgPSBuZXcgSW1hZ2VQcmVsb2FkZXIoKTtcclxuICB0aGlzLmF1ZGlvQ29udHJvbGxlciA9IGF1ZGlvQ29udHJvbGxlckZhY3RvcnkoKTtcclxuICB0aGlzLm1hcmtlcnMgPSBbXTtcclxufTtcclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUV2ZW50XSwgQW5pbWF0aW9uSXRlbSk7XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcbiAgaWYgKHBhcmFtcy53cmFwcGVyIHx8IHBhcmFtcy5jb250YWluZXIpIHtcclxuICAgIHRoaXMud3JhcHBlciA9IHBhcmFtcy53cmFwcGVyIHx8IHBhcmFtcy5jb250YWluZXI7XHJcbiAgfVxyXG4gIHZhciBhbmltVHlwZSA9ICdzdmcnO1xyXG4gIGlmIChwYXJhbXMuYW5pbVR5cGUpIHtcclxuICAgIGFuaW1UeXBlID0gcGFyYW1zLmFuaW1UeXBlO1xyXG4gIH0gZWxzZSBpZiAocGFyYW1zLnJlbmRlcmVyKSB7XHJcbiAgICBhbmltVHlwZSA9IHBhcmFtcy5yZW5kZXJlcjtcclxuICB9XHJcbiAgc3dpdGNoIChhbmltVHlwZSkge1xyXG4gICAgY2FzZSAnY2FudmFzJzpcclxuICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcih0aGlzLCBwYXJhbXMucmVuZGVyZXJTZXR0aW5ncyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnc3ZnJzpcclxuICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBTVkdSZW5kZXJlcih0aGlzLCBwYXJhbXMucmVuZGVyZXJTZXR0aW5ncyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBIeWJyaWRSZW5kZXJlcih0aGlzLCBwYXJhbXMucmVuZGVyZXJTZXR0aW5ncyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldENhY2hlVHlwZShhbmltVHlwZSwgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmRlZnMpO1xyXG4gIHRoaXMucmVuZGVyZXIuc2V0UHJvamVjdEludGVyZmFjZSh0aGlzLnByb2plY3RJbnRlcmZhY2UpO1xyXG4gIHRoaXMuYW5pbVR5cGUgPSBhbmltVHlwZTtcclxuICBpZiAocGFyYW1zLmxvb3AgPT09ICcnXHJcbiAgICAgICAgfHwgcGFyYW1zLmxvb3AgPT09IG51bGxcclxuICAgICAgICB8fCBwYXJhbXMubG9vcCA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgfHwgcGFyYW1zLmxvb3AgPT09IHRydWUpIHtcclxuICAgIHRoaXMubG9vcCA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChwYXJhbXMubG9vcCA9PT0gZmFsc2UpIHtcclxuICAgIHRoaXMubG9vcCA9IGZhbHNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmxvb3AgPSBwYXJzZUludChwYXJhbXMubG9vcCwgMTApO1xyXG4gIH1cclxuICB0aGlzLmF1dG9wbGF5ID0gJ2F1dG9wbGF5JyBpbiBwYXJhbXMgPyBwYXJhbXMuYXV0b3BsYXkgOiB0cnVlO1xyXG4gIHRoaXMubmFtZSA9IHBhcmFtcy5uYW1lID8gcGFyYW1zLm5hbWUgOiAnJztcclxuICB0aGlzLmF1dG9sb2FkU2VnbWVudHMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCAnYXV0b2xvYWRTZWdtZW50cycpID8gcGFyYW1zLmF1dG9sb2FkU2VnbWVudHMgOiB0cnVlO1xyXG4gIHRoaXMuYXNzZXRzUGF0aCA9IHBhcmFtcy5hc3NldHNQYXRoO1xyXG4gIHRoaXMuaW5pdGlhbFNlZ21lbnQgPSBwYXJhbXMuaW5pdGlhbFNlZ21lbnQ7XHJcbiAgaWYgKHBhcmFtcy5hdWRpb0ZhY3RvcnkpIHtcclxuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnNldEF1ZGlvRmFjdG9yeShwYXJhbXMuYXVkaW9GYWN0b3J5KTtcclxuICB9XHJcbiAgaWYgKHBhcmFtcy5hbmltYXRpb25EYXRhKSB7XHJcbiAgICB0aGlzLmNvbmZpZ0FuaW1hdGlvbihwYXJhbXMuYW5pbWF0aW9uRGF0YSk7XHJcbiAgfSBlbHNlIGlmIChwYXJhbXMucGF0aCkge1xyXG4gICAgaWYgKHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCdcXFxcJykgIT09IC0xKSB7XHJcbiAgICAgIHRoaXMucGF0aCA9IHBhcmFtcy5wYXRoLnN1YnN0cigwLCBwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignXFxcXCcpICsgMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBhdGggPSBwYXJhbXMucGF0aC5zdWJzdHIoMCwgcGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5maWxlTmFtZSA9IHBhcmFtcy5wYXRoLnN1YnN0cihwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XHJcbiAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5maWxlTmFtZS5zdWJzdHIoMCwgdGhpcy5maWxlTmFtZS5sYXN0SW5kZXhPZignLmpzb24nKSk7XHJcblxyXG4gICAgYXNzZXRMb2FkZXIubG9hZChwYXJhbXMucGF0aCwgdGhpcy5jb25maWdBbmltYXRpb24uYmluZCh0aGlzKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGFfZmFpbGVkJyk7XHJcbiAgICB9LmJpbmQodGhpcykpO1xyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAod3JhcHBlciwgYW5pbWF0aW9uRGF0YSkge1xyXG4gIGlmIChhbmltYXRpb25EYXRhKSB7XHJcbiAgICBpZiAodHlwZW9mIGFuaW1hdGlvbkRhdGEgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGFuaW1hdGlvbkRhdGEgPSBKU09OLnBhcnNlKGFuaW1hdGlvbkRhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgcGFyYW1zID0ge1xyXG4gICAgd3JhcHBlcjogd3JhcHBlcixcclxuICAgIGFuaW1hdGlvbkRhdGE6IGFuaW1hdGlvbkRhdGEsXHJcbiAgfTtcclxuICB2YXIgd3JhcHBlckF0dHJpYnV0ZXMgPSB3cmFwcGVyLmF0dHJpYnV0ZXM7XHJcblxyXG4gIHBhcmFtcy5wYXRoID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW1hdGlvbi1wYXRoJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbWF0aW9uLXBhdGgnKS52YWx1ZVxyXG4gICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcGF0aCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcGF0aCcpLnZhbHVlXHJcbiAgICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1wYXRoJylcclxuICAgICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcGF0aCcpLnZhbHVlXHJcbiAgICAgICAgOiAnJztcclxuICBwYXJhbXMuYW5pbVR5cGUgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS10eXBlJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS10eXBlJykudmFsdWVcclxuICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXR5cGUnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXR5cGUnKS52YWx1ZVxyXG4gICAgICA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tdHlwZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tdHlwZScpLnZhbHVlXHJcbiAgICAgICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcmVuZGVyZXInKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1yZW5kZXJlcicpLnZhbHVlXHJcbiAgICAgICAgICA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcmVuZGVyZXInKVxyXG4gICAgICAgICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcmVuZGVyZXInKS52YWx1ZVxyXG4gICAgICAgICAgICA6ICdjYW52YXMnO1xyXG5cclxuICB2YXIgbG9vcCA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWxvb3AnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWxvb3AnKS52YWx1ZVxyXG4gICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbG9vcCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbG9vcCcpLnZhbHVlXHJcbiAgICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1sb29wJylcclxuICAgICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbG9vcCcpLnZhbHVlXHJcbiAgICAgICAgOiAnJztcclxuICBpZiAobG9vcCA9PT0gJ2ZhbHNlJykge1xyXG4gICAgcGFyYW1zLmxvb3AgPSBmYWxzZTtcclxuICB9IGVsc2UgaWYgKGxvb3AgPT09ICd0cnVlJykge1xyXG4gICAgcGFyYW1zLmxvb3AgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAobG9vcCAhPT0gJycpIHtcclxuICAgIHBhcmFtcy5sb29wID0gcGFyc2VJbnQobG9vcCwgMTApO1xyXG4gIH1cclxuICB2YXIgYXV0b3BsYXkgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1hdXRvcGxheScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tYXV0b3BsYXknKS52YWx1ZVxyXG4gICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tYXV0b3BsYXknKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XHJcbiAgICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWF1dG9wbGF5JykudmFsdWVcclxuICAgICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLWF1dG9wbGF5JylcclxuICAgICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tYXV0b3BsYXknKS52YWx1ZVxyXG4gICAgICAgIDogdHJ1ZTtcclxuICBwYXJhbXMuYXV0b3BsYXkgPSBhdXRvcGxheSAhPT0gJ2ZhbHNlJztcclxuXHJcbiAgcGFyYW1zLm5hbWUgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtbmFtZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLW5hbWUnKS52YWx1ZVxyXG4gICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbmFtZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcclxuICAgICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbmFtZScpLnZhbHVlXHJcbiAgICAgIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1uYW1lJylcclxuICAgICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbmFtZScpLnZhbHVlXHJcbiAgICAgICAgOiAnJztcclxuICB2YXIgcHJlcmVuZGVyID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tcHJlcmVuZGVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1wcmVyZW5kZXInKS52YWx1ZVxyXG4gICAgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcHJlcmVuZGVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxyXG4gICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1wcmVyZW5kZXInKS52YWx1ZVxyXG4gICAgICA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcHJlcmVuZGVyJylcclxuICAgICAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcHJlcmVuZGVyJykudmFsdWVcclxuICAgICAgICA6ICcnO1xyXG5cclxuICBpZiAocHJlcmVuZGVyID09PSAnZmFsc2UnKSB7XHJcbiAgICBwYXJhbXMucHJlcmVuZGVyID0gZmFsc2U7XHJcbiAgfVxyXG4gIHRoaXMuc2V0UGFyYW1zKHBhcmFtcyk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5pbmNsdWRlTGF5ZXJzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICBpZiAoZGF0YS5vcCA+IHRoaXMuYW5pbWF0aW9uRGF0YS5vcCkge1xyXG4gICAgdGhpcy5hbmltYXRpb25EYXRhLm9wID0gZGF0YS5vcDtcclxuICAgIHRoaXMudG90YWxGcmFtZXMgPSBNYXRoLmZsb29yKGRhdGEub3AgLSB0aGlzLmFuaW1hdGlvbkRhdGEuaXApO1xyXG4gIH1cclxuICB2YXIgbGF5ZXJzID0gdGhpcy5hbmltYXRpb25EYXRhLmxheWVycztcclxuICB2YXIgaTtcclxuICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcclxuICB2YXIgbmV3TGF5ZXJzID0gZGF0YS5sYXllcnM7XHJcbiAgdmFyIGo7XHJcbiAgdmFyIGpMZW4gPSBuZXdMYXllcnMubGVuZ3RoO1xyXG4gIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgaWYgKGxheWVyc1tpXS5pZCA9PT0gbmV3TGF5ZXJzW2pdLmlkKSB7XHJcbiAgICAgICAgbGF5ZXJzW2ldID0gbmV3TGF5ZXJzW2pdO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGRhdGEuY2hhcnMgfHwgZGF0YS5mb250cykge1xyXG4gICAgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmFkZENoYXJzKGRhdGEuY2hhcnMpO1xyXG4gICAgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmFkZEZvbnRzKGRhdGEuZm9udHMsIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5kZWZzKTtcclxuICB9XHJcbiAgaWYgKGRhdGEuYXNzZXRzKSB7XHJcbiAgICBsZW4gPSBkYXRhLmFzc2V0cy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cy5wdXNoKGRhdGEuYXNzZXRzW2ldKTtcclxuICAgIH1cclxuICB9XHJcbiAgdGhpcy5hbmltYXRpb25EYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcclxuICBkYXRhTWFuYWdlci5jb21wbGV0ZURhdGEodGhpcy5hbmltYXRpb25EYXRhLCB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIpO1xyXG4gIHRoaXMucmVuZGVyZXIuaW5jbHVkZUxheWVycyhkYXRhLmxheWVycyk7XHJcbiAgaWYgKGV4cHJlc3Npb25zUGx1Z2luKSB7XHJcbiAgICBleHByZXNzaW9uc1BsdWdpbi5pbml0RXhwcmVzc2lvbnModGhpcyk7XHJcbiAgfVxyXG4gIHRoaXMubG9hZE5leHRTZWdtZW50KCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5sb2FkTmV4dFNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5hbmltYXRpb25EYXRhLnNlZ21lbnRzO1xyXG4gIGlmICghc2VnbWVudHMgfHwgc2VnbWVudHMubGVuZ3RoID09PSAwIHx8ICF0aGlzLmF1dG9sb2FkU2VnbWVudHMpIHtcclxuICAgIHRoaXMudHJpZ2dlcignZGF0YV9yZWFkeScpO1xyXG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIHNlZ21lbnQgPSBzZWdtZW50cy5zaGlmdCgpO1xyXG4gIHRoaXMudGltZUNvbXBsZXRlZCA9IHNlZ21lbnQudGltZSAqIHRoaXMuZnJhbWVSYXRlO1xyXG4gIHZhciBzZWdtZW50UGF0aCA9IHRoaXMucGF0aCArIHRoaXMuZmlsZU5hbWUgKyAnXycgKyB0aGlzLnNlZ21lbnRQb3MgKyAnLmpzb24nO1xyXG4gIHRoaXMuc2VnbWVudFBvcyArPSAxO1xyXG4gIGFzc2V0TG9hZGVyLmxvYWQoc2VnbWVudFBhdGgsIHRoaXMuaW5jbHVkZUxheWVycy5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGFfZmFpbGVkJyk7XHJcbiAgfS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmxvYWRTZWdtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2VnbWVudHMgPSB0aGlzLmFuaW1hdGlvbkRhdGEuc2VnbWVudHM7XHJcbiAgaWYgKCFzZWdtZW50cykge1xyXG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcclxuICB9XHJcbiAgdGhpcy5sb2FkTmV4dFNlZ21lbnQoKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmltYWdlc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnRyaWdnZXIoJ2xvYWRlZF9pbWFnZXMnKTtcclxuICB0aGlzLmNoZWNrTG9hZGVkKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5wcmVsb2FkSW1hZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuaW1hZ2VQcmVsb2FkZXIuc2V0QXNzZXRzUGF0aCh0aGlzLmFzc2V0c1BhdGgpO1xyXG4gIHRoaXMuaW1hZ2VQcmVsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xyXG4gIHRoaXMuaW1hZ2VQcmVsb2FkZXIubG9hZEFzc2V0cyh0aGlzLmFuaW1hdGlvbkRhdGEuYXNzZXRzLCB0aGlzLmltYWdlc0xvYWRlZC5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltRGF0YSkge1xyXG4gIGlmICghdGhpcy5yZW5kZXJlcikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0cnkge1xyXG4gICAgdGhpcy5hbmltYXRpb25EYXRhID0gYW5pbURhdGE7XHJcblxyXG4gICAgaWYgKHRoaXMuaW5pdGlhbFNlZ21lbnQpIHtcclxuICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IE1hdGguZmxvb3IodGhpcy5pbml0aWFsU2VnbWVudFsxXSAtIHRoaXMuaW5pdGlhbFNlZ21lbnRbMF0pO1xyXG4gICAgICB0aGlzLmZpcnN0RnJhbWUgPSBNYXRoLnJvdW5kKHRoaXMuaW5pdGlhbFNlZ21lbnRbMF0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IE1hdGguZmxvb3IodGhpcy5hbmltYXRpb25EYXRhLm9wIC0gdGhpcy5hbmltYXRpb25EYXRhLmlwKTtcclxuICAgICAgdGhpcy5maXJzdEZyYW1lID0gTWF0aC5yb3VuZCh0aGlzLmFuaW1hdGlvbkRhdGEuaXApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJlci5jb25maWdBbmltYXRpb24oYW5pbURhdGEpO1xyXG4gICAgaWYgKCFhbmltRGF0YS5hc3NldHMpIHtcclxuICAgICAgYW5pbURhdGEuYXNzZXRzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hc3NldHMgPSB0aGlzLmFuaW1hdGlvbkRhdGEuYXNzZXRzO1xyXG4gICAgdGhpcy5mcmFtZVJhdGUgPSB0aGlzLmFuaW1hdGlvbkRhdGEuZnI7XHJcbiAgICB0aGlzLmZyYW1lTXVsdCA9IHRoaXMuYW5pbWF0aW9uRGF0YS5mciAvIDEwMDA7XHJcbiAgICB0aGlzLnJlbmRlcmVyLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zKGFuaW1EYXRhLmFzc2V0cyk7XHJcbiAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJQYXJzZXIoYW5pbURhdGEubWFya2VycyB8fCBbXSk7XHJcbiAgICB0aGlzLnRyaWdnZXIoJ2NvbmZpZ19yZWFkeScpO1xyXG4gICAgdGhpcy5wcmVsb2FkSW1hZ2VzKCk7XHJcbiAgICB0aGlzLmxvYWRTZWdtZW50cygpO1xyXG4gICAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xyXG4gICAgdGhpcy53YWl0Rm9yRm9udHNMb2FkZWQoKTtcclxuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XHJcbiAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnBhdXNlKCk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHRoaXMudHJpZ2dlckNvbmZpZ0Vycm9yKGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS53YWl0Rm9yRm9udHNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCF0aGlzLnJlbmRlcmVyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICh0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuaXNMb2FkZWQpIHtcclxuICAgIHRoaXMuY2hlY2tMb2FkZWQoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc2V0VGltZW91dCh0aGlzLndhaXRGb3JGb250c0xvYWRlZC5iaW5kKHRoaXMpLCAyMCk7XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY2hlY2tMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCF0aGlzLmlzTG9hZGVkXHJcbiAgICAgICAgJiYgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmlzTG9hZGVkXHJcbiAgICAgICAgJiYgKHRoaXMuaW1hZ2VQcmVsb2FkZXIubG9hZGVkSW1hZ2VzKCkgfHwgdGhpcy5yZW5kZXJlci5yZW5kZXJlclR5cGUgIT09ICdjYW52YXMnKVxyXG4gICAgICAgICYmICh0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRlZEZvb3RhZ2VzKCkpXHJcbiAgKSB7XHJcbiAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcclxuICAgIGRhdGFNYW5hZ2VyLmNvbXBsZXRlRGF0YSh0aGlzLmFuaW1hdGlvbkRhdGEsIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlcik7XHJcbiAgICBpZiAoZXhwcmVzc2lvbnNQbHVnaW4pIHtcclxuICAgICAgZXhwcmVzc2lvbnNQbHVnaW4uaW5pdEV4cHJlc3Npb25zKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJlci5pbml0SXRlbXMoKTtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ0RPTUxvYWRlZCcpO1xyXG4gICAgfS5iaW5kKHRoaXMpLCAwKTtcclxuICAgIHRoaXMuZ290b0ZyYW1lKCk7XHJcbiAgICBpZiAodGhpcy5hdXRvcGxheSkge1xyXG4gICAgICB0aGlzLnBsYXkoKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5yZW5kZXJlci51cGRhdGVDb250YWluZXJTaXplKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTdWJmcmFtZSA9IGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgdGhpcy5pc1N1YmZyYW1lRW5hYmxlZCA9ICEhZmxhZztcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdvdG9GcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMuaXNTdWJmcmFtZUVuYWJsZWQgPyB0aGlzLmN1cnJlbnRSYXdGcmFtZSA6IH5+dGhpcy5jdXJyZW50UmF3RnJhbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxyXG5cclxuICBpZiAodGhpcy50aW1lQ29tcGxldGVkICE9PSB0aGlzLnRvdGFsRnJhbWVzICYmIHRoaXMuY3VycmVudEZyYW1lID4gdGhpcy50aW1lQ29tcGxldGVkKSB7XHJcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMudGltZUNvbXBsZXRlZDtcclxuICB9XHJcbiAgdGhpcy50cmlnZ2VyKCdlbnRlckZyYW1lJyk7XHJcbiAgdGhpcy5yZW5kZXJGcmFtZSgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMuaXNMb2FkZWQgPT09IGZhbHNlIHx8ICF0aGlzLnJlbmRlcmVyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRyeSB7XHJcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckZyYW1lKHRoaXMuY3VycmVudEZyYW1lICsgdGhpcy5maXJzdEZyYW1lKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhpcy50cmlnZ2VyUmVuZGVyRnJhbWVFcnJvcihlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICh0aGlzLmlzUGF1c2VkID09PSB0cnVlKSB7XHJcbiAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5yZXN1bWUoKTtcclxuICAgIGlmICh0aGlzLl9pZGxlKSB7XHJcbiAgICAgIHRoaXMuX2lkbGUgPSBmYWxzZTtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdfYWN0aXZlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAodGhpcy5pc1BhdXNlZCA9PT0gZmFsc2UpIHtcclxuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5faWRsZSA9IHRydWU7XHJcbiAgICB0aGlzLnRyaWdnZXIoJ19pZGxlJyk7XHJcbiAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5wYXVzZSgpO1xyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRvZ2dsZVBhdXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUpIHtcclxuICAgIHRoaXMucGxheSgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnBhdXNlKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMucGF1c2UoKTtcclxuICB0aGlzLnBsYXlDb3VudCA9IDA7XHJcbiAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xyXG4gIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUoMCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJEYXRhID0gZnVuY3Rpb24gKG1hcmtlck5hbWUpIHtcclxuICB2YXIgbWFya2VyO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICBtYXJrZXIgPSB0aGlzLm1hcmtlcnNbaV07XHJcbiAgICBpZiAobWFya2VyLnBheWxvYWQgJiYgbWFya2VyLnBheWxvYWQubmFtZSA9PT0gbWFya2VyTmFtZSkge1xyXG4gICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdvVG9BbmRTdG9wID0gZnVuY3Rpb24gKHZhbHVlLCBpc0ZyYW1lLCBuYW1lKSB7XHJcbiAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBudW1WYWx1ZSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgaWYgKGlzTmFOKG51bVZhbHVlKSkge1xyXG4gICAgdmFyIG1hcmtlciA9IHRoaXMuZ2V0TWFya2VyRGF0YSh2YWx1ZSk7XHJcbiAgICBpZiAobWFya2VyKSB7XHJcbiAgICAgIHRoaXMuZ29Ub0FuZFN0b3AobWFya2VyLnRpbWUsIHRydWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNGcmFtZSkge1xyXG4gICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSh2YWx1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodmFsdWUgKiB0aGlzLmZyYW1lTW9kaWZpZXIpO1xyXG4gIH1cclxuICB0aGlzLnBhdXNlKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5nb1RvQW5kUGxheSA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNGcmFtZSwgbmFtZSkge1xyXG4gIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xyXG4gIGlmIChpc05hTihudW1WYWx1ZSkpIHtcclxuICAgIHZhciBtYXJrZXIgPSB0aGlzLmdldE1hcmtlckRhdGEodmFsdWUpO1xyXG4gICAgaWYgKG1hcmtlcikge1xyXG4gICAgICBpZiAoIW1hcmtlci5kdXJhdGlvbikge1xyXG4gICAgICAgIHRoaXMuZ29Ub0FuZFN0b3AobWFya2VyLnRpbWUsIHRydWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMucGxheVNlZ21lbnRzKFttYXJrZXIudGltZSwgbWFya2VyLnRpbWUgKyBtYXJrZXIuZHVyYXRpb25dLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmdvVG9BbmRTdG9wKG51bVZhbHVlLCBpc0ZyYW1lLCBuYW1lKTtcclxuICB9XHJcbiAgdGhpcy5wbGF5KCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5hZHZhbmNlVGltZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIGlmICh0aGlzLmlzUGF1c2VkID09PSB0cnVlIHx8IHRoaXMuaXNMb2FkZWQgPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBuZXh0VmFsdWUgPSB0aGlzLmN1cnJlbnRSYXdGcmFtZSArIHZhbHVlICogdGhpcy5mcmFtZU1vZGlmaWVyO1xyXG4gIHZhciBfaXNDb21wbGV0ZSA9IGZhbHNlO1xyXG4gIC8vIENoZWNraW5nIGlmIG5leHRWYWx1ZSA+IHRvdGFsRnJhbWVzIC0gMSBmb3IgYWRkcmVzc2luZyBub24gbG9vcGluZyBhbmQgbG9vcGluZyBhbmltYXRpb25zLlxyXG4gIC8vIElmIGFuaW1hdGlvbiB3b24ndCBsb29wLCBpdCBzaG91bGQgc3RvcCBhdCB0b3RhbEZyYW1lcyAtIDEuIElmIGl0IHdpbGwgbG9vcCBpdCBzaG91bGQgY29tcGxldGUgdGhlIGxhc3QgZnJhbWUgYW5kIHRoZW4gbG9vcC5cclxuICBpZiAobmV4dFZhbHVlID49IHRoaXMudG90YWxGcmFtZXMgLSAxICYmIHRoaXMuZnJhbWVNb2RpZmllciA+IDApIHtcclxuICAgIGlmICghdGhpcy5sb29wIHx8IHRoaXMucGxheUNvdW50ID09PSB0aGlzLmxvb3ApIHtcclxuICAgICAgaWYgKCF0aGlzLmNoZWNrU2VnbWVudHMobmV4dFZhbHVlID4gdGhpcy50b3RhbEZyYW1lcyA/IG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMgOiAwKSkge1xyXG4gICAgICAgIF9pc0NvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICBuZXh0VmFsdWUgPSB0aGlzLnRvdGFsRnJhbWVzIC0gMTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChuZXh0VmFsdWUgPj0gdGhpcy50b3RhbEZyYW1lcykge1xyXG4gICAgICB0aGlzLnBsYXlDb3VudCArPSAxO1xyXG4gICAgICBpZiAoIXRoaXMuY2hlY2tTZWdtZW50cyhuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKSkge1xyXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcyk7XHJcbiAgICAgICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdsb29wQ29tcGxldGUnKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAobmV4dFZhbHVlIDwgMCkge1xyXG4gICAgaWYgKCF0aGlzLmNoZWNrU2VnbWVudHMobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcykpIHtcclxuICAgICAgaWYgKHRoaXMubG9vcCAmJiAhKHRoaXMucGxheUNvdW50LS0gPD0gMCAmJiB0aGlzLmxvb3AgIT09IHRydWUpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGx1c3BsdXNcclxuICAgICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHRoaXMudG90YWxGcmFtZXMgKyAobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcykpO1xyXG4gICAgICAgIGlmICghdGhpcy5fY29tcGxldGVkTG9vcCkge1xyXG4gICAgICAgICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMudHJpZ2dlcignbG9vcENvbXBsZXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9pc0NvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICBuZXh0VmFsdWUgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUobmV4dFZhbHVlKTtcclxuICB9XHJcbiAgaWYgKF9pc0NvbXBsZXRlKSB7XHJcbiAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKG5leHRWYWx1ZSk7XHJcbiAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICB0aGlzLnRyaWdnZXIoJ2NvbXBsZXRlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuYWRqdXN0U2VnbWVudCA9IGZ1bmN0aW9uIChhcnIsIG9mZnNldCkge1xyXG4gIHRoaXMucGxheUNvdW50ID0gMDtcclxuICBpZiAoYXJyWzFdIDwgYXJyWzBdKSB7XHJcbiAgICBpZiAodGhpcy5mcmFtZU1vZGlmaWVyID4gMCkge1xyXG4gICAgICBpZiAodGhpcy5wbGF5U3BlZWQgPCAwKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTcGVlZCgtdGhpcy5wbGF5U3BlZWQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKC0xKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy50b3RhbEZyYW1lcyA9IGFyclswXSAtIGFyclsxXTtcclxuICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XHJcbiAgICB0aGlzLmZpcnN0RnJhbWUgPSBhcnJbMV07XHJcbiAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHRoaXMudG90YWxGcmFtZXMgLSAwLjAwMSAtIG9mZnNldCk7XHJcbiAgfSBlbHNlIGlmIChhcnJbMV0gPiBhcnJbMF0pIHtcclxuICAgIGlmICh0aGlzLmZyYW1lTW9kaWZpZXIgPCAwKSB7XHJcbiAgICAgIGlmICh0aGlzLnBsYXlTcGVlZCA8IDApIHtcclxuICAgICAgICB0aGlzLnNldFNwZWVkKC10aGlzLnBsYXlTcGVlZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZXREaXJlY3Rpb24oMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMudG90YWxGcmFtZXMgPSBhcnJbMV0gLSBhcnJbMF07XHJcbiAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzO1xyXG4gICAgdGhpcy5maXJzdEZyYW1lID0gYXJyWzBdO1xyXG4gICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSgwLjAwMSArIG9mZnNldCk7XHJcbiAgfVxyXG4gIHRoaXMudHJpZ2dlcignc2VnbWVudFN0YXJ0Jyk7XHJcbn07XHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdCwgZW5kKSB7XHJcbiAgdmFyIHBlbmRpbmdGcmFtZSA9IC0xO1xyXG4gIGlmICh0aGlzLmlzUGF1c2VkKSB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50UmF3RnJhbWUgKyB0aGlzLmZpcnN0RnJhbWUgPCBpbml0KSB7XHJcbiAgICAgIHBlbmRpbmdGcmFtZSA9IGluaXQ7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFJhd0ZyYW1lICsgdGhpcy5maXJzdEZyYW1lID4gZW5kKSB7XHJcbiAgICAgIHBlbmRpbmdGcmFtZSA9IGVuZCAtIGluaXQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLmZpcnN0RnJhbWUgPSBpbml0O1xyXG4gIHRoaXMudG90YWxGcmFtZXMgPSBlbmQgLSBpbml0O1xyXG4gIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XHJcbiAgaWYgKHBlbmRpbmdGcmFtZSAhPT0gLTEpIHtcclxuICAgIHRoaXMuZ29Ub0FuZFN0b3AocGVuZGluZ0ZyYW1lLCB0cnVlKTtcclxuICB9XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5wbGF5U2VnbWVudHMgPSBmdW5jdGlvbiAoYXJyLCBmb3JjZUZsYWcpIHtcclxuICBpZiAoZm9yY2VGbGFnKSB7XHJcbiAgICB0aGlzLnNlZ21lbnRzLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgYXJyWzBdID09PSAnb2JqZWN0Jykge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICB0aGlzLnNlZ21lbnRzLnB1c2goYXJyW2ldKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5zZWdtZW50cy5wdXNoKGFycik7XHJcbiAgfVxyXG4gIGlmICh0aGlzLnNlZ21lbnRzLmxlbmd0aCAmJiBmb3JjZUZsYWcpIHtcclxuICAgIHRoaXMuYWRqdXN0U2VnbWVudCh0aGlzLnNlZ21lbnRzLnNoaWZ0KCksIDApO1xyXG4gIH1cclxuICBpZiAodGhpcy5pc1BhdXNlZCkge1xyXG4gICAgdGhpcy5wbGF5KCk7XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVzZXRTZWdtZW50cyA9IGZ1bmN0aW9uIChmb3JjZUZsYWcpIHtcclxuICB0aGlzLnNlZ21lbnRzLmxlbmd0aCA9IDA7XHJcbiAgdGhpcy5zZWdtZW50cy5wdXNoKFt0aGlzLmFuaW1hdGlvbkRhdGEuaXAsIHRoaXMuYW5pbWF0aW9uRGF0YS5vcF0pO1xyXG4gIC8vIHRoaXMuc2VnbWVudHMucHVzaChbdGhpcy5hbmltYXRpb25EYXRhLmlwKnRoaXMuZnJhbWVSYXRlLE1hdGguZmxvb3IodGhpcy5hbmltYXRpb25EYXRhLm9wIC0gdGhpcy5hbmltYXRpb25EYXRhLmlwK3RoaXMuYW5pbWF0aW9uRGF0YS5pcCp0aGlzLmZyYW1lUmF0ZSldKTtcclxuICBpZiAoZm9yY2VGbGFnKSB7XHJcbiAgICB0aGlzLmNoZWNrU2VnbWVudHMoMCk7XHJcbiAgfVxyXG59O1xyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5jaGVja1NlZ21lbnRzID0gZnVuY3Rpb24gKG9mZnNldCkge1xyXG4gIGlmICh0aGlzLnNlZ21lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5hZGp1c3RTZWdtZW50KHRoaXMuc2VnbWVudHMuc2hpZnQoKSwgb2Zmc2V0KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICBpZiAoKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB8fCAhdGhpcy5yZW5kZXJlcikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcclxuICB0aGlzLmltYWdlUHJlbG9hZGVyLmRlc3Ryb3koKTtcclxuICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcclxuICB0aGlzLl9jYnMgPSBudWxsO1xyXG4gIHRoaXMub25FbnRlckZyYW1lID0gbnVsbDtcclxuICB0aGlzLm9uTG9vcENvbXBsZXRlID0gbnVsbDtcclxuICB0aGlzLm9uQ29tcGxldGUgPSBudWxsO1xyXG4gIHRoaXMub25TZWdtZW50U3RhcnQgPSBudWxsO1xyXG4gIHRoaXMub25EZXN0cm95ID0gbnVsbDtcclxuICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuICB0aGlzLmltYWdlUHJlbG9hZGVyID0gbnVsbDtcclxuICB0aGlzLnByb2plY3RJbnRlcmZhY2UgPSBudWxsO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICB0aGlzLmN1cnJlbnRSYXdGcmFtZSA9IHZhbHVlO1xyXG4gIHRoaXMuZ290b0ZyYW1lKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTcGVlZCA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICB0aGlzLnBsYXlTcGVlZCA9IHZhbDtcclxuICB0aGlzLnVwZGFGcmFtZU1vZGlmaWVyKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgdGhpcy5wbGF5RGlyZWN0aW9uID0gdmFsIDwgMCA/IC0xIDogMTtcclxuICB0aGlzLnVwZGFGcmFtZU1vZGlmaWVyKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodmFsLCBuYW1lKSB7XHJcbiAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMuYXVkaW9Db250cm9sbGVyLnNldFZvbHVtZSh2YWwpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0Vm9sdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLmF1ZGlvQ29udHJvbGxlci5nZXRWb2x1bWUoKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLm11dGUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLmF1ZGlvQ29udHJvbGxlci5tdXRlKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS51bm11dGUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLmF1ZGlvQ29udHJvbGxlci51bm11dGUoKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVwZGFGcmFtZU1vZGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuZnJhbWVNb2RpZmllciA9IHRoaXMuZnJhbWVNdWx0ICogdGhpcy5wbGF5U3BlZWQgKiB0aGlzLnBsYXlEaXJlY3Rpb247XHJcbiAgdGhpcy5hdWRpb0NvbnRyb2xsZXIuc2V0UmF0ZSh0aGlzLnBsYXlTcGVlZCAqIHRoaXMucGxheURpcmVjdGlvbik7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnBhdGg7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRBc3NldHNQYXRoID0gZnVuY3Rpb24gKGFzc2V0RGF0YSkge1xyXG4gIHZhciBwYXRoID0gJyc7XHJcbiAgaWYgKGFzc2V0RGF0YS5lKSB7XHJcbiAgICBwYXRoID0gYXNzZXREYXRhLnA7XHJcbiAgfSBlbHNlIGlmICh0aGlzLmFzc2V0c1BhdGgpIHtcclxuICAgIHZhciBpbWFnZVBhdGggPSBhc3NldERhdGEucDtcclxuICAgIGlmIChpbWFnZVBhdGguaW5kZXhPZignaW1hZ2VzLycpICE9PSAtMSkge1xyXG4gICAgICBpbWFnZVBhdGggPSBpbWFnZVBhdGguc3BsaXQoJy8nKVsxXTtcclxuICAgIH1cclxuICAgIHBhdGggPSB0aGlzLmFzc2V0c1BhdGggKyBpbWFnZVBhdGg7XHJcbiAgfSBlbHNlIHtcclxuICAgIHBhdGggPSB0aGlzLnBhdGg7XHJcbiAgICBwYXRoICs9IGFzc2V0RGF0YS51ID8gYXNzZXREYXRhLnUgOiAnJztcclxuICAgIHBhdGggKz0gYXNzZXREYXRhLnA7XHJcbiAgfVxyXG4gIHJldHVybiBwYXRoO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0QXNzZXREYXRhID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgdmFyIGkgPSAwO1xyXG4gIHZhciBsZW4gPSB0aGlzLmFzc2V0cy5sZW5ndGg7XHJcbiAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIGlmIChpZCA9PT0gdGhpcy5hc3NldHNbaV0uaWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXNzZXRzW2ldO1xyXG4gICAgfVxyXG4gICAgaSArPSAxO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5yZW5kZXJlci5oaWRlKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMucmVuZGVyZXIuc2hvdygpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoaXNGcmFtZSkge1xyXG4gIHJldHVybiBpc0ZyYW1lID8gdGhpcy50b3RhbEZyYW1lcyA6IHRoaXMudG90YWxGcmFtZXMgLyB0aGlzLmZyYW1lUmF0ZTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIGlmICh0aGlzLl9jYnMgJiYgdGhpcy5fY2JzW25hbWVdKSB7XHJcbiAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgY2FzZSAnZW50ZXJGcmFtZSc6XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNRW50ZXJGcmFtZUV2ZW50KG5hbWUsIHRoaXMuY3VycmVudEZyYW1lLCB0aGlzLnRvdGFsRnJhbWVzLCB0aGlzLmZyYW1lTW9kaWZpZXIpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnbG9vcENvbXBsZXRlJzpcclxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lLCBuZXcgQk1Db21wbGV0ZUxvb3BFdmVudChuYW1lLCB0aGlzLmxvb3AsIHRoaXMucGxheUNvdW50LCB0aGlzLmZyYW1lTXVsdCkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdjb21wbGV0ZSc6XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNQ29tcGxldGVFdmVudChuYW1lLCB0aGlzLmZyYW1lTXVsdCkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdzZWdtZW50U3RhcnQnOlxyXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTVNlZ21lbnRTdGFydEV2ZW50KG5hbWUsIHRoaXMuZmlyc3RGcmFtZSwgdGhpcy50b3RhbEZyYW1lcykpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdkZXN0cm95JzpcclxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lLCBuZXcgQk1EZXN0cm95RXZlbnQobmFtZSwgdGhpcykpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAobmFtZSA9PT0gJ2VudGVyRnJhbWUnICYmIHRoaXMub25FbnRlckZyYW1lKSB7XHJcbiAgICB0aGlzLm9uRW50ZXJGcmFtZS5jYWxsKHRoaXMsIG5ldyBCTUVudGVyRnJhbWVFdmVudChuYW1lLCB0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy50b3RhbEZyYW1lcywgdGhpcy5mcmFtZU11bHQpKTtcclxuICB9XHJcbiAgaWYgKG5hbWUgPT09ICdsb29wQ29tcGxldGUnICYmIHRoaXMub25Mb29wQ29tcGxldGUpIHtcclxuICAgIHRoaXMub25Mb29wQ29tcGxldGUuY2FsbCh0aGlzLCBuZXcgQk1Db21wbGV0ZUxvb3BFdmVudChuYW1lLCB0aGlzLmxvb3AsIHRoaXMucGxheUNvdW50LCB0aGlzLmZyYW1lTXVsdCkpO1xyXG4gIH1cclxuICBpZiAobmFtZSA9PT0gJ2NvbXBsZXRlJyAmJiB0aGlzLm9uQ29tcGxldGUpIHtcclxuICAgIHRoaXMub25Db21wbGV0ZS5jYWxsKHRoaXMsIG5ldyBCTUNvbXBsZXRlRXZlbnQobmFtZSwgdGhpcy5mcmFtZU11bHQpKTtcclxuICB9XHJcbiAgaWYgKG5hbWUgPT09ICdzZWdtZW50U3RhcnQnICYmIHRoaXMub25TZWdtZW50U3RhcnQpIHtcclxuICAgIHRoaXMub25TZWdtZW50U3RhcnQuY2FsbCh0aGlzLCBuZXcgQk1TZWdtZW50U3RhcnRFdmVudChuYW1lLCB0aGlzLmZpcnN0RnJhbWUsIHRoaXMudG90YWxGcmFtZXMpKTtcclxuICB9XHJcbiAgaWYgKG5hbWUgPT09ICdkZXN0cm95JyAmJiB0aGlzLm9uRGVzdHJveSkge1xyXG4gICAgdGhpcy5vbkRlc3Ryb3kuY2FsbCh0aGlzLCBuZXcgQk1EZXN0cm95RXZlbnQobmFtZSwgdGhpcykpO1xyXG4gIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXJSZW5kZXJGcmFtZUVycm9yID0gZnVuY3Rpb24gKG5hdGl2ZUVycm9yKSB7XHJcbiAgdmFyIGVycm9yID0gbmV3IEJNUmVuZGVyRnJhbWVFcnJvckV2ZW50KG5hdGl2ZUVycm9yLCB0aGlzLmN1cnJlbnRGcmFtZSk7XHJcbiAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Vycm9yJywgZXJyb3IpO1xyXG5cclxuICBpZiAodGhpcy5vbkVycm9yKSB7XHJcbiAgICB0aGlzLm9uRXJyb3IuY2FsbCh0aGlzLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudHJpZ2dlckNvbmZpZ0Vycm9yID0gZnVuY3Rpb24gKG5hdGl2ZUVycm9yKSB7XHJcbiAgdmFyIGVycm9yID0gbmV3IEJNQ29uZmlnRXJyb3JFdmVudChuYXRpdmVFcnJvciwgdGhpcy5jdXJyZW50RnJhbWUpO1xyXG4gIHRoaXMudHJpZ2dlckV2ZW50KCdlcnJvcicsIGVycm9yKTtcclxuXHJcbiAgaWYgKHRoaXMub25FcnJvcikge1xyXG4gICAgdGhpcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qIGdsb2JhbCBDb21wRXhwcmVzc2lvbkludGVyZmFjZSwgZXhwcmVzc2lvbnNQbHVnaW46IHdyaXRhYmxlICovXHJcbi8qIGV4cG9ydGVkIGV4cHJlc3Npb25zUGx1Z2luICovXHJcblxyXG52YXIgRXhwcmVzc2lvbnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBvYiA9IHt9O1xyXG4gIG9iLmluaXRFeHByZXNzaW9ucyA9IGluaXRFeHByZXNzaW9ucztcclxuXHJcbiAgZnVuY3Rpb24gaW5pdEV4cHJlc3Npb25zKGFuaW1hdGlvbikge1xyXG4gICAgdmFyIHN0YWNrQ291bnQgPSAwO1xyXG4gICAgdmFyIHJlZ2lzdGVycyA9IFtdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHB1c2hFeHByZXNzaW9uKCkge1xyXG4gICAgICBzdGFja0NvdW50ICs9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcG9wRXhwcmVzc2lvbigpIHtcclxuICAgICAgc3RhY2tDb3VudCAtPSAxO1xyXG4gICAgICBpZiAoc3RhY2tDb3VudCA9PT0gMCkge1xyXG4gICAgICAgIHJlbGVhc2VJbnN0YW5jZXMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXhwcmVzc2lvblByb3BlcnR5KGV4cHJlc3Npb24pIHtcclxuICAgICAgaWYgKHJlZ2lzdGVycy5pbmRleE9mKGV4cHJlc3Npb24pID09PSAtMSkge1xyXG4gICAgICAgIHJlZ2lzdGVycy5wdXNoKGV4cHJlc3Npb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVsZWFzZUluc3RhbmNlcygpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSByZWdpc3RlcnMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICByZWdpc3RlcnNbaV0ucmVsZWFzZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlZ2lzdGVycy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGFuaW1hdGlvbi5yZW5kZXJlci5jb21wSW50ZXJmYWNlID0gQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UoYW5pbWF0aW9uLnJlbmRlcmVyKTtcclxuICAgIGFuaW1hdGlvbi5yZW5kZXJlci5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihhbmltYXRpb24ucmVuZGVyZXIpO1xyXG4gICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucHVzaEV4cHJlc3Npb24gPSBwdXNoRXhwcmVzc2lvbjtcclxuICAgIGFuaW1hdGlvbi5yZW5kZXJlci5nbG9iYWxEYXRhLnBvcEV4cHJlc3Npb24gPSBwb3BFeHByZXNzaW9uO1xyXG4gICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucmVnaXN0ZXJFeHByZXNzaW9uUHJvcGVydHkgPSByZWdpc3RlckV4cHJlc3Npb25Qcm9wZXJ0eTtcclxuICB9XHJcbiAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuZXhwcmVzc2lvbnNQbHVnaW4gPSBFeHByZXNzaW9ucztcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSwgbm8tdW51c2VkLXZhcnMgKi9cclxuLyogZ2xvYmFsIEJNTWF0aCwgQmV6aWVyRmFjdG9yeSwgY3JlYXRlVHlwZWRBcnJheSwgZGVnVG9SYWRzLCBzaGFwZVBvb2wgKi9cclxuXHJcbnZhciBFeHByZXNzaW9uTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgb2IgPSB7fTtcclxuICB2YXIgTWF0aCA9IEJNTWF0aDtcclxuICB2YXIgd2luZG93ID0gbnVsbDtcclxuICB2YXIgZG9jdW1lbnQgPSBudWxsO1xyXG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IG51bGw7XHJcbiAgdmFyIGZldGNoID0gbnVsbDtcclxuXHJcbiAgZnVuY3Rpb24gJGJtX2lzSW5zdGFuY2VPZkFycmF5KGFycikge1xyXG4gICAgcmV0dXJuIGFyci5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgYXJyLmNvbnN0cnVjdG9yID09PSBGbG9hdDMyQXJyYXk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc051bWVyYWJsZSh0T2ZWLCB2KSB7XHJcbiAgICByZXR1cm4gdE9mViA9PT0gJ251bWJlcicgfHwgdE9mViA9PT0gJ2Jvb2xlYW4nIHx8IHRPZlYgPT09ICdzdHJpbmcnIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiAkYm1fbmVnKGEpIHtcclxuICAgIHZhciB0T2ZBID0gdHlwZW9mIGE7XHJcbiAgICBpZiAodE9mQSA9PT0gJ251bWJlcicgfHwgdE9mQSA9PT0gJ2Jvb2xlYW4nIHx8IGEgaW5zdGFuY2VvZiBOdW1iZXIpIHtcclxuICAgICAgcmV0dXJuIC1hO1xyXG4gICAgfVxyXG4gICAgaWYgKCRibV9pc0luc3RhbmNlT2ZBcnJheShhKSkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbkEgPSBhLmxlbmd0aDtcclxuICAgICAgdmFyIHJldEFyciA9IFtdO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQTsgaSArPSAxKSB7XHJcbiAgICAgICAgcmV0QXJyW2ldID0gLWFbaV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJldEFycjtcclxuICAgIH1cclxuICAgIGlmIChhLnByb3BUeXBlKSB7XHJcbiAgICAgIHJldHVybiBhLnY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLWE7XHJcbiAgfVxyXG5cclxuICB2YXIgZWFzZUluQmV6ID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoMC4zMzMsIDAsIDAuODMzLCAwLjgzMywgJ2Vhc2VJbicpLmdldDtcclxuICB2YXIgZWFzZU91dEJleiA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKDAuMTY3LCAwLjE2NywgMC42NjcsIDEsICdlYXNlT3V0JykuZ2V0O1xyXG4gIHZhciBlYXNlSW5PdXRCZXogPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZygwLjMzLCAwLCAwLjY2NywgMSwgJ2Vhc2VJbk91dCcpLmdldDtcclxuXHJcbiAgZnVuY3Rpb24gc3VtKGEsIGIpIHtcclxuICAgIHZhciB0T2ZBID0gdHlwZW9mIGE7XHJcbiAgICB2YXIgdE9mQiA9IHR5cGVvZiBiO1xyXG4gICAgaWYgKHRPZkEgPT09ICdzdHJpbmcnIHx8IHRPZkIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBhICsgYjtcclxuICAgIH1cclxuICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xyXG4gICAgICByZXR1cm4gYSArIGI7XHJcbiAgICB9XHJcbiAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgIGEgPSBhLnNsaWNlKDApO1xyXG4gICAgICBhWzBdICs9IGI7XHJcbiAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xyXG4gICAgICBiID0gYi5zbGljZSgwKTtcclxuICAgICAgYlswXSA9IGEgKyBiWzBdO1xyXG4gICAgICByZXR1cm4gYjtcclxuICAgIH1cclxuICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIGxlbkEgPSBhLmxlbmd0aDtcclxuICAgICAgdmFyIGxlbkIgPSBiLmxlbmd0aDtcclxuICAgICAgdmFyIHJldEFyciA9IFtdO1xyXG4gICAgICB3aGlsZSAoaSA8IGxlbkEgfHwgaSA8IGxlbkIpIHtcclxuICAgICAgICBpZiAoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XHJcbiAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldICsgYltpXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0QXJyW2ldID0gYltpXSA9PT0gdW5kZWZpbmVkID8gYVtpXSA6IGFbaV0gfHwgYltpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXRBcnI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgdmFyIGFkZCA9IHN1bTtcclxuXHJcbiAgZnVuY3Rpb24gc3ViKGEsIGIpIHtcclxuICAgIHZhciB0T2ZBID0gdHlwZW9mIGE7XHJcbiAgICB2YXIgdE9mQiA9IHR5cGVvZiBiO1xyXG4gICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgIGlmICh0T2ZBID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGEgPSBwYXJzZUludChhLCAxMCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRPZkIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgYiA9IHBhcnNlSW50KGIsIDEwKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICB9XHJcbiAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgIGEgPSBhLnNsaWNlKDApO1xyXG4gICAgICBhWzBdIC09IGI7XHJcbiAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xyXG4gICAgICBiID0gYi5zbGljZSgwKTtcclxuICAgICAgYlswXSA9IGEgLSBiWzBdO1xyXG4gICAgICByZXR1cm4gYjtcclxuICAgIH1cclxuICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIGxlbkEgPSBhLmxlbmd0aDtcclxuICAgICAgdmFyIGxlbkIgPSBiLmxlbmd0aDtcclxuICAgICAgdmFyIHJldEFyciA9IFtdO1xyXG4gICAgICB3aGlsZSAoaSA8IGxlbkEgfHwgaSA8IGxlbkIpIHtcclxuICAgICAgICBpZiAoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XHJcbiAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldIC0gYltpXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0QXJyW2ldID0gYltpXSA9PT0gdW5kZWZpbmVkID8gYVtpXSA6IGFbaV0gfHwgYltpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXRBcnI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG11bChhLCBiKSB7XHJcbiAgICB2YXIgdE9mQSA9IHR5cGVvZiBhO1xyXG4gICAgdmFyIHRPZkIgPSB0eXBlb2YgYjtcclxuICAgIHZhciBhcnI7XHJcbiAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcclxuICAgICAgcmV0dXJuIGEgKiBiO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbjtcclxuICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcclxuICAgICAgbGVuID0gYS5sZW5ndGg7XHJcbiAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBhcnJbaV0gPSBhW2ldICogYjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xyXG4gICAgICBsZW4gPSBiLmxlbmd0aDtcclxuICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIGFycltpXSA9IGEgKiBiW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRpdihhLCBiKSB7XHJcbiAgICB2YXIgdE9mQSA9IHR5cGVvZiBhO1xyXG4gICAgdmFyIHRPZkIgPSB0eXBlb2YgYjtcclxuICAgIHZhciBhcnI7XHJcbiAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcclxuICAgICAgcmV0dXJuIGEgLyBiO1xyXG4gICAgfVxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuO1xyXG4gICAgaWYgKCRibV9pc0luc3RhbmNlT2ZBcnJheShhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xyXG4gICAgICBsZW4gPSBhLmxlbmd0aDtcclxuICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIGFycltpXSA9IGFbaV0gLyBiO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XHJcbiAgICAgIGxlbiA9IGIubGVuZ3RoO1xyXG4gICAgICBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgYXJyW2ldID0gYSAvIGJbaV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBmdW5jdGlvbiBtb2QoYSwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xyXG4gICAgICBhID0gcGFyc2VJbnQoYSwgMTApO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xyXG4gICAgICBiID0gcGFyc2VJbnQoYiwgMTApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEgJSBiO1xyXG4gIH1cclxuICB2YXIgJGJtX3N1bSA9IHN1bTtcclxuICB2YXIgJGJtX3N1YiA9IHN1YjtcclxuICB2YXIgJGJtX211bCA9IG11bDtcclxuICB2YXIgJGJtX2RpdiA9IGRpdjtcclxuICB2YXIgJGJtX21vZCA9IG1vZDtcclxuXHJcbiAgZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xyXG4gICAgaWYgKG1pbiA+IG1heCkge1xyXG4gICAgICB2YXIgbW0gPSBtYXg7XHJcbiAgICAgIG1heCA9IG1pbjtcclxuICAgICAgbWluID0gbW07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmFkaWFuc1RvRGVncmVlcyh2YWwpIHtcclxuICAgIHJldHVybiB2YWwgLyBkZWdUb1JhZHM7XHJcbiAgfVxyXG4gIHZhciByYWRpYW5zX3RvX2RlZ3JlZXMgPSByYWRpYW5zVG9EZWdyZWVzO1xyXG5cclxuICBmdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKHZhbCkge1xyXG4gICAgcmV0dXJuIHZhbCAqIGRlZ1RvUmFkcztcclxuICB9XHJcbiAgdmFyIGRlZ3JlZXNfdG9fcmFkaWFucyA9IHJhZGlhbnNUb0RlZ3JlZXM7XHJcblxyXG4gIHZhciBoZWxwZXJMZW5ndGhBcnJheSA9IFswLCAwLCAwLCAwLCAwLCAwXTtcclxuXHJcbiAgZnVuY3Rpb24gbGVuZ3RoKGFycjEsIGFycjIpIHtcclxuICAgIGlmICh0eXBlb2YgYXJyMSA9PT0gJ251bWJlcicgfHwgYXJyMSBpbnN0YW5jZW9mIE51bWJlcikge1xyXG4gICAgICBhcnIyID0gYXJyMiB8fCAwO1xyXG4gICAgICByZXR1cm4gTWF0aC5hYnMoYXJyMSAtIGFycjIpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhcnIyKSB7XHJcbiAgICAgIGFycjIgPSBoZWxwZXJMZW5ndGhBcnJheTtcclxuICAgIH1cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XHJcbiAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGFkZGVkTGVuZ3RoICs9IE1hdGgucG93KGFycjJbaV0gLSBhcnIxW2ldLCAyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNYXRoLnNxcnQoYWRkZWRMZW5ndGgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplKHZlYykge1xyXG4gICAgcmV0dXJuIGRpdih2ZWMsIGxlbmd0aCh2ZWMpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJnYlRvSHNsKHZhbCkge1xyXG4gICAgdmFyIHIgPSB2YWxbMF07IHZhciBnID0gdmFsWzFdOyB2YXIgYiA9IHZhbFsyXTtcclxuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcclxuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgIHZhciBoO1xyXG4gICAgdmFyIHM7XHJcbiAgICB2YXIgbCA9IChtYXggKyBtaW4pIC8gMjtcclxuXHJcbiAgICBpZiAobWF4ID09PSBtaW4pIHtcclxuICAgICAgaCA9IDA7IC8vIGFjaHJvbWF0aWNcclxuICAgICAgcyA9IDA7IC8vIGFjaHJvbWF0aWNcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBkID0gbWF4IC0gbWluO1xyXG4gICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XHJcbiAgICAgIHN3aXRjaCAobWF4KSB7XHJcbiAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcclxuICAgICAgICBkZWZhdWx0OiBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBoIC89IDY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtoLCBzLCBsLCB2YWxbM11dO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XHJcbiAgICBpZiAodCA8IDApIHQgKz0gMTtcclxuICAgIGlmICh0ID4gMSkgdCAtPSAxO1xyXG4gICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcclxuICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcclxuICAgIHJldHVybiBwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaHNsVG9SZ2IodmFsKSB7XHJcbiAgICB2YXIgaCA9IHZhbFswXTtcclxuICAgIHZhciBzID0gdmFsWzFdO1xyXG4gICAgdmFyIGwgPSB2YWxbMl07XHJcblxyXG4gICAgdmFyIHI7XHJcbiAgICB2YXIgZztcclxuICAgIHZhciBiO1xyXG5cclxuICAgIGlmIChzID09PSAwKSB7XHJcbiAgICAgIHIgPSBsOyAvLyBhY2hyb21hdGljXHJcbiAgICAgIGIgPSBsOyAvLyBhY2hyb21hdGljXHJcbiAgICAgIGcgPSBsOyAvLyBhY2hyb21hdGljXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XHJcbiAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xyXG4gICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xyXG4gICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcclxuICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW3IsIGcsIGIsIHZhbFszXV07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsaW5lYXIodCwgdE1pbiwgdE1heCwgdmFsdWUxLCB2YWx1ZTIpIHtcclxuICAgIGlmICh2YWx1ZTEgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZTIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YWx1ZTEgPSB0TWluO1xyXG4gICAgICB2YWx1ZTIgPSB0TWF4O1xyXG4gICAgICB0TWluID0gMDtcclxuICAgICAgdE1heCA9IDE7XHJcbiAgICB9XHJcbiAgICBpZiAodE1heCA8IHRNaW4pIHtcclxuICAgICAgdmFyIF90TWluID0gdE1heDtcclxuICAgICAgdE1heCA9IHRNaW47XHJcbiAgICAgIHRNaW4gPSBfdE1pbjtcclxuICAgIH1cclxuICAgIGlmICh0IDw9IHRNaW4pIHtcclxuICAgICAgcmV0dXJuIHZhbHVlMTtcclxuICAgIH0gaWYgKHQgPj0gdE1heCkge1xyXG4gICAgICByZXR1cm4gdmFsdWUyO1xyXG4gICAgfVxyXG4gICAgdmFyIHBlcmMgPSB0TWF4ID09PSB0TWluID8gMCA6ICh0IC0gdE1pbikgLyAodE1heCAtIHRNaW4pO1xyXG4gICAgaWYgKCF2YWx1ZTEubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTEgKyAodmFsdWUyIC0gdmFsdWUxKSAqIHBlcmM7XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSB2YWx1ZTEubGVuZ3RoO1xyXG4gICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGFycltpXSA9IHZhbHVlMVtpXSArICh2YWx1ZTJbaV0gLSB2YWx1ZTFbaV0pICogcGVyYztcclxuICAgIH1cclxuICAgIHJldHVybiBhcnI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCkge1xyXG4gICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG1pbiA9IDA7XHJcbiAgICAgICAgbWF4ID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXggPSBtaW47XHJcbiAgICAgICAgbWluID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobWF4Lmxlbmd0aCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IG1heC5sZW5ndGg7XHJcbiAgICAgIGlmICghbWluKSB7XHJcbiAgICAgICAgbWluID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICB2YXIgcm5kID0gQk1NYXRoLnJhbmRvbSgpO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBhcnJbaV0gPSBtaW5baV0gKyBybmQgKiAobWF4W2ldIC0gbWluW2ldKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG4gICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG1pbiA9IDA7XHJcbiAgICB9XHJcbiAgICB2YXIgcm5kbSA9IEJNTWF0aC5yYW5kb20oKTtcclxuICAgIHJldHVybiBtaW4gKyBybmRtICogKG1heCAtIG1pbik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVQYXRoKHBvaW50cywgaW5UYW5nZW50cywgb3V0VGFuZ2VudHMsIGNsb3NlZCkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgIHZhciBwYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcclxuICAgIHBhdGguc2V0UGF0aERhdGEoISFjbG9zZWQsIGxlbik7XHJcbiAgICB2YXIgYXJyUGxhY2Vob2xkZXIgPSBbMCwgMF07XHJcbiAgICB2YXIgaW5WZXJ0ZXhQb2ludDtcclxuICAgIHZhciBvdXRWZXJ0ZXhQb2ludDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpblZlcnRleFBvaW50ID0gKGluVGFuZ2VudHMgJiYgaW5UYW5nZW50c1tpXSkgPyBpblRhbmdlbnRzW2ldIDogYXJyUGxhY2Vob2xkZXI7XHJcbiAgICAgIG91dFZlcnRleFBvaW50ID0gKG91dFRhbmdlbnRzICYmIG91dFRhbmdlbnRzW2ldKSA/IG91dFRhbmdlbnRzW2ldIDogYXJyUGxhY2Vob2xkZXI7XHJcbiAgICAgIHBhdGguc2V0VHJpcGxlQXQocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0sIG91dFZlcnRleFBvaW50WzBdICsgcG9pbnRzW2ldWzBdLCBvdXRWZXJ0ZXhQb2ludFsxXSArIHBvaW50c1tpXVsxXSwgaW5WZXJ0ZXhQb2ludFswXSArIHBvaW50c1tpXVswXSwgaW5WZXJ0ZXhQb2ludFsxXSArIHBvaW50c1tpXVsxXSwgaSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluaXRpYXRlRXhwcmVzc2lvbihlbGVtLCBkYXRhLCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHZhbCA9IGRhdGEueDtcclxuICAgIHZhciBuZWVkc1ZlbG9jaXR5ID0gL3ZlbG9jaXR5KD8hW1xcd1xcZF0pLy50ZXN0KHZhbCk7XHJcbiAgICB2YXIgX25lZWRzUmFuZG9tID0gdmFsLmluZGV4T2YoJ3JhbmRvbScpICE9PSAtMTtcclxuICAgIHZhciBlbGVtVHlwZSA9IGVsZW0uZGF0YS50eTtcclxuICAgIHZhciB0cmFuc2Zvcm07XHJcbiAgICB2YXIgJGJtX3RyYW5zZm9ybTtcclxuICAgIHZhciBjb250ZW50O1xyXG4gICAgdmFyIGVmZmVjdDtcclxuICAgIHZhciB0aGlzUHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuICAgIHRoaXNQcm9wZXJ0eS52YWx1ZUF0VGltZSA9IHRoaXNQcm9wZXJ0eS5nZXRWYWx1ZUF0VGltZTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzUHJvcGVydHksICd2YWx1ZScsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNQcm9wZXJ0eS52O1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBlbGVtLmNvbXAuZnJhbWVEdXJhdGlvbiA9IDEgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICBlbGVtLmNvbXAuZGlzcGxheVN0YXJ0VGltZSA9IDA7XHJcbiAgICB2YXIgaW5Qb2ludCA9IGVsZW0uZGF0YS5pcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgIHZhciBvdXRQb2ludCA9IGVsZW0uZGF0YS5vcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgIHZhciB3aWR0aCA9IGVsZW0uZGF0YS5zdyA/IGVsZW0uZGF0YS5zdyA6IDA7XHJcbiAgICB2YXIgaGVpZ2h0ID0gZWxlbS5kYXRhLnNoID8gZWxlbS5kYXRhLnNoIDogMDtcclxuICAgIHZhciBuYW1lID0gZWxlbS5kYXRhLm5tO1xyXG4gICAgdmFyIGxvb3BJbjtcclxuICAgIHZhciBsb29wX2luO1xyXG4gICAgdmFyIGxvb3BPdXQ7XHJcbiAgICB2YXIgbG9vcF9vdXQ7XHJcbiAgICB2YXIgc21vb3RoO1xyXG4gICAgdmFyIHRvV29ybGQ7XHJcbiAgICB2YXIgZnJvbVdvcmxkO1xyXG4gICAgdmFyIGZyb21Db21wO1xyXG4gICAgdmFyIHRvQ29tcDtcclxuICAgIHZhciBmcm9tQ29tcFRvU3VyZmFjZTtcclxuICAgIHZhciBwb3NpdGlvbjtcclxuICAgIHZhciByb3RhdGlvbjtcclxuICAgIHZhciBhbmNob3JQb2ludDtcclxuICAgIHZhciBzY2FsZTtcclxuICAgIHZhciB0aGlzTGF5ZXI7XHJcbiAgICB2YXIgdGhpc0NvbXA7XHJcbiAgICB2YXIgbWFzaztcclxuICAgIHZhciB2YWx1ZUF0VGltZTtcclxuICAgIHZhciB2ZWxvY2l0eUF0VGltZTtcclxuXHJcbiAgICB2YXIgc2NvcGVkX2JtX3J0O1xyXG4gICAgLy8gdmFsID0gdmFsLnJlcGxhY2UoLyhcXFxcP1wifCcpKChodHRwKShzKT8oOlxcLykpP1xcLy4qPyhcXFxcP1wifCcpL2csIFwiXFxcIlxcXCJcIik7IC8vIGRldGVyIHBvdGVudGlhbCBuZXR3b3JrIGNhbGxzXHJcbiAgICB2YXIgZXhwcmVzc2lvbl9mdW5jdGlvbiA9IGV2YWwoJ1tmdW5jdGlvbiBfZXhwcmVzc2lvbl9mdW5jdGlvbigpeycgKyB2YWwgKyAnO3Njb3BlZF9ibV9ydD0kYm1fcnR9XScpWzBdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcclxuICAgIHZhciBudW1LZXlzID0gcHJvcGVydHkua2YgPyBkYXRhLmsubGVuZ3RoIDogMDtcclxuXHJcbiAgICB2YXIgYWN0aXZlID0gIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEuaGQgIT09IHRydWU7XHJcblxyXG4gICAgdmFyIHdpZ2dsZSA9IGZ1bmN0aW9uIHdpZ2dsZShmcmVxLCBhbXApIHtcclxuICAgICAgdmFyIGlXaWdnbGU7XHJcbiAgICAgIHZhciBqO1xyXG4gICAgICB2YXIgbGVuV2lnZ2xlID0gdGhpcy5wdi5sZW5ndGggPyB0aGlzLnB2Lmxlbmd0aCA6IDE7XHJcbiAgICAgIHZhciBhZGRlZEFtcHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuV2lnZ2xlKTtcclxuICAgICAgZnJlcSA9IDU7XHJcbiAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcih0aW1lICogZnJlcSk7XHJcbiAgICAgIGlXaWdnbGUgPSAwO1xyXG4gICAgICBqID0gMDtcclxuICAgICAgd2hpbGUgKGlXaWdnbGUgPCBpdGVyYXRpb25zKSB7XHJcbiAgICAgICAgLy8gdmFyIHJuZCA9IEJNTWF0aC5yYW5kb20oKTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuV2lnZ2xlOyBqICs9IDEpIHtcclxuICAgICAgICAgIGFkZGVkQW1wc1tqXSArPSAtYW1wICsgYW1wICogMiAqIEJNTWF0aC5yYW5kb20oKTtcclxuICAgICAgICAgIC8vIGFkZGVkQW1wc1tqXSArPSAtYW1wICsgYW1wKjIqcm5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpV2lnZ2xlICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgLy8gdmFyIHJuZDIgPSBCTU1hdGgucmFuZG9tKCk7XHJcbiAgICAgIHZhciBwZXJpb2RzID0gdGltZSAqIGZyZXE7XHJcbiAgICAgIHZhciBwZXJjID0gcGVyaW9kcyAtIE1hdGguZmxvb3IocGVyaW9kcyk7XHJcbiAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuV2lnZ2xlKTtcclxuICAgICAgaWYgKGxlbldpZ2dsZSA+IDEpIHtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuV2lnZ2xlOyBqICs9IDEpIHtcclxuICAgICAgICAgIGFycltqXSA9IHRoaXMucHZbal0gKyBhZGRlZEFtcHNbal0gKyAoLWFtcCArIGFtcCAqIDIgKiBCTU1hdGgucmFuZG9tKCkpICogcGVyYztcclxuICAgICAgICAgIC8vIGFycltqXSA9IHRoaXMucHZbal0gKyBhZGRlZEFtcHNbal0gKyAoLWFtcCArIGFtcCoyKnJuZCkqcGVyYztcclxuICAgICAgICAgIC8vIGFycltpXSA9IHRoaXMucHZbaV0gKyBhZGRlZEFtcCArIGFtcDEqcGVyYyArIGFtcDIqKDEtcGVyYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMucHYgKyBhZGRlZEFtcHNbMF0gKyAoLWFtcCArIGFtcCAqIDIgKiBCTU1hdGgucmFuZG9tKCkpICogcGVyYztcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICBpZiAodGhpc1Byb3BlcnR5Lmxvb3BJbikge1xyXG4gICAgICBsb29wSW4gPSB0aGlzUHJvcGVydHkubG9vcEluLmJpbmQodGhpc1Byb3BlcnR5KTtcclxuICAgICAgbG9vcF9pbiA9IGxvb3BJbjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpc1Byb3BlcnR5Lmxvb3BPdXQpIHtcclxuICAgICAgbG9vcE91dCA9IHRoaXNQcm9wZXJ0eS5sb29wT3V0LmJpbmQodGhpc1Byb3BlcnR5KTtcclxuICAgICAgbG9vcF9vdXQgPSBsb29wT3V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzUHJvcGVydHkuc21vb3RoKSB7XHJcbiAgICAgIHNtb290aCA9IHRoaXNQcm9wZXJ0eS5zbW9vdGguYmluZCh0aGlzUHJvcGVydHkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvb3BJbkR1cmF0aW9uKHR5cGUsIGR1cmF0aW9uKSB7XHJcbiAgICAgIHJldHVybiBsb29wSW4odHlwZSwgZHVyYXRpb24sIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvb3BPdXREdXJhdGlvbih0eXBlLCBkdXJhdGlvbikge1xyXG4gICAgICByZXR1cm4gbG9vcE91dCh0eXBlLCBkdXJhdGlvbiwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZ2V0VmFsdWVBdFRpbWUpIHtcclxuICAgICAgdmFsdWVBdFRpbWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZ2V0VmVsb2NpdHlBdFRpbWUpIHtcclxuICAgICAgdmVsb2NpdHlBdFRpbWUgPSB0aGlzLmdldFZlbG9jaXR5QXRUaW1lLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbXAgPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLmJpbmQoZWxlbS5jb21wLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gbG9va0F0KGVsZW0xLCBlbGVtMikge1xyXG4gICAgICB2YXIgZlZlYyA9IFtlbGVtMlswXSAtIGVsZW0xWzBdLCBlbGVtMlsxXSAtIGVsZW0xWzFdLCBlbGVtMlsyXSAtIGVsZW0xWzJdXTtcclxuICAgICAgdmFyIHBpdGNoID0gTWF0aC5hdGFuMihmVmVjWzBdLCBNYXRoLnNxcnQoZlZlY1sxXSAqIGZWZWNbMV0gKyBmVmVjWzJdICogZlZlY1syXSkpIC8gZGVnVG9SYWRzO1xyXG4gICAgICB2YXIgeWF3ID0gLU1hdGguYXRhbjIoZlZlY1sxXSwgZlZlY1syXSkgLyBkZWdUb1JhZHM7XHJcbiAgICAgIHJldHVybiBbeWF3LCBwaXRjaCwgMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZWFzZU91dCh0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XHJcbiAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZU91dEJleiwgdCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZWFzZUluKHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpIHtcclxuICAgICAgcmV0dXJuIGFwcGx5RWFzZShlYXNlSW5CZXosIHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVhc2UodCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMikge1xyXG4gICAgICByZXR1cm4gYXBwbHlFYXNlKGVhc2VJbk91dEJleiwgdCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlFYXNlKGZuLCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XHJcbiAgICAgIGlmICh2YWwxID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YWwxID0gdE1pbjtcclxuICAgICAgICB2YWwyID0gdE1heDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0ID0gKHQgLSB0TWluKSAvICh0TWF4IC0gdE1pbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHQgPiAxKSB7XHJcbiAgICAgICAgdCA9IDE7XHJcbiAgICAgIH0gZWxzZSBpZiAodCA8IDApIHtcclxuICAgICAgICB0ID0gMDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbXVsdCA9IGZuKHQpO1xyXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KHZhbDEpKSB7XHJcbiAgICAgICAgdmFyIGlLZXk7XHJcbiAgICAgICAgdmFyIGxlbktleSA9IHZhbDEubGVuZ3RoO1xyXG4gICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuS2V5KTtcclxuICAgICAgICBmb3IgKGlLZXkgPSAwOyBpS2V5IDwgbGVuS2V5OyBpS2V5ICs9IDEpIHtcclxuICAgICAgICAgIGFycltpS2V5XSA9ICh2YWwyW2lLZXldIC0gdmFsMVtpS2V5XSkgKiBtdWx0ICsgdmFsMVtpS2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKHZhbDIgLSB2YWwxKSAqIG11bHQgKyB2YWwxO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5lYXJlc3RLZXkodGltZSkge1xyXG4gICAgICB2YXIgaUtleTtcclxuICAgICAgdmFyIGxlbktleSA9IGRhdGEuay5sZW5ndGg7XHJcbiAgICAgIHZhciBpbmRleDtcclxuICAgICAgdmFyIGtleVRpbWU7XHJcbiAgICAgIGlmICghZGF0YS5rLmxlbmd0aCB8fCB0eXBlb2YgKGRhdGEua1swXSkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgIGtleVRpbWUgPSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluZGV4ID0gLTE7XHJcbiAgICAgICAgdGltZSAqPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgICAgaWYgKHRpbWUgPCBkYXRhLmtbMF0udCkge1xyXG4gICAgICAgICAgaW5kZXggPSAxO1xyXG4gICAgICAgICAga2V5VGltZSA9IGRhdGEua1swXS50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3IgKGlLZXkgPSAwOyBpS2V5IDwgbGVuS2V5IC0gMTsgaUtleSArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lID09PSBkYXRhLmtbaUtleV0udCkge1xyXG4gICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDE7XHJcbiAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWUgPiBkYXRhLmtbaUtleV0udCAmJiB0aW1lIDwgZGF0YS5rW2lLZXkgKyAxXS50KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRpbWUgLSBkYXRhLmtbaUtleV0udCA+IGRhdGEua1tpS2V5ICsgMV0udCAtIHRpbWUpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDI7XHJcbiAgICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXkgKyAxXS50O1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGlLZXkgKyAxO1xyXG4gICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBpbmRleCA9IGlLZXkgKyAxO1xyXG4gICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXldLnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciBvYktleSA9IHt9O1xyXG4gICAgICBvYktleS5pbmRleCA9IGluZGV4O1xyXG4gICAgICBvYktleS50aW1lID0ga2V5VGltZSAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgICAgcmV0dXJuIG9iS2V5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGtleShpbmQpIHtcclxuICAgICAgdmFyIG9iS2V5O1xyXG4gICAgICB2YXIgaUtleTtcclxuICAgICAgdmFyIGxlbktleTtcclxuICAgICAgaWYgKCFkYXRhLmsubGVuZ3RoIHx8IHR5cGVvZiAoZGF0YS5rWzBdKSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm9wZXJ0eSBoYXMgbm8ga2V5ZnJhbWUgYXQgaW5kZXggJyArIGluZCk7XHJcbiAgICAgIH1cclxuICAgICAgaW5kIC09IDE7XHJcbiAgICAgIG9iS2V5ID0ge1xyXG4gICAgICAgIHRpbWU6IGRhdGEua1tpbmRdLnQgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsXHJcbiAgICAgICAgdmFsdWU6IFtdLFxyXG4gICAgICB9O1xyXG4gICAgICB2YXIgYXJyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEua1tpbmRdLCAncycpID8gZGF0YS5rW2luZF0ucyA6IGRhdGEua1tpbmQgLSAxXS5lO1xyXG5cclxuICAgICAgbGVuS2V5ID0gYXJyLmxlbmd0aDtcclxuICAgICAgZm9yIChpS2V5ID0gMDsgaUtleSA8IGxlbktleTsgaUtleSArPSAxKSB7XHJcbiAgICAgICAgb2JLZXlbaUtleV0gPSBhcnJbaUtleV07XHJcbiAgICAgICAgb2JLZXkudmFsdWVbaUtleV0gPSBhcnJbaUtleV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9iS2V5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZyYW1lc1RvVGltZShmcmFtZXMsIGZwcykge1xyXG4gICAgICBpZiAoIWZwcykge1xyXG4gICAgICAgIGZwcyA9IGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZnJhbWVzIC8gZnBzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRpbWVUb0ZyYW1lcyh0LCBmcHMpIHtcclxuICAgICAgaWYgKCF0ICYmIHQgIT09IDApIHtcclxuICAgICAgICB0ID0gdGltZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWZwcykge1xyXG4gICAgICAgIGZwcyA9IGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdCAqIGZwcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZWVkUmFuZG9tKHNlZWQpIHtcclxuICAgICAgQk1NYXRoLnNlZWRyYW5kb20ocmFuZFNlZWQgKyBzZWVkKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge1xyXG4gICAgICByZXR1cm4gZWxlbS5zb3VyY2VSZWN0QXRUaW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3Vic3RyaW5nKGluaXQsIGVuZCkge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZyhpbml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZyhpbml0LCBlbmQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJzdHIoaW5pdCwgZW5kKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGluaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGluaXQsIGVuZCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBvc3Rlcml6ZVRpbWUoZnJhbWVzUGVyU2Vjb25kKSB7XHJcbiAgICAgIHRpbWUgPSBmcmFtZXNQZXJTZWNvbmQgPT09IDAgPyAwIDogTWF0aC5mbG9vcih0aW1lICogZnJhbWVzUGVyU2Vjb25kKSAvIGZyYW1lc1BlclNlY29uZDtcclxuICAgICAgdmFsdWUgPSB2YWx1ZUF0VGltZSh0aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGltZTtcclxuICAgIHZhciB2ZWxvY2l0eTtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIHZhciB0ZXh0O1xyXG4gICAgdmFyIHRleHRJbmRleDtcclxuICAgIHZhciB0ZXh0VG90YWw7XHJcbiAgICB2YXIgc2VsZWN0b3JWYWx1ZTtcclxuICAgIHZhciBpbmRleCA9IGVsZW0uZGF0YS5pbmQ7XHJcbiAgICB2YXIgaGFzUGFyZW50ID0gISEoZWxlbS5oaWVyYXJjaHkgJiYgZWxlbS5oaWVyYXJjaHkubGVuZ3RoKTtcclxuICAgIHZhciBwYXJlbnQ7XHJcbiAgICB2YXIgcmFuZFNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcclxuICAgIHZhciBnbG9iYWxEYXRhID0gZWxlbS5nbG9iYWxEYXRhO1xyXG4gICAgZnVuY3Rpb24gZXhlY3V0ZUV4cHJlc3Npb24oX3ZhbHVlKSB7XHJcbiAgICAgIC8vIGdsb2JhbERhdGEucHVzaEV4cHJlc3Npb24oKTtcclxuICAgICAgdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgIGlmIChfbmVlZHNSYW5kb20pIHtcclxuICAgICAgICBzZWVkUmFuZG9tKHJhbmRTZWVkKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5mcmFtZUV4cHJlc3Npb25JZCA9PT0gZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgJiYgdGhpcy5wcm9wVHlwZSAhPT0gJ3RleHRTZWxlY3RvcicpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICd0ZXh0U2VsZWN0b3InKSB7XHJcbiAgICAgICAgdGV4dEluZGV4ID0gdGhpcy50ZXh0SW5kZXg7XHJcbiAgICAgICAgdGV4dFRvdGFsID0gdGhpcy50ZXh0VG90YWw7XHJcbiAgICAgICAgc2VsZWN0b3JWYWx1ZSA9IHRoaXMuc2VsZWN0b3JWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXNMYXllcikge1xyXG4gICAgICAgIHRleHQgPSBlbGVtLmxheWVySW50ZXJmYWNlLnRleHQ7XHJcbiAgICAgICAgdGhpc0xheWVyID0gZWxlbS5sYXllckludGVyZmFjZTtcclxuICAgICAgICB0aGlzQ29tcCA9IGVsZW0uY29tcC5jb21wSW50ZXJmYWNlO1xyXG4gICAgICAgIHRvV29ybGQgPSB0aGlzTGF5ZXIudG9Xb3JsZC5iaW5kKHRoaXNMYXllcik7XHJcbiAgICAgICAgZnJvbVdvcmxkID0gdGhpc0xheWVyLmZyb21Xb3JsZC5iaW5kKHRoaXNMYXllcik7XHJcbiAgICAgICAgZnJvbUNvbXAgPSB0aGlzTGF5ZXIuZnJvbUNvbXAuYmluZCh0aGlzTGF5ZXIpO1xyXG4gICAgICAgIHRvQ29tcCA9IHRoaXNMYXllci50b0NvbXAuYmluZCh0aGlzTGF5ZXIpO1xyXG4gICAgICAgIG1hc2sgPSB0aGlzTGF5ZXIubWFzayA/IHRoaXNMYXllci5tYXNrLmJpbmQodGhpc0xheWVyKSA6IG51bGw7XHJcbiAgICAgICAgZnJvbUNvbXBUb1N1cmZhY2UgPSBmcm9tQ29tcDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xyXG4gICAgICAgIHRyYW5zZm9ybSA9IGVsZW0ubGF5ZXJJbnRlcmZhY2UoJ0FEQkUgVHJhbnNmb3JtIEdyb3VwJyk7XHJcbiAgICAgICAgJGJtX3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICBhbmNob3JQb2ludCA9IHRyYW5zZm9ybS5hbmNob3JQb2ludDtcclxuICAgICAgICAgIC8qIHBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gdHJhbnNmb3JtLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlID0gdHJhbnNmb3JtLnNjYWxlOyAqL1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVsZW1UeXBlID09PSA0ICYmICFjb250ZW50KSB7XHJcbiAgICAgICAgY29udGVudCA9IHRoaXNMYXllcignQURCRSBSb290IFZlY3RvcnMgR3JvdXAnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWVmZmVjdCkge1xyXG4gICAgICAgIGVmZmVjdCA9IHRoaXNMYXllcig0KTtcclxuICAgICAgfVxyXG4gICAgICBoYXNQYXJlbnQgPSAhIShlbGVtLmhpZXJhcmNoeSAmJiBlbGVtLmhpZXJhcmNoeS5sZW5ndGgpO1xyXG4gICAgICBpZiAoaGFzUGFyZW50ICYmICFwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQgPSBlbGVtLmhpZXJhcmNoeVswXS5sYXllckludGVyZmFjZTtcclxuICAgICAgfVxyXG4gICAgICB0aW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgIGlmIChuZWVkc1ZlbG9jaXR5KSB7XHJcbiAgICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eUF0VGltZSh0aW1lKTtcclxuICAgICAgfVxyXG4gICAgICBleHByZXNzaW9uX2Z1bmN0aW9uKCk7XHJcbiAgICAgIHRoaXMuZnJhbWVFeHByZXNzaW9uSWQgPSBlbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxuXHJcbiAgICAgIC8vIFRPRE86IENoZWNrIGlmIGl0J3MgcG9zc2libGUgdG8gcmV0dXJuIG9uIFNoYXBlSW50ZXJmYWNlIHRoZSAudiB2YWx1ZVxyXG4gICAgICBpZiAoc2NvcGVkX2JtX3J0LnByb3BUeXBlID09PSAnc2hhcGUnKSB7XHJcbiAgICAgICAgc2NvcGVkX2JtX3J0ID0gc2NvcGVkX2JtX3J0LnY7XHJcbiAgICAgIH1cclxuICAgICAgLy8gZ2xvYmFsRGF0YS5wb3BFeHByZXNzaW9uKCk7XHJcbiAgICAgIHJldHVybiBzY29wZWRfYm1fcnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhlY3V0ZUV4cHJlc3Npb247XHJcbiAgfVxyXG5cclxuICBvYi5pbml0aWF0ZUV4cHJlc3Npb24gPSBpbml0aWF0ZUV4cHJlc3Npb247XHJcbiAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIEV4cHJlc3Npb25NYW5hZ2VyLCBjcmVhdGVUeXBlZEFycmF5ICovXHJcbi8qIGV4cG9ydGVkIGV4cHJlc3Npb25IZWxwZXJzICovXHJcblxyXG52YXIgZXhwcmVzc2lvbkhlbHBlcnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIHNlYXJjaEV4cHJlc3Npb25zKGVsZW0sIGRhdGEsIHByb3ApIHtcclxuICAgIGlmIChkYXRhLngpIHtcclxuICAgICAgcHJvcC5rID0gdHJ1ZTtcclxuICAgICAgcHJvcC54ID0gdHJ1ZTtcclxuICAgICAgcHJvcC5pbml0aWF0ZUV4cHJlc3Npb24gPSBFeHByZXNzaW9uTWFuYWdlci5pbml0aWF0ZUV4cHJlc3Npb247XHJcbiAgICAgIHByb3AuZWZmZWN0c1NlcXVlbmNlLnB1c2gocHJvcC5pbml0aWF0ZUV4cHJlc3Npb24oZWxlbSwgZGF0YSwgcHJvcCkuYmluZChwcm9wKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRWYWx1ZUF0VGltZShmcmFtZU51bSkge1xyXG4gICAgZnJhbWVOdW0gKj0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgZnJhbWVOdW0gLT0gdGhpcy5vZmZzZXRUaW1lO1xyXG4gICAgaWYgKGZyYW1lTnVtICE9PSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSkge1xyXG4gICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA9IHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdEZyYW1lIDwgZnJhbWVOdW0gPyB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA6IDA7XHJcbiAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUudmFsdWUgPSB0aGlzLmludGVycG9sYXRlVmFsdWUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmdBdFRpbWUpO1xyXG4gICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSA9IGZyYW1lTnVtO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hpbmdBdFRpbWUudmFsdWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRTcGVlZEF0VGltZShmcmFtZU51bSkge1xyXG4gICAgdmFyIGRlbHRhID0gLTAuMDE7XHJcbiAgICB2YXIgdjEgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZyYW1lTnVtKTtcclxuICAgIHZhciB2MiA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0gKyBkZWx0YSk7XHJcbiAgICB2YXIgc3BlZWQgPSAwO1xyXG4gICAgaWYgKHYxLmxlbmd0aCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgc3BlZWQgKz0gTWF0aC5wb3codjJbaV0gLSB2MVtpXSwgMik7XHJcbiAgICAgIH1cclxuICAgICAgc3BlZWQgPSBNYXRoLnNxcnQoc3BlZWQpICogMTAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3BlZWQgPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNwZWVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0VmVsb2NpdHlBdFRpbWUoZnJhbWVOdW0pIHtcclxuICAgIGlmICh0aGlzLnZlbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlbDtcclxuICAgIH1cclxuICAgIHZhciBkZWx0YSA9IC0wLjAwMTtcclxuICAgIC8vIGZyYW1lTnVtICs9IHRoaXMuZWxlbS5kYXRhLnN0O1xyXG4gICAgdmFyIHYxID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSk7XHJcbiAgICB2YXIgdjIgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZyYW1lTnVtICsgZGVsdGEpO1xyXG4gICAgdmFyIHZlbG9jaXR5O1xyXG4gICAgaWYgKHYxLmxlbmd0aCkge1xyXG4gICAgICB2ZWxvY2l0eSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCB2MS5sZW5ndGgpO1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgLy8gcmVtb3ZpbmcgZnJhbWVSYXRlXHJcbiAgICAgICAgLy8gaWYgbmVlZGVkLCBkb24ndCBhZGQgaXQgaGVyZVxyXG4gICAgICAgIC8vIHZlbG9jaXR5W2ldID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVSYXRlKigodjJbaV0gLSB2MVtpXSkvZGVsdGEpO1xyXG4gICAgICAgIHZlbG9jaXR5W2ldID0gKHYyW2ldIC0gdjFbaV0pIC8gZGVsdGE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZlbG9jaXR5ID0gKHYyIC0gdjEpIC8gZGVsdGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmVsb2NpdHk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRTdGF0aWNWYWx1ZUF0VGltZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnB2O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0R3JvdXBQcm9wZXJ0eShwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICB0aGlzLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHNlYXJjaEV4cHJlc3Npb25zOiBzZWFyY2hFeHByZXNzaW9ucyxcclxuICAgIGdldFNwZWVkQXRUaW1lOiBnZXRTcGVlZEF0VGltZSxcclxuICAgIGdldFZlbG9jaXR5QXRUaW1lOiBnZXRWZWxvY2l0eUF0VGltZSxcclxuICAgIGdldFZhbHVlQXRUaW1lOiBnZXRWYWx1ZUF0VGltZSxcclxuICAgIGdldFN0YXRpY1ZhbHVlQXRUaW1lOiBnZXRTdGF0aWNWYWx1ZUF0VGltZSxcclxuICAgIHNldEdyb3VwUHJvcGVydHk6IHNldEdyb3VwUHJvcGVydHksXHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBjcmVhdGVUeXBlZEFycmF5LCBNYXRyaXgsIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSwgZXhwcmVzc2lvbkhlbHBlcnMsIFByb3BlcnR5RmFjdG9yeSwgZXhwcmVzc2lvbkhlbHBlcnMsXHJcbmluaXRpYWxEZWZhdWx0RnJhbWUsIHNoYXBlUG9vbCwgU2hhcGVQcm9wZXJ0eUZhY3RvcnksIGJleiwgZXh0ZW5kUHJvdG90eXBlLCBFeHByZXNzaW9uTWFuYWdlciwgY3JlYXRlU2l6ZWRBcnJheSAqL1xyXG5cclxuKGZ1bmN0aW9uIGFkZFByb3BlcnR5RGVjb3JhdG9yKCkge1xyXG4gIGZ1bmN0aW9uIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIGR1cmF0aW9uRmxhZykge1xyXG4gICAgaWYgKCF0aGlzLmsgfHwgIXRoaXMua2V5ZnJhbWVzKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB2O1xyXG4gICAgfVxyXG4gICAgdHlwZSA9IHR5cGUgPyB0eXBlLnRvTG93ZXJDYXNlKCkgOiAnJztcclxuICAgIHZhciBjdXJyZW50RnJhbWUgPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZTtcclxuICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcclxuICAgIHZhciBsYXN0S2V5RnJhbWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQ7XHJcbiAgICBpZiAoY3VycmVudEZyYW1lIDw9IGxhc3RLZXlGcmFtZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdjtcclxuICAgIH1cclxuICAgIHZhciBjeWNsZUR1cmF0aW9uO1xyXG4gICAgdmFyIGZpcnN0S2V5RnJhbWU7XHJcbiAgICBpZiAoIWR1cmF0aW9uRmxhZykge1xyXG4gICAgICBpZiAoIWR1cmF0aW9uIHx8IGR1cmF0aW9uID4ga2V5ZnJhbWVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICBkdXJhdGlvbiA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGZpcnN0S2V5RnJhbWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDEgLSBkdXJhdGlvbl0udDtcclxuICAgICAgY3ljbGVEdXJhdGlvbiA9IGxhc3RLZXlGcmFtZSAtIGZpcnN0S2V5RnJhbWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoIWR1cmF0aW9uKSB7XHJcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGgubWF4KDAsIGxhc3RLZXlGcmFtZSAtIHRoaXMuZWxlbS5kYXRhLmlwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5hYnMobGFzdEtleUZyYW1lIC0gdGhpcy5lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgKiBkdXJhdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgZmlyc3RLZXlGcmFtZSA9IGxhc3RLZXlGcmFtZSAtIGN5Y2xlRHVyYXRpb247XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW47XHJcbiAgICB2YXIgcmV0O1xyXG4gICAgaWYgKHR5cGUgPT09ICdwaW5ncG9uZycpIHtcclxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xyXG4gICAgICBpZiAoaXRlcmF0aW9ucyAlIDIgIT09IDApIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKCgoY3ljbGVEdXJhdGlvbiAtIChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29mZnNldCcpIHtcclxuICAgICAgdmFyIGluaXRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmaXJzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgdmFyIGVuZFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGxhc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKCgoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgIHZhciByZXBlYXRzID0gTWF0aC5mbG9vcigoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKTtcclxuICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KGluaXRWLmxlbmd0aCk7XHJcbiAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgIHJldFtpXSA9IChlbmRWW2ldIC0gaW5pdFZbaV0pICogcmVwZWF0cyArIGN1cnJlbnRbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChlbmRWIC0gaW5pdFYpICogcmVwZWF0cyArIGN1cnJlbnQ7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb250aW51ZScpIHtcclxuICAgICAgdmFyIGxhc3RWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgdmFyIG5leHRMYXN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChsYXN0S2V5RnJhbWUgLSAwLjAwMSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkobGFzdFZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gbGFzdFZhbHVlW2ldICsgKGxhc3RWYWx1ZVtpXSAtIG5leHRMYXN0VmFsdWVbaV0pICogKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlKSAvIDAuMDAwNTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsYXN0VmFsdWUgKyAobGFzdFZhbHVlIC0gbmV4dExhc3RWYWx1ZSkgKiAoKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpKSAvIDAuMDAxKTtcclxuICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKCgoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxvb3BJbih0eXBlLCBkdXJhdGlvbiwgZHVyYXRpb25GbGFnKSB7XHJcbiAgICBpZiAoIXRoaXMuaykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdjtcclxuICAgIH1cclxuICAgIHR5cGUgPSB0eXBlID8gdHlwZS50b0xvd2VyQ2FzZSgpIDogJyc7XHJcbiAgICB2YXIgY3VycmVudEZyYW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWU7XHJcbiAgICB2YXIga2V5ZnJhbWVzID0gdGhpcy5rZXlmcmFtZXM7XHJcbiAgICB2YXIgZmlyc3RLZXlGcmFtZSA9IGtleWZyYW1lc1swXS50O1xyXG4gICAgaWYgKGN1cnJlbnRGcmFtZSA+PSBmaXJzdEtleUZyYW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB2O1xyXG4gICAgfVxyXG4gICAgdmFyIGN5Y2xlRHVyYXRpb247XHJcbiAgICB2YXIgbGFzdEtleUZyYW1lO1xyXG4gICAgaWYgKCFkdXJhdGlvbkZsYWcpIHtcclxuICAgICAgaWYgKCFkdXJhdGlvbiB8fCBkdXJhdGlvbiA+IGtleWZyYW1lcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgZHVyYXRpb24gPSBrZXlmcmFtZXMubGVuZ3RoIC0gMTtcclxuICAgICAgfVxyXG4gICAgICBsYXN0S2V5RnJhbWUgPSBrZXlmcmFtZXNbZHVyYXRpb25dLnQ7XHJcbiAgICAgIGN5Y2xlRHVyYXRpb24gPSBsYXN0S2V5RnJhbWUgLSBmaXJzdEtleUZyYW1lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCFkdXJhdGlvbikge1xyXG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBNYXRoLm1heCgwLCB0aGlzLmVsZW0uZGF0YS5vcCAtIGZpcnN0S2V5RnJhbWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBNYXRoLmFicyh0aGlzLmVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSAqIGR1cmF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBsYXN0S2V5RnJhbWUgPSBmaXJzdEtleUZyYW1lICsgY3ljbGVEdXJhdGlvbjtcclxuICAgIH1cclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbjtcclxuICAgIHZhciByZXQ7XHJcbiAgICBpZiAodHlwZSA9PT0gJ3Bpbmdwb25nJykge1xyXG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IE1hdGguZmxvb3IoKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpIC8gY3ljbGVEdXJhdGlvbik7XHJcbiAgICAgIGlmIChpdGVyYXRpb25zICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKCgoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZmZzZXQnKSB7XHJcbiAgICAgIHZhciBpbml0ViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZmlyc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgIHZhciBlbmRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShsYXN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoKGN5Y2xlRHVyYXRpb24gLSAoKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpICUgY3ljbGVEdXJhdGlvbikgKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgIHZhciByZXBlYXRzID0gTWF0aC5mbG9vcigoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKSArIDE7XHJcbiAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShpbml0Vi5sZW5ndGgpO1xyXG4gICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICByZXRbaV0gPSBjdXJyZW50W2ldIC0gKGVuZFZbaV0gLSBpbml0VltpXSkgKiByZXBlYXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjdXJyZW50IC0gKGVuZFYgLSBpbml0VikgKiByZXBlYXRzO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29udGludWUnKSB7XHJcbiAgICAgIHZhciBmaXJzdFZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmaXJzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgdmFyIG5leHRGaXJzdFZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgoZmlyc3RLZXlGcmFtZSArIDAuMDAxKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShmaXJzdFZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgIHJldFtpXSA9IGZpcnN0VmFsdWVbaV0gKyAoKGZpcnN0VmFsdWVbaV0gLSBuZXh0Rmlyc3RWYWx1ZVtpXSkgKiAoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkpIC8gMC4wMDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZpcnN0VmFsdWUgKyAoKGZpcnN0VmFsdWUgLSBuZXh0Rmlyc3RWYWx1ZSkgKiAoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkpIC8gMC4wMDE7XHJcbiAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKCgoY3ljbGVEdXJhdGlvbiAtICgoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkpKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzbW9vdGgod2lkdGgsIHNhbXBsZXMpIHtcclxuICAgIGlmICghdGhpcy5rKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB2O1xyXG4gICAgfVxyXG4gICAgd2lkdGggPSAod2lkdGggfHwgMC40KSAqIDAuNTtcclxuICAgIHNhbXBsZXMgPSBNYXRoLmZsb29yKHNhbXBsZXMgfHwgNSk7XHJcbiAgICBpZiAoc2FtcGxlcyA8PSAxKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB2O1xyXG4gICAgfVxyXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICB2YXIgaW5pdEZyYW1lID0gY3VycmVudFRpbWUgLSB3aWR0aDtcclxuICAgIHZhciBlbmRGcmFtZSA9IGN1cnJlbnRUaW1lICsgd2lkdGg7XHJcbiAgICB2YXIgc2FtcGxlRnJlcXVlbmN5ID0gc2FtcGxlcyA+IDEgPyAoZW5kRnJhbWUgLSBpbml0RnJhbWUpIC8gKHNhbXBsZXMgLSAxKSA6IDE7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgaiA9IDA7XHJcbiAgICB2YXIgdmFsdWU7XHJcbiAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcclxuICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgdGhpcy5wdi5sZW5ndGgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsdWUgPSAwO1xyXG4gICAgfVxyXG4gICAgdmFyIHNhbXBsZVZhbHVlO1xyXG4gICAgd2hpbGUgKGkgPCBzYW1wbGVzKSB7XHJcbiAgICAgIHNhbXBsZVZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZShpbml0RnJhbWUgKyBpICogc2FtcGxlRnJlcXVlbmN5KTtcclxuICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMucHYubGVuZ3RoOyBqICs9IDEpIHtcclxuICAgICAgICAgIHZhbHVlW2pdICs9IHNhbXBsZVZhbHVlW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YWx1ZSArPSBzYW1wbGVWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcclxuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMucHYubGVuZ3RoOyBqICs9IDEpIHtcclxuICAgICAgICB2YWx1ZVtqXSAvPSBzYW1wbGVzO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWx1ZSAvPSBzYW1wbGVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVmFsdWVBdFRpbWUodGltZSkge1xyXG4gICAgaWYgKCF0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lKSB7XHJcbiAgICAgIHRoaXMuX3RyYW5zZm9ybUNhY2hpbmdBdFRpbWUgPSB7XHJcbiAgICAgICAgdjogbmV3IE1hdHJpeCgpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8vIC9cclxuICAgIHZhciBtYXRyaXggPSB0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lLnY7XHJcbiAgICBtYXRyaXguY2xvbmVGcm9tUHJvcHModGhpcy5wcmUucHJvcHMpO1xyXG4gICAgaWYgKHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDEpIHtcclxuICAgICAgdmFyIGFuY2hvciA9IHRoaXMuYS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcclxuICAgICAgbWF0cml4LnRyYW5zbGF0ZShcclxuICAgICAgICAtYW5jaG9yWzBdICogdGhpcy5hLm11bHQsXHJcbiAgICAgICAgLWFuY2hvclsxXSAqIHRoaXMuYS5tdWx0LFxyXG4gICAgICAgIGFuY2hvclsyXSAqIHRoaXMuYS5tdWx0XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMikge1xyXG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnMuZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIG1hdHJpeC5zY2FsZShcclxuICAgICAgICBzY2FsZVswXSAqIHRoaXMucy5tdWx0LFxyXG4gICAgICAgIHNjYWxlWzFdICogdGhpcy5zLm11bHQsXHJcbiAgICAgICAgc2NhbGVbMl0gKiB0aGlzLnMubXVsdFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuc2sgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMykge1xyXG4gICAgICB2YXIgc2tldyA9IHRoaXMuc2suZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIHZhciBza2V3QXhpcyA9IHRoaXMuc2EuZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIG1hdHJpeC5za2V3RnJvbUF4aXMoLXNrZXcgKiB0aGlzLnNrLm11bHQsIHNrZXdBeGlzICogdGhpcy5zYS5tdWx0KTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnIgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgNCkge1xyXG4gICAgICB2YXIgcm90YXRpb24gPSB0aGlzLnIuZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIG1hdHJpeC5yb3RhdGUoLXJvdGF0aW9uICogdGhpcy5yLm11bHQpO1xyXG4gICAgfSBlbHNlIGlmICghdGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcclxuICAgICAgdmFyIHJvdGF0aW9uWiA9IHRoaXMucnouZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIHZhciByb3RhdGlvblkgPSB0aGlzLnJ5LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xyXG4gICAgICB2YXIgcm90YXRpb25YID0gdGhpcy5yeC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcclxuICAgICAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vci5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcclxuICAgICAgbWF0cml4LnJvdGF0ZVooLXJvdGF0aW9uWiAqIHRoaXMucnoubXVsdClcclxuICAgICAgICAucm90YXRlWShyb3RhdGlvblkgKiB0aGlzLnJ5Lm11bHQpXHJcbiAgICAgICAgLnJvdGF0ZVgocm90YXRpb25YICogdGhpcy5yeC5tdWx0KVxyXG4gICAgICAgIC5yb3RhdGVaKC1vcmllbnRhdGlvblsyXSAqIHRoaXMub3IubXVsdClcclxuICAgICAgICAucm90YXRlWShvcmllbnRhdGlvblsxXSAqIHRoaXMub3IubXVsdClcclxuICAgICAgICAucm90YXRlWChvcmllbnRhdGlvblswXSAqIHRoaXMub3IubXVsdCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5kYXRhLnAgJiYgdGhpcy5kYXRhLnAucykge1xyXG4gICAgICB2YXIgcG9zaXRpb25YID0gdGhpcy5weC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcclxuICAgICAgdmFyIHBvc2l0aW9uWSA9IHRoaXMucHkuZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIGlmICh0aGlzLmRhdGEucC56KSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uWiA9IHRoaXMucHouZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShcclxuICAgICAgICAgIHBvc2l0aW9uWCAqIHRoaXMucHgubXVsdCxcclxuICAgICAgICAgIHBvc2l0aW9uWSAqIHRoaXMucHkubXVsdCxcclxuICAgICAgICAgIC1wb3NpdGlvblogKiB0aGlzLnB6Lm11bHRcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUocG9zaXRpb25YICogdGhpcy5weC5tdWx0LCBwb3NpdGlvblkgKiB0aGlzLnB5Lm11bHQsIDApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUodGltZSk7XHJcbiAgICAgIG1hdHJpeC50cmFuc2xhdGUoXHJcbiAgICAgICAgcG9zaXRpb25bMF0gKiB0aGlzLnAubXVsdCxcclxuICAgICAgICBwb3NpdGlvblsxXSAqIHRoaXMucC5tdWx0LFxyXG4gICAgICAgIC1wb3NpdGlvblsyXSAqIHRoaXMucC5tdWx0XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgLy8vIC9cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVN0YXRpY1ZhbHVlQXRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudi5jbG9uZShuZXcgTWF0cml4KCkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGdldFRyYW5zZm9ybVByb3BlcnR5ID0gVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5O1xyXG4gIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCBjb250YWluZXIpIHtcclxuICAgIHZhciBwcm9wID0gZ2V0VHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKTtcclxuICAgIGlmIChwcm9wLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZ2V0VHJhbnNmb3JtVmFsdWVBdFRpbWUuYmluZChwcm9wKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xyXG4gICAgfVxyXG4gICAgcHJvcC5zZXRHcm91cFByb3BlcnR5ID0gZXhwcmVzc2lvbkhlbHBlcnMuc2V0R3JvdXBQcm9wZXJ0eTtcclxuICAgIHJldHVybiBwcm9wO1xyXG4gIH07XHJcblxyXG4gIHZhciBwcm9wZXJ0eUdldFByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcDtcclxuICBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCB0eXBlLCBtdWx0LCBjb250YWluZXIpIHtcclxuICAgIHZhciBwcm9wID0gcHJvcGVydHlHZXRQcm9wKGVsZW0sIGRhdGEsIHR5cGUsIG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICAvLyBwcm9wLmdldFZlbG9jaXR5QXRUaW1lID0gZ2V0VmVsb2NpdHlBdFRpbWU7XHJcbiAgICAvLyBwcm9wLmxvb3BPdXQgPSBsb29wT3V0O1xyXG4gICAgLy8gcHJvcC5sb29wSW4gPSBsb29wSW47XHJcbiAgICBpZiAocHJvcC5rZikge1xyXG4gICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0VmFsdWVBdFRpbWUuYmluZChwcm9wKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRTdGF0aWNWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xyXG4gICAgfVxyXG4gICAgcHJvcC5zZXRHcm91cFByb3BlcnR5ID0gZXhwcmVzc2lvbkhlbHBlcnMuc2V0R3JvdXBQcm9wZXJ0eTtcclxuICAgIHByb3AubG9vcE91dCA9IGxvb3BPdXQ7XHJcbiAgICBwcm9wLmxvb3BJbiA9IGxvb3BJbjtcclxuICAgIHByb3Auc21vb3RoID0gc21vb3RoO1xyXG4gICAgcHJvcC5nZXRWZWxvY2l0eUF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFZlbG9jaXR5QXRUaW1lLmJpbmQocHJvcCk7XHJcbiAgICBwcm9wLmdldFNwZWVkQXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0U3BlZWRBdFRpbWUuYmluZChwcm9wKTtcclxuICAgIHByb3AubnVtS2V5cyA9IGRhdGEuYSA9PT0gMSA/IGRhdGEuay5sZW5ndGggOiAwO1xyXG4gICAgcHJvcC5wcm9wZXJ0eUluZGV4ID0gZGF0YS5peDtcclxuICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICBpZiAodHlwZSAhPT0gMCkge1xyXG4gICAgICB2YWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkYXRhLmEgPT09IDEgPyBkYXRhLmtbMF0ucy5sZW5ndGggOiBkYXRhLmsubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHByb3AuX2NhY2hpbmdBdFRpbWUgPSB7XHJcbiAgICAgIGxhc3RGcmFtZTogaW5pdGlhbERlZmF1bHRGcmFtZSxcclxuICAgICAgbGFzdEluZGV4OiAwLFxyXG4gICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICB9O1xyXG4gICAgZXhwcmVzc2lvbkhlbHBlcnMuc2VhcmNoRXhwcmVzc2lvbnMoZWxlbSwgZGF0YSwgcHJvcCk7XHJcbiAgICBpZiAocHJvcC5rKSB7XHJcbiAgICAgIGNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByb3A7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0U2hhcGVWYWx1ZUF0VGltZShmcmFtZU51bSkge1xyXG4gICAgLy8gRm9yIG5vdyB0aGlzIGNhY2hpbmcgb2JqZWN0IGlzIGNyZWF0ZWQgb25seSB3aGVuIG5lZWRlZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGl0IHdoZW4gdGhlIHNoYXBlIGlzIGluaXRpYWxpemVkLlxyXG4gICAgaWYgKCF0aGlzLl9jYWNoaW5nQXRUaW1lKSB7XHJcbiAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUgPSB7XHJcbiAgICAgICAgc2hhcGVWYWx1ZTogc2hhcGVQb29sLmNsb25lKHRoaXMucHYpLFxyXG4gICAgICAgIGxhc3RJbmRleDogMCxcclxuICAgICAgICBsYXN0VGltZTogaW5pdGlhbERlZmF1bHRGcmFtZSxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmcmFtZU51bSAqPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICBmcmFtZU51bSAtPSB0aGlzLm9mZnNldFRpbWU7XHJcbiAgICBpZiAoZnJhbWVOdW0gIT09IHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdFRpbWUpIHtcclxuICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggPSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RUaW1lIDwgZnJhbWVOdW0gPyB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA6IDA7XHJcbiAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdFRpbWUgPSBmcmFtZU51bTtcclxuICAgICAgdGhpcy5pbnRlcnBvbGF0ZVNoYXBlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nQXRUaW1lLnNoYXBlVmFsdWUsIHRoaXMuX2NhY2hpbmdBdFRpbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hpbmdBdFRpbWUuc2hhcGVWYWx1ZTtcclxuICB9XHJcblxyXG4gIHZhciBTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbiA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldENvbnN0cnVjdG9yRnVuY3Rpb24oKTtcclxuICB2YXIgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24gPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uKCk7XHJcblxyXG4gIGZ1bmN0aW9uIFNoYXBlRXhwcmVzc2lvbnMoKSB7fVxyXG4gIFNoYXBlRXhwcmVzc2lvbnMucHJvdG90eXBlID0ge1xyXG4gICAgdmVydGljZXM6IGZ1bmN0aW9uIChwcm9wLCB0aW1lKSB7XHJcbiAgICAgIGlmICh0aGlzLmspIHtcclxuICAgICAgICB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHNoYXBlUGF0aCA9IHRoaXMudjtcclxuICAgICAgaWYgKHRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNoYXBlUGF0aCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSBzaGFwZVBhdGguX2xlbmd0aDtcclxuICAgICAgdmFyIHZlcnRpY2VzID0gc2hhcGVQYXRoW3Byb3BdO1xyXG4gICAgICB2YXIgcG9pbnRzID0gc2hhcGVQYXRoLnY7XHJcbiAgICAgIHZhciBhcnIgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIGlmIChwcm9wID09PSAnaScgfHwgcHJvcCA9PT0gJ28nKSB7XHJcbiAgICAgICAgICBhcnJbaV0gPSBbdmVydGljZXNbaV1bMF0gLSBwb2ludHNbaV1bMF0sIHZlcnRpY2VzW2ldWzFdIC0gcG9pbnRzW2ldWzFdXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYXJyW2ldID0gW3ZlcnRpY2VzW2ldWzBdLCB2ZXJ0aWNlc1tpXVsxXV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9LFxyXG4gICAgcG9pbnRzOiBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcygndicsIHRpbWUpO1xyXG4gICAgfSxcclxuICAgIGluVGFuZ2VudHM6IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCdpJywgdGltZSk7XHJcbiAgICB9LFxyXG4gICAgb3V0VGFuZ2VudHM6IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCdvJywgdGltZSk7XHJcbiAgICB9LFxyXG4gICAgaXNDbG9zZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudi5jO1xyXG4gICAgfSxcclxuICAgIHBvaW50T25QYXRoOiBmdW5jdGlvbiAocGVyYywgdGltZSkge1xyXG4gICAgICB2YXIgc2hhcGVQYXRoID0gdGhpcy52O1xyXG4gICAgICBpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2hhcGVQYXRoID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lLCAwKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXMuX3NlZ21lbnRzTGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5fc2VnbWVudHNMZW5ndGggPSBiZXouZ2V0U2VnbWVudHNMZW5ndGgoc2hhcGVQYXRoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNlZ21lbnRzTGVuZ3RoID0gdGhpcy5fc2VnbWVudHNMZW5ndGg7XHJcbiAgICAgIHZhciBsZW5ndGhzID0gc2VnbWVudHNMZW5ndGgubGVuZ3RocztcclxuICAgICAgdmFyIGxlbmd0aFBvcyA9IHNlZ21lbnRzTGVuZ3RoLnRvdGFsTGVuZ3RoICogcGVyYztcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbGVuID0gbGVuZ3Rocy5sZW5ndGg7XHJcbiAgICAgIHZhciBhY2N1bXVsYXRlZExlbmd0aCA9IDA7XHJcbiAgICAgIHZhciBwdDtcclxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBpZiAoYWNjdW11bGF0ZWRMZW5ndGggKyBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoID4gbGVuZ3RoUG9zKSB7XHJcbiAgICAgICAgICB2YXIgaW5pdEluZGV4ID0gaTtcclxuICAgICAgICAgIHZhciBlbmRJbmRleCA9IChzaGFwZVBhdGguYyAmJiBpID09PSBsZW4gLSAxKSA/IDAgOiBpICsgMTtcclxuICAgICAgICAgIHZhciBzZWdtZW50UGVyYyA9IChsZW5ndGhQb3MgLSBhY2N1bXVsYXRlZExlbmd0aCkgLyBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoO1xyXG4gICAgICAgICAgcHQgPSBiZXouZ2V0UG9pbnRJblNlZ21lbnQoc2hhcGVQYXRoLnZbaW5pdEluZGV4XSwgc2hhcGVQYXRoLnZbZW5kSW5kZXhdLCBzaGFwZVBhdGgub1tpbml0SW5kZXhdLCBzaGFwZVBhdGguaVtlbmRJbmRleF0sIHNlZ21lbnRQZXJjLCBsZW5ndGhzW2ldKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhY2N1bXVsYXRlZExlbmd0aCArPSBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFwdCkge1xyXG4gICAgICAgIHB0ID0gc2hhcGVQYXRoLmMgPyBbc2hhcGVQYXRoLnZbMF1bMF0sIHNoYXBlUGF0aC52WzBdWzFdXSA6IFtzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzBdLCBzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzFdXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcHQ7XHJcbiAgICB9LFxyXG4gICAgdmVjdG9yT25QYXRoOiBmdW5jdGlvbiAocGVyYywgdGltZSwgdmVjdG9yVHlwZSkge1xyXG4gICAgICAvLyBwZXJjIGRvZXNuJ3QgdXNlIHRyaXBsZSBlcXVhbGl0eSBiZWNhdXNlIGl0IGNhbiBiZSBhIE51bWJlciBvYmplY3QgYXMgd2VsbCBhcyBhIHByaW1pdGl2ZS5cclxuICAgICAgaWYgKHBlcmMgPT0gMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxyXG4gICAgICAgIHBlcmMgPSB0aGlzLnYuYztcclxuICAgICAgfSBlbHNlIGlmIChwZXJjID09IDApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcclxuICAgICAgICBwZXJjID0gMC45OTk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHB0MSA9IHRoaXMucG9pbnRPblBhdGgocGVyYywgdGltZSk7XHJcbiAgICAgIHZhciBwdDIgPSB0aGlzLnBvaW50T25QYXRoKHBlcmMgKyAwLjAwMSwgdGltZSk7XHJcbiAgICAgIHZhciB4TGVuZ3RoID0gcHQyWzBdIC0gcHQxWzBdO1xyXG4gICAgICB2YXIgeUxlbmd0aCA9IHB0MlsxXSAtIHB0MVsxXTtcclxuICAgICAgdmFyIG1hZ25pdHVkZSA9IE1hdGguc3FydChNYXRoLnBvdyh4TGVuZ3RoLCAyKSArIE1hdGgucG93KHlMZW5ndGgsIDIpKTtcclxuICAgICAgaWYgKG1hZ25pdHVkZSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBbMCwgMF07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHVuaXRWZWN0b3IgPSB2ZWN0b3JUeXBlID09PSAndGFuZ2VudCcgPyBbeExlbmd0aCAvIG1hZ25pdHVkZSwgeUxlbmd0aCAvIG1hZ25pdHVkZV0gOiBbLXlMZW5ndGggLyBtYWduaXR1ZGUsIHhMZW5ndGggLyBtYWduaXR1ZGVdO1xyXG4gICAgICByZXR1cm4gdW5pdFZlY3RvcjtcclxuICAgIH0sXHJcbiAgICB0YW5nZW50T25QYXRoOiBmdW5jdGlvbiAocGVyYywgdGltZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JPblBhdGgocGVyYywgdGltZSwgJ3RhbmdlbnQnKTtcclxuICAgIH0sXHJcbiAgICBub3JtYWxPblBhdGg6IGZ1bmN0aW9uIChwZXJjLCB0aW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3Rvck9uUGF0aChwZXJjLCB0aW1lLCAnbm9ybWFsJyk7XHJcbiAgICB9LFxyXG4gICAgc2V0R3JvdXBQcm9wZXJ0eTogZXhwcmVzc2lvbkhlbHBlcnMuc2V0R3JvdXBQcm9wZXJ0eSxcclxuICAgIGdldFZhbHVlQXRUaW1lOiBleHByZXNzaW9uSGVscGVycy5nZXRTdGF0aWNWYWx1ZUF0VGltZSxcclxuICB9O1xyXG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVFeHByZXNzaW9uc10sIFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uKTtcclxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlRXhwcmVzc2lvbnNdLCBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbik7XHJcbiAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24ucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZ2V0U2hhcGVWYWx1ZUF0VGltZTtcclxuICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbi5wcm90b3R5cGUuaW5pdGlhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uO1xyXG5cclxuICB2YXIgcHJvcGVydHlHZXRTaGFwZVByb3AgPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3A7XHJcbiAgU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIHR5cGUsIGFyciwgdHJpbXMpIHtcclxuICAgIHZhciBwcm9wID0gcHJvcGVydHlHZXRTaGFwZVByb3AoZWxlbSwgZGF0YSwgdHlwZSwgYXJyLCB0cmltcyk7XHJcbiAgICBwcm9wLnByb3BlcnR5SW5kZXggPSBkYXRhLml4O1xyXG4gICAgcHJvcC5sb2NrID0gZmFsc2U7XHJcbiAgICBpZiAodHlwZSA9PT0gMykge1xyXG4gICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLnB0LCBwcm9wKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xyXG4gICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLmtzLCBwcm9wKTtcclxuICAgIH1cclxuICAgIGlmIChwcm9wLmspIHtcclxuICAgICAgZWxlbS5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcDtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIEV4cHJlc3Npb25NYW5hZ2VyLCBUZXh0UHJvcGVydHkgKi9cclxuXHJcbihmdW5jdGlvbiBhZGREZWNvcmF0b3IoKSB7XHJcbiAgZnVuY3Rpb24gc2VhcmNoRXhwcmVzc2lvbnMoKSB7XHJcbiAgICBpZiAodGhpcy5kYXRhLmQueCkge1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZUV4cHJlc3Npb24gPSBFeHByZXNzaW9uTWFuYWdlci5pbml0aWF0ZUV4cHJlc3Npb24uYmluZCh0aGlzKSh0aGlzLmVsZW0sIHRoaXMuZGF0YS5kLCB0aGlzKTtcclxuICAgICAgdGhpcy5hZGRFZmZlY3QodGhpcy5nZXRFeHByZXNzaW9uVmFsdWUuYmluZCh0aGlzKSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmdldEV4cHJlc3Npb25WYWx1ZSA9IGZ1bmN0aW9uIChjdXJyZW50VmFsdWUsIHRleHQpIHtcclxuICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY2FsY3VsYXRlRXhwcmVzc2lvbih0ZXh0KTtcclxuICAgIGlmIChjdXJyZW50VmFsdWUudCAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcclxuICAgICAgdGhpcy5jb3B5RGF0YShuZXdEYXRhLCBjdXJyZW50VmFsdWUpO1xyXG4gICAgICBuZXdEYXRhLnQgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICBuZXdEYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuIG5ld0RhdGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudFZhbHVlO1xyXG4gIH07XHJcblxyXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaXNLZXlmcmFtZWQgPSB0aGlzLnNlYXJjaEtleWZyYW1lcygpO1xyXG4gICAgdmFyIGhhc0V4cHJlc3Npb25zID0gdGhpcy5zZWFyY2hFeHByZXNzaW9ucygpO1xyXG4gICAgdGhpcy5rZiA9IGlzS2V5ZnJhbWVkIHx8IGhhc0V4cHJlc3Npb25zO1xyXG4gICAgcmV0dXJuIHRoaXMua2Y7XHJcbiAgfTtcclxuXHJcbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hFeHByZXNzaW9ucyA9IHNlYXJjaEV4cHJlc3Npb25zO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIHByb3BlcnR5R3JvdXBGYWN0b3J5LCBQcm9wZXJ0eUludGVyZmFjZSAqL1xyXG4vKiBleHBvcnRlZCBTaGFwZVBhdGhJbnRlcmZhY2UgKi9cclxuXHJcbnZhciBTaGFwZVBhdGhJbnRlcmZhY2UgPSAoXHJcblxyXG4gIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwYXRoSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xyXG4gICAgICB2YXIgcHJvcCA9IHZpZXcuc2g7XHJcblxyXG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcclxuICAgICAgICBpZiAodmFsID09PSAnU2hhcGUnIHx8IHZhbCA9PT0gJ3NoYXBlJyB8fCB2YWwgPT09ICdQYXRoJyB8fCB2YWwgPT09ICdwYXRoJyB8fCB2YWwgPT09ICdBREJFIFZlY3RvciBTaGFwZScgfHwgdmFsID09PSAyKSB7XHJcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcclxuICAgICAgcHJvcC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdQYXRoJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgICBwYXRoOiB7XHJcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHByb3Auaykge1xyXG4gICAgICAgICAgICAgIHByb3AuZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wLmspIHtcclxuICAgICAgICAgICAgICBwcm9wLmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX25hbWU6IHsgdmFsdWU6IHNoYXBlLm5tIH0sXHJcbiAgICAgICAgaXg6IHsgdmFsdWU6IHNoYXBlLml4IH0sXHJcbiAgICAgICAgcHJvcGVydHlJbmRleDogeyB2YWx1ZTogc2hhcGUuaXggfSxcclxuICAgICAgICBtbjogeyB2YWx1ZTogc2hhcGUubW4gfSxcclxuICAgICAgICBwcm9wZXJ0eUdyb3VwOiB7IHZhbHVlOiBwcm9wZXJ0eUdyb3VwIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgICB9O1xyXG4gIH0oKVxyXG4pO1xyXG5cclxuLyogZXhwb3J0ZWQgcHJvcGVydHlHcm91cEZhY3RvcnkgKi9cclxuXHJcbnZhciBwcm9wZXJ0eUdyb3VwRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbnRlcmZhY2VGdW5jdGlvbiwgcGFyZW50UHJvcGVydHlHcm91cCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyAxIDogdmFsO1xyXG4gICAgICBpZiAodmFsIDw9IDApIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhcmVudFByb3BlcnR5R3JvdXAodmFsIC0gMSk7XHJcbiAgICB9O1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBleHBvcnRlZCBQcm9wZXJ0eUludGVyZmFjZSAqL1xyXG5cclxudmFyIFByb3BlcnR5SW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgcHJvcGVydHlHcm91cCkge1xyXG4gICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0ge1xyXG4gICAgICBfbmFtZTogcHJvcGVydHlOYW1lLFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfcHJvcGVydHlHcm91cCh2YWwpIHtcclxuICAgICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyAxIDogdmFsO1xyXG4gICAgICBpZiAodmFsIDw9IDApIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXAodmFsIC0gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9wcm9wZXJ0eUdyb3VwO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBnbG9iYWwgRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlLCBQcm9wZXJ0eUludGVyZmFjZSwgcHJvcGVydHlHcm91cEZhY3RvcnksIFNoYXBlUGF0aEludGVyZmFjZSAqL1xyXG4vKiBleHBvcnRlZCBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UgKi9cclxuXHJcbnZhciBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIGl0ZXJhdGVFbGVtZW50cyhzaGFwZXMsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIHZhciBhcnIgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbiA9IHNoYXBlcyA/IHNoYXBlcy5sZW5ndGggOiAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGlmIChzaGFwZXNbaV0udHkgPT09ICdncicpIHtcclxuICAgICAgICBhcnIucHVzaChncm91cEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZmwnKSB7XHJcbiAgICAgICAgYXJyLnB1c2goZmlsbEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc3QnKSB7XHJcbiAgICAgICAgYXJyLnB1c2goc3Ryb2tlSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcclxuICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICd0bScpIHtcclxuICAgICAgICBhcnIucHVzaCh0cmltSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcclxuICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICd0cicpIHtcclxuICAgICAgICAvLyBhcnIucHVzaCh0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSx2aWV3W2ldLHByb3BlcnR5R3JvdXApKTtcclxuICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdlbCcpIHtcclxuICAgICAgICBhcnIucHVzaChlbGxpcHNlSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcclxuICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdzcicpIHtcclxuICAgICAgICBhcnIucHVzaChzdGFySW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcclxuICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdzaCcpIHtcclxuICAgICAgICBhcnIucHVzaChTaGFwZVBhdGhJbnRlcmZhY2Uoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAncmMnKSB7XHJcbiAgICAgICAgYXJyLnB1c2gocmVjdEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAncmQnKSB7XHJcbiAgICAgICAgYXJyLnB1c2gocm91bmRlZEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAncnAnKSB7XHJcbiAgICAgICAgYXJyLnB1c2gocmVwZWF0ZXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2dmJykge1xyXG4gICAgICAgIGFyci5wdXNoKGdyYWRpZW50RmlsbEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXJyLnB1c2goZGVmYXVsdEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcnI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb250ZW50c0ludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIHZhciBpbnRlcmZhY2VzO1xyXG4gICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIGxlbiA9IGludGVyZmFjZXMubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmIChpbnRlcmZhY2VzW2ldLl9uYW1lID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLm1uID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLnByb3BlcnR5SW5kZXggPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0uaXggPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0uaW5kID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VzW3ZhbHVlIC0gMV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICBpbnRlcmZhY2VzID0gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlLml0LCB2aWV3Lml0LCBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBpbnRlcmZhY2VzLmxlbmd0aDtcclxuICAgIHZhciB0cmFuc2Zvcm1JbnRlcmZhY2UgPSB0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLml0W3NoYXBlLml0Lmxlbmd0aCAtIDFdLCB2aWV3Lml0W3ZpZXcuaXQubGVuZ3RoIC0gMV0sIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtSW50ZXJmYWNlO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLmNpeDtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gc2hhcGUubm07XHJcblxyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ3JvdXBJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICB2YXIgaW50ZXJmYWNlRnVuY3Rpb24gPSBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgc3dpdGNoICh2YWx1ZSkge1xyXG4gICAgICAgIGNhc2UgJ0FEQkUgVmVjdG9ycyBHcm91cCc6XHJcbiAgICAgICAgY2FzZSAnQ29udGVudHMnOlxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50O1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSBmb3Igbm93LiBLZWVwaW5nIHRoZW0gaGVyZSBpbiBjYXNlIGEgbmV3IGNhc2UgYXBwZWFyc1xyXG4gICAgICAgICAgLy8gY2FzZSAnQURCRSBWZWN0b3IgVHJhbnNmb3JtIEdyb3VwJzpcclxuICAgICAgICAgIC8vIGNhc2UgMzpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnRyYW5zZm9ybTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICB2YXIgY29udGVudCA9IGNvbnRlbnRzSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XHJcbiAgICB2YXIgdHJhbnNmb3JtSW50ZXJmYWNlID0gdHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeShzaGFwZS5pdFtzaGFwZS5pdC5sZW5ndGggLSAxXSwgdmlldy5pdFt2aWV3Lml0Lmxlbmd0aCAtIDFdLCBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLmNvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtSW50ZXJmYWNlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGludGVyZmFjZUZ1bmN0aW9uLCAnX25hbWUnLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBzaGFwZS5ubTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgLy8gaW50ZXJmYWNlRnVuY3Rpb24uY29udGVudCA9IGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ubnVtUHJvcGVydGllcyA9IHNoYXBlLm5wO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ubm0gPSBzaGFwZS5ubTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XHJcbiAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaWxsSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xyXG4gICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XHJcbiAgICAgIGlmICh2YWwgPT09ICdDb2xvcicgfHwgdmFsID09PSAnY29sb3InKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmNvbG9yO1xyXG4gICAgICB9IGlmICh2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgY29sb3I6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LmMpLFxyXG4gICAgICB9LFxyXG4gICAgICBvcGFjaXR5OiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5vKSxcclxuICAgICAgfSxcclxuICAgICAgX25hbWU6IHsgdmFsdWU6IHNoYXBlLm5tIH0sXHJcbiAgICAgIG1uOiB7IHZhbHVlOiBzaGFwZS5tbiB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmlldy5jLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0NvbG9yJywgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgdmlldy5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09wYWNpdHknLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcclxuICAgICAgaWYgKHZhbCA9PT0gJ1N0YXJ0IFBvaW50JyB8fCB2YWwgPT09ICdzdGFydCBwb2ludCcpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3RhcnRQb2ludDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmFsID09PSAnRW5kIFBvaW50JyB8fCB2YWwgPT09ICdlbmQgcG9pbnQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmVuZFBvaW50O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgc3RhcnRQb2ludDoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcucyksXHJcbiAgICAgIH0sXHJcbiAgICAgIGVuZFBvaW50OiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5lKSxcclxuICAgICAgfSxcclxuICAgICAgb3BhY2l0eToge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubyksXHJcbiAgICAgIH0sXHJcbiAgICAgIHR5cGU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiAnYSc7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgX25hbWU6IHsgdmFsdWU6IHNoYXBlLm5tIH0sXHJcbiAgICAgIG1uOiB7IHZhbHVlOiBzaGFwZS5tbiB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmlldy5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1N0YXJ0IFBvaW50JywgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgdmlldy5lLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0VuZCBQb2ludCcsIHByb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuICBmdW5jdGlvbiBkZWZhdWx0SW50ZXJmYWNlRmFjdG9yeSgpIHtcclxuICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0cm9rZUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcclxuICAgIHZhciBfZGFzaFByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShkYXNoT2IsIF9wcm9wZXJ0eUdyb3VwKTtcclxuICAgIGZ1bmN0aW9uIGFkZFByb3BlcnR5VG9EYXNoT2IoaSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGFzaE9iLCBzaGFwZS5kW2ldLm5tLCB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5kLmRhdGFQcm9wc1tpXS5wKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBzaGFwZS5kID8gc2hhcGUuZC5sZW5ndGggOiAwO1xyXG4gICAgdmFyIGRhc2hPYiA9IHt9O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIGFkZFByb3BlcnR5VG9EYXNoT2IoaSk7XHJcbiAgICAgIHZpZXcuZC5kYXRhUHJvcHNbaV0ucC5zZXRHcm91cFByb3BlcnR5KF9kYXNoUHJvcGVydHlHcm91cCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XHJcbiAgICAgIGlmICh2YWwgPT09ICdDb2xvcicgfHwgdmFsID09PSAnY29sb3InKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmNvbG9yO1xyXG4gICAgICB9IGlmICh2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xyXG4gICAgICB9IGlmICh2YWwgPT09ICdTdHJva2UgV2lkdGgnIHx8IHZhbCA9PT0gJ3N0cm9rZSB3aWR0aCcpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3Ryb2tlV2lkdGg7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICBjb2xvcjoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuYyksXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wYWNpdHk6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3Lm8pLFxyXG4gICAgICB9LFxyXG4gICAgICBzdHJva2VXaWR0aDoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudyksXHJcbiAgICAgIH0sXHJcbiAgICAgIGRhc2g6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBkYXNoT2I7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgX25hbWU6IHsgdmFsdWU6IHNoYXBlLm5tIH0sXHJcbiAgICAgIG1uOiB7IHZhbHVlOiBzaGFwZS5tbiB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmlldy5jLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0NvbG9yJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcudy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTdHJva2UgV2lkdGgnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdHJpbUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICBpZiAodmFsID09PSBzaGFwZS5lLml4IHx8IHZhbCA9PT0gJ0VuZCcgfHwgdmFsID09PSAnZW5kJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5lbmQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbCA9PT0gc2hhcGUucy5peCkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zdGFydDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmFsID09PSBzaGFwZS5vLml4KSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9mZnNldDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XHJcblxyXG4gICAgdmlldy5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1N0YXJ0JywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcuZS5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdFbmQnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgdmlldy5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09mZnNldCcsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cDtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICBzdGFydDoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcucyksXHJcbiAgICAgIH0sXHJcbiAgICAgIGVuZDoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuZSksXHJcbiAgICAgIH0sXHJcbiAgICAgIG9mZnNldDoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubyksXHJcbiAgICAgIH0sXHJcbiAgICAgIF9uYW1lOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgfSk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xyXG4gICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKHNoYXBlLmEuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnQW5jaG9yIFBvaW50Jykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5hbmNob3JQb2ludDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUuby5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdPcGFjaXR5Jykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1Bvc2l0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdSb3RhdGlvbicgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBSb3RhdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm90YXRpb247XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLnMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnU2NhbGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNjYWxlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoc2hhcGUuc2sgJiYgc2hhcGUuc2suaXggPT09IHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ1NrZXcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNrZXc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChzaGFwZS5zYSAmJiBzaGFwZS5zYS5peCA9PT0gdmFsdWUpIHx8IHZhbHVlID09PSAnU2tldyBBeGlzJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5za2V3QXhpcztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcclxuICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09wYWNpdHknLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLmEuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnQW5jaG9yIFBvaW50JywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NjYWxlJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JvdGF0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIGlmICh2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2spIHtcclxuICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnNrLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NrZXcnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2Euc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU2tldyBBbmdsZScsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICB9XHJcbiAgICB2aWV3LnRyYW5zZm9ybS5vcC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XHJcbiAgICAgIG9wYWNpdHk6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnRyYW5zZm9ybS5tUHJvcHMubyksXHJcbiAgICAgIH0sXHJcbiAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnApLFxyXG4gICAgICB9LFxyXG4gICAgICBhbmNob3JQb2ludDoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5hKSxcclxuICAgICAgfSxcclxuICAgICAgc2NhbGU6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnRyYW5zZm9ybS5tUHJvcHMucyksXHJcbiAgICAgIH0sXHJcbiAgICAgIHJvdGF0aW9uOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnIpLFxyXG4gICAgICB9LFxyXG4gICAgICBza2V3OiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnNrKSxcclxuICAgICAgfSxcclxuICAgICAgc2tld0F4aXM6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2EpLFxyXG4gICAgICB9LFxyXG4gICAgICBfbmFtZTogeyB2YWx1ZTogc2hhcGUubm0gfSxcclxuICAgIH0pO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24udHkgPSAndHInO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZWxsaXBzZUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUucy5peCA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2l6ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcclxuICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XHJcbiAgICBwcm9wLnMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU2l6ZScsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICBwcm9wLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XHJcbiAgICAgIHNpemU6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnMpLFxyXG4gICAgICB9LFxyXG4gICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucCksXHJcbiAgICAgIH0sXHJcbiAgICAgIF9uYW1lOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgfSk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RhckludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm90YXRpb247XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLnB0Lml4ID09PSB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb2ludHM7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNoYXBlLm9yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFN0YXIgT3V0ZXIgUmFkaXVzJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRlclJhZGl1cztcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUub3MuaXggPT09IHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm91dGVyUm91bmRuZXNzO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaGFwZS5pciAmJiAoc2hhcGUuaXIuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnQURCRSBWZWN0b3IgU3RhciBJbm5lciBSYWRpdXMnKSkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5pbm5lclJhZGl1cztcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUuaXMgJiYgc2hhcGUuaXMuaXggPT09IHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmlubmVyUm91bmRuZXNzO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcclxuICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XHJcbiAgICBwcm9wLm9yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ091dGVyIFJhZGl1cycsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICBwcm9wLm9zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ091dGVyIFJvdW5kbmVzcycsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICBwcm9wLnB0LnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1BvaW50cycsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICBwcm9wLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcHJvcC5yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JvdGF0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIGlmIChzaGFwZS5pcikge1xyXG4gICAgICBwcm9wLmlyLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0lubmVyIFJhZGl1cycsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgIHByb3AuaXMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnSW5uZXIgUm91bmRuZXNzJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucCksXHJcbiAgICAgIH0sXHJcbiAgICAgIHJvdGF0aW9uOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5yKSxcclxuICAgICAgfSxcclxuICAgICAgcG9pbnRzOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5wdCksXHJcbiAgICAgIH0sXHJcbiAgICAgIG91dGVyUmFkaXVzOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5vciksXHJcbiAgICAgIH0sXHJcbiAgICAgIG91dGVyUm91bmRuZXNzOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5vcyksXHJcbiAgICAgIH0sXHJcbiAgICAgIGlubmVyUmFkaXVzOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5pciksXHJcbiAgICAgIH0sXHJcbiAgICAgIGlubmVyUm91bmRuZXNzOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5pcyksXHJcbiAgICAgIH0sXHJcbiAgICAgIF9uYW1lOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgfSk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVjdEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcclxuICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm91bmRuZXNzO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaGFwZS5zLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NpemUnIHx8IHZhbHVlID09PSAnQURCRSBWZWN0b3IgUmVjdCBTaXplJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zaXplO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xyXG5cclxuICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XHJcbiAgICBwcm9wLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcHJvcC5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NpemUnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgcHJvcC5yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JvdGF0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucCksXHJcbiAgICAgIH0sXHJcbiAgICAgIHJvdW5kbmVzczoge1xyXG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuciksXHJcbiAgICAgIH0sXHJcbiAgICAgIHNpemU6IHtcclxuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnMpLFxyXG4gICAgICB9LFxyXG4gICAgICBfbmFtZTogeyB2YWx1ZTogc2hhcGUubm0gfSxcclxuICAgIH0pO1xyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcclxuICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJvdW5kZWRJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdSb3VuZCBDb3JuZXJzIDEnKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnJhZGl1cztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICB2YXIgcHJvcCA9IHZpZXc7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XHJcbiAgICBwcm9wLnJkLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JhZGl1cycsIF9wcm9wZXJ0eUdyb3VwKSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgcmFkaXVzOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5yZCksXHJcbiAgICAgIH0sXHJcbiAgICAgIF9uYW1lOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgfSk7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVwZWF0ZXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAoc2hhcGUuYy5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdDb3BpZXMnKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmNvcGllcztcclxuICAgICAgfSBpZiAoc2hhcGUuby5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdPZmZzZXQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9mZnNldDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XHJcbiAgICB2YXIgcHJvcCA9IHZpZXc7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XHJcbiAgICBwcm9wLmMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnQ29waWVzJywgX3Byb3BlcnR5R3JvdXApKTtcclxuICAgIHByb3Auby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPZmZzZXQnLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgY29waWVzOiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5jKSxcclxuICAgICAgfSxcclxuICAgICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5vKSxcclxuICAgICAgfSxcclxuICAgICAgX25hbWU6IHsgdmFsdWU6IHNoYXBlLm5tIH0sXHJcbiAgICB9KTtcclxuICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XHJcbiAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKHNoYXBlcywgdmlldywgcHJvcGVydHlHcm91cCkge1xyXG4gICAgdmFyIGludGVyZmFjZXM7XHJcbiAgICBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyAxIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZXNbdmFsdWUgLSAxXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBsZW4gPSBpbnRlcmZhY2VzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBpZiAoaW50ZXJmYWNlc1tpXS5fbmFtZSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJlbnRHcm91cFdyYXBwZXIoKSB7XHJcbiAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwO1xyXG4gICAgfVxyXG4gICAgX2ludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShfaW50ZXJmYWNlRnVuY3Rpb24sIHBhcmVudEdyb3VwV3JhcHBlcik7XHJcbiAgICBpbnRlcmZhY2VzID0gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlcywgdmlldywgX2ludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xyXG4gICAgX2ludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBpbnRlcmZhY2VzLmxlbmd0aDtcclxuICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5fbmFtZSA9ICdDb250ZW50cyc7XHJcbiAgICByZXR1cm4gX2ludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKiBleHBvcnRlZCBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSAqL1xyXG5cclxudmFyIFRleHRFeHByZXNzaW9uSW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgIHZhciBfcHJldlZhbHVlO1xyXG4gICAgdmFyIF9zb3VyY2VUZXh0O1xyXG4gICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgICAgY2FzZSAnQURCRSBUZXh0IERvY3VtZW50JzpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlVGV4dDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0xheWVyRnVuY3Rpb24sICdzb3VyY2VUZXh0Jywge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBlbGVtLnRleHRQcm9wZXJ0eS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IGVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLnQ7XHJcbiAgICAgICAgaWYgKHN0cmluZ1ZhbHVlICE9PSBfcHJldlZhbHVlKSB7XHJcbiAgICAgICAgICBlbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS50ID0gX3ByZXZWYWx1ZTtcclxuICAgICAgICAgIF9zb3VyY2VUZXh0ID0gbmV3IFN0cmluZyhzdHJpbmdWYWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXHJcbiAgICAgICAgICAvLyBJZiBzdHJpbmdWYWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcsIGV2YWwgcmV0dXJucyB1bmRlZmluZWQsIHNvIGl0IGhhcyB0byBiZSByZXR1cm5lZCBhcyBhIFN0cmluZyBwcmltaXRpdmVcclxuICAgICAgICAgIF9zb3VyY2VUZXh0LnZhbHVlID0gc3RyaW5nVmFsdWUgfHwgbmV3IFN0cmluZyhzdHJpbmdWYWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc291cmNlVGV4dDtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIE1hdHJpeCwgTWFza01hbmFnZXJJbnRlcmZhY2UsIFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UsIGdldERlc2NyaXB0b3IgKi9cclxuLyogZXhwb3J0ZWQgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlICovXHJcblxyXG52YXIgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBnZXRNYXRyaXgodGltZSkge1xyXG4gICAgdmFyIHRvV29ybGRNYXQgPSBuZXcgTWF0cml4KCk7XHJcbiAgICBpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBwcm9wTWF0cml4ID0gdGhpcy5fZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcclxuICAgICAgcHJvcE1hdHJpeC5jbG9uZSh0b1dvcmxkTWF0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciB0cmFuc2Zvcm1NYXQgPSB0aGlzLl9lbGVtLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xyXG4gICAgICB0cmFuc2Zvcm1NYXQuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0b1dvcmxkTWF0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9Xb3JsZFZlYyhhcnIsIHRpbWUpIHtcclxuICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XHJcbiAgICB0b1dvcmxkTWF0LnByb3BzWzEyXSA9IDA7XHJcbiAgICB0b1dvcmxkTWF0LnByb3BzWzEzXSA9IDA7XHJcbiAgICB0b1dvcmxkTWF0LnByb3BzWzE0XSA9IDA7XHJcbiAgICByZXR1cm4gdGhpcy5hcHBseVBvaW50KHRvV29ybGRNYXQsIGFycik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b1dvcmxkKGFyciwgdGltZSkge1xyXG4gICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcclxuICAgIHJldHVybiB0aGlzLmFwcGx5UG9pbnQodG9Xb3JsZE1hdCwgYXJyKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZyb21Xb3JsZFZlYyhhcnIsIHRpbWUpIHtcclxuICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XHJcbiAgICB0b1dvcmxkTWF0LnByb3BzWzEyXSA9IDA7XHJcbiAgICB0b1dvcmxkTWF0LnByb3BzWzEzXSA9IDA7XHJcbiAgICB0b1dvcmxkTWF0LnByb3BzWzE0XSA9IDA7XHJcbiAgICByZXR1cm4gdGhpcy5pbnZlcnRQb2ludCh0b1dvcmxkTWF0LCBhcnIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZnJvbVdvcmxkKGFyciwgdGltZSkge1xyXG4gICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcclxuICAgIHJldHVybiB0aGlzLmludmVydFBvaW50KHRvV29ybGRNYXQsIGFycik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhcHBseVBvaW50KG1hdHJpeCwgYXJyKSB7XHJcbiAgICBpZiAodGhpcy5fZWxlbS5oaWVyYXJjaHkgJiYgdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICB0aGlzLl9lbGVtLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KG1hdHJpeCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtYXRyaXguYXBwbHlUb1BvaW50QXJyYXkoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSB8fCAwKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludmVydFBvaW50KG1hdHJpeCwgYXJyKSB7XHJcbiAgICBpZiAodGhpcy5fZWxlbS5oaWVyYXJjaHkgJiYgdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICB0aGlzLl9lbGVtLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KG1hdHJpeCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtYXRyaXguaW52ZXJzZVBvaW50KGFycik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmcm9tQ29tcChhcnIpIHtcclxuICAgIHZhciB0b1dvcmxkTWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgdG9Xb3JsZE1hdC5yZXNldCgpO1xyXG4gICAgdGhpcy5fZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KHRvV29ybGRNYXQpO1xyXG4gICAgaWYgKHRoaXMuX2VsZW0uaGllcmFyY2h5ICYmIHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbS5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdG9Xb3JsZE1hdC5pbnZlcnNlUG9pbnQoYXJyKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0b1dvcmxkTWF0LmludmVyc2VQb2ludChhcnIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2FtcGxlSW1hZ2UoKSB7XHJcbiAgICByZXR1cm4gWzEsIDEsIDEsIDFdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICB2YXIgdHJhbnNmb3JtSW50ZXJmYWNlO1xyXG5cclxuICAgIGZ1bmN0aW9uIF9yZWdpc3Rlck1hc2tJbnRlcmZhY2UobWFza01hbmFnZXIpIHtcclxuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLm1hc2sgPSBuZXcgTWFza01hbmFnZXJJbnRlcmZhY2UobWFza01hbmFnZXIsIGVsZW0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX3JlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZShlZmZlY3RzKSB7XHJcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5lZmZlY3QgPSBlZmZlY3RzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF90aGlzTGF5ZXJGdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ0FEQkUgUm9vdCBWZWN0b3JzIEdyb3VwJzpcclxuICAgICAgICBjYXNlICdDb250ZW50cyc6XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5zaGFwZUludGVyZmFjZTtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgIGNhc2UgJ1RyYW5zZm9ybSc6XHJcbiAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcclxuICAgICAgICBjYXNlICdBREJFIFRyYW5zZm9ybSBHcm91cCc6XHJcbiAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtSW50ZXJmYWNlO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICBjYXNlICdBREJFIEVmZmVjdCBQYXJhZGUnOlxyXG4gICAgICAgIGNhc2UgJ2VmZmVjdHMnOlxyXG4gICAgICAgIGNhc2UgJ0VmZmVjdHMnOlxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5lZmZlY3Q7XHJcbiAgICAgICAgY2FzZSAnQURCRSBUZXh0IFByb3BlcnRpZXMnOlxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi50ZXh0SW50ZXJmYWNlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLmdldE1hdHJpeCA9IGdldE1hdHJpeDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5pbnZlcnRQb2ludCA9IGludmVydFBvaW50O1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLmFwcGx5UG9pbnQgPSBhcHBseVBvaW50O1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvV29ybGQgPSB0b1dvcmxkO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvV29ybGRWZWMgPSB0b1dvcmxkVmVjO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLmZyb21Xb3JsZCA9IGZyb21Xb3JsZDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tV29ybGRWZWMgPSBmcm9tV29ybGRWZWM7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24udG9Db21wID0gdG9Xb3JsZDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tQ29tcCA9IGZyb21Db21wO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLnNhbXBsZUltYWdlID0gc2FtcGxlSW1hZ2U7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlUmVjdEF0VGltZSA9IGVsZW0uc291cmNlUmVjdEF0VGltZS5iaW5kKGVsZW0pO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLl9lbGVtID0gZWxlbTtcclxuICAgIHRyYW5zZm9ybUludGVyZmFjZSA9IFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UoZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcCk7XHJcbiAgICB2YXIgYW5jaG9yUG9pbnREZXNjcmlwdG9yID0gZ2V0RGVzY3JpcHRvcih0cmFuc2Zvcm1JbnRlcmZhY2UsICdhbmNob3JQb2ludCcpO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXNMYXllckZ1bmN0aW9uLCB7XHJcbiAgICAgIGhhc1BhcmVudDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGVsZW0uaGllcmFyY2h5Lmxlbmd0aDtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICBwYXJlbnQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBlbGVtLmhpZXJhcmNoeVswXS5sYXllckludGVyZmFjZTtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICByb3RhdGlvbjogZ2V0RGVzY3JpcHRvcih0cmFuc2Zvcm1JbnRlcmZhY2UsICdyb3RhdGlvbicpLFxyXG4gICAgICBzY2FsZTogZ2V0RGVzY3JpcHRvcih0cmFuc2Zvcm1JbnRlcmZhY2UsICdzY2FsZScpLFxyXG4gICAgICBwb3NpdGlvbjogZ2V0RGVzY3JpcHRvcih0cmFuc2Zvcm1JbnRlcmZhY2UsICdwb3NpdGlvbicpLFxyXG4gICAgICBvcGFjaXR5OiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ29wYWNpdHknKSxcclxuICAgICAgYW5jaG9yUG9pbnQ6IGFuY2hvclBvaW50RGVzY3JpcHRvcixcclxuICAgICAgYW5jaG9yX3BvaW50OiBhbmNob3JQb2ludERlc2NyaXB0b3IsXHJcbiAgICAgIHRyYW5zZm9ybToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUludGVyZmFjZTtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICBhY3RpdmU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBlbGVtLmlzSW5SYW5nZTtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLnN0YXJ0VGltZSA9IGVsZW0uZGF0YS5zdDtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5pbmRleCA9IGVsZW0uZGF0YS5pbmQ7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlID0gZWxlbS5kYXRhLnJlZklkO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLmhlaWdodCA9IGVsZW0uZGF0YS50eSA9PT0gMCA/IGVsZW0uZGF0YS5oIDogMTAwO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLndpZHRoID0gZWxlbS5kYXRhLnR5ID09PSAwID8gZWxlbS5kYXRhLncgOiAxMDA7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW5Qb2ludCA9IGVsZW0uZGF0YS5pcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5vdXRQb2ludCA9IGVsZW0uZGF0YS5vcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5fbmFtZSA9IGVsZW0uZGF0YS5ubTtcclxuXHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24ucmVnaXN0ZXJNYXNrSW50ZXJmYWNlID0gX3JlZ2lzdGVyTWFza0ludGVyZmFjZTtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UgPSBfcmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlO1xyXG4gICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsICovXHJcbi8qIGV4cG9ydGVkIEZvb3RhZ2VJbnRlcmZhY2UgKi9cclxuXHJcbnZhciBGb290YWdlSW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgb3V0bGluZUludGVyZmFjZUZhY3RvcnkgPSAoZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgIHZhciBjdXJyZW50UHJvcGVydHlOYW1lID0gJyc7XHJcbiAgICB2YXIgY3VycmVudFByb3BlcnR5ID0gZWxlbS5nZXRGb290YWdlRGF0YSgpO1xyXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgICAgY3VycmVudFByb3BlcnR5TmFtZSA9ICcnO1xyXG4gICAgICBjdXJyZW50UHJvcGVydHkgPSBlbGVtLmdldEZvb3RhZ2VEYXRhKCk7XHJcbiAgICAgIHJldHVybiBzZWFyY2hQcm9wZXJ0eTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNlYXJjaFByb3BlcnR5KHZhbHVlKSB7XHJcbiAgICAgIGlmIChjdXJyZW50UHJvcGVydHlbdmFsdWVdKSB7XHJcbiAgICAgICAgY3VycmVudFByb3BlcnR5TmFtZSA9IHZhbHVlO1xyXG4gICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eVt2YWx1ZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50UHJvcGVydHkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2VhcmNoUHJvcGVydHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHByb3BlcnR5TmFtZUluZGV4ID0gdmFsdWUuaW5kZXhPZihjdXJyZW50UHJvcGVydHlOYW1lKTtcclxuICAgICAgaWYgKHByb3BlcnR5TmFtZUluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cihwcm9wZXJ0eU5hbWVJbmRleCArIGN1cnJlbnRQcm9wZXJ0eU5hbWUubGVuZ3RoKSwgMTApO1xyXG4gICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eVtpbmRleF07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50UHJvcGVydHkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2VhcmNoUHJvcGVydHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50UHJvcGVydHk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluaXQ7XHJcbiAgfSk7XHJcblxyXG4gIHZhciBkYXRhSW50ZXJmYWNlRmFjdG9yeSA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAodmFsdWUgPT09ICdPdXRsaW5lJykge1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRsaW5lSW50ZXJmYWNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJmYWNlRnVuY3Rpb24uX25hbWUgPSAnT3V0bGluZSc7XHJcbiAgICBpbnRlcmZhY2VGdW5jdGlvbi5vdXRsaW5lSW50ZXJmYWNlID0gb3V0bGluZUludGVyZmFjZUZhY3RvcnkoZWxlbSk7XHJcbiAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKHZhbHVlID09PSAnRGF0YScpIHtcclxuICAgICAgICByZXR1cm4gX2ludGVyZmFjZUZ1bmN0aW9uLmRhdGFJbnRlcmZhY2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgX2ludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gJ0RhdGEnO1xyXG4gICAgX2ludGVyZmFjZUZ1bmN0aW9uLmRhdGFJbnRlcmZhY2UgPSBkYXRhSW50ZXJmYWNlRmFjdG9yeShlbGVtKTtcclxuICAgIHJldHVybiBfaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGV4cG9ydGVkIENvbXBFeHByZXNzaW9uSW50ZXJmYWNlICovXHJcblxyXG52YXIgQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoY29tcCkge1xyXG4gICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB2YXIgbGVuID0gY29tcC5sYXllcnMubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmIChjb21wLmxheWVyc1tpXS5ubSA9PT0gbmFtZSB8fCBjb21wLmxheWVyc1tpXS5pbmQgPT09IG5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiBjb21wLmVsZW1lbnRzW2ldLmxheWVySW50ZXJmYWNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIC8vIHJldHVybiB7YWN0aXZlOmZhbHNlfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0xheWVyRnVuY3Rpb24sICdfbmFtZScsIHsgdmFsdWU6IGNvbXAuZGF0YS5ubSB9KTtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5sYXllciA9IF90aGlzTGF5ZXJGdW5jdGlvbjtcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5waXhlbEFzcGVjdCA9IDE7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uaGVpZ2h0ID0gY29tcC5kYXRhLmggfHwgY29tcC5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24ud2lkdGggPSBjb21wLmRhdGEudyB8fCBjb21wLmdsb2JhbERhdGEuY29tcFNpemUudztcclxuICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5waXhlbEFzcGVjdCA9IDE7XHJcbiAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJhbWVEdXJhdGlvbiA9IDEgLyBjb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLmRpc3BsYXlTdGFydFRpbWUgPSAwO1xyXG4gICAgX3RoaXNMYXllckZ1bmN0aW9uLm51bUxheWVycyA9IGNvbXAubGF5ZXJzLmxlbmd0aDtcclxuICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UgKi9cclxuLyogZXhwb3J0ZWQgVHJhbnNmb3JtRXhwcmVzc2lvbkludGVyZmFjZSAqL1xyXG5cclxudmFyIFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XHJcbiAgICBmdW5jdGlvbiBfdGhpc0Z1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgICAgY2FzZSAnc2NhbGUnOlxyXG4gICAgICAgIGNhc2UgJ1NjYWxlJzpcclxuICAgICAgICBjYXNlICdBREJFIFNjYWxlJzpcclxuICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5zY2FsZTtcclxuICAgICAgICBjYXNlICdyb3RhdGlvbic6XHJcbiAgICAgICAgY2FzZSAnUm90YXRpb24nOlxyXG4gICAgICAgIGNhc2UgJ0FEQkUgUm90YXRpb24nOlxyXG4gICAgICAgIGNhc2UgJ0FEQkUgUm90YXRlIFonOlxyXG4gICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5yb3RhdGlvbjtcclxuICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBYJzpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnhSb3RhdGlvbjtcclxuICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBZJzpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnlSb3RhdGlvbjtcclxuICAgICAgICBjYXNlICdwb3NpdGlvbic6XHJcbiAgICAgICAgY2FzZSAnUG9zaXRpb24nOlxyXG4gICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb24nOlxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnBvc2l0aW9uO1xyXG4gICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb25fMCc6XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi54UG9zaXRpb247XHJcbiAgICAgICAgY2FzZSAnQURCRSBQb3NpdGlvbl8xJzpcclxuICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnlQb3NpdGlvbjtcclxuICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uXzInOlxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24uelBvc2l0aW9uO1xyXG4gICAgICAgIGNhc2UgJ2FuY2hvclBvaW50JzpcclxuICAgICAgICBjYXNlICdBbmNob3JQb2ludCc6XHJcbiAgICAgICAgY2FzZSAnQW5jaG9yIFBvaW50JzpcclxuICAgICAgICBjYXNlICdBREJFIEFuY2hvclBvaW50JzpcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5hbmNob3JQb2ludDtcclxuICAgICAgICBjYXNlICdvcGFjaXR5JzpcclxuICAgICAgICBjYXNlICdPcGFjaXR5JzpcclxuICAgICAgICBjYXNlIDExOlxyXG4gICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ub3BhY2l0eTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAncm90YXRpb24nLCB7XHJcbiAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yIHx8IHRyYW5zZm9ybS5yeiksXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3pSb3RhdGlvbicsIHtcclxuICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnJ6IHx8IHRyYW5zZm9ybS5yKSxcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneFJvdGF0aW9uJywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucngpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd5Um90YXRpb24nLCB7XHJcbiAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeSksXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnc2NhbGUnLCB7XHJcbiAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5zKSxcclxuICAgIH0pO1xyXG4gICAgdmFyIF9weDtcclxuICAgIHZhciBfcHk7XHJcbiAgICB2YXIgX3B6O1xyXG4gICAgdmFyIF90cmFuc2Zvcm1GYWN0b3J5O1xyXG4gICAgaWYgKHRyYW5zZm9ybS5wKSB7XHJcbiAgICAgIF90cmFuc2Zvcm1GYWN0b3J5ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5wKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9weCA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHgpO1xyXG4gICAgICBfcHkgPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnB5KTtcclxuICAgICAgaWYgKHRyYW5zZm9ybS5weikge1xyXG4gICAgICAgIF9weiA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHopO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3Bvc2l0aW9uJywge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodHJhbnNmb3JtLnApIHtcclxuICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtRmFjdG9yeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgX3B4KCksXHJcbiAgICAgICAgICBfcHkoKSxcclxuICAgICAgICAgIF9weiA/IF9weigpIDogMF07XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3hQb3NpdGlvbicsIHtcclxuICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnB4KSxcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneVBvc2l0aW9uJywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHkpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd6UG9zaXRpb24nLCB7XHJcbiAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weiksXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ2FuY2hvclBvaW50Jywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0uYSksXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29wYWNpdHknLCB7XHJcbiAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5vKSxcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnc2tldycsIHtcclxuICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnNrKSxcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnc2tld0F4aXMnLCB7XHJcbiAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5zYSksXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29yaWVudGF0aW9uJywge1xyXG4gICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ub3IpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIF90aGlzRnVuY3Rpb247XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGV4cG9ydGVkIFByb2plY3RJbnRlcmZhY2UgKi9cclxuXHJcbnZhciBQcm9qZWN0SW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiByZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApIHtcclxuICAgIHRoaXMuY29tcG9zaXRpb25zLnB1c2goY29tcCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gX3RoaXNQcm9qZWN0RnVuY3Rpb24obmFtZSkge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBsZW4gPSB0aGlzLmNvbXBvc2l0aW9ucy5sZW5ndGg7XHJcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRpb25zW2ldLmRhdGEgJiYgdGhpcy5jb21wb3NpdGlvbnNbaV0uZGF0YS5ubSA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRpb25zW2ldLnByZXBhcmVGcmFtZSAmJiB0aGlzLmNvbXBvc2l0aW9uc1tpXS5kYXRhLnh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25zW2ldLnByZXBhcmVGcmFtZSh0aGlzLmN1cnJlbnRGcmFtZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb3NpdGlvbnNbaV0uY29tcEludGVyZmFjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLmNvbXBvc2l0aW9ucyA9IFtdO1xyXG4gICAgX3RoaXNQcm9qZWN0RnVuY3Rpb24uY3VycmVudEZyYW1lID0gMDtcclxuXHJcbiAgICBfdGhpc1Byb2plY3RGdW5jdGlvbi5yZWdpc3RlckNvbXBvc2l0aW9uID0gcmVnaXN0ZXJDb21wb3NpdGlvbjtcclxuXHJcbiAgICByZXR1cm4gX3RoaXNQcm9qZWN0RnVuY3Rpb247XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbi8qIGdsb2JhbCBwcm9wZXJ0eUdyb3VwRmFjdG9yeSwgRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlLCBQcm9wZXJ0eUludGVyZmFjZSAqL1xyXG4vKiBleHBvcnRlZCBFZmZlY3RzRXhwcmVzc2lvbkludGVyZmFjZSAqL1xyXG5cclxudmFyIEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgb2IgPSB7XHJcbiAgICBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlOiBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlLFxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UoZWxlbSwgcHJvcGVydHlHcm91cCkge1xyXG4gICAgaWYgKGVsZW0uZWZmZWN0c01hbmFnZXIpIHtcclxuICAgICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gW107XHJcbiAgICAgIHZhciBlZmZlY3RzRGF0YSA9IGVsZW0uZGF0YS5lZjtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBsZW4gPSBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgZWZmZWN0RWxlbWVudHMucHVzaChjcmVhdGVHcm91cEludGVyZmFjZShlZmZlY3RzRGF0YVtpXSwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSwgcHJvcGVydHlHcm91cCwgZWxlbSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZWZmZWN0cyA9IGVsZW0uZGF0YS5lZiB8fCBbXTtcclxuICAgICAgdmFyIGdyb3VwSW50ZXJmYWNlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpID0gMDtcclxuICAgICAgICBsZW4gPSBlZmZlY3RzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgICAgaWYgKG5hbWUgPT09IGVmZmVjdHNbaV0ubm0gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5tbiB8fCBuYW1lID09PSBlZmZlY3RzW2ldLml4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH07XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShncm91cEludGVyZmFjZSwgJ251bVByb3BlcnRpZXMnLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBncm91cEludGVyZmFjZTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlR3JvdXBJbnRlcmZhY2UoZGF0YSwgZWxlbWVudHMsIHByb3BlcnR5R3JvdXAsIGVsZW0pIHtcclxuICAgIGZ1bmN0aW9uIGdyb3VwSW50ZXJmYWNlKG5hbWUpIHtcclxuICAgICAgdmFyIGVmZmVjdHMgPSBkYXRhLmVmO1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBsZW4gPSBlZmZlY3RzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBpZiAobmFtZSA9PT0gZWZmZWN0c1tpXS5ubSB8fCBuYW1lID09PSBlZmZlY3RzW2ldLm1uIHx8IG5hbWUgPT09IGVmZmVjdHNbaV0uaXgpIHtcclxuICAgICAgICAgIGlmIChlZmZlY3RzW2ldLnR5ID09PSA1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShncm91cEludGVyZmFjZSwgcHJvcGVydHlHcm91cCk7XHJcblxyXG4gICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBsZW4gPSBkYXRhLmVmLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICBpZiAoZGF0YS5lZltpXS50eSA9PT0gNSkge1xyXG4gICAgICAgIGVmZmVjdEVsZW1lbnRzLnB1c2goY3JlYXRlR3JvdXBJbnRlcmZhY2UoZGF0YS5lZltpXSwgZWxlbWVudHMuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLnByb3BlcnR5R3JvdXAsIGVsZW0pKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZVZhbHVlSW50ZXJmYWNlKGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLCBkYXRhLmVmW2ldLnR5LCBlbGVtLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRhdGEubW4gPT09ICdBREJFIENvbG9yIENvbnRyb2wnKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShncm91cEludGVyZmFjZSwgJ2NvbG9yJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGVmZmVjdEVsZW1lbnRzWzBdKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhncm91cEludGVyZmFjZSwge1xyXG4gICAgICBudW1Qcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGF0YS5ucDtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICBfbmFtZTogeyB2YWx1ZTogZGF0YS5ubSB9LFxyXG4gICAgICBwcm9wZXJ0eUdyb3VwOiB7IHZhbHVlOiBfcHJvcGVydHlHcm91cCB9LFxyXG4gICAgfSk7XHJcbiAgICBncm91cEludGVyZmFjZS5lbmFibGVkID0gZGF0YS5lbiAhPT0gMDtcclxuICAgIGdyb3VwSW50ZXJmYWNlLmFjdGl2ZSA9IGdyb3VwSW50ZXJmYWNlLmVuYWJsZWQ7XHJcbiAgICByZXR1cm4gZ3JvdXBJbnRlcmZhY2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVWYWx1ZUludGVyZmFjZShlbGVtZW50LCB0eXBlLCBlbGVtLCBwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICB2YXIgZXhwcmVzc2lvblByb3BlcnR5ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKGVsZW1lbnQucCk7XHJcbiAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHR5cGUgPT09IDEwKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW0uY29tcC5jb21wSW50ZXJmYWNlKGVsZW1lbnQucC52KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZXhwcmVzc2lvblByb3BlcnR5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsZW1lbnQucC5zZXRHcm91cFByb3BlcnR5KSB7XHJcbiAgICAgIGVsZW1lbnQucC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCcnLCBwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVNpemVkQXJyYXkgKi9cclxuLyogZXhwb3J0ZWQgTWFza01hbmFnZXJJbnRlcmZhY2UgKi9cclxuXHJcbnZhciBNYXNrTWFuYWdlckludGVyZmFjZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gTWFza0ludGVyZmFjZShtYXNrLCBkYXRhKSB7XHJcbiAgICB0aGlzLl9tYXNrID0gbWFzaztcclxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG4gIH1cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFza0ludGVyZmFjZS5wcm90b3R5cGUsICdtYXNrUGF0aCcsIHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAodGhpcy5fbWFzay5wcm9wLmspIHtcclxuICAgICAgICB0aGlzLl9tYXNrLnByb3AuZ2V0VmFsdWUoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fbWFzay5wcm9wO1xyXG4gICAgfSxcclxuICB9KTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFza0ludGVyZmFjZS5wcm90b3R5cGUsICdtYXNrT3BhY2l0eScsIHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAodGhpcy5fbWFzay5vcC5rKSB7XHJcbiAgICAgICAgdGhpcy5fbWFzay5vcC5nZXRWYWx1ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl9tYXNrLm9wLnYgKiAxMDA7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICB2YXIgTWFza01hbmFnZXIgPSBmdW5jdGlvbiAobWFza01hbmFnZXIpIHtcclxuICAgIHZhciBfbWFza3NJbnRlcmZhY2VzID0gY3JlYXRlU2l6ZWRBcnJheShtYXNrTWFuYWdlci52aWV3RGF0YS5sZW5ndGgpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuID0gbWFza01hbmFnZXIudmlld0RhdGEubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgIF9tYXNrc0ludGVyZmFjZXNbaV0gPSBuZXcgTWFza0ludGVyZmFjZShtYXNrTWFuYWdlci52aWV3RGF0YVtpXSwgbWFza01hbmFnZXIubWFza3NQcm9wZXJ0aWVzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWFza0Z1bmN0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgaSA9IDA7XHJcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgaWYgKG1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllc1tpXS5ubSA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgcmV0dXJuIF9tYXNrc0ludGVyZmFjZXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gbWFza0Z1bmN0aW9uO1xyXG4gIH07XHJcbiAgcmV0dXJuIE1hc2tNYW5hZ2VyO1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGNyZWF0ZVR5cGVkQXJyYXkgKi9cclxuLyogZXhwb3J0ZWQgRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlICovXHJcblxyXG52YXIgRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgZGVmYXVsdFVuaWRpbWVuc2lvbmFsVmFsdWUgPSB7IHB2OiAwLCB2OiAwLCBtdWx0OiAxIH07XHJcbiAgdmFyIGRlZmF1bHRNdWx0aWRpbWVuc2lvbmFsVmFsdWUgPSB7IHB2OiBbMCwgMCwgMF0sIHY6IFswLCAwLCAwXSwgbXVsdDogMSB9O1xyXG5cclxuICBmdW5jdGlvbiBjb21wbGV0ZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgcHJvcGVydHksIHR5cGUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHByZXNzaW9uVmFsdWUsICd2ZWxvY2l0eScsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5LmdldFZlbG9jaXR5QXRUaW1lKHByb3BlcnR5LmNvbXAuY3VycmVudEZyYW1lKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgZXhwcmVzc2lvblZhbHVlLm51bUtleXMgPSBwcm9wZXJ0eS5rZXlmcmFtZXMgPyBwcm9wZXJ0eS5rZXlmcmFtZXMubGVuZ3RoIDogMDtcclxuICAgIGV4cHJlc3Npb25WYWx1ZS5rZXkgPSBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgIGlmICghZXhwcmVzc2lvblZhbHVlLm51bUtleXMpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdmFsdWUgPSAnJztcclxuICAgICAgaWYgKCdzJyBpbiBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMV0pIHtcclxuICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAxXS5zO1xyXG4gICAgICB9IGVsc2UgaWYgKCdlJyBpbiBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMl0pIHtcclxuICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAyXS5lO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDJdLnM7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHZhbHVlUHJvcCA9IHR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcgPyBuZXcgTnVtYmVyKHZhbHVlKSA6IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcclxuICAgICAgdmFsdWVQcm9wLnRpbWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMV0udCAvIHByb3BlcnR5LmVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgICAgdmFsdWVQcm9wLnZhbHVlID0gdHlwZSA9PT0gJ3VuaWRpbWVuc2lvbmFsJyA/IHZhbHVlWzBdIDogdmFsdWU7XHJcbiAgICAgIHJldHVybiB2YWx1ZVByb3A7XHJcbiAgICB9O1xyXG4gICAgZXhwcmVzc2lvblZhbHVlLnZhbHVlQXRUaW1lID0gcHJvcGVydHkuZ2V0VmFsdWVBdFRpbWU7XHJcbiAgICBleHByZXNzaW9uVmFsdWUuc3BlZWRBdFRpbWUgPSBwcm9wZXJ0eS5nZXRTcGVlZEF0VGltZTtcclxuICAgIGV4cHJlc3Npb25WYWx1ZS52ZWxvY2l0eUF0VGltZSA9IHByb3BlcnR5LmdldFZlbG9jaXR5QXRUaW1lO1xyXG4gICAgZXhwcmVzc2lvblZhbHVlLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eS5wcm9wZXJ0eUdyb3VwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gVW5pZGltZW5zaW9uYWxQcm9wZXJ0eUludGVyZmFjZShwcm9wZXJ0eSkge1xyXG4gICAgaWYgKCFwcm9wZXJ0eSB8fCAhKCdwdicgaW4gcHJvcGVydHkpKSB7XHJcbiAgICAgIHByb3BlcnR5ID0gZGVmYXVsdFVuaWRpbWVuc2lvbmFsVmFsdWU7XHJcbiAgICB9XHJcbiAgICB2YXIgbXVsdCA9IDEgLyBwcm9wZXJ0eS5tdWx0O1xyXG4gICAgdmFyIHZhbCA9IHByb3BlcnR5LnB2ICogbXVsdDtcclxuICAgIHZhciBleHByZXNzaW9uVmFsdWUgPSBuZXcgTnVtYmVyKHZhbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXHJcbiAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSB2YWw7XHJcbiAgICBjb21wbGV0ZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgcHJvcGVydHksICd1bmlkaW1lbnNpb25hbCcpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChwcm9wZXJ0eS5rKSB7XHJcbiAgICAgICAgcHJvcGVydHkuZ2V0VmFsdWUoKTtcclxuICAgICAgfVxyXG4gICAgICB2YWwgPSBwcm9wZXJ0eS52ICogbXVsdDtcclxuICAgICAgaWYgKGV4cHJlc3Npb25WYWx1ZS52YWx1ZSAhPT0gdmFsKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvblZhbHVlID0gbmV3IE51bWJlcih2YWwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xyXG4gICAgICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZSA9IHZhbDtcclxuICAgICAgICBjb21wbGV0ZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgcHJvcGVydHksICd1bmlkaW1lbnNpb25hbCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBleHByZXNzaW9uVmFsdWU7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KSB7XHJcbiAgICBpZiAoIXByb3BlcnR5IHx8ICEoJ3B2JyBpbiBwcm9wZXJ0eSkpIHtcclxuICAgICAgcHJvcGVydHkgPSBkZWZhdWx0TXVsdGlkaW1lbnNpb25hbFZhbHVlO1xyXG4gICAgfVxyXG4gICAgdmFyIG11bHQgPSAxIC8gcHJvcGVydHkubXVsdDtcclxuICAgIHZhciBsZW4gPSAocHJvcGVydHkuZGF0YSAmJiBwcm9wZXJ0eS5kYXRhLmwpIHx8IHByb3BlcnR5LnB2Lmxlbmd0aDtcclxuICAgIHZhciBleHByZXNzaW9uVmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgIHZhciBhcnJWYWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgZXhwcmVzc2lvblZhbHVlLnZhbHVlID0gYXJyVmFsdWU7XHJcbiAgICBjb21wbGV0ZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgcHJvcGVydHksICdtdWx0aWRpbWVuc2lvbmFsJyk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHByb3BlcnR5LmspIHtcclxuICAgICAgICBwcm9wZXJ0eS5nZXRWYWx1ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBhcnJWYWx1ZVtpXSA9IHByb3BlcnR5LnZbaV0gKiBtdWx0O1xyXG4gICAgICAgIGV4cHJlc3Npb25WYWx1ZVtpXSA9IGFyclZhbHVlW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBleHByZXNzaW9uVmFsdWU7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogdHJ5IHRvIGF2b2lkIHVzaW5nIHRoaXMgZ2V0dGVyXHJcbiAgZnVuY3Rpb24gZGVmYXVsdEdldHRlcigpIHtcclxuICAgIHJldHVybiBkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAocHJvcGVydHkpIHtcclxuICAgIGlmICghcHJvcGVydHkpIHtcclxuICAgICAgcmV0dXJuIGRlZmF1bHRHZXR0ZXI7XHJcbiAgICB9IGlmIChwcm9wZXJ0eS5wcm9wVHlwZSA9PT0gJ3VuaWRpbWVuc2lvbmFsJykge1xyXG4gICAgICByZXR1cm4gVW5pZGltZW5zaW9uYWxQcm9wZXJ0eUludGVyZmFjZShwcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KTtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuLyogZ2xvYmFsIGV4cHJlc3Npb25IZWxwZXJzLCBUZXh0U2VsZWN0b3JQcm9wLCBFeHByZXNzaW9uTWFuYWdlciAqL1xyXG4vKiBleHBvcnRlZCBUZXh0RXhwcmVzc2lvblNlbGVjdG9yUHJvcEZhY3RvcnkgKi9cclxuXHJcbnZhciBUZXh0RXhwcmVzc2lvblNlbGVjdG9yUHJvcEZhY3RvcnkgPSAoZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiAgZnVuY3Rpb24gZ2V0VmFsdWVQcm94eShpbmRleCwgdG90YWwpIHtcclxuICAgIHRoaXMudGV4dEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgdGhpcy50ZXh0VG90YWwgPSB0b3RhbDtcclxuICAgIHRoaXMudiA9IHRoaXMuZ2V0VmFsdWUoKSAqIHRoaXMubXVsdDtcclxuICAgIHJldHVybiB0aGlzLnY7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcclxuICAgIHRoaXMucHYgPSAxO1xyXG4gICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgIHRoaXMubXVsdCA9IDAuMDE7XHJcbiAgICB0aGlzLnByb3BUeXBlID0gJ3RleHRTZWxlY3Rvcic7XHJcbiAgICB0aGlzLnRleHRUb3RhbCA9IGRhdGEudG90YWxDaGFycztcclxuICAgIHRoaXMuc2VsZWN0b3JWYWx1ZSA9IDEwMDtcclxuICAgIHRoaXMubGFzdFZhbHVlID0gWzEsIDEsIDFdO1xyXG4gICAgdGhpcy5rID0gdHJ1ZTtcclxuICAgIHRoaXMueCA9IHRydWU7XHJcbiAgICB0aGlzLmdldFZhbHVlID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uLmJpbmQodGhpcykoZWxlbSwgZGF0YSwgdGhpcyk7XHJcbiAgICB0aGlzLmdldE11bHQgPSBnZXRWYWx1ZVByb3h5O1xyXG4gICAgdGhpcy5nZXRWZWxvY2l0eUF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFZlbG9jaXR5QXRUaW1lO1xyXG4gICAgaWYgKHRoaXMua2YpIHtcclxuICAgICAgdGhpcy5nZXRWYWx1ZUF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFZhbHVlQXRUaW1lLmJpbmQodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmdldFZhbHVlQXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0U3RhdGljVmFsdWVBdFRpbWUuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0R3JvdXBQcm9wZXJ0eSA9IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHk7XHJcbiAgfTtcclxufSgpKTtcclxuXHJcbnZhciBwcm9wZXJ0eUdldFRleHRQcm9wID0gVGV4dFNlbGVjdG9yUHJvcC5nZXRUZXh0U2VsZWN0b3JQcm9wO1xyXG5UZXh0U2VsZWN0b3JQcm9wLmdldFRleHRTZWxlY3RvclByb3AgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSwgYXJyKSB7XHJcbiAgaWYgKGRhdGEudCA9PT0gMSkge1xyXG4gICAgcmV0dXJuIG5ldyBUZXh0RXhwcmVzc2lvblNlbGVjdG9yUHJvcEZhY3RvcnkoZWxlbSwgZGF0YSwgYXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxyXG4gIH1cclxuICByZXR1cm4gcHJvcGVydHlHZXRUZXh0UHJvcChlbGVtLCBkYXRhLCBhcnIpO1xyXG59O1xyXG5cclxuLyogZ2xvYmFsIFByb3BlcnR5RmFjdG9yeSAqL1xyXG4vKiBleHBvcnRlZCBTbGlkZXJFZmZlY3QsIEFuZ2xlRWZmZWN0LCBDb2xvckVmZmVjdCwgUG9pbnRFZmZlY3QsIExheWVySW5kZXhFZmZlY3QsIE1hc2tJbmRleEVmZmVjdCwgQ2hlY2tib3hFZmZlY3QsIE5vVmFsdWVFZmZlY3QgKi9cclxuXHJcbmZ1bmN0aW9uIFNsaWRlckVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcclxuICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XHJcbn1cclxuZnVuY3Rpb24gQW5nbGVFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XHJcbiAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIENvbG9yRWZmZWN0KGRhdGEsIGVsZW0sIGNvbnRhaW5lcikge1xyXG4gIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudiwgMSwgMCwgY29udGFpbmVyKTtcclxufVxyXG5mdW5jdGlvbiBQb2ludEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcclxuICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDEsIDAsIGNvbnRhaW5lcik7XHJcbn1cclxuZnVuY3Rpb24gTGF5ZXJJbmRleEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcclxuICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XHJcbn1cclxuZnVuY3Rpb24gTWFza0luZGV4RWZmZWN0KGRhdGEsIGVsZW0sIGNvbnRhaW5lcikge1xyXG4gIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudiwgMCwgMCwgY29udGFpbmVyKTtcclxufVxyXG5mdW5jdGlvbiBDaGVja2JveEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcclxuICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XHJcbn1cclxuZnVuY3Rpb24gTm9WYWx1ZUVmZmVjdCgpIHtcclxuICB0aGlzLnAgPSB7fTtcclxufVxyXG5cclxuLyogZ2xvYmFsIGV4dGVuZFByb3RvdHlwZSwgU2xpZGVyRWZmZWN0LCBBbmdsZUVmZmVjdCwgQ29sb3JFZmZlY3QsIFBvaW50RWZmZWN0LCBDaGVja2JveEVmZmVjdCwgTGF5ZXJJbmRleEVmZmVjdCxcclxuTWFza0luZGV4RWZmZWN0LCBOb1ZhbHVlRWZmZWN0LCBEeW5hbWljUHJvcGVydHlDb250YWluZXIgKi9cclxuXHJcbmZ1bmN0aW9uIEVmZmVjdHNNYW5hZ2VyKGRhdGEsIGVsZW1lbnQpIHtcclxuICB2YXIgZWZmZWN0cyA9IGRhdGEuZWYgfHwgW107XHJcbiAgdGhpcy5lZmZlY3RFbGVtZW50cyA9IFtdO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSBlZmZlY3RzLmxlbmd0aDtcclxuICB2YXIgZWZmZWN0SXRlbTtcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgIGVmZmVjdEl0ZW0gPSBuZXcgR3JvdXBFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCk7XHJcbiAgICB0aGlzLmVmZmVjdEVsZW1lbnRzLnB1c2goZWZmZWN0SXRlbSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBHcm91cEVmZmVjdChkYXRhLCBlbGVtZW50KSB7XHJcbiAgdGhpcy5pbml0KGRhdGEsIGVsZW1lbnQpO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIEdyb3VwRWZmZWN0KTtcclxuXHJcbkdyb3VwRWZmZWN0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IEdyb3VwRWZmZWN0LnByb3RvdHlwZS5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XHJcblxyXG5Hcm91cEVmZmVjdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChkYXRhLCBlbGVtZW50KSB7XHJcbiAgdGhpcy5kYXRhID0gZGF0YTtcclxuICB0aGlzLmVmZmVjdEVsZW1lbnRzID0gW107XHJcbiAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW1lbnQpO1xyXG4gIHZhciBpO1xyXG4gIHZhciBsZW4gPSB0aGlzLmRhdGEuZWYubGVuZ3RoO1xyXG4gIHZhciBlZmY7XHJcbiAgdmFyIGVmZmVjdHMgPSB0aGlzLmRhdGEuZWY7XHJcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBlZmYgPSBudWxsO1xyXG4gICAgc3dpdGNoIChlZmZlY3RzW2ldLnR5KSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICBlZmYgPSBuZXcgU2xpZGVyRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgZWZmID0gbmV3IEFuZ2xlRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgZWZmID0gbmV3IENvbG9yRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgZWZmID0gbmV3IFBvaW50RWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDQ6XHJcbiAgICAgIGNhc2UgNzpcclxuICAgICAgICBlZmYgPSBuZXcgQ2hlY2tib3hFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgZWZmID0gbmV3IExheWVySW5kZXhFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgZWZmID0gbmV3IE1hc2tJbmRleEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA1OlxyXG4gICAgICAgIGVmZiA9IG5ldyBFZmZlY3RzTWFuYWdlcihlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBjYXNlIDY6XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgZWZmID0gbmV3IE5vVmFsdWVFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpZiAoZWZmKSB7XHJcbiAgICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmYpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblxyXG52YXIgbG90dGllID0ge307XHJcblxyXG5mdW5jdGlvbiBzZXRMb2NhdGlvbkhyZWYoaHJlZikge1xyXG4gIGxvY2F0aW9uSHJlZiA9IGhyZWY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlYXJjaEFuaW1hdGlvbnMoKSB7XHJcbiAgaWYgKHN0YW5kYWxvbmUgPT09IHRydWUpIHtcclxuICAgIGFuaW1hdGlvbk1hbmFnZXIuc2VhcmNoQW5pbWF0aW9ucyhhbmltYXRpb25EYXRhLCBzdGFuZGFsb25lLCByZW5kZXJlcik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFuaW1hdGlvbk1hbmFnZXIuc2VhcmNoQW5pbWF0aW9ucygpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0U3ViZnJhbWVSZW5kZXJpbmcoZmxhZykge1xyXG4gIHN1YmZyYW1lRW5hYmxlZCA9IGZsYWc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldElEUHJlZml4KHByZWZpeCkge1xyXG4gIGlkUHJlZml4ID0gcHJlZml4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcykge1xyXG4gIGlmIChzdGFuZGFsb25lID09PSB0cnVlKSB7XHJcbiAgICBwYXJhbXMuYW5pbWF0aW9uRGF0YSA9IEpTT04ucGFyc2UoYW5pbWF0aW9uRGF0YSk7XHJcbiAgfVxyXG4gIHJldHVybiBhbmltYXRpb25NYW5hZ2VyLmxvYWRBbmltYXRpb24ocGFyYW1zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0UXVhbGl0eSh2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XHJcbiAgICAgIGNhc2UgJ2hpZ2gnOlxyXG4gICAgICAgIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gMjAwO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICBjYXNlICdtZWRpdW0nOlxyXG4gICAgICAgIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gNTA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2xvdyc6XHJcbiAgICAgICAgZGVmYXVsdEN1cnZlU2VnbWVudHMgPSAxMDtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKCFpc05hTih2YWx1ZSkgJiYgdmFsdWUgPiAxKSB7XHJcbiAgICBkZWZhdWx0Q3VydmVTZWdtZW50cyA9IHZhbHVlO1xyXG4gIH1cclxuICBpZiAoZGVmYXVsdEN1cnZlU2VnbWVudHMgPj0gNTApIHtcclxuICAgIHJvdW5kVmFsdWVzKGZhbHNlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcm91bmRWYWx1ZXModHJ1ZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbkJyb3dzZXIoKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnN0YWxsUGx1Z2luKHR5cGUsIHBsdWdpbikge1xyXG4gIGlmICh0eXBlID09PSAnZXhwcmVzc2lvbnMnKSB7XHJcbiAgICBleHByZXNzaW9uc1BsdWdpbiA9IHBsdWdpbjtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZhY3RvcnkobmFtZSkge1xyXG4gIHN3aXRjaCAobmFtZSkge1xyXG4gICAgY2FzZSAncHJvcGVydHlGYWN0b3J5JzpcclxuICAgICAgcmV0dXJuIFByb3BlcnR5RmFjdG9yeTtcclxuICAgIGNhc2UgJ3NoYXBlUHJvcGVydHlGYWN0b3J5JzpcclxuICAgICAgcmV0dXJuIFNoYXBlUHJvcGVydHlGYWN0b3J5O1xyXG4gICAgY2FzZSAnbWF0cml4JzpcclxuICAgICAgcmV0dXJuIE1hdHJpeDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxubG90dGllLnBsYXkgPSBhbmltYXRpb25NYW5hZ2VyLnBsYXk7XHJcbmxvdHRpZS5wYXVzZSA9IGFuaW1hdGlvbk1hbmFnZXIucGF1c2U7XHJcbmxvdHRpZS5zZXRMb2NhdGlvbkhyZWYgPSBzZXRMb2NhdGlvbkhyZWY7XHJcbmxvdHRpZS50b2dnbGVQYXVzZSA9IGFuaW1hdGlvbk1hbmFnZXIudG9nZ2xlUGF1c2U7XHJcbmxvdHRpZS5zZXRTcGVlZCA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0U3BlZWQ7XHJcbmxvdHRpZS5zZXREaXJlY3Rpb24gPSBhbmltYXRpb25NYW5hZ2VyLnNldERpcmVjdGlvbjtcclxubG90dGllLnN0b3AgPSBhbmltYXRpb25NYW5hZ2VyLnN0b3A7XHJcbmxvdHRpZS5zZWFyY2hBbmltYXRpb25zID0gc2VhcmNoQW5pbWF0aW9ucztcclxubG90dGllLnJlZ2lzdGVyQW5pbWF0aW9uID0gYW5pbWF0aW9uTWFuYWdlci5yZWdpc3RlckFuaW1hdGlvbjtcclxubG90dGllLmxvYWRBbmltYXRpb24gPSBsb2FkQW5pbWF0aW9uO1xyXG5sb3R0aWUuc2V0U3ViZnJhbWVSZW5kZXJpbmcgPSBzZXRTdWJmcmFtZVJlbmRlcmluZztcclxubG90dGllLnJlc2l6ZSA9IGFuaW1hdGlvbk1hbmFnZXIucmVzaXplO1xyXG4vLyBsb3R0aWUuc3RhcnQgPSBzdGFydDtcclxubG90dGllLmdvVG9BbmRTdG9wID0gYW5pbWF0aW9uTWFuYWdlci5nb1RvQW5kU3RvcDtcclxubG90dGllLmRlc3Ryb3kgPSBhbmltYXRpb25NYW5hZ2VyLmRlc3Ryb3k7XHJcbmxvdHRpZS5zZXRRdWFsaXR5ID0gc2V0UXVhbGl0eTtcclxubG90dGllLmluQnJvd3NlciA9IGluQnJvd3NlcjtcclxubG90dGllLmluc3RhbGxQbHVnaW4gPSBpbnN0YWxsUGx1Z2luO1xyXG5sb3R0aWUuZnJlZXplID0gYW5pbWF0aW9uTWFuYWdlci5mcmVlemU7XHJcbmxvdHRpZS51bmZyZWV6ZSA9IGFuaW1hdGlvbk1hbmFnZXIudW5mcmVlemU7XHJcbmxvdHRpZS5zZXRWb2x1bWUgPSBhbmltYXRpb25NYW5hZ2VyLnNldFZvbHVtZTtcclxubG90dGllLm11dGUgPSBhbmltYXRpb25NYW5hZ2VyLm11dGU7XHJcbmxvdHRpZS51bm11dGUgPSBhbmltYXRpb25NYW5hZ2VyLnVubXV0ZTtcclxubG90dGllLmdldFJlZ2lzdGVyZWRBbmltYXRpb25zID0gYW5pbWF0aW9uTWFuYWdlci5nZXRSZWdpc3RlcmVkQW5pbWF0aW9ucztcclxubG90dGllLnNldElEUHJlZml4ID0gc2V0SURQcmVmaXg7XHJcbmxvdHRpZS5fX2dldEZhY3RvcnkgPSBnZXRGYWN0b3J5O1xyXG5sb3R0aWUudmVyc2lvbiA9ICc1LjcuMTQnO1xyXG5cclxuZnVuY3Rpb24gY2hlY2tSZWFkeSgpIHtcclxuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG4gICAgY2xlYXJJbnRlcnZhbChyZWFkeVN0YXRlQ2hlY2tJbnRlcnZhbCk7XHJcbiAgICBzZWFyY2hBbmltYXRpb25zKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRRdWVyeVZhcmlhYmxlKHZhcmlhYmxlKSB7XHJcbiAgdmFyIHZhcnMgPSBxdWVyeVN0cmluZy5zcGxpdCgnJicpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICBpZiAoZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pID09IHZhcmlhYmxlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcbnZhciBzdGFuZGFsb25lID0gJ19fW1NUQU5EQUxPTkVdX18nO1xyXG52YXIgYW5pbWF0aW9uRGF0YSA9ICdfX1tBTklNQVRJT05EQVRBXV9fJztcclxudmFyIHJlbmRlcmVyID0gJyc7XHJcbnZhciBxdWVyeVN0cmluZztcclxuaWYgKHN0YW5kYWxvbmUpIHtcclxuICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcclxuICB2YXIgaW5kZXggPSBzY3JpcHRzLmxlbmd0aCAtIDE7XHJcbiAgdmFyIG15U2NyaXB0ID0gc2NyaXB0c1tpbmRleF0gfHwge1xyXG4gICAgc3JjOiAnJyxcclxuICB9O1xyXG4gIHF1ZXJ5U3RyaW5nID0gbXlTY3JpcHQuc3JjLnJlcGxhY2UoL15bXlxcP10rXFw/Py8sICcnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxyXG4gIHJlbmRlcmVyID0gZ2V0UXVlcnlWYXJpYWJsZSgncmVuZGVyZXInKTtcclxufVxyXG52YXIgcmVhZHlTdGF0ZUNoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjaGVja1JlYWR5LCAxMDApO1xyXG5cbnJldHVybiBsb3R0aWU7XG59KSk7IiwiKGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUubG9nKCdhY2NvcmRpb24nKTtcbiAgY29uc3QgYWNjb3JkaW9ucz1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWNjb3JkaW9uX19pdGVtJyk7XG4gIGFjY29yZGlvbnMuZm9yRWFjaChlbCA9PiB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZiA9IGUuY3VycmVudFRhcmdldDtcbiAgICAgIGNvbnN0IGNvbnRyb2wgPSBzZWxmLnF1ZXJ5U2VsZWN0b3IoJy5hY2NvcmRpb25fX2NvbnRyb2wnKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBzZWxmLnF1ZXJ5U2VsZWN0b3IoJy5hY2NvcmRpb25fX2NvbnRlbnQnKTtcbiAgICAgIHNlbGYuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpO1xuXG4gICAgICBpZiggc2VsZi5jbGFzc0xpc3QuY29udGFpbnMoJ29wZW4nKSkge1xuICAgICAgICBjb250cm9sLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgICAgICBjb250ZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG4gICAgICAgIGNvbnRlbnQuc3R5bGUubWF4SGVpZ2h0ID0gY29udGVudC5zY3JvbGxIZWlnaHQgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgICBjb250ZW50LnN0eWxlLm1heEhlaWdodCA9IG51bGw7XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pKClcbiIsIihmdW5jdGlvbigpe1xuXG4gIGNvbnNvbGUubG9nKCdhbmltYXRpb24gbG90dGllJyk7XG5cbiAgY29uc3QgYW5pbSA9IGxvdHRpZVxuXG4gIC8vIHByb21vdGUtbG90dGllMVxuXG4gIGFuaW0ubG9hZEFuaW1hdGlvbih7XG4gICAgY29udGFpbmVyOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcHJvbW90ZS1sb3R0aWUxJyksXG4gICAgcmVuZGVyZWQ6ICdzdmcnLFxuICAgIGxvb3A6IHRydWUsXG4gICAgYXV0b3BsYXk6IHRydWUsXG4gICAgcGF0aDogJy4vanNvbi9wcm9tb3RlLWxvdHRpZTEuanNvbicsXG4gIH0pXG5cbiAgYW5pbS5sb2FkQW5pbWF0aW9uKHtcbiAgICBjb250YWluZXI6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwcm9tb3RlLWxvdHRpZTInKSxcbiAgICByZW5kZXJlZDogJ3N2ZycsXG4gICAgbG9vcDogdHJ1ZSxcbiAgICBhdXRvcGxheTogdHJ1ZSxcbiAgICBwYXRoOiAnLi9qc29uL3Byb21vdGUtbG90dGllMi5qc29uJyxcbiAgfSlcblxuICBhbmltLmxvYWRBbmltYXRpb24oe1xuICAgIGNvbnRhaW5lcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Byb21vdGUtbG90dGllMycpLFxuICAgIHJlbmRlcmVkOiAnc3ZnJyxcbiAgICBsb29wOiB0cnVlLFxuICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgIHBhdGg6ICcuL2pzb24vcHJvbW90ZS1sb3R0aWUzLmpzb24nLFxuICB9KVxuXG4gIGFuaW0ubG9hZEFuaW1hdGlvbih7XG4gICAgY29udGFpbmVyOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcHJvbW90ZS1sb3R0aWU0JyksXG4gICAgcmVuZGVyZWQ6ICdzdmcnLFxuICAgIGxvb3A6IHRydWUsXG4gICAgYXV0b3BsYXk6IHRydWUsXG4gICAgcGF0aDogJy4vanNvbi9wcm9tb3RlLWxvdHRpZTQuanNvbicsXG4gIH0pXG5cblxuICBhbmltLmxvYWRBbmltYXRpb24oe1xuICAgIGNvbnRhaW5lcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NoZW1lLWxvdHRpZScpLFxuICAgIHJlbmRlcmVkOiAnc3ZnJyxcbiAgICBsb29wOiB0cnVlLFxuICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgIHBhdGg6ICcuL2pzb24vc2hlbWUtbG90dGllLmpzb24nLFxuICB9KVxuXG5cbiAgYW5pbS5sb2FkQW5pbWF0aW9uKHtcbiAgICBjb250YWluZXI6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNvcGluaW9uLWxvdHRpZScpLFxuICAgIHJlbmRlcmVkOiAnc3ZnJyxcbiAgICBsb29wOiB0cnVlLFxuICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgIHBhdGg6ICcuL2pzb24vb3Bpbmlvbi1sb3R0aWUuanNvbicsXG4gIH0pXG5cbiAgYW5pbS5sb2FkQW5pbWF0aW9uKHtcbiAgICBjb250YWluZXI6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdGFmZi1waG9uZScpLFxuICAgIHJlbmRlcmVkOiAnc3ZnJyxcbiAgICBsb29wOiB0cnVlLFxuICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgIHBhdGg6ICcuL2pzb24vc3RhZmYtcGhvbmUuanNvbicsXG4gIH0pXG5cblxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuICBjb25zb2xlLmxvZygnY2FyZSBwYXJhbGxheCcpO1xuXG4gIGNhcmVEZXZpY2VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhcmVfX2RldmljZXMnKTtcblxuICBpZiAoY2FyZURldmljZXMpIHtcblxuICAgIGNhcmVQaG9uZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXJlX19waG9uZScpO1xuICAgIGNhcmVNYWNib29rID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhcmVfX21hY2Jvb2snKTtcblxuXG4gIGNhcmVEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIChlKSA9PiB7XG5cblxuICAgIGNvbnN0IGVsID0gZS50YXJnZXQ7XG5cblxuICAgIHJ1blNjYWxlKCdjYXJlX19waG9uZScsIGNhcmVQaG9uZSwgdHJ1ZSk7XG4gICAgcnVuU2NhbGUoJ2NhcmVfX21hY2Jvb2snLCBjYXJlTWFjYm9vaywgZmFsc2UpO1xuXG4gICAgICAgZnVuY3Rpb24gcnVuU2NhbGUoY2xhc3NOYW1lLCBub2RlLCBkb2N1bWVudCkge1xuXG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSBkb2N1bWVudCA/IGB0cmFuc2Zvcm06IHNjYWxlKDEuMSkgcm90YXRlKC0xMGRlZylgIDogYHRyYW5zZm9ybTogc2NhbGUoMS4xKWA7XG5cblxuICAgICAgICAgIGlmKGVsLmNsYXNzTGlzdC5jb250YWlucyhgJHtjbGFzc05hbWV9YCkpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuY3NzVGV4dCA9IHRyYW5zZm9ybTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cblxuICB9KVxuXG4gICBjYXJlRGV2aWNlcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIChlKSA9PiB7XG5cblxuICAgIGNvbnN0IGVsID0gZS50YXJnZXQ7XG5cblxuICAgIHN0b3BTY2FsZSgnY2FyZV9fcGhvbmUnLCBjYXJlUGhvbmUpO1xuICAgIHN0b3BTY2FsZSgnY2FyZV9fbWFjYm9vaycsIGNhcmVNYWNib29rKTtcblxuICAgICAgIGZ1bmN0aW9uIHN0b3BTY2FsZShjbGFzc05hbWUsIG5vZGUpIHtcblxuICAgICAgICAgIGlmKGVsLmNsYXNzTGlzdC5jb250YWlucyhgJHtjbGFzc05hbWV9YCkpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuY3NzVGV4dCA9IGB0cmFuc2Zvcm06IGluaXRpYWxgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cblxuXG4gIH0pXG4gIH1cblxuXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUubG9nKCdoc20gcGFyYWxsYXgnKTtcblxuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhzbV9fZ3JhcGgtd3JhcCcpXG5cbiAgaWYgKHdyYXBwZXIpIHtcbiAgICBjb25zdCBoc21TZXNzaW9uID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yKCcuaHNtX19zZXNzaW9uJyk7XG4gICAgY29uc3QgaHNtQ2xhc3NlbWVudERlbW9uZGVzID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yKCcuaHNtX19jbGFzc2VtZW50LWRlbW9uZGVzJyk7XG4gICAgY29uc3QgaHNtVG90YWwgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5oc21fX3RvdGFsJyk7XG4gICAgY29uc3QgaHNtVGF1eCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLmhzbV9fdGF1eCcpO1xuXG4gICAgY29uc3QgaHNtQWN0aW9uSW1wYWN0TGFyZ2UgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5oc21fX2FjdGlvbi1pbXBhY3QtbGFyZ2UnKVxuICAgIGNvbnN0IGhzbVRyYWluZWQgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5oc21fX3RyYWluZWQnKTtcbiAgICBjb25zdCBoc21SZXBvcnQ9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLmhzbV9fcmVwb3J0Jyk7XG5cbiAgICBjb25zdCBoc21MZWF2ZXMgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5oc21fX2xlYXZlcycpO1xuICAgIGNvbnN0IGhzbVBlb3BsZXMgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5oc21fX3Blb3BsZXMnKTtcbiAgICBjb25zdCBoc21DaGVjayA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLmhzbV9fY2hlY2snKTtcbiAgICBjb25zdCBoc21Ib21lID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yKCcuaHNtX19ob21lJyk7XG5cbiAgICBjb25zdCBoc21Xb21hbiA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLmhzbV9fd29tYW4nKTtcbiAgICBjb25zdCBoc21Xb21hbjIgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5oc21fX3dvbWFuMicpO1xuICAgIGNvbnN0IGhzbU1hbiA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLmhzbV9fbWFuJyk7XG5cbiAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIChlKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IGUudGFyZ2V0LnBhcmVudE5vZGU7XG5cblxuICAgICBydW5TY2FsZSgnc2Vzc2lvbicsIGhzbVNlc3Npb24sIDMpXG4gICAgIHJ1blNjYWxlKCdjbGFzc2VtZW50LWRlbW9uZGVzJywgaHNtQ2xhc3NlbWVudERlbW9uZGVzLCAzKVxuICAgICBydW5TY2FsZSgndG90YWwnLCBoc21Ub3RhbCwgMylcbiAgICAgcnVuU2NhbGUoJ3RhdXgnLCBoc21UYXV4LCAyKVxuICAgICBydW5TY2FsZSgnYWN0aW9uLWltcGFjdC1sYXJnZScsIGhzbUFjdGlvbkltcGFjdExhcmdlLCAyKVxuICAgICBydW5TY2FsZSgnaHNtX190cmFpbmVkJywgaHNtVHJhaW5lZCwgMSlcbiAgICAgcnVuU2NhbGUoJ2hzbV9fcmVwb3J0JywgaHNtUmVwb3J0LCAxKVxuICAgICBydW5TY2FsZSgnaHNtX19sZWF2ZXMnLCBoc21MZWF2ZXMsIDEpXG4gICAgIHJ1blNjYWxlKCdoc21fX3Blb3BsZXMnLCBoc21QZW9wbGVzLCAxKVxuICAgICBydW5TY2FsZSgnaHNtX19jaGVjaycsIGhzbUNoZWNrLCAxKVxuICAgICBydW5TY2FsZSgnaHNtX19ob21lJywgaHNtSG9tZSwgMSlcbiAgICAgcnVuU2NhbGUoJ2hzbV9fd29tYW4nLCBoc21Xb21hbiwgMSlcbiAgICAgcnVuU2NhbGUoJ2hzbV9fd29tYW4yJywgaHNtV29tYW4yLCAxKVxuICAgICBydW5TY2FsZSgnaHNtX19tYW4nLCBoc21NYW4sIDEpXG5cbiAgICAgIGZ1bmN0aW9uIHJ1blNjYWxlKGNsYXNzTmFtZSwgbm9kZSwgY29lZmZpY2llbnQpIHtcbiAgICAgICAgbGV0IHNjYWxlVmFsdWUgPSAnMC4zJztcbiAgICAgICAgc3dpdGNoIChjb2VmZmljaWVudCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHNjYWxlVmFsdWUgPSAnMC44JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHNjYWxlVmFsdWUgPSAnMC43JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHNjYWxlVmFsdWUgPSAnMC42JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgICBpZihlbC5jbGFzc0xpc3QuY29udGFpbnMoYCR7Y2xhc3NOYW1lfWApKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBgdHJhbnNmb3JtOiBzY2FsZSgke3NjYWxlVmFsdWV9KWA7XG4gICAgICAgICAgfTtcblxuICAgICAgICB9XG5cblxuICAgIH0pXG5cblxuXG4gICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIChlKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IGUudGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgICAgc3RvcFNjYWxlKCdzZXNzaW9uJywgaHNtU2Vzc2lvbilcbiAgICAgc3RvcFNjYWxlKCdjbGFzc2VtZW50LWRlbW9uZGVzJywgaHNtQ2xhc3NlbWVudERlbW9uZGVzKVxuICAgICBzdG9wU2NhbGUoJ3RvdGFsJywgaHNtVG90YWwpXG4gICAgIHN0b3BTY2FsZSgndGF1eCcsIGhzbVRhdXgpXG4gICAgIHN0b3BTY2FsZSgnYWN0aW9uLWltcGFjdC1sYXJnZScsIGhzbUFjdGlvbkltcGFjdExhcmdlKVxuICAgICBzdG9wU2NhbGUoJ2hzbV9fdHJhaW5lZCcsIGhzbVRyYWluZWQpXG4gICAgIHN0b3BTY2FsZSgnaHNtX19yZXBvcnQnLCBoc21SZXBvcnQpXG4gICAgIHN0b3BTY2FsZSgnaHNtX19sZWF2ZXMnLCBoc21MZWF2ZXMpXG4gICAgIHN0b3BTY2FsZSgnaHNtX19wZW9wbGVzJywgaHNtUGVvcGxlcylcbiAgICAgc3RvcFNjYWxlKCdoc21fX2NoZWNrJywgaHNtQ2hlY2spXG4gICAgIHN0b3BTY2FsZSgnaHNtX19ob21lJywgaHNtSG9tZSlcbiAgICAgc3RvcFNjYWxlKCdoc21fX3dvbWFuJywgaHNtV29tYW4pXG4gICAgIHN0b3BTY2FsZSgnaHNtX193b21hbjInLCBoc21Xb21hbjIpXG4gICAgIHN0b3BTY2FsZSgnaHNtX19tYW4nLCBoc21NYW4pXG5cbiAgICAgICAgZnVuY3Rpb24gc3RvcFNjYWxlKGNsYXNzTmFtZSwgbm9kZSkge1xuXG4gICAgICAgICAgaWYoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGAke2NsYXNzTmFtZX1gKSkge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID0gYHRyYW5zZm9ybTogaW5pdGlhbGA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG5cbiAgfSlcblxuICB9XG59KSgpXG4iLCIoZnVuY3Rpb24oKXtcbiAgY29uc29sZS5sb2coJ21hbmFnZSBwYXJhbGxheCcpO1xuXG4gIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFuYWdlX19ncmFwaC13cmFwJylcblxuICBpZiAod3JhcHBlcikge1xuICAgIGNvbnN0IG1hbmFnZUVtcGxveWVlciA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLm1hbmFnZV9fZW1wbG95ZWVyJyk7XG4gICAgY29uc3QgbWFuYWdlVHJhaW5lZCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLm1hbmFnZV9fdHJhaW5lZCcpO1xuICAgIGNvbnN0IG1hbmFnZUFjdGlvbkltcGFjdCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLm1hbmFnZV9fYWN0aW9uLWltcGFjdCcpXG4gICAgY29uc3QgbWFuYWdlTGFzdE1vbnRoID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yKCcubWFuYWdlX19sYXN0LW1vbnRoJylcbiAgICBjb25zdCBtYW5hZ2VDbGFzc2VtZW50RGVtb25kZXMgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5tYW5hZ2VfX2NsYXNzZW1lbnQtZGVtb25kZXMnKTtcbiAgICBjb25zdCBtYW5hZ2VUb3RhbCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLm1hbmFnZV9fdG90YWwnKTtcblxuICAgIGNvbnN0IG1hbmFnZUFjdGlvbkltcGFjdExhcmdlID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yKCcubWFuYWdlX19hY3Rpb24taW1wYWN0LWxhcmdlJylcblxuXG5cbiAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIChlKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IGUudGFyZ2V0LnBhcmVudE5vZGU7XG5cblxuICAgICBydW5TY2FsZSgnbWFuYWdlX19lbXBsb3llZXInLCBtYW5hZ2VFbXBsb3llZXIsIDEpXG4gICAgIHJ1blNjYWxlKCdtYW5hZ2VfX3RyYWluZWQnLCBtYW5hZ2VUcmFpbmVkLCAxKVxuICAgICBydW5TY2FsZSgnbWFuYWdlX19hY3Rpb24taW1wYWN0JywgbWFuYWdlQWN0aW9uSW1wYWN0LCAxKVxuICAgICBydW5TY2FsZSgnbWFuYWdlX19sYXN0LW1vbnRoJywgbWFuYWdlTGFzdE1vbnRoLCAxKVxuICAgICBydW5TY2FsZSgnY2xhc3NlbWVudC1kZW1vbmRlcycsIG1hbmFnZUNsYXNzZW1lbnREZW1vbmRlcywgMylcbiAgICAgcnVuU2NhbGUoJ3RvdGFsJywgbWFuYWdlVG90YWwsIDMpXG4gICAgIHJ1blNjYWxlKCdhY3Rpb24taW1wYWN0LWxhcmdlJywgbWFuYWdlQWN0aW9uSW1wYWN0TGFyZ2UsIDIpXG5cblxuXG4gICAgICBmdW5jdGlvbiBydW5TY2FsZShjbGFzc05hbWUsIG5vZGUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgIGxldCBzY2FsZVZhbHVlID0gJzAuMyc7XG4gICAgICAgIHN3aXRjaCAoY29lZmZpY2llbnQpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzY2FsZVZhbHVlID0gJzAuOCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBzY2FsZVZhbHVlID0gJzAuNyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzY2FsZVZhbHVlID0gJzAuNic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuXG4gICAgICAgICAgaWYoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGAke2NsYXNzTmFtZX1gKSkge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID0gYHRyYW5zZm9ybTogc2NhbGUoJHtzY2FsZVZhbHVlfSlgO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuXG5cbiAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgKGUpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gZS50YXJnZXQucGFyZW50Tm9kZTtcblxuXG5cbiAgICAgc3RvcFNjYWxlKCdtYW5hZ2VfX2VtcGxveWVlcicsIG1hbmFnZUVtcGxveWVlcilcbiAgICAgc3RvcFNjYWxlKCdtYW5hZ2VfX3RyYWluZWQnLCBtYW5hZ2VUcmFpbmVkKVxuICAgICBzdG9wU2NhbGUoJ21hbmFnZV9fYWN0aW9uLWltcGFjdCcsIG1hbmFnZUFjdGlvbkltcGFjdClcbiAgICAgc3RvcFNjYWxlKCdtYW5hZ2VfX2xhc3QtbW9udGgnLCBtYW5hZ2VMYXN0TW9udGgpXG4gICAgIHN0b3BTY2FsZSgnY2xhc3NlbWVudC1kZW1vbmRlcycsIG1hbmFnZUNsYXNzZW1lbnREZW1vbmRlcylcbiAgICAgc3RvcFNjYWxlKCd0b3RhbCcsIG1hbmFnZVRvdGFsKVxuICAgICBzdG9wU2NhbGUoJ2FjdGlvbi1pbXBhY3QtbGFyZ2UnLCBtYW5hZ2VBY3Rpb25JbXBhY3RMYXJnZSlcblxuICAgIGZ1bmN0aW9uIHN0b3BTY2FsZShjbGFzc05hbWUsIG5vZGUpIHtcblxuICAgICAgaWYoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGAke2NsYXNzTmFtZX1gKSkge1xuICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBgdHJhbnNmb3JtOiBpbml0aWFsYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSlcblxuXG5cbiAgICB9KVxuXG4gIH1cbn0pKClcbiIsIihmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJ21lbnUnKTtcbiAgY29uc3QgbWVudVRvZ2dsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZW51X190b2dnbGUnKTtcbiAgY29uc3QgbWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZW51Jyk7XG4gIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JylcblxuICBtZW51VG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgbWVudS5jbGFzc0xpc3QudG9nZ2xlKCdtZW51LS1vcGVuZWQnKVxuICAgIGJvZHkuY2xhc3NMaXN0LnRvZ2dsZSgnYm9keS0tbG9ja2VkJylcbiAgfSlcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgLy8gY29uc29sZS5sb2coJzInKTtcbiAgLy8gY29uc3QgdmlkZW8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudmlkZW8nKTtcbiAgLy8gY29uc3QgdmlkZW9CdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudmlkZW9fX2J0bicpO1xuICAvLyB2aWRlb0J0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXG4gIC8vICAgLy8gMi4gVGhpcyBjb2RlIGxvYWRzIHRoZSBJRnJhbWUgUGxheWVyIEFQSSBjb2RlIGFzeW5jaHJvbm91c2x5LlxuICAvLyAgIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICAvLyAgIHRhZy5zcmMgPSBcImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2lmcmFtZV9hcGlcIjtcbiAgLy8gICB2YXIgZmlyc3RTY3JpcHRUYWcgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG5cbiAgLy8gICBjb25zb2xlLmxvZyhmaXJzdFNjcmlwdFRhZy5wYXJlbnROb2RlKTtcbiAgLy8gICBmaXJzdFNjcmlwdFRhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YWcsIGZpcnN0U2NyaXB0VGFnKTtcblxuICAvLyAgIC8vIDMuIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhbiA8aWZyYW1lPiAoYW5kIFlvdVR1YmUgcGxheWVyKVxuICAvLyAgIC8vICAgIGFmdGVyIHRoZSBBUEkgY29kZSBkb3dubG9hZHMuXG4gIC8vICAgdmFyIHBsYXllcjtcblxuICAvLyAgIGZ1bmN0aW9uIG9uWW91VHViZUlmcmFtZUFQSVJlYWR5KCkge1xuICAvLyAgICAgcGxheWVyID0gbmV3IFlULlBsYXllcigndmlkZW9fX3BsYXllcicsIHtcbiAgLy8gICAgICAgaGVpZ2h0OiAnMzYwJyxcbiAgLy8gICAgICAgd2lkdGg6ICc2NDAnLFxuICAvLyAgICAgICB2aWRlb0lkOiAnTTdsYzFVVmYtVkUnLFxuICAvLyAgICAgICBldmVudHM6IHtcbiAgLy8gICAgICAgICAnb25SZWFkeSc6IG9uUGxheWVyUmVhZHksXG4gIC8vICAgICAgICAgJ29uU3RhdGVDaGFuZ2UnOiBvblBsYXllclN0YXRlQ2hhbmdlXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH0pO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIDQuIFRoZSBBUEkgd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gd2hlbiB0aGUgdmlkZW8gcGxheWVyIGlzIHJlYWR5LlxuICAvLyAgIGZ1bmN0aW9uIG9uUGxheWVyUmVhZHkoZXZlbnQpIHtcbiAgLy8gICAgIGV2ZW50LnRhcmdldC5wbGF5VmlkZW8oKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyA1LiBUaGUgQVBJIGNhbGxzIHRoaXMgZnVuY3Rpb24gd2hlbiB0aGUgcGxheWVyJ3Mgc3RhdGUgY2hhbmdlcy5cbiAgLy8gICAvLyAgICBUaGUgZnVuY3Rpb24gaW5kaWNhdGVzIHRoYXQgd2hlbiBwbGF5aW5nIGEgdmlkZW8gKHN0YXRlPTEpLFxuICAvLyAgIC8vICAgIHRoZSBwbGF5ZXIgc2hvdWxkIHBsYXkgZm9yIHNpeCBzZWNvbmRzIGFuZCB0aGVuIHN0b3AuXG4gIC8vICAgdmFyIGRvbmUgPSBmYWxzZTtcblxuICAvLyAgIGZ1bmN0aW9uIG9uUGxheWVyU3RhdGVDaGFuZ2UoZXZlbnQpIHtcbiAgLy8gICAgIGlmIChldmVudC5kYXRhID09IFlULlBsYXllclN0YXRlLlBMQVlJTkcgJiYgIWRvbmUpIHtcbiAgLy8gICAgICAgc2V0VGltZW91dChzdG9wVmlkZW8sIDYwMDApO1xuICAvLyAgICAgICBkb25lID0gdHJ1ZTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG5cbiAgLy8gICBmdW5jdGlvbiBzdG9wVmlkZW8oKSB7XG4gIC8vICAgICBwbGF5ZXIuc3RvcFZpZGVvKCk7XG4gIC8vICAgfVxuXG4gIC8vIH0pXG5cblxufSkoKVxuIiwiKGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygncG9zc2liaWxpdGllcy1zbGlkZXInKTtcbi8v0JjQvdC40YbQuNCw0LvQuNC30LjRgNGD0LXQvCDRgdC70LDQudC00LXRgFxubmV3IFN3aXBlcignLnBvc3NpYmlsaXRpZXMtc2xpZGVyJywge1xuICAvL9Ch0YLRgNC10LvQutC4XG4gIC8vIG5hdmlnYXRpb246IHtcbiAgLy8gICBuZXh0RWw6ICcuc3dpcGVyLWJ1dHRvbi1uZXh0JywgLy/RgtGD0YIg0LzQvtC20LXQvCDQt9Cw0LTQsNGC0Ywg0YHQstC+0LggLSDQsiDQvtC00L3QuNGFINC40Lcg0LHQu9C+0LrQvtCyINCx0YPQtNGD0YJcbiAgLy8gICBwcmV2RWw6ICcuc3dpcGVyLWJ1dHRvbi1wcmV2JyxcbiAgLy8gfSxcbiAgLy/QndCw0LLQuNCz0LDRhtC40Y9cblxuICAvLyDQkdGD0LvQu9C10YLRiywg0YLQtdC60YPRidC10LUg0L/QvtC70L7QttC10L3QuNC1LCDQv9GA0L7Qs9GA0LXRgdGB0LHQsNGAXG4gIC8vIHBhZ2luYXRpb246IHtcbiAgLy8gICBlbDogJy5zd2lwZXItcGFnaW5hdGlvbicsXG5cblxuICAgIC8vIC8vIDEg0YLQuNC/OiDQsdGD0LvQu9C10YLRi1xuICAgIC8vIHR5cGU6ICdidWxsZXRzJywgLy/Qv9C+INGD0LzQvtC70YfQsNC90LjRjlxuICAgIC8vIGNsaWNrYWJsZTogdHJ1ZSxcbiAgICAvLyAvLyDQtNC40L3QsNC80LjRh9C10YHQutC40LUg0LHRg9C70LvQtdGC0YtcbiAgICAvLyBkeW5hbWljQnVsbGV0czogdHJ1ZSxcbiAgICAvLyAvL9C60LDRgdGC0L7QvNC90YvQtSDQsdGD0LvQu9C10YLRi1xuICAgIC8vIHJlbmRlckJ1bGxldDogZnVuY3Rpb24oaW5kZXgsIGNsYXNzTmFtZSkge1xuICAgIC8vICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc05hbWUgKyAnXCI+JyArIChpbmRleCArIDEpICsgJzwvc3Bhbj4nO1xuICAgIC8vIH1cblxuICAgIC8vMiDRgtC40L8uINGE0YDQsNC60YbQuNGPXG4gICAgLy8gdHlwZTogJ2ZyYWN0aW9uJyxcbiAgICAvL9C60LDRgdGC0L7QvNC90YvQuSDQstGL0LLQvtC0INGE0YDQsNC60YbQuNC4XG4gICAgLy8gcmVuZGVyRnJhY3Rpb246IGZ1bmN0aW9uIChjdXJyZW50Q2xhc3MsIHRvdGFsQ2xhc3MpIHtcbiAgICAvLyAgIHJldHVybiAn0KHQu9Cw0LnQtNC10YAgPHNwYW4gY2xhc3M9XCInICsgY3VycmVudENsYXNzICsgJ1wiPjwvc3Bhbj4nICsgJyDQuNC3ICcgKyAnPHNwYW4gY2xhc3M9XCInICsgdG90YWxDbGFzcyArICdcIj48L3NwYW4+JztcbiAgICAvLyB9XG5cbiAgICAvLzMg0YLQuNC/LiDQv9GA0L7Qs9GA0LXRgdGB0LHQsNGAINGB0LLQtdGA0YXRg1xuICAgIC8vIHR5cGU6ICdwcm9ncmVzc2JhcicsXG5cbiAgLy8gfSxcblxuICAvL9GB0LrRgNC+0LvQu1xuICAvLyBzY3JvbGxiYXI6IHtcbiAgLy8gICBlbDogJy5zd2lwZXItc2Nyb2xsYmFyJyxcbiAgLy8gICAvL9Cy0L7Qt9C80L7QttC90L7RgdGC0Ywg0L/QtdGA0LXRgtCw0YHQutC40LLQsNGC0Ywg0YHQutGA0L7Qu9C7XG4gIC8vICAgZHJhZ2dhYmxlOiB0cnVlXG4gIC8vIH0sXG5cbiAgLy/RgdCy0LDQudC/0YtcbiAgLy/QstC60LvRjtGH0LXQvdC40LUgLyDQvtGC0LrQu9GO0YfQtdC90LjQtSDQv9C10YDQtdGC0LDRgdC60LjQstCw0L3QuNGPINC90LAg0J/QmlxuICBzaW11bGF0ZVRvdWNoOiB0cnVlLCAvL2ZhbHNlINC10YHQu9C4INC90YPQttC90L4g0L7RgtC60LvRjtGH0LjRgtGMXG5cbiAgLy/Rh9GD0LLRgdGC0LLQuNGC0LXQu9GM0L3QvtGB0YLRjCDRgdCy0LDQudC/0LBcbiAgLy8gdG91Y2hSYXRpbzogMSwgLy8wIC0g0L7RgtC70Y7Rh9Cw0LXRgiDRgdCy0LDQudC/0Ysg0LLQtdC30LTQtVxuICAvL9GD0LPQvtC7INGB0YDQsNCx0LDRgtGL0LLQsNC90LjRjyDRgdCy0LDQudC/0LBcbiAgLy8gdG91Y2hBbmdsZTogNDUsXG4gIC8v0LrRg9GA0YHQvtGAINC/0LXRgNC10YLQsNGB0LrQuNCy0LDQvdC40Y9cbiAgLy8gZ3JhYkN1cnNvcjogdHJ1ZSxcbiAgLy/Qv9C10YDQtdC60LvRjtGH0LXQvdC40LUg0YHQu9Cw0LnQtNCwINC/0YDQuCDQutC70LjQutC1INC90LAg0L3QtdCz0L5cbiAgLy8gc2xpZGVUb0NsaWNrZWRTbGlkZTogdHJ1ZSxcblxuICAvLyDQvdCw0LLQuNCz0LDRhtC40Y8g0L/QviDRhdC10YjRgyDQtNC70Y8g0LrQsNC20LTQvtCz0L4g0YHQu9Cw0LnQtNCwINC90YPQttC90L4g0LfQsNC00LDRgtGMICAgZGF0YS1oYXNoPVwic2xpZGUtJFwiXG4gIC8vIGhhc2hOYXZpZ2F0aW9uOiB7XG4gIC8vICAgLy/QvtGC0YHQu9C10LbQuNCy0LDRgtGMINGB0L7RgdGC0L7Rj9C90LjQtVxuICAvLyAgIHdoYXRjaFN0YXRlOiB0cnVlLFxuICAvLyB9LFxuXG4gIC8v0YPQv9GA0LDQstC70LXQvdC40LUg0LrQu9Cw0LLQuNCw0YLRg9GA0L7QuVxuICAvLyBrZXlib2FyZDoge1xuICAvLyAgIC8v0LLQutC70Y7Rh9C40YLRjCAvINCy0YvQutC70Y7Rh9C40YLRjFxuICAvLyAgIGVuYWJsZWQ6IHRydWUsXG4gIC8vICAgLy/QstC60LvRjtGH0LjRgtGMIC8g0LLRi9C60LvRjtGH0LjRgtGMINGC0L7Qu9GM0LrQviDRgtC+0LPQtNCwINC60L7Qs9C00LAg0YHQu9Cw0LnQtNC10YAg0LIg0L/RgNC10LTQtdC70LDRhSB2aWV3cG9ydFxuICAvLyAgIG9ubHlJblZpZXdwb3J0OiB0cnVlLFxuICAvLyAgIC8v0LLQutC70Y7Rh9C40YLRjCAvINCy0YvQutC70Y7Rh9C40YLRjCDRg9C/0YDQsNCy0LvQtdC90LjQtSAg0LrQu9Cw0LLQuNGI0LDQvNC4IHBhZ2VVcCwgcGFnZURvd25cbiAgLy8gICBwYWdlVXBEb3duOiB0cnVlLFxuICAvLyB9XG5cbiAgLy/Rg9C/0YDQsNCy0LvQtdC90LjQtSDQutC+0LvQtdGB0L7QvCDQvNGL0YjQuFxuICAvLyBtb3VzZXdoZWVsOiB7XG4gIC8vICAgLy/Rh9GD0LLRgdGC0LLQuNGC0LXQu9GM0L3QvtGB0YLRjCDQutC+0LvQtdGB0LAg0LzRi9GI0LhcbiAgLy8gICBzZW5zaXRpdml0eTogMSxcbiAgLy8gICAvL9C60LvQsNGB0YEg0L7QsdGK0LXQutGC0LAg0L3QsCDQutC+0YLQvtGA0L7QvCDQsdGD0LTQtdGCINGB0YDQsNCx0LDRgtGL0LLQsNGC0Ywg0L/RgNC+0LrRgNGD0YLQutCwINC80YvRiNGM0Y5cbiAgLy8gICBldmVudHNUYXJnZXQ6IFwiLnBvc3NpYmlsaXRpZXMtc2xpZGVyXCJcbiAgLy8gfVxuXG4gIC8v0LDQstGC0L7QstGL0YHQvtGC0LBcbiAgLy8gYXV0b0hlaWdodDogMSxcblxuICAvL9C60L7Qu9C40YfQtdGB0YLQstC+INGB0LvQsNC50LTQtdGA0L7QsiDQtNC70Y8g0L/QvtC60LDQt9CwXG4gIHNsaWRlc1BlclZpZXc6ICdhdXRvJywgLy/QvNC+0LbQvdC+INGD0LrQsNC30LDRgtGMINC00LLQsCDRgSDQv9C+0LvQvtCy0LjQvdC+0LkgMi41ICkpIC8vICdhdXRvJyAtINGB0LLQsNC50L/QtdGAINGB0LDQvCDRgdGE0L7RgNC80LjRgNGD0LXRgiwg0YLQvtCz0LTQsCDRgSBzd2lwZXItc2xpZGUgd2lkdGg6IGF1dG9cblxuICAvL9C+0YLQutC70Y7Rh9C10L3QuNC1INGE0YPQvdC60YbQuNC+0L3QsNC70LAg0LXRgdC70Lgg0YHQu9Cw0LnQtNC+0LIg0LzQtdC90YzRiNC1INGH0LXQvCDRg9C60LDQt9Cw0L3QviDQsiBzbGlkZXNQZXJWaWV3XG4gIC8vIHdoYXRjaE92ZXJmbG93OiB0cnVlLFxuXG4gIC8v0L7RgdGC0YPQvyDQvNC10LbQtNGDINGB0LvQsNC50LTQsNC80LhcbiAgc3BhY2VCZXR3ZWVuOiAzMCxcblxuICAvL9C60L7Qu9C40YfQtdGB0YLQstC+INC/0YDQvtC70LjRgdGC0YvQstCw0LXQvNGL0YUg0YHQu9Cw0LnQtNC+0LJcbiAgc2xpZGVzUGVyR3JvdXA6IDEsIC8v0LjQt9C80LXQvdGP0LXRgiDRhNGA0LDQutGG0LjRjlxuXG4gIC8v0LDQutGC0LjQstC90YvQuSDRgdC70LDQudC0INC/0L4g0YbQtdC90YLRgNGDXG4gIGNlbnRlcmVkU2xpZGVzOiB0cnVlLFxuXG4gIC8v0YHRgtCw0YDRgtC+0LLRi9C5INGB0LvQsNC50LRcbiAgaW5pdGlhbFNsaWRlOiAzLCAvL9C+0YLRgdGH0ZHRgiDRgSAgMFxuXG4gIC8v0LzRg9C70YzRgtC40YDRj9C00L3QvtGB0YLRjFxuICAvLyBzbGlkZXNQZXJDb2x1bW46IDIsIC8v0LTQu9GPINC60L7RgNGA0LXQutGC0L3QvtC5INGA0LDQsdC+0YLRiyDQvtGC0LrQu9GO0YfQuNGC0Ywg0LDQstGC0L7QstGL0YHQvtGC0YMg0LAg0YLQsNC60LbQtSDRgdC70LDQudC00LXRgNGDINC30LDQtNCw0YLRjCBoZWlnaHQ6IDcwMCDQuCDRgdCw0LzQuCDRgdC70LDQudC00LDQvCBoZWlnaHQ6IGNhbGMoKDEwMCUgLSAzMHB4KSAvMik7IG92ZXJmbG93OmhpZGRlbjtcblxuICAvL9Cx0LXRgdC60L7QvdC10YfQvdGL0Lkg0YHQu9Cw0LnQtNC10YBcbiAgbG9vcDogdHJ1ZSxcblxuICAvL9C60L7Qu9C40YfQtdGB0YLQstC+INC00YPQsdC70LjRgNGD0Y7RidC40YUg0YHQu9Cw0LnQtNC+0LIg0LTQu9GPINCx0LXRgdC60L7QvdC10YfQvdC+0LPQviDRgdC70LDQudC00LXRgNCwINC10YHQu9C4IHNsaWRlc1BlclZpZXcg0LHQvtC70YzRiNC1IDFcbiAgLy8gbG9vcGVkU2xpZGVzOiAzLFxuXG4gIC8v0YHQstC+0LHQvtC00L3Ri9C5INGA0LXQttC40LxcbiAgLy8gZnJlZU1vZGU6IHRydWUsXG5cbiAgLy/QsNCy0YLQvtC/0YDQvtC60YDRg9GC0LrQsFxuICBhdXRvcGxheToge1xuICAgIC8v0L/QsNGD0LfQsCDQvNC10LbQtNGDINC/0YDQvtC60YDRg9GC0LrQvtC5XG4gICAgZGVsYXk6IDEwMDAsXG4gICAgLy/Qt9Cw0LrQvtC90YfQuNGC0Ywg0L3QsCDQv9C+0YHQu9C10LTQvdC10Lwg0YHQu9Cw0LnQtNC1INC10YHQu9C4INC+0YLQutC70Y7Rh9C10L3QsCDQsdC10YHQutC+0L3QtdGH0L3Ri9C5XG4gICAgc3RvcE9uTGFzdFNsaWRlOiBmYWxzZSxcbiAgICAvL9C+0YLQutC70Y7Rh9C40YLRjCDQv9C+0YHQu9C1INGA0YPRh9C90L7Qs9C+INC/0LXRgNC10LrQu9GO0YfQtdC90LjRj1xuICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiBmYWxzZSxcblxuICB9LFxuXG4gIC8v0YHQutC+0YDQvtGB0YLRjCDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y8g0YHQu9Cw0LnQtNC+0LJcbiAgc3BlZWQ6IDE1MDAsXG5cbiAgLy/QstC10YDRgtC40LrQsNC70YzQvdGL0Lkg0YHQu9Cw0LnQtNC10YBcbiAgLy8gZGlyZWN0aW9uOiAndmVydGljYWwnLCAvLyDQtNC70Y8g0Y3RgtC+0LPQviDQvdGD0LbQvdC+INGD0YHRgtCw0L3QvtCy0LjRgtGMINCy0YvRgdC+0YLRgyDQstGB0LXQvNGDINGB0LvQsNC50LTQtdGA0YNcblxuICAvL9GN0YTRhNC10LrRgtGLINC/0LXRgNC10LrQu9GO0YfQtdC90LjRjyDRgdC70LDQudC00L7QslxuICAvL9GB0LzQtdC90LAg0L/RgNC+0LfRgNCw0YfQvdC+0YHRgtC4XG4gIC8vIGVmZmVjdDogJ2ZhZGUnLFxuXG4gIC8vIC8v0LTQvtC/0L7Qu9C90LjRgtC10LvRjNC90L4g0LogZmFkZVxuICAvLyBmYWRlRWZmZWN0OiB7XG4gIC8vICAgLy/Qv9Cw0YDQsNC70LvQtdC70YzQvdCw0Y8g0YHQvNC10L3QsCDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0LhcbiAgLy8gICBjcm9zc0ZhZGU6IHRydWVcbiAgLy8gfSxcblxuICAgIC8v0Y3RhNGE0LXQutGC0Ysg0L/QtdGA0LXQutC70Y7Rh9C10L3QuNGPINGB0LvQsNC50LTQvtCyXG4gIC8v0YHQvNC10L3QsCDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0LhcbiAgLy8gZWZmZWN0OiAnZmxpcCcsXG5cbiAgLy8gLy/QtNC+0L/QvtC70L3QuNGC0LXQu9GM0L3QviDQuiBmbGlwXG4gIC8vIGZsaXBFZmZlY3Q6IHtcbiAgLy8gICAvL9GC0LXQvdGMXG4gIC8vICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxuICAvLyAgIC8v0L/QvtC60LDQtyDRgtC+0LvRjNC60L4g0LDQutGC0LjQstC90L7Qs9C+INGB0LvQsNC50LTQsFxuICAvLyAgIGxpbWl0Um90YXRpb246IHRydWUsXG4gIC8vIH0sXG5cbiAgICAgIC8v0Y3RhNGE0LXQutGC0Ysg0L/QtdGA0LXQutC70Y7Rh9C10L3QuNGPINGB0LvQsNC50LTQvtCyXG4gIC8v0YHQvNC10L3QsCDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0LhcbiAgLy8gZWZmZWN0OiAnY3ViZScsIC8v0LTQu9GPINGN0YLQvtCz0L4g0Y3RhNGE0LXQutGC0LAg0L3Rg9C20L3QviDQvtCz0YDQsNC90LjRh9C40YLRjCDRiNC40YDQuNC90YMg0LLRgdC10LPQviDRgdC70LDQudC00LXRgNCwIHdpZHRoOiA1MDBweFxuXG4gIC8vIC8v0LTQvtC/0L7Qu9C90LjRgtC10LvRjNC90L4g0LogY3ViZVxuICAvLyBjdWJlRWZmZWN0OiB7XG4gIC8vICAgLy/QvdCw0YHRgtGA0L7QudC60Lgg0YLQtdC90LhcbiAgLy8gICBzbGlkZVNoYWRvd3M6IHRydWUsXG4gIC8vICAgc2hhZG93OiB0cnVlLFxuICAvLyAgIHNoYWRvd09mZnNldDogMjAsXG4gIC8vICAgc2hhZG93U2NhbGU6IDAuOTRcbiAgLy8gfSxcblxuXG5cbiAgICAgIC8v0Y3RhNGE0LXQutGC0Ysg0L/QtdGA0LXQutC70Y7Rh9C10L3QuNGPINGB0LvQsNC50LTQvtCyXG4gIC8v0YHQvNC10L3QsCDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0LhcbiAgLy8gZWZmZWN0OiAnY292ZXJmbG93JyxcblxuICAvLyAvLyAvL9C00L7Qv9C+0LvQvdC40YLQtdC70YzQvdC+INC6IGNvdmVyZmxvd1xuICAvLyBjb3ZlcmZsb3dFZmZlY3Q6IHtcbiAgLy8gICAvL9GD0LPQvtC7XG4gIC8vICAgcm90YXRlOiAyMCxcbiAgLy8gICAvLyDQvdCw0LvQvtC20LXQvdC40LVcbiAgLy8gICBzdHJldGNoOiA1MCxcbiAgLy8gICAvLyDRgtC10L3RjFxuICAvLyAgIHNsaWRlU2hhZG93czogdHJ1ZSxcblxuICAvLyB9LFxuXG4gIC8v0Y3RhNGE0LXQutGC0Ysg0L/QtdGA0LXQutC70Y7Rh9C10L3QuNGPINGB0LvQsNC50LTQvtCyXG4gIC8v0YHRgtCw0L3QtNCw0YDRgtC90YvQuSDRjdGE0YTQtdC60YIg0LvQuNGB0YLQsNC90LjQtVxuICBlZmZlY3Q6ICdzbGlkZScsXG5cbiAgLy/QsdGA0LXQutC/0L7QuNC90YLRiyAoYWRhcHRpdmUgTU9CSUxFIEZJUlNUKVxuICAvL9GI0LjRgNC40L3QsCDRjdC60YDQsNC90LBcbiAgLy8gYnJlYWtwb2ludHM6IHtcbiAgLy8gICAzMjA6IHsvL9C+0YIgMzIwXG4gIC8vICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAvLyAgIH0sXG4gIC8vICAgNzY4OiB7Ly/QvtGCIDQ4MFxuICAvLyAgICAgc2xpZGVzUGVyVmlldzogMixcbiAgLy8gICB9LFxuICAvLyAgIDEwMjM6IHsgLy/QvtGCIDk5MlxuICAvLyAgICAgc2xpZGVzUGVyVmlldzogMyxcbiAgLy8gICB9XG4gIC8vIH0sXG5cbiAgb246IHtcbiAgICBpbml0KCkge1xuICAvL9C+0YHRgtCw0L3QvtCy0LjRgtGMINC/0YDQuCDQvdCw0LLQtdC00LXQvdC40LhcbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsICgpID0+IHtcbiAgICAgICAgdGhpcy5hdXRvcGxheS5zdG9wKCk7XG4gICAgICB9KTtcblxuICAvL9Cy0L7Qt9C+0LHQvdC+0LLQuNGC0Ywg0L/RgNC4INC+0YLQstC10LTQtdC90LjQuFxuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmF1dG9wbGF5LnN0YXJ0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cblxufSk7XG5cblxuLy8gY29uc3Qgc3dpcGVyID0gbmV3IFN3aXBlcignLnN3aXBlcicsIHtcbi8vICAgLy8gT3B0aW9uYWwgcGFyYW1ldGVyc1xuLy8gICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4vLyAgIGxvb3A6IHRydWUsXG5cblxuXG5cblxuLy8gICAvLyBBbmQgaWYgd2UgbmVlZCBzY3JvbGxiYXJcbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuICAgIC8v0JjQvdC40YbQuNCw0LvQuNC30LjRgNGD0LXQvCDRgdC70LDQudC00LXRgFxuICBjb25zb2xlLmxvZygncHJvbW90ZS1zbGlkZXInKTtcbm5ldyBTd2lwZXIoJy5wcm9tb3RlLXNsaWRlcicsIHtcbiAgLy/QodGC0YDQtdC70LrQuFxuICBuYXZpZ2F0aW9uOiB7XG4gICAgbmV4dEVsOiAnLnByb21vdGUtc2xpZGVyX19idXR0b24tbmV4dCcsIC8v0YLRg9GCINC80L7QttC10Lwg0LfQsNC00LDRgtGMINGB0LLQvtC4IC0g0LIg0L7QtNC90LjRhSDQuNC3INCx0LvQvtC60L7QsiDQsdGD0LTRg9GCXG4gICAgcHJldkVsOiAnLnByb21vdGUtc2xpZGVyX19idXR0b24tcHJldicsXG4gIH0sXG4gIC8v0J3QsNCy0LjQs9Cw0YbQuNGPXG5cbiAgLy8g0JHRg9C70LvQtdGC0YssINGC0LXQutGD0YnQtdC1INC/0L7Qu9C+0LbQtdC90LjQtSwg0L/RgNC+0LPRgNC10YHRgdCx0LDRgFxuICBwYWdpbmF0aW9uOiB7XG4gICAgZWw6ICcucHJvbW90ZS1zbGlkZXJfX3BhZ2luYXRpb24nLFxuXG5cbiAgICAvLyAvLyAxINGC0LjQvzog0LHRg9C70LvQtdGC0YtcbiAgICAvLyB0eXBlOiAnYnVsbGV0cycsIC8v0L/QviDRg9C80L7Qu9GH0LDQvdC40Y5cbiAgICAvLyBjbGlja2FibGU6IHRydWUsXG4gICAgLy8gLy8g0LTQuNC90LDQvNC40YfQtdGB0LrQuNC1INCx0YPQu9C70LXRgtGLXG4gICAgLy8gZHluYW1pY0J1bGxldHM6IHRydWUsXG4gICAgLy8gLy/QutCw0YHRgtC+0LzQvdGL0LUg0LHRg9C70LvQtdGC0YtcbiAgICAvLyByZW5kZXJCdWxsZXQ6IGZ1bmN0aW9uKGluZGV4LCBjbGFzc05hbWUpIHtcbiAgICAvLyAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCInICsgY2xhc3NOYW1lICsgJ1wiPicgKyAoaW5kZXggKyAxKSArICc8L3NwYW4+JztcbiAgICAvLyB9XG5cbiAgICAvLzIg0YLQuNC/LiDRhNGA0LDQutGG0LjRj1xuICAgIHR5cGU6ICdmcmFjdGlvbicsXG4gICAgLy/QutCw0YHRgtC+0LzQvdGL0Lkg0LLRi9Cy0L7QtCDRhNGA0LDQutGG0LjQuFxuICAgIC8vIHJlbmRlckZyYWN0aW9uOiBmdW5jdGlvbiAoY3VycmVudENsYXNzLCB0b3RhbENsYXNzKSB7XG4gICAgLy8gICByZXR1cm4gJ9Ch0LvQsNC50LTQtdGAIDxzcGFuIGNsYXNzPVwiJyArIGN1cnJlbnRDbGFzcyArICdcIj48L3NwYW4+JyArICcg0LjQtyAnICsgJzxzcGFuIGNsYXNzPVwiJyArIHRvdGFsQ2xhc3MgKyAnXCI+PC9zcGFuPic7XG4gICAgLy8gfVxuXG4gICAgLy8zINGC0LjQvy4g0L/RgNC+0LPRgNC10YHRgdCx0LDRgCDRgdCy0LXRgNGF0YNcbiAgICAvLyB0eXBlOiAncHJvZ3Jlc3NiYXInLFxuXG4gIH0sXG5cbiAgLy/RgdC60YDQvtC70LtcbiAgLy8gc2Nyb2xsYmFyOiB7XG4gIC8vICAgZWw6ICcuc3dpcGVyLXNjcm9sbGJhcicsXG4gIC8vICAgLy/QstC+0LfQvNC+0LbQvdC+0YHRgtGMINC/0LXRgNC10YLQsNGB0LrQuNCy0LDRgtGMINGB0LrRgNC+0LvQu1xuICAvLyAgIGRyYWdnYWJsZTogdHJ1ZVxuICAvLyB9LFxuXG4gIC8v0YHQstCw0LnQv9GLXG4gIC8v0LLQutC70Y7Rh9C10L3QuNC1IC8g0L7RgtC60LvRjtGH0LXQvdC40LUg0L/QtdGA0LXRgtCw0YHQutC40LLQsNC90LjRjyDQvdCwINCf0JpcbiAgLy8gc2ltdWxhdGVUb3VjaDogdHJ1ZSwgLy9mYWxzZSDQtdGB0LvQuCDQvdGD0LbQvdC+INC+0YLQutC70Y7Rh9C40YLRjFxuXG4gIC8v0YfRg9Cy0YHRgtCy0LjRgtC10LvRjNC90L7RgdGC0Ywg0YHQstCw0LnQv9CwXG4gIC8vIHRvdWNoUmF0aW86IDEsIC8vMCAtINC+0YLQu9GO0YfQsNC10YIg0YHQstCw0LnQv9GLINCy0LXQt9C00LVcbiAgLy/Rg9Cz0L7QuyDRgdGA0LDQsdCw0YLRi9Cy0LDQvdC40Y8g0YHQstCw0LnQv9CwXG4gIC8vIHRvdWNoQW5nbGU6IDQ1LFxuICAvL9C60YPRgNGB0L7RgCDQv9C10YDQtdGC0LDRgdC60LjQstCw0L3QuNGPXG4gIC8vIGdyYWJDdXJzb3I6IHRydWUsXG4gIC8v0L/QtdGA0LXQutC70Y7Rh9C10L3QuNC1INGB0LvQsNC50LTQsCDQv9GA0Lgg0LrQu9C40LrQtSDQvdCwINC90LXQs9C+XG4gIC8vIHNsaWRlVG9DbGlja2VkU2xpZGU6IHRydWUsXG5cbiAgLy8g0L3QsNCy0LjQs9Cw0YbQuNGPINC/0L4g0YXQtdGI0YMg0LTQu9GPINC60LDQttC00L7Qs9C+INGB0LvQsNC50LTQsCDQvdGD0LbQvdC+INC30LDQtNCw0YLRjCAgIGRhdGEtaGFzaD1cInNsaWRlLSRcIlxuICAvLyBoYXNoTmF2aWdhdGlvbjoge1xuICAvLyAgIC8v0L7RgtGB0LvQtdC20LjQstCw0YLRjCDRgdC+0YHRgtC+0Y/QvdC40LVcbiAgLy8gICB3aGF0Y2hTdGF0ZTogdHJ1ZSxcbiAgLy8gfSxcblxuICAvL9GD0L/RgNCw0LLQu9C10L3QuNC1INC60LvQsNCy0LjQsNGC0YPRgNC+0LlcbiAgLy8ga2V5Ym9hcmQ6IHtcbiAgLy8gICAvL9Cy0LrQu9GO0YfQuNGC0YwgLyDQstGL0LrQu9GO0YfQuNGC0YxcbiAgLy8gICBlbmFibGVkOiB0cnVlLFxuICAvLyAgIC8v0LLQutC70Y7Rh9C40YLRjCAvINCy0YvQutC70Y7Rh9C40YLRjCDRgtC+0LvRjNC60L4g0YLQvtCz0LTQsCDQutC+0LPQtNCwINGB0LvQsNC50LTQtdGAINCyINC/0YDQtdC00LXQu9Cw0YUgdmlld3BvcnRcbiAgLy8gICBvbmx5SW5WaWV3cG9ydDogdHJ1ZSxcbiAgLy8gICAvL9Cy0LrQu9GO0YfQuNGC0YwgLyDQstGL0LrQu9GO0YfQuNGC0Ywg0YPQv9GA0LDQstC70LXQvdC40LUgINC60LvQsNCy0LjRiNCw0LzQuCBwYWdlVXAsIHBhZ2VEb3duXG4gIC8vICAgcGFnZVVwRG93bjogdHJ1ZSxcbiAgLy8gfVxuXG4gIC8v0YPQv9GA0LDQstC70LXQvdC40LUg0LrQvtC70LXRgdC+0Lwg0LzRi9GI0LhcbiAgLy8gbW91c2V3aGVlbDoge1xuICAvLyAgIC8v0YfRg9Cy0YHRgtCy0LjRgtC10LvRjNC90L7RgdGC0Ywg0LrQvtC70LXRgdCwINC80YvRiNC4XG4gIC8vICAgc2Vuc2l0aXZpdHk6IDEsXG4gIC8vICAgLy/QutC70LDRgdGBINC+0LHRitC10LrRgtCwINC90LAg0LrQvtGC0L7RgNC+0Lwg0LHRg9C00LXRgiDRgdGA0LDQsdCw0YLRi9Cy0LDRgtGMINC/0YDQvtC60YDRg9GC0LrQsCDQvNGL0YjRjNGOXG4gIC8vICAgZXZlbnRzVGFyZ2V0OiBcIi5wb3NzaWJpbGl0aWVzLXNsaWRlclwiXG4gIC8vIH1cblxuICAvL9Cw0LLRgtC+0LLRi9GB0L7RgtCwXG4gIC8vIGF1dG9IZWlnaHQ6IDEsXG5cbiAgLy/QutC+0LvQuNGH0LXRgdGC0LLQviDRgdC70LDQudC00LXRgNC+0LIg0LTQu9GPINC/0L7QutCw0LfQsFxuICBzbGlkZXNQZXJWaWV3OiAnYXV0bycsIC8v0LzQvtC20L3QviDRg9C60LDQt9Cw0YLRjCDQtNCy0LAg0YEg0L/QvtC70L7QstC40L3QvtC5IDIuNSApKSAvLyAnYXV0bycgLSDRgdCy0LDQudC/0LXRgCDRgdCw0Lwg0YHRhNC+0YDQvNC40YDRg9C10YIsINGC0L7Qs9C00LAg0YEgc3dpcGVyLXNsaWRlIHdpZHRoOiBhdXRvXG5cbiAgLy/QvtGC0LrQu9GO0YfQtdC90LjQtSDRhNGD0L3QutGG0LjQvtC90LDQu9CwINC10YHQu9C4INGB0LvQsNC50LTQvtCyINC80LXQvdGM0YjQtSDRh9C10Lwg0YPQutCw0LfQsNC90L4g0LIgc2xpZGVzUGVyVmlld1xuICAvLyB3aGF0Y2hPdmVyZmxvdzogdHJ1ZSxcblxuICAvL9C+0YHRgtGD0L8g0LzQtdC20LTRgyDRgdC70LDQudC00LDQvNC4XG4gIHNwYWNlQmV0d2VlbjogMCxcblxuICAvL9C60L7Qu9C40YfQtdGB0YLQstC+INC/0YDQvtC70LjRgdGC0YvQstCw0LXQvNGL0YUg0YHQu9Cw0LnQtNC+0LJcbiAgc2xpZGVzUGVyR3JvdXA6IDEsIC8v0LjQt9C80LXQvdGP0LXRgiDRhNGA0LDQutGG0LjRjlxuXG4gIC8v0LDQutGC0LjQstC90YvQuSDRgdC70LDQudC0INC/0L4g0YbQtdC90YLRgNGDXG4gIGNlbnRlcmVkU2xpZGVzOiB0cnVlLFxuXG4gIC8v0YHRgtCw0YDRgtC+0LLRi9C5INGB0LvQsNC50LRcbiAgLy8gaW5pdGlhbFNsaWRlOiAwLCAvL9C+0YLRgdGH0ZHRgiDRgSAgMFxuXG4gIC8v0LzRg9C70YzRgtC40YDRj9C00L3QvtGB0YLRjFxuICAvLyBzbGlkZXNQZXJDb2x1bW46IDIsIC8v0LTQu9GPINC60L7RgNGA0LXQutGC0L3QvtC5INGA0LDQsdC+0YLRiyDQvtGC0LrQu9GO0YfQuNGC0Ywg0LDQstGC0L7QstGL0YHQvtGC0YMg0LAg0YLQsNC60LbQtSDRgdC70LDQudC00LXRgNGDINC30LDQtNCw0YLRjCBoZWlnaHQ6IDcwMCDQuCDRgdCw0LzQuCDRgdC70LDQudC00LDQvCBoZWlnaHQ6IGNhbGMoKDEwMCUgLSAzMHB4KSAvMik7IG92ZXJmbG93OmhpZGRlbjtcblxuICAvL9Cx0LXRgdC60L7QvdC10YfQvdGL0Lkg0YHQu9Cw0LnQtNC10YBcbiAgLy8gbG9vcDogdHJ1ZSxcblxuICAvL9C60L7Qu9C40YfQtdGB0YLQstC+INC00YPQsdC70LjRgNGD0Y7RidC40YUg0YHQu9Cw0LnQtNC+0LIg0LTQu9GPINCx0LXRgdC60L7QvdC10YfQvdC+0LPQviDRgdC70LDQudC00LXRgNCwINC10YHQu9C4IHNsaWRlc1BlclZpZXcg0LHQvtC70YzRiNC1IDFcbiAgLy8gbG9vcGVkU2xpZGVzOiAzLFxuXG4gIC8v0YHQstC+0LHQvtC00L3Ri9C5INGA0LXQttC40LxcbiAgLy8gZnJlZU1vZGU6IHRydWUsXG5cbiAgLy/QsNCy0YLQvtC/0YDQvtC60YDRg9GC0LrQsFxuICBhdXRvcGxheToge1xuICAgIC8v0L/QsNGD0LfQsCDQvNC10LbQtNGDINC/0YDQvtC60YDRg9GC0LrQvtC5XG4gICAgZGVsYXk6IDMwMDAsXG4gICAgLy/Qt9Cw0LrQvtC90YfQuNGC0Ywg0L3QsCDQv9C+0YHQu9C10LTQvdC10Lwg0YHQu9Cw0LnQtNC1INC10YHQu9C4INC+0YLQutC70Y7Rh9C10L3QsCDQsdC10YHQutC+0L3QtdGH0L3Ri9C5XG4gICAgLy8gc3RvcE9uTGFzdFNsaWRlOiBmYWxzZSxcbiAgICAvL9C+0YLQutC70Y7Rh9C40YLRjCDQv9C+0YHQu9C1INGA0YPRh9C90L7Qs9C+INC/0LXRgNC10LrQu9GO0YfQtdC90LjRj1xuICAgIC8vIGRpc2FibGVPbkludGVyYWN0aW9uOiBmYWxzZSxcblxuICB9LFxuXG4gIC8v0YHQutC+0YDQvtGB0YLRjCDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y8g0YHQu9Cw0LnQtNC+0LJcbiAgc3BlZWQ6IDgwMCxcblxuICAvL9Cy0LXRgNGC0LjQutCw0LvRjNC90YvQuSDRgdC70LDQudC00LXRgFxuICAvLyBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsIC8vINC00LvRjyDRjdGC0L7Qs9C+INC90YPQttC90L4g0YPRgdGC0LDQvdC+0LLQuNGC0Ywg0LLRi9GB0L7RgtGDINCy0YHQtdC80YMg0YHQu9Cw0LnQtNC10YDRg1xuXG4gIC8v0Y3RhNGE0LXQutGC0Ysg0L/QtdGA0LXQutC70Y7Rh9C10L3QuNGPINGB0LvQsNC50LTQvtCyXG4gIC8v0YHQvNC10L3QsCDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0LhcbiAgZWZmZWN0OiAnZmFkZScsXG5cbiAgLy/QtNC+0L/QvtC70L3QuNGC0LXQu9GM0L3QviDQuiBmYWRlXG4gIGZhZGVFZmZlY3Q6IHtcbiAgICAvL9C/0LDRgNCw0LvQu9C10LvRjNC90LDRjyDRgdC80LXQvdCwINC/0YDQvtC30YDQsNGH0L3QvtGB0YLQuFxuICAgIGNyb3NzRmFkZTogdHJ1ZVxuICB9LFxuXG4gICAgLy/RjdGE0YTQtdC60YLRiyDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y8g0YHQu9Cw0LnQtNC+0LJcbiAgLy/RgdC80LXQvdCwINC/0YDQvtC30YDQsNGH0L3QvtGB0YLQuFxuICAvLyBlZmZlY3Q6ICdmbGlwJyxcblxuICAvLyAvL9C00L7Qv9C+0LvQvdC40YLQtdC70YzQvdC+INC6IGZsaXBcbiAgLy8gZmxpcEVmZmVjdDoge1xuICAvLyAgIC8v0YLQtdC90YxcbiAgLy8gICBzbGlkZVNoYWRvd3M6IHRydWUsXG4gIC8vICAgLy/Qv9C+0LrQsNC3INGC0L7Qu9GM0LrQviDQsNC60YLQuNCy0L3QvtCz0L4g0YHQu9Cw0LnQtNCwXG4gIC8vICAgbGltaXRSb3RhdGlvbjogdHJ1ZSxcbiAgLy8gfSxcblxuICAgICAgLy/RjdGE0YTQtdC60YLRiyDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y8g0YHQu9Cw0LnQtNC+0LJcbiAgLy/RgdC80LXQvdCwINC/0YDQvtC30YDQsNGH0L3QvtGB0YLQuFxuICAvLyBlZmZlY3Q6ICdjdWJlJywgLy/QtNC70Y8g0Y3RgtC+0LPQviDRjdGE0YTQtdC60YLQsCDQvdGD0LbQvdC+INC+0LPRgNCw0L3QuNGH0LjRgtGMINGI0LjRgNC40L3RgyDQstGB0LXQs9C+INGB0LvQsNC50LTQtdGA0LAgd2lkdGg6IDUwMHB4XG5cbiAgLy8gLy/QtNC+0L/QvtC70L3QuNGC0LXQu9GM0L3QviDQuiBjdWJlXG4gIC8vIGN1YmVFZmZlY3Q6IHtcbiAgLy8gICAvL9C90LDRgdGC0YDQvtC50LrQuCDRgtC10L3QuFxuICAvLyAgIHNsaWRlU2hhZG93czogdHJ1ZSxcbiAgLy8gICBzaGFkb3c6IHRydWUsXG4gIC8vICAgc2hhZG93T2Zmc2V0OiAyMCxcbiAgLy8gICBzaGFkb3dTY2FsZTogMC45NFxuICAvLyB9LFxuXG5cblxuICAgICAgLy/RjdGE0YTQtdC60YLRiyDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y8g0YHQu9Cw0LnQtNC+0LJcbiAgLy/RgdC80LXQvdCwINC/0YDQvtC30YDQsNGH0L3QvtGB0YLQuFxuICAvLyBlZmZlY3Q6ICdjb3ZlcmZsb3cnLFxuXG4gIC8vIC8vIC8v0LTQvtC/0L7Qu9C90LjRgtC10LvRjNC90L4g0LogY292ZXJmbG93XG4gIC8vIGNvdmVyZmxvd0VmZmVjdDoge1xuICAvLyAgIC8v0YPQs9C+0LtcbiAgLy8gICByb3RhdGU6IDIwLFxuICAvLyAgIC8vINC90LDQu9C+0LbQtdC90LjQtVxuICAvLyAgIHN0cmV0Y2g6IDUwLFxuICAvLyAgIC8vINGC0LXQvdGMXG4gIC8vICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxuXG4gIC8vIH0sXG5cbiAgLy/RjdGE0YTQtdC60YLRiyDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y8g0YHQu9Cw0LnQtNC+0LJcbiAgLy/RgdGC0LDQvdC00LDRgNGC0L3Ri9C5INGN0YTRhNC10LrRgiDQu9C40YHRgtCw0L3QuNC1XG4gIC8vIGVmZmVjdDogJ3NsaWRlJyxcblxuICAvL9Cx0YDQtdC60L/QvtC40L3RgtGLIChhZGFwdGl2ZSBNT0JJTEUgRklSU1QpXG4gIC8v0YjQuNGA0LjQvdCwINGN0LrRgNCw0L3QsFxuICAvLyBicmVha3BvaW50czoge1xuICAvLyAgIDMyMDogey8v0L7RgiAzMjBcbiAgLy8gICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gIC8vICAgfSxcbiAgLy8gICA3Njg6IHsvL9C+0YIgNDgwXG4gIC8vICAgICBzbGlkZXNQZXJWaWV3OiAyLFxuICAvLyAgIH0sXG4gIC8vICAgMTAyMzogeyAvL9C+0YIgOTkyXG4gIC8vICAgICBzbGlkZXNQZXJWaWV3OiAzLFxuICAvLyAgIH1cbiAgLy8gfSxcblxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gIC8v0L7RgdGC0LDQvdC+0LLQuNGC0Ywg0L/RgNC4INC90LDQstC10LTQtdC90LjQuFxuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmF1dG9wbGF5LnN0b3AoKTtcbiAgICAgIH0pO1xuXG4gIC8v0LLQvtC30L7QsdC90L7QstC40YLRjCDQv9GA0Lgg0L7RgtCy0LXQtNC10L3QuNC4XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYXV0b3BsYXkuc3RhcnQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxufSk7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4vL9CY0L3QuNGG0LjQsNC70LjQt9C40YDRg9C10Lwg0YHQu9Cw0LnQtNC10YBcbiAgY29uc29sZS5sb2coJ3JpYmJvbi1zbGlkZXInKTtcbm5ldyBTd2lwZXIoJy5yaWJib24tc2xpZGVyJywge1xuICAvL9Ch0YLRgNC10LvQutC4XG4gIC8vIG5hdmlnYXRpb246IHtcbiAgLy8gICBuZXh0RWw6ICcuc3dpcGVyLWJ1dHRvbi1uZXh0JywgLy/RgtGD0YIg0LzQvtC20LXQvCDQt9Cw0LTQsNGC0Ywg0YHQstC+0LggLSDQsiDQvtC00L3QuNGFINC40Lcg0LHQu9C+0LrQvtCyINCx0YPQtNGD0YJcbiAgLy8gICBwcmV2RWw6ICcuc3dpcGVyLWJ1dHRvbi1wcmV2JyxcbiAgLy8gfSxcbiAgLy/QndCw0LLQuNCz0LDRhtC40Y9cblxuICAvLyDQkdGD0LvQu9C10YLRiywg0YLQtdC60YPRidC10LUg0L/QvtC70L7QttC10L3QuNC1LCDQv9GA0L7Qs9GA0LXRgdGB0LHQsNGAXG4gIC8vIHBhZ2luYXRpb246IHtcbiAgLy8gICBlbDogJy5zd2lwZXItcGFnaW5hdGlvbicsXG5cblxuICAgIC8vIC8vIDEg0YLQuNC/OiDQsdGD0LvQu9C10YLRi1xuICAgIC8vIHR5cGU6ICdidWxsZXRzJywgLy/Qv9C+INGD0LzQvtC70YfQsNC90LjRjlxuICAgIC8vIGNsaWNrYWJsZTogdHJ1ZSxcbiAgICAvLyAvLyDQtNC40L3QsNC80LjRh9C10YHQutC40LUg0LHRg9C70LvQtdGC0YtcbiAgICAvLyBkeW5hbWljQnVsbGV0czogdHJ1ZSxcbiAgICAvLyAvL9C60LDRgdGC0L7QvNC90YvQtSDQsdGD0LvQu9C10YLRi1xuICAgIC8vIHJlbmRlckJ1bGxldDogZnVuY3Rpb24oaW5kZXgsIGNsYXNzTmFtZSkge1xuICAgIC8vICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc05hbWUgKyAnXCI+JyArIChpbmRleCArIDEpICsgJzwvc3Bhbj4nO1xuICAgIC8vIH1cblxuICAgIC8vMiDRgtC40L8uINGE0YDQsNC60YbQuNGPXG4gICAgLy8gdHlwZTogJ2ZyYWN0aW9uJyxcbiAgICAvL9C60LDRgdGC0L7QvNC90YvQuSDQstGL0LLQvtC0INGE0YDQsNC60YbQuNC4XG4gICAgLy8gcmVuZGVyRnJhY3Rpb246IGZ1bmN0aW9uIChjdXJyZW50Q2xhc3MsIHRvdGFsQ2xhc3MpIHtcbiAgICAvLyAgIHJldHVybiAn0KHQu9Cw0LnQtNC10YAgPHNwYW4gY2xhc3M9XCInICsgY3VycmVudENsYXNzICsgJ1wiPjwvc3Bhbj4nICsgJyDQuNC3ICcgKyAnPHNwYW4gY2xhc3M9XCInICsgdG90YWxDbGFzcyArICdcIj48L3NwYW4+JztcbiAgICAvLyB9XG5cbiAgICAvLzMg0YLQuNC/LiDQv9GA0L7Qs9GA0LXRgdGB0LHQsNGAINGB0LLQtdGA0YXRg1xuICAgIC8vIHR5cGU6ICdwcm9ncmVzc2JhcicsXG5cbiAgLy8gfSxcblxuICAvL9GB0LrRgNC+0LvQu1xuICAvLyBzY3JvbGxiYXI6IHtcbiAgLy8gICBlbDogJy5zd2lwZXItc2Nyb2xsYmFyJyxcbiAgLy8gICAvL9Cy0L7Qt9C80L7QttC90L7RgdGC0Ywg0L/QtdGA0LXRgtCw0YHQutC40LLQsNGC0Ywg0YHQutGA0L7Qu9C7XG4gIC8vICAgZHJhZ2dhYmxlOiB0cnVlXG4gIC8vIH0sXG5cbiAgLy/RgdCy0LDQudC/0YtcbiAgLy/QstC60LvRjtGH0LXQvdC40LUgLyDQvtGC0LrQu9GO0YfQtdC90LjQtSDQv9C10YDQtdGC0LDRgdC60LjQstCw0L3QuNGPINC90LAg0J/QmlxuICBzaW11bGF0ZVRvdWNoOiB0cnVlLCAvL2ZhbHNlINC10YHQu9C4INC90YPQttC90L4g0L7RgtC60LvRjtGH0LjRgtGMXG5cbiAgLy/Rh9GD0LLRgdGC0LLQuNGC0LXQu9GM0L3QvtGB0YLRjCDRgdCy0LDQudC/0LBcbiAgLy8gdG91Y2hSYXRpbzogMSwgLy8wIC0g0L7RgtC70Y7Rh9Cw0LXRgiDRgdCy0LDQudC/0Ysg0LLQtdC30LTQtVxuICAvL9GD0LPQvtC7INGB0YDQsNCx0LDRgtGL0LLQsNC90LjRjyDRgdCy0LDQudC/0LBcbiAgLy8gdG91Y2hBbmdsZTogNDUsXG4gIC8v0LrRg9GA0YHQvtGAINC/0LXRgNC10YLQsNGB0LrQuNCy0LDQvdC40Y9cbiAgZ3JhYkN1cnNvcjogdHJ1ZSxcbiAgLy/Qv9C10YDQtdC60LvRjtGH0LXQvdC40LUg0YHQu9Cw0LnQtNCwINC/0YDQuCDQutC70LjQutC1INC90LAg0L3QtdCz0L5cbiAgLy8gc2xpZGVUb0NsaWNrZWRTbGlkZTogdHJ1ZSxcblxuICAvLyDQvdCw0LLQuNCz0LDRhtC40Y8g0L/QviDRhdC10YjRgyDQtNC70Y8g0LrQsNC20LTQvtCz0L4g0YHQu9Cw0LnQtNCwINC90YPQttC90L4g0LfQsNC00LDRgtGMICAgZGF0YS1oYXNoPVwic2xpZGUtJFwiXG4gIC8vIGhhc2hOYXZpZ2F0aW9uOiB7XG4gIC8vICAgLy/QvtGC0YHQu9C10LbQuNCy0LDRgtGMINGB0L7RgdGC0L7Rj9C90LjQtVxuICAvLyAgIHdoYXRjaFN0YXRlOiB0cnVlLFxuICAvLyB9LFxuXG4gIC8v0YPQv9GA0LDQstC70LXQvdC40LUg0LrQu9Cw0LLQuNCw0YLRg9GA0L7QuVxuICAvLyBrZXlib2FyZDoge1xuICAvLyAgIC8v0LLQutC70Y7Rh9C40YLRjCAvINCy0YvQutC70Y7Rh9C40YLRjFxuICAvLyAgIGVuYWJsZWQ6IHRydWUsXG4gIC8vICAgLy/QstC60LvRjtGH0LjRgtGMIC8g0LLRi9C60LvRjtGH0LjRgtGMINGC0L7Qu9GM0LrQviDRgtC+0LPQtNCwINC60L7Qs9C00LAg0YHQu9Cw0LnQtNC10YAg0LIg0L/RgNC10LTQtdC70LDRhSB2aWV3cG9ydFxuICAvLyAgIG9ubHlJblZpZXdwb3J0OiB0cnVlLFxuICAvLyAgIC8v0LLQutC70Y7Rh9C40YLRjCAvINCy0YvQutC70Y7Rh9C40YLRjCDRg9C/0YDQsNCy0LvQtdC90LjQtSAg0LrQu9Cw0LLQuNGI0LDQvNC4IHBhZ2VVcCwgcGFnZURvd25cbiAgLy8gICBwYWdlVXBEb3duOiB0cnVlLFxuICAvLyB9XG5cbiAgLy/Rg9C/0YDQsNCy0LvQtdC90LjQtSDQutC+0LvQtdGB0L7QvCDQvNGL0YjQuFxuICAvLyBtb3VzZXdoZWVsOiB7XG4gIC8vICAgLy/Rh9GD0LLRgdGC0LLQuNGC0LXQu9GM0L3QvtGB0YLRjCDQutC+0LvQtdGB0LAg0LzRi9GI0LhcbiAgLy8gICBzZW5zaXRpdml0eTogMSxcbiAgLy8gICAvL9C60LvQsNGB0YEg0L7QsdGK0LXQutGC0LAg0L3QsCDQutC+0YLQvtGA0L7QvCDQsdGD0LTQtdGCINGB0YDQsNCx0LDRgtGL0LLQsNGC0Ywg0L/RgNC+0LrRgNGD0YLQutCwINC80YvRiNGM0Y5cbiAgLy8gICBldmVudHNUYXJnZXQ6IFwiLnBvc3NpYmlsaXRpZXMtc2xpZGVyXCJcbiAgLy8gfVxuXG4gIC8v0LDQstGC0L7QstGL0YHQvtGC0LBcbiAgLy8gYXV0b0hlaWdodDogMSxcblxuICAvL9C60L7Qu9C40YfQtdGB0YLQstC+INGB0LvQsNC50LTQtdGA0L7QsiDQtNC70Y8g0L/QvtC60LDQt9CwXG4gIHNsaWRlc1BlclZpZXc6ICdhdXRvJywgLy/QvNC+0LbQvdC+INGD0LrQsNC30LDRgtGMINC00LLQsCDRgSDQv9C+0LvQvtCy0LjQvdC+0LkgMi41ICkpIC8vICdhdXRvJyAtINGB0LLQsNC50L/QtdGAINGB0LDQvCDRgdGE0L7RgNC80LjRgNGD0LXRgiwg0YLQvtCz0LTQsCDRgSBzd2lwZXItc2xpZGUgd2lkdGg6IGF1dG9cblxuICAvL9C+0YLQutC70Y7Rh9C10L3QuNC1INGE0YPQvdC60YbQuNC+0L3QsNC70LAg0LXRgdC70Lgg0YHQu9Cw0LnQtNC+0LIg0LzQtdC90YzRiNC1INGH0LXQvCDRg9C60LDQt9Cw0L3QviDQsiBzbGlkZXNQZXJWaWV3XG4gIC8vIHdoYXRjaE92ZXJmbG93OiB0cnVlLFxuXG4gIC8v0L7RgdGC0YPQvyDQvNC10LbQtNGDINGB0LvQsNC50LTQsNC80LhcbiAgc3BhY2VCZXR3ZWVuOiAwLFxuXG4gIC8v0LrQvtC70LjRh9C10YHRgtCy0L4g0L/RgNC+0LvQuNGB0YLRi9Cy0LDQtdC80YvRhSDRgdC70LDQudC00L7QslxuICBzbGlkZXNQZXJHcm91cDogMSwgLy/QuNC30LzQtdC90Y/QtdGCINGE0YDQsNC60YbQuNGOXG5cbiAgLy/QsNC60YLQuNCy0L3Ri9C5INGB0LvQsNC50LQg0L/QviDRhtC10L3RgtGA0YNcbiAgY2VudGVyZWRTbGlkZXM6IHRydWUsXG5cbiAgLy/RgdGC0LDRgNGC0L7QstGL0Lkg0YHQu9Cw0LnQtFxuICBpbml0aWFsU2xpZGU6IDMsIC8v0L7RgtGB0YfRkdGCINGBICAwXG5cbiAgLy/QvNGD0LvRjNGC0LjRgNGP0LTQvdC+0YHRgtGMXG4gIC8vIHNsaWRlc1BlckNvbHVtbjogMiwgLy/QtNC70Y8g0LrQvtGA0YDQtdC60YLQvdC+0Lkg0YDQsNCx0L7RgtGLINC+0YLQutC70Y7Rh9C40YLRjCDQsNCy0YLQvtCy0YvRgdC+0YLRgyDQsCDRgtCw0LrQttC1INGB0LvQsNC50LTQtdGA0YMg0LfQsNC00LDRgtGMIGhlaWdodDogNzAwINC4INGB0LDQvNC4INGB0LvQsNC50LTQsNC8IGhlaWdodDogY2FsYygoMTAwJSAtIDMwcHgpIC8yKTsgb3ZlcmZsb3c6aGlkZGVuO1xuXG4gIC8v0LHQtdGB0LrQvtC90LXRh9C90YvQuSDRgdC70LDQudC00LXRgFxuICBsb29wOiB0cnVlLFxuXG4gIC8v0LrQvtC70LjRh9C10YHRgtCy0L4g0LTRg9Cx0LvQuNGA0YPRjtGJ0LjRhSDRgdC70LDQudC00L7QsiDQtNC70Y8g0LHQtdGB0LrQvtC90LXRh9C90L7Qs9C+INGB0LvQsNC50LTQtdGA0LAg0LXRgdC70Lggc2xpZGVzUGVyVmlldyDQsdC+0LvRjNGI0LUgMVxuICAvLyBsb29wZWRTbGlkZXM6IDMsXG5cbiAgLy/RgdCy0L7QsdC+0LTQvdGL0Lkg0YDQtdC20LjQvFxuICAvLyBmcmVlTW9kZTogdHJ1ZSxcblxuICAvL9Cw0LLRgtC+0L/RgNC+0LrRgNGD0YLQutCwXG4gIGF1dG9wbGF5OiB7XG4gICAgLy/Qv9Cw0YPQt9CwINC80LXQttC00YMg0L/RgNC+0LrRgNGD0YLQutC+0LlcbiAgICBkZWxheTogMzAwMCxcbiAgICAvL9C30LDQutC+0L3Rh9C40YLRjCDQvdCwINC/0L7RgdC70LXQtNC90LXQvCDRgdC70LDQudC00LUg0LXRgdC70Lgg0L7RgtC60LvRjtGH0LXQvdCwINCx0LXRgdC60L7QvdC10YfQvdGL0LlcbiAgICAvLyBzdG9wT25MYXN0U2xpZGU6IGZhbHNlLFxuICAgIC8v0L7RgtC60LvRjtGH0LjRgtGMINC/0L7RgdC70LUg0YDRg9GH0L3QvtCz0L4g0L/QtdGA0LXQutC70Y7Rh9C10L3QuNGPXG4gICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IGZhbHNlLFxuXG4gIH0sXG5cbiAgLy/RgdC60L7RgNC+0YHRgtGMINC/0LXRgNC10LrQu9GO0YfQtdC90LjRjyDRgdC70LDQudC00L7QslxuICBzcGVlZDogODAwLFxuXG4gIC8v0LLQtdGA0YLQuNC60LDQu9GM0L3Ri9C5INGB0LvQsNC50LTQtdGAXG4gIC8vIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJywgLy8g0LTQu9GPINGN0YLQvtCz0L4g0L3Rg9C20L3QviDRg9GB0YLQsNC90L7QstC40YLRjCDQstGL0YHQvtGC0YMg0LLRgdC10LzRgyDRgdC70LDQudC00LXRgNGDXG5cbiAgLy/RjdGE0YTQtdC60YLRiyDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y8g0YHQu9Cw0LnQtNC+0LJcbiAgLy/RgdC80LXQvdCwINC/0YDQvtC30YDQsNGH0L3QvtGB0YLQuFxuICAvLyBlZmZlY3Q6ICdmYWRlJyxcblxuICAvLyAvL9C00L7Qv9C+0LvQvdC40YLQtdC70YzQvdC+INC6IGZhZGVcbiAgLy8gZmFkZUVmZmVjdDoge1xuICAvLyAgIC8v0L/QsNGA0LDQu9C70LXQu9GM0L3QsNGPINGB0LzQtdC90LAg0L/RgNC+0LfRgNCw0YfQvdC+0YHRgtC4XG4gIC8vICAgY3Jvc3NGYWRlOiB0cnVlXG4gIC8vIH0sXG5cbiAgICAvL9GN0YTRhNC10LrRgtGLINC/0LXRgNC10LrQu9GO0YfQtdC90LjRjyDRgdC70LDQudC00L7QslxuICAvL9GB0LzQtdC90LAg0L/RgNC+0LfRgNCw0YfQvdC+0YHRgtC4XG4gIC8vIGVmZmVjdDogJ2ZsaXAnLFxuXG4gIC8vIC8v0LTQvtC/0L7Qu9C90LjRgtC10LvRjNC90L4g0LogZmxpcFxuICAvLyBmbGlwRWZmZWN0OiB7XG4gIC8vICAgLy/RgtC10L3RjFxuICAvLyAgIHNsaWRlU2hhZG93czogdHJ1ZSxcbiAgLy8gICAvL9C/0L7QutCw0Lcg0YLQvtC70YzQutC+INCw0LrRgtC40LLQvdC+0LPQviDRgdC70LDQudC00LBcbiAgLy8gICBsaW1pdFJvdGF0aW9uOiB0cnVlLFxuICAvLyB9LFxuXG4gICAgICAvL9GN0YTRhNC10LrRgtGLINC/0LXRgNC10LrQu9GO0YfQtdC90LjRjyDRgdC70LDQudC00L7QslxuICAvL9GB0LzQtdC90LAg0L/RgNC+0LfRgNCw0YfQvdC+0YHRgtC4XG4gIC8vIGVmZmVjdDogJ2N1YmUnLCAvL9C00LvRjyDRjdGC0L7Qs9C+INGN0YTRhNC10LrRgtCwINC90YPQttC90L4g0L7Qs9GA0LDQvdC40YfQuNGC0Ywg0YjQuNGA0LjQvdGDINCy0YHQtdCz0L4g0YHQu9Cw0LnQtNC10YDQsCB3aWR0aDogNTAwcHhcblxuICAvLyAvL9C00L7Qv9C+0LvQvdC40YLQtdC70YzQvdC+INC6IGN1YmVcbiAgLy8gY3ViZUVmZmVjdDoge1xuICAvLyAgIC8v0L3QsNGB0YLRgNC+0LnQutC4INGC0LXQvdC4XG4gIC8vICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxuICAvLyAgIHNoYWRvdzogdHJ1ZSxcbiAgLy8gICBzaGFkb3dPZmZzZXQ6IDIwLFxuICAvLyAgIHNoYWRvd1NjYWxlOiAwLjk0XG4gIC8vIH0sXG5cblxuXG4gICAgICAvL9GN0YTRhNC10LrRgtGLINC/0LXRgNC10LrQu9GO0YfQtdC90LjRjyDRgdC70LDQudC00L7QslxuICAvL9GB0LzQtdC90LAg0L/RgNC+0LfRgNCw0YfQvdC+0YHRgtC4XG4gIC8vIGVmZmVjdDogJ2NvdmVyZmxvdycsXG5cbiAgLy8gLy8gLy/QtNC+0L/QvtC70L3QuNGC0LXQu9GM0L3QviDQuiBjb3ZlcmZsb3dcbiAgLy8gY292ZXJmbG93RWZmZWN0OiB7XG4gIC8vICAgLy/Rg9Cz0L7Qu1xuICAvLyAgIHJvdGF0ZTogMjAsXG4gIC8vICAgLy8g0L3QsNC70L7QttC10L3QuNC1XG4gIC8vICAgc3RyZXRjaDogNTAsXG4gIC8vICAgLy8g0YLQtdC90YxcbiAgLy8gICBzbGlkZVNoYWRvd3M6IHRydWUsXG5cbiAgLy8gfSxcblxuICAvL9GN0YTRhNC10LrRgtGLINC/0LXRgNC10LrQu9GO0YfQtdC90LjRjyDRgdC70LDQudC00L7QslxuICAvL9GB0YLQsNC90LTQsNGA0YLQvdGL0Lkg0Y3RhNGE0LXQutGCINC70LjRgdGC0LDQvdC40LVcbiAgZWZmZWN0OiAnc2xpZGUnLFxuXG4gIC8v0LHRgNC10LrQv9C+0LjQvdGC0YsgKGFkYXB0aXZlIE1PQklMRSBGSVJTVClcbiAgLy/RiNC40YDQuNC90LAg0Y3QutGA0LDQvdCwXG4gIC8vIGJyZWFrcG9pbnRzOiB7XG4gIC8vICAgMzIwOiB7Ly/QvtGCIDMyMFxuICAvLyAgICAgc2xpZGVzUGVyVmlldzogMSxcbiAgLy8gICB9LFxuICAvLyAgIDc2ODogey8v0L7RgiA0ODBcbiAgLy8gICAgIHNsaWRlc1BlclZpZXc6IDIsXG4gIC8vICAgfSxcbiAgLy8gICAxMDIzOiB7IC8v0L7RgiA5OTJcbiAgLy8gICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gIC8vICAgfVxuICAvLyB9LFxuXG4gIG9uOiB7XG4gICAgaW5pdCgpIHtcbiAgLy/QvtGB0YLQsNC90L7QstC40YLRjCDQv9GA0Lgg0L3QsNCy0LXQtNC10L3QuNC4XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgfSk7XG5cbiAgLy/QstC+0LfQvtCx0L3QvtCy0LjRgtGMINC/0YDQuCDQvtGC0LLQtdC00LXQvdC40LhcbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5hdXRvcGxheS5zdGFydCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG59KTtcblxufSkoKTtcblxuIiwiKGZ1bmN0aW9uKCkge1xuXG4gIGNvbnNvbGUubG9nKCdzY3JvbGwgYW5pbWF0aW9uJyk7XG4gICBjb25zdCBhbmltSXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuX2FuaW0taXRlbXMnKTtcblxuXG5cbiAgaWYgKGFuaW1JdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGFuaW1PblNjcm9sbClcbiAgICBmdW5jdGlvbiBhbmltT25TY3JvbGwoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuaW1JdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhbmltSXRlbSA9IGFuaW1JdGVtc1tpXTtcblxuICAgICAgICBjb25zdCBhbmltSXRlbUhlaWdodCA9IGFuaW1JdGVtLm9mZnNldEhlaWdodDsgLy/QstGL0YHQvtGC0LAg0Y3Qu9C10LzQtdC90YLQsCAxODJcbiAgICAgICAgY29uc3QgYW5pbUl0ZW1PZmZzZXQgPSBvZmZzZXQoYW5pbUl0ZW0pLnRvcDsgLy/Qv9C+0LfQuNGG0LjRjyDQvtCx0YrQtdC60YLQsCDQvtGC0L3QvtGB0LjRgtC10LvRjNC90L4g0LLQstC10YDRhdCwINC+0LrQvdCwXG4gICAgICAgIGNvbnN0IGFuaW1TdGFydCA9IDY7IC8vINC60L7RjdGE0YTQuNGG0LjQtdC90YIg0YDQtdCz0YPQu9C40YDQvtCy0LDQvdC40Y8g0L3QsNGH0LDQu9CwINCw0L3QuNC80LDRhtC40Y9cblxuICAgICAgICBsZXQgYW5pbUl0ZW1Qb2ludCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGFuaW1JdGVtSGVpZ2h0IC8gYW5pbVN0YXJ0OyAvLyA3MDAgLSAyMDAgLzQgPSA3NTBcbiAgICAgICAgaWYgKCBhbmltSXRlbUhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgIGFuaW1JdGVtUG9pbnQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHQgLyBhbmltU3RhcnQ7OyAvLyA4MDAgLSA4MDAgLyA0ID0gMTAwMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwYWdlWU9mZnNldCA+IGFuaW1JdGVtT2Zmc2V0IC0gYW5pbUl0ZW1Qb2ludCkgJiYgKHBhZ2VZT2Zmc2V0IDwgYW5pbUl0ZW1PZmZzZXQgKyBhbmltSXRlbUhlaWdodCkpIC8v0LLQvtC30LLRgNCw0YnQsNC10YIg0LrQvtC70LjRh9C10YHRgtCy0L4g0L/QuNC60YHQtdC70LXQuSwg0L3QsCDQutC+0YLQvtGA0L7QtSDQv9GA0L7QutGA0YPRh9C10L0g0LTQvtC60YPQvNC10L3RgiDQv9C+INCy0LXRgNGC0LjQutCw0LvQuFxuICAgICAgICB7XG4gICAgICAgICAgYW5pbUl0ZW0uY2xhc3NMaXN0LmFkZCgnX2FjdGl2ZScpO1xuXG5cbiAgICAgICAgICBpZiAoYW5pbUl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZWNobm9sb2d5X193cmFwJykgJiYgIWFuaW1JdGVtLmNsYXNzTGlzdC5jb250YWlucygnX29uZScpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRlY2hub2xvZ3lMb3R0aWUgPSBsb3R0aWUubG9hZEFuaW1hdGlvbih7XG4gICAgICAgICAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RlY2hub2xvZ3lfX2xvdHRpZScpLFxuICAgICAgICAgICAgICByZW5kZXJlZDogJ3N2ZycsXG4gICAgICAgICAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgICAgICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgIHBhdGg6ICcuL2pzb24vdGVjaG5vbG9neV9fbG90dGllLmpzb24nLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc29sZS5sb2codGVjaG5vbG9neUxvdHRpZS5wbGF5KCkpO1xuICAgICAgICAgICAgYW5pbUl0ZW0uY2xhc3NMaXN0LmFkZCgnX29uZScpO1xuICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWFuaW1JdGVtLmNsYXNzTGlzdC5jb250YWlucygnX2FuaW0tbm8taGlkZScpKSB7XG4gICAgICAgICAgICBhbmltSXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdfYWN0aXZlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG9mZnNldChlbCkge1xuXG4gICAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vINGA0LDQt9C80LXRgCDRjdC70LXQvNC10L3RgtCwINC4INC10LPQviDQv9C+0LfQuNGG0LjRjiDQvtGC0L3QvtGB0LjRgtC10LvRjNC90L4gIHZpZXdwb3J0XG5cbiAgICAgIGNvbnN0IHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAvLyBwYWdlWE9mZnNldCAtINGC0LXQutGD0YnQsNGPINC/0YDQvtC60YDRg9GC0LrQsCDRgdC70LXQstCwICxcbiAgICAgIC8vIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAtIGh0bWwsXG4gICAgICAvLyBzY3JvbGxUb3AgLSDRgdC60L7Qu9GM0LrQviDQv9GA0L7QutGA0YPRh9C10L3QviDQstCy0LXRgNGFXG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHJlY3QudG9wICsgc2Nyb2xsVG9wLFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyBzY3JvbGxMZWZ0XG4gICAgICB9XG5cbiAgICB9XG5cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYW5pbU9uU2Nyb2xsKClcbiAgICB9LCA0MDApO1xuXG4gIH1cbn0pKClcbiIsIihmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJ3RhYnMnKTtcblxuICBjb25zdCB0YWJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRhYnMnKTtcbiAgY29uc3QgdGFic0J0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50YWJzX19idG4nKTtcbiAgY29uc3QgdGFic0NvbnRlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudGFic19fY29udGVudCcpO1xuXG4gIGlmKHRhYnMpIHtcbiAgICB0YWJzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3RhYnNfX2J0bicpKSB7XG4gICAgICAgIGNvbnN0IHRhYnNQYXRoID0gZS50YXJnZXQuZGF0YXNldC50YWJzUGF0aDtcbiAgICAgICAgdGFic0hhbmRsZXIodGFic1BhdGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHRhYnNIYW5kbGVyID0gKHBhdGgpID0+IHtcbiAgICB0YWJzQnRuLmZvckVhY2goIGVsID0+IHsgZWwuY2xhc3NMaXN0LnJlbW92ZSgndGFic19fYnRuLS1hY3RpdmUnKX0pO1xuICAgIHRhYnMucXVlcnlTZWxlY3RvcihgW2RhdGEtdGFicy1wYXRoPVwiJHtwYXRofVwiXWApLmNsYXNzTGlzdC5hZGQoJ3RhYnNfX2J0bi0tYWN0aXZlJyk7XG5cblxuICAgIHRhYnNDb250ZW50LmZvckVhY2goIGVsID0+IHsgZWwuY2xhc3NMaXN0LnJlbW92ZSgndGFic19fY29udGVudC0tYWN0aXZlJyl9KTtcbiAgICB0YWJzLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXRhYnMtdGFyZ2V0PVwiJHtwYXRofVwiXWApLmNsYXNzTGlzdC5hZGQoJ3RhYnNfX2NvbnRlbnQtLWFjdGl2ZScpO1xuICB9XG5cbn0pKClcbiJdfQ==
